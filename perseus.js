'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _reactAddonsPureRenderMixin = require('react-addons-pure-render-mixin');
var $$6 = require('jquery');
var _react = require('react');
var _reactDom = require('react-dom');
var _createReactClass = require('create-react-class');
var _propTypes = require('prop-types');
var _katex = require('katex');
var _classnames = require('classnames');
var _underscore = require('underscore');
var MathQuill$1 = require('mathquill');
var _mathInput = require('@khanacademy/math-input');
var aphrodite = require('aphrodite');
var _simpleMarkdown = require('simple-markdown');
var immutable = require('immutable');
var draftJs = require('draft-js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var _reactAddonsPureRenderMixin__default = /*#__PURE__*/_interopDefaultLegacy(_reactAddonsPureRenderMixin);
var $__default = /*#__PURE__*/_interopDefaultLegacy($$6);
var _react__default = /*#__PURE__*/_interopDefaultLegacy(_react);
var _react__namespace = /*#__PURE__*/_interopNamespace(_react);
var _reactDom__default = /*#__PURE__*/_interopDefaultLegacy(_reactDom);
var _createReactClass__default = /*#__PURE__*/_interopDefaultLegacy(_createReactClass);
var _propTypes__default = /*#__PURE__*/_interopDefaultLegacy(_propTypes);
var _katex__default = /*#__PURE__*/_interopDefaultLegacy(_katex);
var _classnames__default = /*#__PURE__*/_interopDefaultLegacy(_classnames);
var _underscore__default = /*#__PURE__*/_interopDefaultLegacy(_underscore);
var MathQuill__default = /*#__PURE__*/_interopDefaultLegacy(MathQuill$1);
var _mathInput__default = /*#__PURE__*/_interopDefaultLegacy(_mathInput);
var _simpleMarkdown__default = /*#__PURE__*/_interopDefaultLegacy(_simpleMarkdown);

// Perseus running in local mode depends on $_, which is defined here
var createFragment$1 = function createFragment(obj) {
  return React.createElement(React.Fragment, null, Object.keys(obj).map(key => React.createElement(React.Fragment, {
    key: key
  }, obj[key])));
}; // The plural language strings for all the languages we have
// listed in crowdin.  The values here need to match what crowdin
// uses (sometimes different platforms use different plural forms,
// for ambiguous languages like Turkish).  I got it by running
//    deploy/download_i18n.py -s
// and looking a the .po files in all.zip.  Each .po file has a
// header line that say something like:
//    "Plural-Forms: nplurals=2; plural=(n != 1);\n"
// which I copied in here with the following changes:
//    1) I only take the 'plural=' section, which I wrapped in a function
//    2) Changed 'or' to '||'
// These functions return either true or false or a number.  We map
// true to 1 and false to 0 below, to always get a number out of this.

/* eslint-disable space-infix-ops, eqeqeq, max-len */


var likeEnglish = function likeEnglish(n) {
  return n != 1;
}; // TODO(csilvers): auto-generate this list from the foo.po files (in dropbox)


var allPluralForms = {
  "accents": likeEnglish,
  // a 'fake' langauge
  "af": likeEnglish,
  "ar": function ar(n) {
    return n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 && n % 100 <= 99 ? 4 : 5;
  },
  "az": likeEnglish,
  "bg": likeEnglish,
  "bn": likeEnglish,
  "boxes": likeEnglish,
  // a 'fake' langauge
  "ca": likeEnglish,
  "cs": function cs(n) {
    return n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;
  },
  "da": likeEnglish,
  "de": likeEnglish,
  "el": likeEnglish,
  "empty": likeEnglish,
  // a 'fake' langauge
  "en": likeEnglish,
  "en-pt": likeEnglish,
  // a 'fake' language, used by crowdin for JIPT
  "es": likeEnglish,
  "fa": function fa(n) {
    return 0;
  },
  "fa-af": function faAf(n) {
    return 0;
  },
  "fi": likeEnglish,
  "fr": function fr(n) {
    return n > 1;
  },
  "he": likeEnglish,
  "hi": likeEnglish,
  "hu": likeEnglish,
  "hy": likeEnglish,
  "id": function id(n) {
    return 0;
  },
  "it": likeEnglish,
  "ja": function ja(n) {
    return 0;
  },
  "ko": function ko(n) {
    return 0;
  },
  "lol": likeEnglish,
  // a 'fake' langauge
  "mn": likeEnglish,
  "ms": function ms(n) {
    return 0;
  },
  "nb": likeEnglish,
  "nl": likeEnglish,
  "pl": function pl(n) {
    return n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
  },
  "pt": likeEnglish,
  "pt-pt": likeEnglish,
  "ro": function ro(n) {
    return n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2;
  },
  "ru": function ru(n) {
    return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
  },
  "si-LK": likeEnglish,
  "sk": function sk(n) {
    return n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;
  },
  "sr": function sr(n) {
    return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
  },
  "sv-SE": likeEnglish,
  "sw": likeEnglish,
  "te": likeEnglish,
  "th": function th(n) {
    return 0;
  },
  "tr": function tr(n) {
    return 0;
  },
  "uk": function uk(n) {
    return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
  },
  "ur": likeEnglish,
  "vi": function vi(n) {
    return 0;
  },
  "xh": likeEnglish,
  "zh-hans": function zhHans(n) {
    return 0;
  },
  "zh-hant": function zhHant(n) {
    return 0;
  },
  "zu": likeEnglish
};
/* eslint-enable */

var interpolationMarker = /%\(([\w_]+)\)s/g;
/**
 * Performs sprintf-like %(name)s replacement on str, and returns a React
 * fragment of the string interleaved with those replacements. The replacements
 * can be any valid React node including strings and numbers.
 *
 * For example:
 *  interpolateStringToFragment("test", {}) ->
 *      test
 *  interpolateStringToFragment("test %(num)s", {num: 5}) ->
 *      test 5
 *  interpolateStringToFragment("test %(num)s", {num: <Count />}) ->
 *      test <Count />
 */

var interpolateStringToFragment = function interpolateStringToFragment(str, options) {
  options = options || {}; // Split the string into its language fragments and substitutions

  var split = str.split(interpolationMarker);
  var result = {
    "text_0": split[0]
  }; // Replace the substitutions with the appropriate option

  for (var i = 1; i < split.length; i += 2) {
    var key = split[i];
    var replaceWith = options[key];

    if (replaceWith === undefined) {
      replaceWith = "%(" + key + ")s";
    } // We prefix each substitution key with a number that increments each
    // time it's used, so "test %(num)s %(fruit)s and %(num)s again" turns
    // into an object with keys:
    // [text_0, 0_num, text_2, 0_fruit, text_4, 1_num, text_6]
    // This is better than just using the array index in the case that we
    // switch between two translated strings with the same variables.
    // Admittedly, an edge case.


    var j = 0;

    while ("" + j + "_" + key in result) {
      j++;
    }

    result["" + j + "_" + key] = replaceWith; // Because the regex has one capturing group, the `split` array always
    // has an odd number of elements, so this always stays in bounds.

    result["text_" + (i + 1)] = split[i + 1];
  }

  return createFragment$1(result);
};
/**
    * Simple i18n method with sprintf-like %(name)s replacement
    * To be used like so:
    *   i18n._("Some string")
    *   i18n._("Hello %(name)s", {name: "John"})
    */


var _$1N = function _(str, options) {
  // Sometimes we're given an argument that's meant for ngettext().  This
  // happens if the same string is used in both i18n._() and i18n.ngettext()
  // (.g. a = i18n._(foo); b = i18n.ngettext("foo", "bar", count);
  // In such cases, only the plural form ends up in the .po file, and
  // then it gets sent to us for the i18n._() case too.  No problem, though:
  // we'll just take the singular arg.
  if (typeof str === "object" && str.messages) {
    str = str.messages[0];
  }

  options = options || {};
  return str.replace(interpolationMarker, function (match, key) {
    var replaceWith = options[key];
    return replaceWith === undefined ? match : replaceWith;
  });
};
/**
    * A simple i18n react component-like function to allow for string
    * interpolation destined for the output of a react render() function
    *
    * This function understands react components, or other things
    * renderable by react, passed in as props.
    *
    * Examples:
    *   <$_ first="Motoko" last="Kusanagi">
    *       Hello, %(first)s %(last)s!
    *   </$_>
    *
    * which react/jsx compiles to:
    *   $_({first: "Motoko", last: "Kusanagi"}, "Hello, %(first)s %(last)s!")
    *
    *
    *   <$_ textbox={<input type="text" />}>
    *       Please enter a number: %(textbox)s
    *   </$_>
    *
    * which react/jsx compiles to:
    *   $_({textbox: ReactDOMtags.input({type: "text"}),
    *       "Please enter a number: %(textbox)s")
    *
    * Note: this is not a full react component to avoid complex handling of
    * other things added to props, such as this.props.ref and
    * this.props.children
    */


var $_$1 = function $_(options, str) {
  if (arguments.length !== 2 || typeof str !== "string") {
    return "<$_> must have exactly one child, which must be a string";
  }

  return interpolateStringToFragment(str, options);
};
/**
    * A simple i18n react component-like function to allow for marking a
    * string as not needing to be translated.
    *
    * Example:
    *
    *    <$i18nDoNotTranslate>English only text.</$i18nDoNotTranslate>
    *
    * which react/jsx compiles to:
    *    $i18nDoNotTranslate(null, "English only text.")
    */

var $i18nDoNotTranslate = function $i18nDoNotTranslate(options, str) {
  return str;
};
/**
    * Simple ngettext method with sprintf-like %(name)s replacement
    * To be used like so:
    *   i18n.ngettext("Singular", "Plural", 3)
    *   i18n.ngettext("1 Cat", "%(num)s Cats", 3)
    *   i18n.ngettext("1 %(type)s", "%(num)s %(type)s", 3, {type: "Cat"})
    * This method is also meant to be used when injecting for other
    * non-English languages, like so (taking an array of plural messages,
    * which varies based upon the language):
    *   i18n.ngettext({
    *     lang: "ja",
    *     messages: ["%(num)s 猫 %(username)s"]
    *   }, 3, {username: "John"});
    */

var ngettext = function ngettext(singular, plural, num, options) {
  // Fall back to the default lang
  var lang;
  var messages; // If the first argument is an object then we're receiving a plural
  // configuration object

  if (typeof singular === "object") {
    lang = singular.lang;
    messages = singular.messages; // We only have a messages object no plural string
    // thus we need to shift all the arguments over by one.

    options = num;
    num = plural;
  } else {
    lang = "en"; // We're using text written into the source code

    messages = [singular, plural];
  } // Get the translated string


  var idx = ngetpos(num, lang);
  var translation = "";

  if (idx < messages.length) {
    // the common (non-error) case
    translation = messages[idx];
  } // Get the options to substitute into the string.
  // We automatically add in the 'magic' option-variable 'num'.


  options = options || {};
  options.num = options.num || num; // Then pass into i18n._ for the actual substitution

  return _$1N(translation, options);
};
/*
    * Return the ngettext position that matches the given number and locale.
    *
    * Arguments:
    *  - num: The number upon which to toggle the plural forms.
    *  - lang: The language to use as the basis for the pluralization.
    */


var ngetpos = function ngetpos(num, lang) {
  var pluralForm = allPluralForms[lang] || allPluralForms["en"];
  var pos = pluralForm(num); // Map true to 1 and false to 0, keep any numeric return value the same.

  return pos === true ? 1 : pos ? pos : 0;
};
/*
    * A dummy identity function.  It's used as a signal to automatic
    * translation-identification tools that they shouldn't mark this
    * text up to be translated, even though it looks like
    * natural-language text.  (And likewise, a signal to linters that
    * they shouldn't complain that this text isn't translated.)
    * Use it like so: 'tag.author = i18n.i18nDoNotTranslate("Jim");'
    */


var i18nDoNotTranslate = _$1N;
// bootstrap-daterangepicker (live-editor also uses the global i18n
// var, but defines its own version of it.)  We export the symbols
// that they need.


window.i18n = {
  _: _$1N,
  ngettext: ngettext,
  i18nDoNotTranslate: i18nDoNotTranslate,
  // khan-exercises is the only client of ngetpos (which is emitted
  // into khan-exercises by kake/translate-exercises.py).
  ngetpos: ngetpos
}; // TODO(csilvers): is it still necessary to make these globals?

window.$_ = $_$1;
window.$i18nDoNotTranslate = $i18nDoNotTranslate;

//       import "perseus-configured/lib/khan-exercises.css";
//       import "perseus-configured/lib/perseus.css";
// TODO: Consider a build step to make it one CSS file, and include Mathquill too?
// Add some backfills to make React 17 behave like old-style React.
// TODO: Update Perseus to use these libraries directly, instead. They're not perfect
//       backfills and I'm not sure how reliable this is!

window.createReactClass = _createReactClass__default["default"];
window.PropTypes = _propTypes__default["default"];
window.ReactDOMtags = {
  span: props => /*#__PURE__*/_react__default["default"].createElement("span", props),
  input: props => /*#__PURE__*/_react__default["default"].createElement("input", props)
};
window.jQuery = window.$ = $__default["default"];
window.katex = _katex__default["default"];
window.MathQuill = MathQuill__default["default"];
window.classnames = _classnames__default["default"];
window._ = _underscore__default["default"]; // Perseus bundles its own copy of Raphael but throws if Raphael isn't already
// defined, because Raphael does a global `Raphael = ...` assignment but we
// load it in strict mode

window.Raphael = undefined;
var PureRenderMixin$1 = _reactAddonsPureRenderMixin__default["default"];
window.React = _react__default["default"];
window.ReactDOM = _reactDom__default["default"];
window["underscore"] = window._;
window["react"] = window.React;
window["react-dom"] = window.ReactDOM;
window["classnames"] = window.classNames;
window["jquery"] = window.jQuery;
window["react-addons-pure-render-mixin"] = PureRenderMixin$1;
/**
 * Sets up the basic environment for running Perseus in.
 */

window.icu = {
  getDecimalFormatSymbols: function getDecimalFormatSymbols() {
    return {
      decimal_separator: ".",
      grouping_separator: ",",
      minus: "-"
    };
  }
};
window.KhanUtil = {
  debugLog: function debugLog() {},
  localeToFixed: function localeToFixed(num, precision) {
    return num.toFixed(precision);
  }
};
window.Exercises = {
  localMode: true,
  useKatex: true,
  khanExercisesUrlBase: "../",
  getCurrentFramework: function getCurrentFramework() {
    return "khan-exercises";
  },
  PerseusBridge: {
    cleanupProblem: function cleanupProblem() {
      return false;
    }
  }
};
window.Khan = {
  Util: window.KhanUtil,
  error: function error() {},
  query: {
    debug: ""
  },
  imageBase: "/images/"
};

var _module_$3a = {
  exports: {}
};
/**
 * These tools allow you to construct arbirtary shapes, by combining simple
 * leaf shapes like `content` and `hint` into composite shapes like
 * `arrayOf(shape({question: content, hints: arrayOf(hint)}))`.
 */

var contentShape = {
  type: "content"
};
var hintShape = {
  type: "hint"
};
var tagsShape = {
  type: "tags"
};

var buildArrayShape = elementShape => ({
  type: "array",
  elementShape
});

var buildObjectShape = shape => ({
  type: "object",
  shape
});

var hintsShape = buildArrayShape(hintShape);
_module_$3a.exports = {
  content: contentShape,
  hint: hintShape,
  hints: hintsShape,
  tags: tagsShape,
  arrayOf: buildArrayShape,
  shape: buildObjectShape
};
var _multiItemsShapesJs = _module_$3a.exports;

/**
 * Return a PropType that accepts Items of the given shape, and rejects other
 * objects.
 *
 * Usage: `propTypes: {item: buildPropTypeForShape(myShape)}`
 */

function buildPropTypeForShape(shape) {
  return PropTypes.oneOfType([PropTypes.shape({
    _multi: buildTreePropTypeForShape(shape)
  }), PropTypes.oneOf([null, undefined])]);
}
/**
 * Return a PropType that accepts ItemTrees of the given shape, and rejects
 * other objects.
 */

function buildTreePropTypeForShape(shape) {
  if (shape.type === "content") {
    return PropTypes.shape({
      // TODO(mdr): Remove #LegacyContentNode support.
      __type: PropTypes.oneOf(["content", "item"]).isRequired,
      content: PropTypes.string,
      images: PropTypes.objectOf(PropTypes.any),
      widgets: PropTypes.objectOf(PropTypes.any)
    });
  } else if (shape.type === "hint") {
    return PropTypes.shape({
      __type: PropTypes.oneOf(["hint"]).isRequired,
      content: PropTypes.string,
      images: PropTypes.objectOf(PropTypes.any),
      widgets: PropTypes.objectOf(PropTypes.any),
      replace: PropTypes.bool
    });
  } else if (shape.type === "tags") {
    return PropTypes.arrayOf(PropTypes.string.isRequired);
  } else if (shape.type === "array") {
    var elementPropType = buildTreePropTypeForShape(shape.elementShape);
    return PropTypes.arrayOf(elementPropType.isRequired);
  } else if (shape.type === "object") {
    var valueShapes = shape.shape;
    var propTypeShape = {};
    Object.keys(valueShapes).forEach(key => {
      propTypeShape[key] = buildTreePropTypeForShape(valueShapes[key]).isRequired;
    });
    return PropTypes.shape(propTypeShape);
  } else {
    throw new Error("unexpected shape type ".concat(shape.type));
  }
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var svgLabelsRegex = /^web\+graphie\:/;
function isLabeledSVG(url) {
  return svgLabelsRegex.test(url);
} // For each svg+labels, there are two urls we need to download from. This gets
// the base url without the suffix, and `getSvgUrl` and `getDataUrl` apply
// appropriate suffixes to get the image and other data

function getBaseUrl(url) {
  // Force HTTPS connection unless we're on HTTP, so that IE works.
  var protocol = window.location.protocol === "http:" ? "http:" : "https:";
  return url.replace(svgLabelsRegex, protocol);
}
function getSvgUrl(url) {
  return getBaseUrl(url) + ".svg";
}
function getDataUrl(url) {
  return getBaseUrl(url) + "-data.json";
} // A regex to split at the last / of a URL, separating the base part from the
// hash. This is used to create the localized label data URLs.

var splitHashRegex = /\/(?=[^/]+$)/;
function getLocalizedDataUrl(url) {
  if (typeof KA !== "undefined") {
    // Parse out the hash and base so that we can insert the locale
    // directory in the middle.
    var [base, hash] = getBaseUrl(url).split(splitHashRegex);
    return "".concat(base, "/").concat(KA.language, "/").concat(hash, "-data.json");
  } else {
    return getDataUrl(url);
  }
}
function getRealImageUrl(url) {
  if (isLabeledSVG(url)) {
    return getSvgUrl(url);
  } else {
    return url;
  }
}

/*! KAS | https://github.com/Khan/KAS */
// This is a @generated file
var KAS = {};

(function (KAS) {
  /* parser generated by jison 0.4.15 */

  /*
    Returns a Parser object of the following structure:
  
    Parser: {
      yy: {}
    }
  
    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),
  
      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),
  
          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },
  
          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }
  
  
    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }
  
  
    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var parser = function () {
    var o = function o(k, v, _o, l) {
      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
      }

      return _o;
    },
        $V0 = [1, 7],
        $V1 = [1, 17],
        $V2 = [1, 13],
        $V3 = [1, 14],
        $V4 = [1, 15],
        $V5 = [1, 32],
        $V6 = [1, 22],
        $V7 = [1, 23],
        $V8 = [1, 24],
        $V9 = [1, 25],
        $Va = [1, 26],
        $Vb = [1, 33],
        $Vc = [1, 27],
        $Vd = [1, 28],
        $Ve = [1, 29],
        $Vf = [1, 30],
        $Vg = [1, 20],
        $Vh = [1, 36],
        $Vi = [1, 37],
        $Vj = [5, 6, 8, 10, 33, 35, 41, 43, 45],
        $Vk = [1, 39],
        $Vl = [1, 40],
        $Vm = [5, 6, 8, 10, 12, 14, 16, 19, 21, 22, 28, 29, 30, 31, 32, 33, 34, 35, 37, 39, 41, 42, 43, 44, 45, 46],
        $Vn = [10, 16, 19, 21, 22, 28, 29, 30, 31, 32, 34, 37, 39, 42, 43, 44, 46],
        $Vo = [5, 6, 8, 10, 12, 14, 16, 18, 19, 21, 22, 28, 29, 30, 31, 32, 33, 34, 35, 37, 39, 41, 42, 43, 44, 45, 46];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "equation": 3,
        "expression": 4,
        "SIGN": 5,
        "EOF": 6,
        "additive": 7,
        "+": 8,
        "multiplicative": 9,
        "-": 10,
        "triglog": 11,
        "*": 12,
        "negative": 13,
        "/": 14,
        "trig": 15,
        "TRIG": 16,
        "trigfunc": 17,
        "^": 18,
        "TRIGINV": 19,
        "logbase": 20,
        "ln": 21,
        "log": 22,
        "_": 23,
        "subscriptable": 24,
        "power": 25,
        "primitive": 26,
        "variable": 27,
        "VAR": 28,
        "CONST": 29,
        "INT": 30,
        "FLOAT": 31,
        "{": 32,
        "}": 33,
        "(": 34,
        ")": 35,
        "function": 36,
        "FUNC": 37,
        "invocation": 38,
        "sqrt": 39,
        "[": 40,
        "]": 41,
        "abs": 42,
        "|": 43,
        "LEFT|": 44,
        "RIGHT|": 45,
        "FRAC": 46,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        5: "SIGN",
        6: "EOF",
        8: "+",
        10: "-",
        12: "*",
        14: "/",
        16: "TRIG",
        18: "^",
        19: "TRIGINV",
        21: "ln",
        22: "log",
        23: "_",
        28: "VAR",
        29: "CONST",
        30: "INT",
        31: "FLOAT",
        32: "{",
        33: "}",
        34: "(",
        35: ")",
        37: "FUNC",
        39: "sqrt",
        40: "[",
        41: "]",
        42: "abs",
        43: "|",
        44: "LEFT|",
        45: "RIGHT|",
        46: "FRAC"
      },
      productions_: [0, [3, 4], [3, 2], [3, 1], [4, 1], [7, 3], [7, 3], [7, 1], [9, 2], [9, 3], [9, 3], [9, 1], [13, 2], [13, 1], [15, 1], [17, 1], [17, 3], [17, 1], [20, 1], [20, 1], [20, 3], [11, 2], [11, 2], [11, 1], [25, 3], [25, 1], [27, 1], [24, 3], [24, 1], [24, 1], [24, 1], [24, 1], [24, 3], [24, 3], [36, 1], [38, 4], [38, 4], [38, 7], [38, 4], [38, 3], [38, 3], [38, 4], [26, 1], [26, 1], [26, 7]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
      /* action[1] */
      , $$
      /* vstack */
      , _$
      /* lstack */
      ) {
        /* this == yyval */
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
            return new yy.Eq($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);

          case 2:
            return $$[$0 - 1];

          case 3:
            return new yy.Add([]);

          case 4:
          case 7:
          case 11:
          case 13:
          case 15:
          case 20:
          case 23:
          case 25:
          case 42:
          case 43:
            this.$ = $$[$0];
            break;

          case 5:
            this.$ = yy.Add.createOrAppend($$[$0 - 2], $$[$0]);
            break;

          case 6:
            this.$ = yy.Add.createOrAppend($$[$0 - 2], yy.Mul.handleNegative($$[$0], "subtract"));
            break;

          case 8:
            this.$ = yy.Mul.fold(yy.Mul.createOrAppend($$[$0 - 1], $$[$0]));
            break;

          case 9:
            this.$ = yy.Mul.fold(yy.Mul.createOrAppend($$[$0 - 2], $$[$0]));
            break;

          case 10:
            this.$ = yy.Mul.fold(yy.Mul.handleDivide($$[$0 - 2], $$[$0]));
            break;

          case 12:
            this.$ = yy.Mul.handleNegative($$[$0]);
            break;

          case 14:
          case 17:
            this.$ = [yytext];
            break;

          case 16:
            this.$ = $$[$0 - 2].concat($$[$0]);
            break;

          case 18:
            this.$ = yy.Log.natural();
            break;

          case 19:
            this.$ = yy.Log.common();
            break;

          case 21:
            this.$ = yy.Trig.create($$[$0 - 1], $$[$0]);
            break;

          case 22:
            this.$ = yy.Log.create($$[$0 - 1], $$[$0]);
            break;

          case 24:
            this.$ = new yy.Pow($$[$0 - 2], $$[$0]);
            break;

          case 26:
          case 34:
            this.$ = yytext;
            break;

          case 27:
            this.$ = new yy.Var($$[$0 - 2], $$[$0]);
            break;

          case 28:
            this.$ = new yy.Var($$[$0]);
            break;

          case 29:
            this.$ = new yy.Const(yytext.toLowerCase());
            break;

          case 30:
            this.$ = yy.Int.create(Number(yytext));
            break;

          case 31:
            this.$ = yy.Float.create(Number(yytext));
            break;

          case 32:
            this.$ = $$[$0 - 1].completeParse();
            break;

          case 33:
            this.$ = $$[$0 - 1].completeParse().addHint('parens');
            break;

          case 35:
          case 36:
            this.$ = yy.Pow.sqrt($$[$0 - 1]);
            break;

          case 37:
            this.$ = new yy.Pow.nthroot($$[$0 - 1], $$[$0 - 4]);
            break;

          case 38:
          case 39:
          case 40:
            this.$ = new yy.Abs($$[$0 - 1]);
            break;

          case 41:
            this.$ = new yy.Func($$[$0 - 3], $$[$0 - 1]);
            break;

          case 44:
            this.$ = yy.Mul.handleDivide($$[$0 - 4], $$[$0 - 1]);
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        6: [1, 3],
        7: 4,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        1: [3]
      }, {
        5: [1, 34],
        6: [1, 35]
      }, {
        1: [2, 3]
      }, o([5, 6], [2, 4], {
        8: $Vh,
        10: $Vi
      }), o($Vj, [2, 7], {
        17: 9,
        20: 10,
        25: 11,
        15: 12,
        26: 16,
        24: 18,
        38: 19,
        27: 21,
        36: 31,
        11: 38,
        12: $Vk,
        14: $Vl,
        16: $V1,
        19: $V2,
        21: $V3,
        22: $V4,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        37: $Vb,
        39: $Vc,
        42: $Vd,
        44: $Vf,
        46: $Vg
      }), o($Vm, [2, 11]), {
        10: $V0,
        11: 8,
        13: 41,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, o($Vm, [2, 13]), {
        10: $V0,
        11: 8,
        13: 42,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        10: $V0,
        11: 8,
        13: 43,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, o($Vm, [2, 23]), o($Vn, [2, 15], {
        18: [1, 44]
      }), o($Vn, [2, 17]), o($Vn, [2, 18]), o($Vn, [2, 19], {
        23: [1, 45]
      }), o($Vm, [2, 25], {
        18: [1, 46]
      }), o([10, 16, 18, 19, 21, 22, 28, 29, 30, 31, 32, 34, 37, 39, 42, 43, 44, 46], [2, 14]), o($Vo, [2, 42]), o($Vo, [2, 43]), {
        32: [1, 47]
      }, o($Vo, [2, 28], {
        23: [1, 48]
      }), o($Vo, [2, 29]), o($Vo, [2, 30]), o($Vo, [2, 31]), {
        7: 49,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        7: 50,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        32: [1, 52],
        34: [1, 51],
        40: [1, 53]
      }, {
        34: [1, 54]
      }, {
        7: 55,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        7: 56,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        34: [1, 57]
      }, o([5, 6, 8, 10, 12, 14, 16, 18, 19, 21, 22, 23, 28, 29, 30, 31, 32, 33, 34, 35, 37, 39, 41, 42, 43, 44, 45, 46], [2, 26]), {
        34: [2, 34]
      }, {
        4: 58,
        7: 4,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        1: [2, 2]
      }, {
        9: 59,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        9: 60,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, o($Vm, [2, 8]), {
        10: $V0,
        11: 8,
        13: 61,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        10: $V0,
        11: 8,
        13: 62,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, o($Vm, [2, 12]), o($Vm, [2, 21]), o($Vm, [2, 22]), {
        10: $V0,
        11: 8,
        13: 63,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        24: 64,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va
      }, {
        10: $V0,
        11: 8,
        13: 65,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        7: 66,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        24: 67,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va
      }, {
        8: $Vh,
        10: $Vi,
        33: [1, 68]
      }, {
        8: $Vh,
        10: $Vi,
        35: [1, 69]
      }, {
        7: 70,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        7: 71,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        7: 72,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        7: 73,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        8: $Vh,
        10: $Vi,
        43: [1, 74]
      }, {
        8: $Vh,
        10: $Vi,
        45: [1, 75]
      }, {
        7: 76,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        6: [1, 77]
      }, o($Vj, [2, 5], {
        17: 9,
        20: 10,
        25: 11,
        15: 12,
        26: 16,
        24: 18,
        38: 19,
        27: 21,
        36: 31,
        11: 38,
        12: $Vk,
        14: $Vl,
        16: $V1,
        19: $V2,
        21: $V3,
        22: $V4,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        37: $Vb,
        39: $Vc,
        42: $Vd,
        44: $Vf,
        46: $Vg
      }), o($Vj, [2, 6], {
        17: 9,
        20: 10,
        25: 11,
        15: 12,
        26: 16,
        24: 18,
        38: 19,
        27: 21,
        36: 31,
        11: 38,
        12: $Vk,
        14: $Vl,
        16: $V1,
        19: $V2,
        21: $V3,
        22: $V4,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        37: $Vb,
        39: $Vc,
        42: $Vd,
        44: $Vf,
        46: $Vg
      }), o($Vm, [2, 9]), o($Vm, [2, 10]), o($Vn, [2, 16]), o($Vn, [2, 20]), o($Vm, [2, 24]), {
        8: $Vh,
        10: $Vi,
        33: [1, 78]
      }, o($Vo, [2, 27]), o($Vo, [2, 32]), o($Vo, [2, 33]), {
        8: $Vh,
        10: $Vi,
        35: [1, 79]
      }, {
        8: $Vh,
        10: $Vi,
        33: [1, 80]
      }, {
        8: $Vh,
        10: $Vi,
        41: [1, 81]
      }, {
        8: $Vh,
        10: $Vi,
        35: [1, 82]
      }, o($Vo, [2, 39]), o($Vo, [2, 40]), {
        8: $Vh,
        10: $Vi,
        35: [1, 83]
      }, {
        1: [2, 1]
      }, {
        32: [1, 84]
      }, o($Vo, [2, 35]), o($Vo, [2, 36]), {
        32: [1, 85]
      }, o($Vo, [2, 38]), o($Vo, [2, 41]), {
        7: 86,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        7: 87,
        9: 5,
        10: $V0,
        11: 8,
        13: 6,
        15: 12,
        16: $V1,
        17: 9,
        19: $V2,
        20: 10,
        21: $V3,
        22: $V4,
        24: 18,
        25: 11,
        26: 16,
        27: 21,
        28: $V5,
        29: $V6,
        30: $V7,
        31: $V8,
        32: $V9,
        34: $Va,
        36: 31,
        37: $Vb,
        38: 19,
        39: $Vc,
        42: $Vd,
        43: $Ve,
        44: $Vf,
        46: $Vg
      }, {
        8: $Vh,
        10: $Vi,
        33: [1, 88]
      }, {
        8: $Vh,
        10: $Vi,
        33: [1, 89]
      }, o($Vo, [2, 44]), o($Vo, [2, 37])],
      defaultActions: {
        3: [2, 3],
        33: [2, 34],
        35: [2, 2],
        77: [2, 1]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          throw new Error(str);
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        function lex() {
          var token;
          token = lexer.lex() || EOF;

          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }

          return token;
        }

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push('\'' + this.terminals_[p] + '\'');
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;

              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }

              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* generated by jison-lex 0.3.4 */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        // resets the lexer, sets new input
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        // consumes and returns one char from the input
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        // unshifts one char (or a string) into the input
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function more() {
          this._more = true;
          return this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        // retain first n characters of the match
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false; // rule action called reject() implying the next rule should be tested instead.
          }

          return false;
        },
        // return next match in input
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


            return false;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        // return next match that has a token
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {
          "flex": true
        },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

          switch ($avoiding_name_collisions) {
            case 0:
              /* skip whitespace */
              break;

            case 1:
              /* skip \space */
              break;

            case 2:
              /* skip '\ ' */
              break;

            case 3:
              return "INT";

            case 4:
              return "FLOAT";

            case 5:
              return "^";

            case 6:
              return "*";

            case 7:
              return "*";

            case 8:
              return "*";

            case 9:
              return "*";

            case 10:
              return "/";

            case 11:
              return "/";

            case 12:
              return "-";

            case 13:
              return "-";

            case 14:
              return "+";

            case 15:
              return "^";

            case 16:
              return "(";

            case 17:
              return ")";

            case 18:
              return "(";

            case 19:
              return ")";

            case 20:
              return "[";

            case 21:
              return "]";

            case 22:
              return "{";

            case 23:
              return "}";

            case 24:
              return "{";

            case 25:
              return "}";

            case 26:
              return "_";

            case 27:
              return "|";

            case 28:
              return "LEFT|";

            case 29:
              return "RIGHT|";

            case 30:
              return "!";

            case 31:
              return "SIGN";

            case 32:
              yy_.yytext = "<=";
              return "SIGN";

            case 33:
              yy_.yytext = ">=";
              return "SIGN";

            case 34:
              yy_.yytext = "<=";
              return "SIGN";

            case 35:
              yy_.yytext = ">=";
              return "SIGN";

            case 36:
              yy_.yytext = "<>";
              return "SIGN";

            case 37:
              yy_.yytext = "<>";
              return "SIGN";

            case 38:
              yy_.yytext = "<>";
              return "SIGN";

            case 39:
              yy_.yytext = "<>";
              return "SIGN";

            case 40:
              yy_.yytext = "<=";
              return "SIGN";

            case 41:
              yy_.yytext = ">=";
              return "SIGN";

            case 42:
              return "FRAC";

            case 43:
              return "FRAC";

            case 44:
              return "sqrt";

            case 45:
              return "abs";

            case 46:
              return "ln";

            case 47:
              return "log";

            case 48:
              return "TRIG";

            case 49:
              return "TRIG";

            case 50:
              return "TRIG";

            case 51:
              return "TRIG";

            case 52:
              yy_.yytext = "sin";
              return "TRIG";

            case 53:
              yy_.yytext = "cos";
              return "TRIG";

            case 54:
              yy_.yytext = "tan";
              return "TRIG";

            case 55:
              yy_.yytext = "csc";
              return "TRIG";

            case 56:
              yy_.yytext = "sec";
              return "TRIG";

            case 57:
              yy_.yytext = "cot";
              return "TRIG";

            case 58:
              yy_.yytext = "arcsin";
              return "TRIG";

            case 59:
              yy_.yytext = "arccos";
              return "TRIG";

            case 60:
              yy_.yytext = "arctan";
              return "TRIG";

            case 61:
              yy_.yytext = "arccsc";
              return "TRIG";

            case 62:
              yy_.yytext = "arcsec";
              return "TRIG";

            case 63:
              yy_.yytext = "arccot";
              return "TRIG";

            case 64:
              return "TRIGINV";

            case 65:
              return "TRIGINV";

            case 66:
              yy_.yytext = "sinh";
              return "TRIG";

            case 67:
              yy_.yytext = "cosh";
              return "TRIG";

            case 68:
              yy_.yytext = "tanh";
              return "TRIG";

            case 69:
              yy_.yytext = "csch";
              return "TRIG";

            case 70:
              yy_.yytext = "sech";
              return "TRIG";

            case 71:
              yy_.yytext = "tanh";
              return "TRIG";

            case 72:
              return "CONST";

            case 73:
              yy_.yytext = "pi";
              return "CONST";

            case 74:
              yy_.yytext = "pi";
              return "CONST";

            case 75:
              return "VAR";

            case 76:
              yy_.yytext = "theta";
              return "VAR";

            case 77:
              yy_.yytext = "theta";
              return "VAR";

            case 78:
              return "VAR";

            case 79:
              yy_.yytext = "phi";
              return "VAR";

            case 80:
              yy_.yytext = "phi";
              return "VAR";

            case 81:
              return yy.symbolLexer(yy_.yytext);

            case 82:
              return "EOF";

            case 83:
              return "INVALID";

            case 84:
              console.log(yy_.yytext);
              break;
          }
        },
        rules: [/^(?:\s+)/, /^(?:\\space)/, /^(?:\\ )/, /^(?:[0-9]+\.?)/, /^(?:([0-9]+)?\.[0-9]+)/, /^(?:\*\*)/, /^(?:\*)/, /^(?:\\cdot|·)/, /^(?:\\times|×)/, /^(?:\\ast)/, /^(?:\/)/, /^(?:\\div|÷)/, /^(?:-)/, /^(?:−)/, /^(?:\+)/, /^(?:\^)/, /^(?:\()/, /^(?:\))/, /^(?:\\left\()/, /^(?:\\right\))/, /^(?:\[)/, /^(?:\])/, /^(?:\{)/, /^(?:\})/, /^(?:\\left\{)/, /^(?:\\right\})/, /^(?:_)/, /^(?:\|)/, /^(?:\\left\|)/, /^(?:\\right\|)/, /^(?:\!)/, /^(?:<=|>=|<>|<|>|=)/, /^(?:\\le)/, /^(?:\\ge)/, /^(?:\\leq)/, /^(?:\\geq)/, /^(?:=\/=)/, /^(?:\\ne)/, /^(?:\\neq)/, /^(?:≠)/, /^(?:≤)/, /^(?:≥)/, /^(?:\\frac)/, /^(?:\\dfrac)/, /^(?:sqrt|\\sqrt)/, /^(?:abs|\\abs)/, /^(?:ln|\\ln)/, /^(?:log|\\log)/, /^(?:sin|cos|tan)/, /^(?:csc|sec|cot)/, /^(?:sinh|cosh|tanh)/, /^(?:csch|sech|coth)/, /^(?:\\sin)/, /^(?:\\cos)/, /^(?:\\tan)/, /^(?:\\csc)/, /^(?:\\sec)/, /^(?:\\cot)/, /^(?:\\arcsin)/, /^(?:\\arccos)/, /^(?:\\arctan)/, /^(?:\\arccsc)/, /^(?:\\arcsec)/, /^(?:\\arccot)/, /^(?:arcsin|arccos|arctan)/, /^(?:arccsc|arcsec|arccot)/, /^(?:\\sinh)/, /^(?:\\cosh)/, /^(?:\\tanh)/, /^(?:\\csch)/, /^(?:\\sech)/, /^(?:\\coth)/, /^(?:pi)/, /^(?:π)/, /^(?:\\pi)/, /^(?:theta)/, /^(?:θ)/, /^(?:\\theta)/, /^(?:phi)/, /^(?:φ)/, /^(?:\\phi)/, /^(?:[a-zA-Z])/, /^(?:$)/, /^(?:.)/, /^(?:.)/],
        conditions: {
          "INITIAL": {
            "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84],
            "inclusive": true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  KAS.parser = parser;
})(KAS); // this is a @generated file


(function (KAS) {
  /* parser generated by jison 0.4.15 */

  /*
    Returns a Parser object of the following structure:
  
    Parser: {
      yy: {}
    }
  
    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),
  
      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),
  
          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },
  
          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }
  
  
    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }
  
  
    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var parser = function () {
    var o = function o(k, v, _o2, l) {
      for (_o2 = _o2 || {}, l = k.length; l--; _o2[k[l]] = v) {
      }

      return _o2;
    },
        $V0 = [1, 11],
        $V1 = [1, 9],
        $V2 = [8, 17],
        $V3 = [6, 11],
        $V4 = [6, 11, 13, 17];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        "error": 2,
        "unitvalue": 3,
        "magnitude": 4,
        "unit": 5,
        "EOF": 6,
        "float": 7,
        "POW": 8,
        "int": 9,
        "multatoms": 10,
        "DIV": 11,
        "expatom": 12,
        "MUL": 13,
        "atom": 14,
        "^": 15,
        "nat": 16,
        "ATOM": 17,
        "FLOAT": 18,
        "NAT": 19,
        "NEG": 20,
        "$accept": 0,
        "$end": 1
      },
      terminals_: {
        2: "error",
        6: "EOF",
        8: "POW",
        11: "DIV",
        13: "MUL",
        15: "^",
        17: "ATOM",
        18: "FLOAT",
        19: "NAT",
        20: "NEG"
      },
      productions_: [0, [3, 3], [3, 2], [4, 3], [4, 1], [5, 3], [5, 1], [10, 3], [10, 2], [10, 1], [12, 3], [12, 1], [14, 1], [7, 1], [7, 1], [16, 1], [9, 2], [9, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
      /* action[1] */
      , $$
      /* vstack */
      , _$
      /* lstack */
      ) {
        /* this == yyval */
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
            return {
              type: "unitMagnitude",
              magnitude: $$[$0 - 2],
              unit: $$[$0 - 1]
            };

          case 2:
            return {
              type: "unitStandalone",
              unit: $$[$0 - 1]
            };

          case 3:
            this.$ = $$[$0 - 2] + "e" + $$[$0];
            break;

          case 4:
          case 13:
          case 14:
          case 15:
          case 17:
            this.$ = $$[$0];
            break;

          case 5:
            this.$ = {
              num: $$[$0 - 2],
              denom: $$[$0]
            };
            break;

          case 6:
            this.$ = {
              num: $$[$0],
              denom: null
            };
            break;

          case 7:
            this.$ = [$$[$0 - 2]].concat($$[$0]);
            break;

          case 8:
            this.$ = [$$[$0 - 1]].concat($$[$0]);
            break;

          case 9:
            this.$ = [$$[$0]];
            break;

          case 10:
            this.$ = {
              name: $$[$0 - 2],
              pow: $$[$0]
            };
            break;

          case 11:
            this.$ = {
              name: $$[$0],
              pow: 1
            };
            break;

          case 12:
            this.$ = yytext;
            break;

          case 16:
            this.$ = "-" + $$[$0];
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        5: 3,
        7: 4,
        10: 5,
        12: 8,
        14: 10,
        16: 7,
        17: $V0,
        18: [1, 6],
        19: $V1
      }, {
        1: [3]
      }, {
        5: 12,
        10: 5,
        12: 8,
        14: 10,
        17: $V0
      }, {
        6: [1, 13]
      }, {
        8: [1, 14],
        17: [2, 4]
      }, {
        6: [2, 6],
        11: [1, 15]
      }, o($V2, [2, 13]), o($V2, [2, 14]), o($V3, [2, 9], {
        12: 8,
        14: 10,
        10: 17,
        13: [1, 16],
        17: $V0
      }), o([6, 8, 11, 13, 17], [2, 15]), o($V4, [2, 11], {
        15: [1, 18]
      }), o([6, 11, 13, 15, 17], [2, 12]), {
        6: [1, 19]
      }, {
        1: [2, 2]
      }, {
        9: 20,
        19: [1, 22],
        20: [1, 21]
      }, {
        10: 23,
        12: 8,
        14: 10,
        17: $V0
      }, {
        10: 24,
        12: 8,
        14: 10,
        17: $V0
      }, o($V3, [2, 8]), {
        16: 25,
        19: $V1
      }, {
        1: [2, 1]
      }, {
        17: [2, 3]
      }, {
        19: [1, 26]
      }, {
        17: [2, 17]
      }, {
        6: [2, 5]
      }, o($V3, [2, 7]), o($V4, [2, 10]), {
        17: [2, 16]
      }],
      defaultActions: {
        13: [2, 2],
        19: [2, 1],
        20: [2, 3],
        22: [2, 17],
        23: [2, 5],
        26: [2, 16]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          throw new Error(str);
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        function lex() {
          var token;
          token = lexer.lex() || EOF;

          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }

          return token;
        }

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push('\'' + this.terminals_[p] + '\'');
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;

              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }

              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };
    /* generated by jison-lex 0.3.4 */

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        // resets the lexer, sets new input
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        // consumes and returns one char from the input
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        // unshifts one char (or a string) into the input
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        // When called from action, caches matched text and appends it on next action
        more: function more() {
          this._more = true;
          return this;
        },
        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        // retain first n characters of the match
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        // displays already matched input, i.e. for error messages
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
        },
        // displays upcoming input, i.e. for error messages
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
        },
        // displays the character position where the lexing error occurred, i.e. for error messages
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        // test the lexed token: return FALSE when not a match, otherwise return token
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            // save context
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false; // rule action called reject() implying the next rule should be tested instead.
          }

          return false;
        },
        // return next match in input
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue; // rule action called reject() implying a rule MISmatch.
                } else {
                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


            return false;
          }

          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        // return next match that has a token
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        // pop the previously active lexer condition state off the condition stack
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        // produce the lexer rule set which is active for the currently active lexer condition state
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        // alias for begin(condition)
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        // return the number of states currently on the stack
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

          switch ($avoiding_name_collisions) {
            case 0:
              return 11;

            case 1:
              return '(';

            case 2:
              return ')';

            case 3:
              return 8;

            case 4:
              return 15;

            case 5:
              return 13;

            case 6:
              return 18;

            case 7:
              return 19;

            case 8:
              return 20;

            case 9:
              return 17;

            case 10:
              return 17;

            case 11:
              return 17;

            case 12:
              /* skip whitespace */
              break;

            case 13:
              return 6;
          }
        },
        rules: [/^(?:\/)/, /^(?:\()/, /^(?:\))/, /^(?:(\*|x|\u00d7|\u2219|\u22c5|\u00b7)\s*10\s*\^)/, /^(?:\^)/, /^(?:\*)/, /^(?:[0-9]+\.[0-9]+)/, /^(?:[0-9]+)/, /^(?:-)/, /^(?:\u00b0( ?)[cCfF])/, /^(?:fl\.? oz\.?)/, /^(?:[\u00b5]?([A-Za-z-]+|[\u2103\u2109\u212b]))/, /^(?:\s+)/, /^(?:$)/],
        conditions: {
          "INITIAL": {
            "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
            "inclusive": true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  KAS.unitParser = parser;
})(KAS);
/* TODO(charlie): fix these lint errors (http://eslint.org/docs/rules): */

/* eslint-disable indent, no-undef, no-var, one-var, no-dupe-keys, no-new-func, no-redeclare, no-unused-vars, comma-dangle, max-len, prefer-spread, space-infix-ops, space-unary-ops */


(function (KAS) {
  /*  The node hierarcy is as follows:
  
      (Expr)
          (Seq)           2+ children
              Add
              Mul
          Pow             2 children
          Log             2 children
          Eq              2 children
          Trig            1 child
          Abs             1 child
          (Symbol)
              Func        1 child     e.g. f(x)
              Var         leaf node   e.g. x, x_n
              Const       leaf node   e.g. pi, e, <i>
              Unit        leaf node   e.g. kg
          (Num)           leaf node
              Rational                e.g. 2/3
                  Int
              Float
  
      (abstract, not meant to be instantiated)
  
      == Key design concepts ==
      Functional: All methods return new nodes - nodes are never mutated.
      Ignore commutativity: Commutative inputs should be parsed equivalently.
      Exploit commutativity: Output should take advantage of ordering.
  */

  /* non user-facing functions */
  // assert that all abstract methods have been overridden
  var abstract = function abstract() {
    // Try to give people a bit of information when this happens
    throw new Error("Abstract method - must override for expr: " + this.print());
  }; // throw an error that is meant to be caught by the test suite (not user facing)


  var error = function error(message) {
    throw new Error(message);
  }; // reliably detect NaN


  var isNaN = function isNaN(object) {
    return object !== object;
  }; // return a random float between min (inclusive) and max (exclusive),
  // not that inclusivity means much, probabilistically, on floats


  var randomFloat = function randomFloat(min, max) {
    var extent = max - min;
    return Math.random() * extent + min;
  };
  /* constants */


  var ITERATIONS = 12;
  var TOLERANCE = 9; // decimal places

  /* abstract base expression node */

  function Expr() {}

  _.extend(Expr.prototype, {
    // this node's immediate constructor
    func: abstract,
    // an array of the arguments to this node's immediate constructor
    args: abstract,
    // make a new node with the given arguments
    construct: function construct(args) {
      var instance = new this.func();
      this.func.apply(instance, args);
      return instance;
    },
    // an abstraction for chainable, bottom-up recursion
    recurse: function recurse(method) {
      var passed = Array.prototype.slice.call(arguments, 1);

      var args = _.map(this.args(), function (arg) {
        return _.isString(arg) ? arg : arg[method].apply(arg, passed);
      });

      return this.construct(args);
    },
    // evaluate numerically with given variable mapping
    eval: abstract,
    codegen: abstract,
    compile: function compile() {
      var code = this.codegen();

      try {
        return new Function("vars", "return " + code + ";");
      } catch (e) {
        throw new Error("Function did not compile: " + code);
      }
    },
    // returns a string unambiguously representing the expression
    // should be valid as input
    // e.g. this.equals(parse(this.print())) === true
    print: abstract,
    // returns a TeX string representing the expression
    tex: abstract,
    // returns a TeX string, modified by the given options
    asTex: function asTex(options) {
      options = options || {};

      _.defaults(options, {
        display: true,
        dynamic: true,
        times: false
      });

      var tex = this.tex();

      if (options.display) {
        tex = "\\displaystyle " + tex;
      }

      if (options.dynamic) {
        tex = tex.replace(/\(/g, "\\left(");
        tex = tex.replace(/\)/g, "\\right)");
      }

      if (options.times) {
        tex = tex.replace(/\\cdot/g, "\\times");
      }

      return tex;
    },
    // returns the name of this expression's constructor as a string
    // only used for testing and debugging (the ugly regex is for IE8)
    name: function name() {
      if (this.func.name) {
        return this.func.name;
      } else {
        return this.func.toString().match(/^function\s*([^\s(]+)/)[1];
      }
    },
    // returns a string representing current node structure
    repr: function repr() {
      return this.name() + "(" + _.map(this.args(), function (arg) {
        return _.isString(arg) ? arg : arg.repr();
      }).join(",") + ")";
    },
    // removes all negative signs
    strip: function strip() {
      return this.recurse("strip");
    },
    // canonically reorders all commutative elements
    normalize: function normalize() {
      return this.recurse("normalize");
    },
    // expands the expression
    expand: function expand() {
      return this.recurse("expand");
    },
    // naively factors out like terms
    factor: function factor(options) {
      return this.recurse("factor", options);
    },
    // collect all like terms
    collect: function collect(options) {
      return this.recurse("collect", options);
    },
    // strict syntactic equality check
    equals: function equals(other) {
      return this.normalize().print() === other.normalize().print();
    },
    // expand and collect until the expression no longer changes
    simplify: function simplify(options) {
      options = _.extend({
        once: false
      }, options); // Attempt to factor and collect

      var step1 = this.factor(options);
      var step2 = step1.collect(options); // Rollback if collect didn't do anything

      if (step1.equals(step2)) {
        step2 = this.collect(options);
      } // Attempt to expand and collect


      var step3 = step2.expand(options);
      var step4 = step3.collect(options); // Rollback if collect didn't do anything

      if (step3.equals(step4)) {
        step4 = step2.collect(options);
      } // One round of simplification complete


      var simplified = step4;

      if (options.once || this.equals(simplified)) {
        return simplified;
      } else {
        return simplified.simplify(options);
      }
    },
    // check whether this expression is simplified
    isSimplified: function isSimplified() {
      return this.equals(this.simplify());
    },
    // return the child nodes of this node
    exprArgs: function exprArgs() {
      return _.filter(this.args(), function (arg) {
        return arg instanceof Expr;
      });
    },
    // return the variables (function and non) within the expression
    getVars: function getVars(excludeFunc) {
      return _.uniq(_.flatten(_.invoke(this.exprArgs(), "getVars", excludeFunc))).sort();
    },
    getConsts: function getConsts() {
      return _.uniq(_.flatten(_.invoke(this.exprArgs(), "getConsts"))).sort();
    },
    getUnits: function getUnits() {
      return _.flatten(_.invoke(this.exprArgs(), "getUnits"));
    },
    // check whether this expression node is of a particular type
    is: function is(func) {
      return this instanceof func;
    },
    // check whether this expression has a particular node type
    has: function has(func) {
      if (this instanceof func) {
        return true;
      }

      return _.any(this.exprArgs(), function (arg) {
        return arg.has(func);
      });
    },
    // raise this expression to a given exponent
    // most useful for eventually implementing i^3 = -i, etc.
    raiseToThe: function raiseToThe(exp) {
      return new Pow(this, exp);
    },
    // does this expression have a specific rendering hint?
    // rendering hints are picked up while parsing, but are lost during transformations
    isSubtract: function isSubtract() {
      return false;
    },
    isDivide: function isDivide() {
      return false;
    },
    isRoot: function isRoot() {
      return false;
    },
    // whether this node needs an explicit multiplication sign if following a Num
    needsExplicitMul: function needsExplicitMul() {
      return this.args()[0].needsExplicitMul();
    },
    // check that the variables in both expressions are the same
    sameVars: function sameVars(other) {
      var vars1 = this.getVars();
      var vars2 = other.getVars(); // the other Expr can have more variables than this one
      // this lets you multiply equations by other variables

      var same = function same(array1, array2) {
        return !_.difference(array1, array2).length;
      };

      var lower = function lower(array) {
        return _.uniq(_.invoke(array, "toLowerCase")).sort();
      };

      var equal = same(vars1, vars2);
      var equalIgnoringCase = same(lower(vars1), lower(vars2));
      return {
        equal: equal,
        equalIgnoringCase: equalIgnoringCase
      };
    },
    // semantic equality check, call after sameVars() to avoid potential false positives
    // plug in random numbers for the variables in both expressions
    // if they both consistently evaluate the same, then they're the same
    compare: function compare(other) {
      // equation comparisons are handled by Eq.compare()
      if (other instanceof Eq) {
        return false;
      }

      var varList = _.union(this.getVars(
      /* excludeFunc */
      true), other.getVars(
      /* excludeFunc */
      true)); // If the numbers are large we would like to do a relative comparison
      // rather than an absolute one, but if they're small enough then an
      // absolute comparison makes more sense


      var getDelta = function getDelta(num1, num2) {
        if (Math.abs(num1) < 1 || Math.abs(num2) < 1) {
          return Math.abs(num1 - num2);
        } else {
          return Math.abs(1 - num1 / num2);
        }
      };

      var equalNumbers = function equalNumbers(num1, num2) {
        var delta = getDelta(num1, num2);
        return num1 === num2 ||
        /* needed if either is +/- Infinity */
        isNaN(num1) && isNaN(num2) || delta < Math.pow(10, -TOLERANCE);
      }; // if no variables, only need to evaluate once


      if (!varList.length && !this.has(Unit) && !other.has(Unit)) {
        return equalNumbers(this.eval(), other.eval());
      } // collect here to avoid sometimes dividing by zero, and sometimes not
      // it is better to be deterministic, e.g. x/x -> 1
      // TODO(alex): may want to keep track of assumptions as they're made


      var expr1 = this.collect();
      var expr2 = other.collect();
      var unitList1 = this.getUnits();
      var unitList2 = other.getUnits();

      if (!_.isEqual(unitList1, unitList2)) {
        return false;
      } // Compare at a set number (currently 12) of points to determine
      // equality.
      //
      // `range` (and `vars`) is the only variable that varies through the
      // iterations. For each of range = 10, 100, and 1000, each random
      // variable is picked from (-range, range).
      //
      // Note that because there are 12 iterations and three ranges, each
      // range is checked four times.


      for (var i = 0; i < ITERATIONS; i++) {
        var vars = {}; // One third total iterations each with range 10, 100, and 1000

        var range = Math.pow(10, 1 + Math.floor(3 * i / ITERATIONS)); // Half of the iterations should only use integer values.
        // This is because expressions like (-2)^x are common but result
        // in NaN when evaluated in JS with non-integer values of x.
        // Without this, (-2)^x and (-2)^(x+1) both end up always being NaN
        // and thus equivalent. With this, the most common failure case is
        // avoided. However, less common cases such as (-2)^(x+0.1) and
        // (-2)^(x+1.1) will still both evaluate to NaN and result in a
        // false positive.
        //
        // Note that the above is only true in vanilla JS Number-land,
        // which has no concept of complex numbers. The solution is simple:
        // Integrate a library for handling complex numbers.
        //
        // TODO(alex): Add support for complex numbers, then remove this.

        var useFloats = i % 2 === 0;

        _.each(varList, function (v) {
          vars[v] = useFloats ? randomFloat(-range, range) : _.random(-range, range);
        });

        var equal;

        if (expr1.has(Func) || expr2.has(Func) || expr1.has(Unit) || expr2.has(Unit)) {
          var result1 = expr1.partialEval(vars);
          var result2 = expr2.partialEval(vars);
          equal = result1.simplify().equals(result2.simplify());
        } else {
          var result1 = expr1.eval(vars);
          var result2 = expr2.eval(vars);
          equal = equalNumbers(result1, result2);
        }

        if (!equal) {
          return false;
        }
      }

      return true;
    },
    // evaluate as much of the expression as possible
    partialEval: function partialEval(vars) {
      if (this instanceof Unit) {
        return this;
      } else if (!this.has(Func)) {
        return new Float(this.eval(vars).toFixed(TOLERANCE)).collect();
      } else if (this instanceof Func) {
        return new Func(this.symbol, this.arg.partialEval(vars));
      } else {
        return this.recurse("partialEval", vars);
      }
    },
    // check that the structure of both expressions is the same
    // all negative signs are stripped and the expressions are converted to
    // a canonical commutative form
    // should only be done after compare() returns true to avoid false positives
    sameForm: function sameForm(other) {
      return this.strip().equals(other.strip());
    },
    // returns the GCD of this expression and the given factor
    findGCD: function findGCD(factor) {
      return this.equals(factor) ? factor : Num.One;
    },
    // return this expression's denominator
    getDenominator: function getDenominator() {
      return Num.One;
    },
    // return this expression as a Mul
    asMul: function asMul() {
      return new Mul(Num.One, this);
    },
    // TODO(alex): rename to isDefinitePositive or similar?
    // return whether this expression is 100% positive
    isPositive: abstract,
    // TODO(alex): rename to hasNegativeSign or similar?
    // return whether this expression has a negative sign
    isNegative: function isNegative() {
      return false;
    },
    // return a factor of this expression that is 100% positive
    asPositiveFactor: function asPositiveFactor() {
      return this.isPositive() ? this : Num.One;
    },
    // return a copy of the expression with a new hint set (preserves hints)
    addHint: function addHint(hint) {
      if (!hint) {
        return this;
      }

      var expr = this.construct(this.args());
      expr.hints = _.clone(this.hints);
      expr.hints[hint] = true;
      return expr;
    },
    hints: {
      parens: false
    },
    // currently unused!
    asExpr: function asExpr() {
      return this;
    },
    // complete parse by performing a few necessary transformations
    completeParse: function completeParse() {
      return this.recurse("completeParse");
    },
    abs: abstract,
    negate: function negate() {
      return new Mul(Num.Neg, this);
    }
  });
  /* abstract sequence node */


  function Seq() {}

  Seq.prototype = new Expr();

  _.extend(Seq.prototype, {
    args: function args() {
      return this.terms;
    },
    normalize: function normalize() {
      var terms = _.sortBy(_.invoke(this.terms, "normalize"), function (term) {
        return term.print();
      });

      return new this.func(terms);
    },
    expand: function expand() {
      return this.recurse("expand").flatten();
    },
    // partition the sequence into its numeric and non-numeric parts
    // makes no guarantees about the validity of either part!
    partition: function partition() {
      var terms = _.groupBy(this.terms, function (term) {
        return term instanceof Num;
      }); // XXX using a boolean as a key just converts it to a string. I don't
      // think this code was written with that in mind. Probably doesn't
      // matter except for readability.


      var numbers = terms[true] || [];
      var others = terms[false] || [];
      return [new this.func(numbers), new this.func(others)];
    },
    // ensure that sequences have 2+ terms and no nested sequences of the same type
    // this is a shallow flattening and will return a non-Seq if terms.length <= 1
    flatten: function flatten() {
      var type = this;

      var terms = _.reject(this.terms, function (term) {
        return term.equals(type.identity);
      });

      if (terms.length === 0) {
        return type.identity;
      }

      if (terms.length === 1) {
        return terms[0];
      }

      var grouped = _.groupBy(terms, function (term) {
        return term instanceof type.func;
      }); // same contains the children which are Seqs of the same type as this Seq


      var same = grouped[true] || [];
      var others = grouped[false] || [];
      var flattened = others.concat(_.flatten(_.pluck(same, "terms"),
      /* shallow: */
      true));
      return new type.func(flattened);
    },
    // the identity associated with the sequence
    identity: undefined,
    // reduce a numeric sequence to a Num
    reduce: abstract,
    isPositive: function isPositive() {
      var terms = _.invoke(this.terms, "collect");

      return _.all(_.invoke(terms, "isPositive"));
    },
    // return a new Seq with a given term replaced by a different term
    // (or array of terms). given term can be passed directly, or by index
    // if no new term is provided, the old one is simply removed
    replace: function replace(oldTerm, newTerm) {
      var index;

      if (oldTerm instanceof Expr) {
        index = _.indexOf(this.terms, oldTerm);
      } else {
        index = oldTerm;
      }

      var newTerms = [];

      if (_.isArray(newTerm)) {
        newTerms = newTerm;
      } else if (newTerm) {
        newTerms = [newTerm];
      }

      var terms = this.terms.slice(0, index).concat(newTerms).concat(this.terms.slice(index + 1));
      return new this.func(terms);
    },
    // syntactic sugar for replace()
    remove: function remove(term) {
      return this.replace(term);
    },
    getDenominator: function getDenominator() {
      // TODO(alex): find and return LCM
      return new Mul(_.invoke(this.terms, "getDenominator")).flatten();
    }
  });
  /* sequence of additive terms */


  function Add() {
    if (arguments.length === 1) {
      this.terms = arguments[0];
    } else {
      this.terms = _.toArray(arguments);
    }
  }

  Add.prototype = new Seq();

  _.extend(Add.prototype, {
    func: Add,
    eval: function _eval(vars, options) {
      return _.reduce(this.terms, function (memo, term) {
        return memo + term.eval(vars, options);
      }, 0);
    },
    codegen: function codegen() {
      return _.map(this.terms, function (term) {
        return "(" + term.codegen() + ")";
      }).join(" + ") || "0";
    },
    print: function print() {
      return _.invoke(this.terms, "print").join("+");
    },
    tex: function tex() {
      var tex = "";

      _.each(this.terms, function (term) {
        if (!tex || term.isSubtract()) {
          tex += term.tex();
        } else {
          tex += "+" + term.tex();
        }
      });

      return tex;
    },
    collect: function collect(options) {
      var terms = _.invoke(this.terms, "collect", options); // [Expr expr, Num coefficient]


      var pairs = [];

      _.each(terms, function (term) {
        if (term instanceof Mul) {
          var muls = term.partition();
          pairs.push([muls[1].flatten(), muls[0].reduce(options)]);
        } else if (term instanceof Num) {
          pairs.push([Num.One, term]);
        } else {
          pairs.push([term, Num.One]);
        }
      }); // { (Expr expr).print(): [[Expr expr, Num coefficient]] }


      var grouped = _.groupBy(pairs, function (pair) {
        return pair[0].normalize().print();
      });

      var collected = _.compact(_.map(grouped, function (pairs) {
        var expr = pairs[0][0];
        var sum = new Add(_.zip.apply(_, pairs)[1]);
        var coefficient = sum.reduce(options);
        return new Mul(coefficient, expr).collect(options);
      })); // TODO(alex): use the Pythagorean identity here
      // e.g. x*sin^2(y) + x*cos^2(y) -> x


      return new Add(collected).flatten();
    },
    // naively factor out anything that is common to all terms
    // if options.keepNegative is specified, won't factor out a common -1
    factor: function factor(options) {
      options = _.extend({
        keepNegative: false
      }, options);

      var terms = _.invoke(this.terms, "collect");

      var factors;

      if (terms[0] instanceof Mul) {
        factors = terms[0].terms;
      } else {
        factors = [terms[0]];
      }

      _.each(_.rest(this.terms), function (term) {
        factors = _.map(factors, function (factor) {
          return term.findGCD(factor);
        });
      });

      if (!options.keepNegative && this.isNegative()) {
        factors.push(Num.Neg);
      }

      factors = new Mul(factors).flatten().collect();

      var remainder = _.map(terms, function (term) {
        return Mul.handleDivide(term, factors).simplify();
      });

      remainder = new Add(remainder).flatten();
      return Mul.createOrAppend(factors, remainder).flatten();
    },
    reduce: function reduce(options) {
      return _.reduce(this.terms, function (memo, term) {
        return memo.add(term, options);
      }, this.identity);
    },
    needsExplicitMul: function needsExplicitMul() {
      return false;
    },
    isNegative: function isNegative() {
      var terms = _.invoke(this.terms, "collect");

      return _.all(_.invoke(terms, "isNegative"));
    },
    negate: function negate() {
      return new Add(_.invoke(this.terms, "negate"));
    }
  });
  /* sequence of multiplicative terms */


  function Mul() {
    if (arguments.length === 1) {
      this.terms = arguments[0];
    } else {
      this.terms = _.toArray(arguments);
    }
  }

  Mul.prototype = new Seq();

  _.extend(Mul.prototype, {
    func: Mul,
    eval: function _eval(vars, options) {
      return _.reduce(this.terms, function (memo, term) {
        return memo * term.eval(vars, options);
      }, 1);
    },
    codegen: function codegen() {
      return _.map(this.terms, function (term) {
        return "(" + term.codegen() + ")";
      }).join(" * ") || "0";
    },
    print: function print() {
      return _.map(this.terms, function (term) {
        return term instanceof Add ? "(" + term.print() + ")" : term.print();
      }).join("*");
    },
    getUnits: function getUnits() {
      var tmUnits = _.chain(this.terms).map(function (term) {
        return term.getUnits();
      }).flatten().value();

      tmUnits.sort(function (a, b) {
        return a.unit < b.unit;
      });
      return tmUnits;
    },
    // since we don't care about commutativity, we can render a Mul any way we choose
    // so we follow convention: first any negatives, then any numbers, then everything else
    tex: function tex() {
      var cdot = " \\cdot ";

      var terms = _.groupBy(this.terms, function (term) {
        if (term.isDivide()) {
          return "inverse";
        } else if (term instanceof Num) {
          return "number";
        } else {
          return "other";
        }
      });

      var inverses = terms.inverse || [];
      var numbers = terms.number || [];
      var others = terms.other || [];
      var negatives = "";
      var numerator; // check all the numbers to see if there is a rational we can extract,
      // since we would like 1/2x/y to come out as \frac{1}{2}\frac{x}{y},
      // and not \frac{1x}{2y}.

      for (var i = 0; i < numbers.length; i++) {
        var isRational = numbers[i] instanceof Rational && !(numbers[i] instanceof Int);

        if (isRational && others.length > 0 && inverses.length > 0) {
          var withThisRemoved = numbers.slice();
          withThisRemoved.splice(i, 1);
          var newTerms = withThisRemoved.concat(inverses).concat(others);
          return numbers[i].tex() + new Mul(newTerms).tex();
        }
      }

      numbers = _.compact(_.map(numbers, function (term) {
        var hasDenom = term instanceof Rational && !(term instanceof Int);
        var shouldPushDown = !term.hints.fraction || inverses.length > 0;

        if (hasDenom && shouldPushDown) {
          // e.g. 3x/4 -> 3/4*x (internally) -> 3x/4 (rendered)
          inverses.push(new Pow(new Int(term.d), Num.Div));
          var number = new Int(term.n);
          number.hints = term.hints;
          return _.any(term.hints) ? number : null;
        } else {
          return term;
        }
      }));

      if (numbers.length === 0 && others.length === 1) {
        // e.g. (x+y)/z -> \frac{x+y}{z}
        numerator = others[0].tex();
      } else {
        var tex = "";

        _.each(numbers, function (term) {
          if (term.hints.subtract && term.hints.entered) {
            negatives += "-";
            tex += (tex ? cdot : "") + term.abs().tex();
          } else if (term instanceof Int && term.n === -1 && (term.hints.negate || term.hints.subtract)) {
            // e.g. -1*-1 -> --1
            // e.g. -1*x -> -x
            negatives += "-";
          } else {
            // e.g. 2*3 -> 2(dot)3
            tex += (tex ? cdot : "") + term.tex();
          }
        });

        _.each(others, function (term) {
          if (term.needsExplicitMul()) {
            // e.g. 2*2^3 -> 2(dot)2^3
            tex += (tex ? cdot : "") + term.tex();
          } else if (term instanceof Add) {
            // e.g. (a+b)*c -> (a+b)c
            tex += "(" + term.tex() + ")";
          } else {
            // e.g. a*b*c -> abc
            tex += term.tex();
          }
        });

        numerator = tex ? tex : "1";
      }

      if (!inverses.length) {
        return negatives + numerator;
      } else {
        var denominator = new Mul(_.invoke(inverses, "asDivide")).flatten().tex();
        return negatives + "\\frac{" + numerator + "}{" + denominator + "}";
      }
    },
    strip: function strip() {
      var terms = _.map(this.terms, function (term) {
        return term instanceof Num ? term.abs() : term.strip();
      });

      return new Mul(terms).flatten();
    },
    // expand numerator and denominator separately
    expand: function expand() {
      var isAdd = function isAdd(term) {
        return term instanceof Add;
      };

      var isInverse = function isInverse(term) {
        return term instanceof Pow && term.exp.isNegative();
      };

      var isInverseAdd = function isInverseAdd(term) {
        return isInverse(term) && isAdd(term.base);
      };

      var mul = this.recurse("expand").flatten();

      var hasAdd = _.any(mul.terms, isAdd);

      var hasInverseAdd = _.any(mul.terms, isInverseAdd);

      if (!(hasAdd || hasInverseAdd)) {
        return mul;
      }

      var terms = _.groupBy(mul.terms, isInverse);

      var normals = terms[false] || [];
      var inverses = terms[true] || [];

      if (hasAdd) {
        var grouped = _.groupBy(normals, isAdd);

        var adds = grouped[true] || [];
        var others = grouped[false] || []; // loop over each additive sequence

        var expanded = _.reduce(adds, function (expanded, add) {
          // loop over each expanded array of terms
          return _.reduce(expanded, function (temp, array) {
            // loop over each additive sequence's terms
            return temp.concat(_.map(add.terms, function (term) {
              return array.concat(term);
            }));
          }, []);
        }, [[]]); // join each fully expanded array of factors with remaining multiplicative factors


        var muls = _.map(expanded, function (array) {
          return new Mul(others.concat(array)).flatten();
        });

        normals = [new Add(muls)];
      }

      if (hasInverseAdd) {
        var denominator = new Mul(_.invoke(inverses, "getDenominator")).flatten();
        inverses = [new Pow(denominator.expand(), Num.Div)];
      }

      return new Mul(normals.concat(inverses)).flatten();
    },
    factor: function factor(options) {
      var factored = this.recurse("factor", options).flatten();

      if (!(factored instanceof Mul)) {
        return factored;
      } // Combine any factored out Rationals into one, but don't collect


      var grouped = _.groupBy(factored.terms, function (term) {
        return term instanceof Rational;
      }); // Could also accomplish this by passing a new option
      // e.g. return  memo.mul(term, {autocollect: false});
      // TODO(alex): Decide whether this is a good use of options or not


      var rational = _.reduce(grouped[true], function (memo, term) {
        return {
          n: memo.n * term.n,
          d: memo.d * term.d
        };
      }, {
        n: 1,
        d: 1
      });

      if (rational.d === 1) {
        rational = new Int(rational.n);
      } else {
        rational = new Rational(rational.n, rational.d);
      }

      return new Mul((grouped[false] || []).concat(rational)).flatten();
    },
    collect: function collect(options) {
      var partitioned = this.recurse("collect", options).partition();
      var number = partitioned[0].reduce(options); // e.g. 0*x -> 0

      if (number.eval() === 0) {
        return Num.Zero;
      }

      var others = partitioned[1].flatten(); // e.g. 2*2 -> 4
      // e.g. 2*2*x -> 4*x

      if (!(others instanceof Mul)) {
        return new Mul(number, others).flatten();
      }

      others = others.terms; // [Expr base, Expr exp]

      var pairs = [];

      _.each(others, function (term) {
        if (term instanceof Pow) {
          pairs.push([term.base, term.exp]);
        } else {
          pairs.push([term, Num.One]);
        }
      }); // {(Expr base).print(): [[Expr base, Expr exp]]}


      var grouped = _.groupBy(pairs, function (pair) {
        return pair[0].normalize().print();
      }); // [[Expr base, Expr exp]]


      var summed = _.compact(_.map(grouped, function (pairs) {
        var base = pairs[0][0];
        var sum = new Add(_.zip.apply(_, pairs)[1]);
        var exp = sum.collect(options);

        if (exp instanceof Num && exp.eval() === 0) {
          return null;
        } else {
          return [base, exp];
        }
      })); // XXX `pairs` is shadowed four or five times in this function


      var pairs = _.groupBy(summed, function (pair) {
        if (pair[0] instanceof Trig && pair[0].isBasic()) {
          return "trig";
        } else if (pair[0] instanceof Log) {
          return "log";
        } else {
          return "expr";
        }
      });

      var trigs = pairs.trig || [];
      var logs = pairs.log || [];
      var exprs = pairs.expr || [];

      if (trigs.length > 1) {
        // combine sines and cosines into other trig functions
        // {Trig.arg.print(): [[Trig base, Expr exp]]}
        var byArg = _.groupBy(trigs, function (pair) {
          return pair[0].arg.normalize().print();
        });

        trigs = [];

        _.each(byArg, function (pairs) {
          var arg = pairs[0][0].arg; // {Trig.type: Expr exp}

          var funcs = {
            sin: Num.Zero,
            cos: Num.Zero
          };

          _.each(pairs, function (pair) {
            funcs[pair[0].type] = pair[1];
          });

          if (Mul.handleNegative(funcs.sin).collect(options).equals(funcs.cos)) {
            // e.g. sin^x(y)/cos^x(y) -> tan^x(y)
            if (funcs.cos.isNegative()) {
              funcs = {
                tan: funcs.sin
              };
            } else {
              funcs = {
                cot: funcs.cos
              };
            }
          } // TODO(alex): combine even if exponents not a perfect match
          // TODO(alex): transform 1/sin and 1/cos into csc and sec


          _.each(funcs, function (exp, type) {
            trigs.push([new Trig(type, arg), exp]);
          });
        });
      }

      if (logs.length > 1) {
        // combine logs with the same base
        // {Log.base.print(): [[Log base, Expr exp]]}
        var byBase = _.groupBy(logs, function (pair) {
          return pair[0].base.normalize().print();
        });

        logs = [];

        _.each(byBase, function (pairs) {
          // only combine two logs of the same base, otherwise commutative
          // differences result in different equally valid output
          // e.g. ln(x)/ln(z)*ln(y) -> log_z(x)*ln(y)
          // e.g. ln(x)*ln(y)/ln(z) -> ln(x)*log_z(y)
          if (pairs.length === 2 && Mul.handleNegative(pairs[0][1]).collect(options).equals(pairs[1][1])) {
            // e.g. ln(x)^y/ln(b)^y -> log_b(x)^y
            if (pairs[0][1].isNegative()) {
              logs.push([new Log(pairs[0][0].power, pairs[1][0].power), pairs[1][1]]);
            } else {
              logs.push([new Log(pairs[1][0].power, pairs[0][0].power), pairs[0][1]]);
            }
          } else {
            logs = logs.concat(pairs);
          }
        }); // TODO(alex): combine if all inverses are the same e.g. ln(y)*ln(z)/ln(x)/ln(x)

      }

      pairs = trigs.concat(logs).concat(exprs);

      var collected = _.map(pairs, function (pair) {
        return new Pow(pair[0], pair[1]).collect(options);
      });

      return new Mul([number].concat(collected)).flatten();
    },
    isSubtract: function isSubtract() {
      return _.any(this.terms, function (term) {
        return term instanceof Num && term.hints.subtract;
      });
    },
    // factor a single -1 in to the Mul
    // combine with a Num if all Nums are positive, else add as a term
    factorIn: function factorIn(hint) {
      var partitioned = this.partition();
      var numbers = partitioned[0].terms;

      var fold = numbers.length && _.all(numbers, function (num) {
        return num.n > 0;
      });

      if (fold) {
        // e.g. - x*2*3 -> x*-2*3
        var num = numbers[0].negate();
        num.hints = numbers[0].hints;
        return this.replace(numbers[0], num.addHint(hint));
      } else {
        // e.g. - x*y -> -1*x*y
        // e.g. - x*-2 -> -1*x*-2
        return new Mul([Num.negativeOne(hint)].concat(this.terms));
      }
    },
    // factor out a single hinted -1 (assume it is the division hint)
    // TODO(alex): make more general or rename to be more specific
    factorOut: function factorOut() {
      var factored = false;

      var terms = _.compact(_.map(this.terms, function (term, i, list) {
        if (!factored && term instanceof Num && term.hints.divide) {
          factored = true;
          return term.n !== -1 ? term.negate() : null;
        } else {
          return term;
        }
      }));

      if (terms.length === 1) {
        return terms[0];
      } else {
        return new Mul(terms);
      }
    },
    reduce: function reduce(options) {
      return _.reduce(this.terms, function (memo, term) {
        return memo.mul(term, options);
      }, this.identity);
    },
    findGCD: function findGCD(factor) {
      return new Mul(_.invoke(this.terms, "findGCD", factor)).flatten();
    },
    asMul: function asMul() {
      return this;
    },
    asPositiveFactor: function asPositiveFactor() {
      if (this.isPositive()) {
        return this;
      } else {
        var terms = _.invoke(this.collect().terms, "asPositiveFactor");

        return new Mul(terms).flatten();
      }
    },
    isNegative: function isNegative() {
      return _.any(_.invoke(this.collect().terms, "isNegative"));
    },
    fold: function fold() {
      return Mul.fold(this);
    },
    negate: function negate() {
      var isNum = function isNum(expr) {
        return expr instanceof Num;
      };

      if (_.any(this.terms, isNum)) {
        var num = _.find(this.terms, isNum);

        return this.replace(num, num.negate());
      } else {
        return new Mul([Num.Neg].concat(this.terms));
      }
    }
  }); // static methods for the sequence types


  _.each([Add, Mul], function (type) {
    _.extend(type, {
      // create a new sequence unless left is already one (returns a copy)
      createOrAppend: function createOrAppend(left, right) {
        if (left instanceof type) {
          return new type(left.terms.concat(right));
        } else {
          return new type(left, right);
        }
      }
    });
  });

  _.extend(Mul, {
    // negative signs should be folded into numbers whenever possible
    // never fold into a Num that's already negative or a Mul that has a negative Num
    // an optional hint is kept track of to properly render user input
    // an empty hint means negation
    handleNegative: function handleNegative(expr, hint) {
      if (expr instanceof Num && expr.n > 0) {
        // e.g. - 2 -> -2
        var negated = expr.negate(); // TODO(alex): rework hint system so that this isn't necessary

        negated.hints = expr.hints;
        return negated.addHint(hint);
      } else if (expr instanceof Mul) {
        // e.g. - x*2*3 -> x*-2*3
        // e.g. - x*y -> -1*x*y
        // e.g. - x*-2 -> -1*x*-2
        return expr.factorIn(hint);
      } else {
        // e.g. - x -> -1*x
        return new Mul(Num.negativeOne(hint), expr);
      }
    },
    // division can create either a Rational or a Mul
    handleDivide: function handleDivide(left, right) {
      // dividing by a Mul is the same as repeated division by its terms
      if (right instanceof Mul) {
        var first = Mul.handleDivide(left, right.terms[0]);
        var rest = new Mul(_.rest(right.terms)).flatten();
        return Mul.handleDivide(first, rest);
      }

      var isInt = function isInt(expr) {
        return expr instanceof Int;
      };

      var isRational = function isRational(expr) {
        return expr instanceof Rational;
      }; // for simplification purposes, fold Ints into Rationals if possible
      // e.g. 3x / 4 -> 3/4 * x (will still render as 3x/4)


      if (isInt(right) && left instanceof Mul && _.any(left.terms, isInt)) {
        // search from the right
        var reversed = left.terms.slice().reverse();

        var num = _.find(reversed, isRational);

        if (!isInt(num)) {
          return new Mul(left.terms.concat([new Rational(1, right.n).addHint("fraction")]));
        }

        var rational = new Rational(num.n, right.n);
        rational.hints = num.hints; // in the case of something like 1/3 * 6/8, we want the
        // 6/8 to be considered a fraction, not just a division

        if (num === reversed[0]) {
          rational = rational.addHint("fraction");
        }

        if (num.n < 0 && right.n < 0) {
          rational.d = -rational.d;
          return left.replace(num, [Num.Neg, rational]);
        } else {
          return left.replace(num, rational);
        }
      }

      var divide = function divide(a, b) {
        if (b instanceof Int) {
          if (a instanceof Int) {
            if (a.n < 0 && b.n < 0) {
              // e.g. -2 / -3 -> -1*-2/3
              return [Num.Neg, new Rational(a.n, -b.n).addHint("fraction")];
            } else {
              // e.g. 2 / 3 -> 2/3
              // e.g. -2 / 3 -> -2/3
              // e.g. 2 / -3 -> -2/3
              return [new Rational(a.n, b.n).addHint("fraction")];
            }
          } else {
            // e.g. x / 3 -> x*1/3
            // e.g. x / -3 -> x*-1/3
            var inverse = new Rational(1, b.eval());

            if (b.eval() < 0) {
              return [a, inverse.addHint("negate")];
            } else {
              return [a, inverse];
            }
          }
        } else {
          var pow;

          if (b instanceof Trig && b.exp) {
            // e.g. sin^2(x) -> sin(x)^2
            var exp = b.exp;
            b.exp = undefined;
            b = new Pow(b, exp);
          }

          if (b instanceof Pow) {
            // e.g. (x^2) ^ -1 -> x^-2
            // e.g. (x^y) ^ -1 -> x^(-1*y)
            // e.g. (x^(yz)) ^ -1 -> x^(-1*y*z)
            pow = new Pow(b.base, Mul.handleNegative(b.exp, "divide"));
          } else {
            // e.g. x ^ -1 -> x^-1
            pow = new Pow(b, Num.Div);
          }

          if (a instanceof Int && a.n === 1) {
            // e.g. 1 / x -> x^-1
            return [pow];
          } else {
            // e.g. 2 / x -> 2*x^-1
            return [a, pow];
          }
        }
      };

      if (left instanceof Mul) {
        var divided = divide(_.last(left.terms), right);
        return new Mul(_.initial(left.terms).concat(divided));
      } else {
        var divided = divide(left, right);
        return new Mul(divided).flatten();
      }
    },
    // fold negative signs into numbers if possible
    // negative signs are not the same as multiplying by negative one!
    // e.g. -x      ->  -1*x    simplified
    // e.g. -2*x    ->  -2*x    simplified
    // e.g. -x*2    ->  -1*x*2  not simplified -> x*-2 simplified
    // e.g. -1*x*2  ->  -1*x*2  not simplified
    // also fold multiplicative terms into open Trig and Log nodes
    // e.g. (sin x)*x -> sin(x)*x
    // e.g. sin(x)*x -> sin(x)*x
    // e.g. sin(x)*(x) -> sin(x)*x
    // e.g. sin(x)*sin(y) -> sin(x)*sin(y)
    fold: function fold(expr) {
      if (expr instanceof Mul) {
        // assuming that this will be second to last
        var trigLog = _.find(_.initial(expr.terms), function (term) {
          return (term instanceof Trig || term instanceof Log) && term.hints.open;
        });

        var index = _.indexOf(expr.terms, trigLog);

        if (trigLog) {
          var last = _.last(expr.terms);

          if (trigLog.hints.parens || last.hints.parens || last.has(Trig) || last.has(Log)) {
            trigLog.hints.open = false;
          } else {
            var newTrigLog;

            if (trigLog instanceof Trig) {
              newTrigLog = Trig.create([trigLog.type, trigLog.exp], Mul.createOrAppend(trigLog.arg, last).fold());
            } else {
              newTrigLog = Log.create(trigLog.base, Mul.createOrAppend(trigLog.power, last).fold());
            }

            if (index === 0) {
              return newTrigLog;
            } else {
              return new Mul(expr.terms.slice(0, index).concat(newTrigLog)).fold();
            }
          }
        }

        var partitioned = expr.partition();
        var numbers = partitioned[0].terms;

        var pos = function pos(num) {
          return num.n > 0;
        };

        var neg = function neg(num) {
          return num.n === -1 && num.hints.negate;
        };

        var posOrNeg = function posOrNeg(num) {
          return pos(num) || neg(num);
        };

        if (numbers.length > 1 && _.some(numbers, neg) && _.some(numbers, pos) && _.every(numbers, posOrNeg)) {
          var firstNeg = _.indexOf(expr.terms, _.find(expr.terms, neg));

          var firstNum = _.indexOf(expr.terms, _.find(expr.terms, pos)); // e.g. -x*2 -> x*-2


          if (firstNeg < firstNum) {
            return expr.replace(firstNum, expr.terms[firstNum].negate()).remove(firstNeg);
          }
        }
      } // in all other cases, make no change


      return expr;
    }
  });
  /* exponentiation */


  function Pow(base, exp) {
    this.base = base;
    this.exp = exp;
  }

  Pow.prototype = new Expr();

  _.extend(Pow.prototype, {
    func: Pow,
    args: function args() {
      return [this.base, this.exp];
    },
    eval: function _eval(vars, options) {
      var evaledBase = this.base.eval(vars, options);
      var evaledExp = this.exp.eval(vars, options); // Math.pow unequivocally returns NaN when provided with both a
      // negative base and a fractional exponent. However, in some cases, we
      // know that our exponent is actually valid for use with negative
      // bases (e.g., (-5)^(1/3)).
      //
      // Here, we explicitly check for such cases. We really only handle a
      // limited subset (by requiring that the exponent is rational with an
      // odd denominator), but it's still useful.
      //   See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow

      if (evaledBase < 0) {
        var simplifiedExp = this.exp.simplify(); // If Float, convert to a Rational to enable the logic below

        if (simplifiedExp instanceof Float) {
          var num = simplifiedExp.n;
          var decimals = (num - num.toFixed()).toString().length - 2;
          var denominator = Math.pow(10, decimals);
          var rationalExp = new Rational(num * denominator, denominator);
          simplifiedExp = rationalExp.simplify();
        }

        if (simplifiedExp instanceof Rational) {
          var oddDenominator = Math.abs(simplifiedExp.d) % 2 === 1;

          if (oddDenominator) {
            var oddNumerator = Math.abs(simplifiedExp.n) % 2 === 1;
            var sign = oddNumerator ? -1 : 1;
            return sign * Math.pow(-1 * evaledBase, evaledExp);
          }
        }
      }

      return Math.pow(evaledBase, evaledExp);
    },
    getUnits: function getUnits() {
      return this.base.getUnits().map(function (unit) {
        return {
          unit: unit.unit,
          pow: unit.pow * this.exp.n
        };
      }.bind(this));
    },
    codegen: function codegen() {
      return "Math.pow(" + this.base.codegen() + ", " + this.exp.codegen() + ")";
    },
    print: function print() {
      var base = this.base.print();

      if (this.base instanceof Seq || this.base instanceof Pow) {
        base = "(" + base + ")";
      }

      return base + "^(" + this.exp.print() + ")";
    },
    tex: function tex() {
      if (this.isDivide()) {
        // e.g. x ^ -1 w/hint -> 1/x
        return "\\frac{1}{" + this.asDivide().tex() + "}";
      } else if (this.isRoot()) {
        if (this.exp.n !== 1) {
          error("Node marked with hint 'root' does not have exponent " + "of form 1/x.");
        }

        if (this.exp.d === 2) {
          // e.g. x ^ 1/2 w/hint -> sqrt{x}
          return "\\sqrt{" + this.base.tex() + "}";
        } else {
          // e.g. x ^ 1/y w/hint -> sqrt[y]{x}
          return "\\sqrt[" + this.exp.d + "]{" + this.base.tex() + "}";
        }
      } else if (this.base instanceof Trig && !this.base.isInverse() && this.exp instanceof Num && this.exp.isSimple() && this.exp.eval() >= 0) {
        // e.g sin(x) ^ 2 -> sin^2(x)
        var split = this.base.tex({
          split: true
        });
        return split[0] + "^{" + this.exp.tex() + "}" + split[1];
      } else {
        // e.g. x ^ y -> x^y
        var base = this.base.tex();

        if (this.base instanceof Seq || this.base instanceof Pow || this.base instanceof Num && !this.base.isSimple()) {
          // e.g. a+b ^ c -> (a+b)^c
          base = "(" + base + ")";
        } else if (this.base instanceof Trig || this.base instanceof Log) {
          // e.g. ln(x) ^ 2 -> [ln(x)]^2
          base = "[" + base + "]";
        }

        return base + "^{" + this.exp.tex() + "}";
      }
    },
    needsExplicitMul: function needsExplicitMul() {
      return this.isRoot() ? false : this.base.needsExplicitMul();
    },
    expand: function expand() {
      var pow = this.recurse("expand");

      if (pow.base instanceof Mul) {
        // e.g. (ab)^c -> a^c*b^c
        var terms = _.map(pow.base.terms, function (term) {
          return new Pow(term, pow.exp);
        });

        return new Mul(terms).expand();
      } else if (pow.base instanceof Add && pow.exp instanceof Int && pow.exp.abs().eval() > 1) {
        // e.g. (a+b)^2 -> a*a+a*b+a*b+b*b
        // e.g. (a+b)^-2 -> (a*a+a*b+a*b+b*b)^-1
        var positive = pow.exp.eval() > 0;
        var n = pow.exp.abs().eval();

        var signed = function signed(mul) {
          return positive ? mul : new Pow(mul, Num.Div);
        }; // compute and cache powers of 2 up to n


        var cache = {
          1: pow.base
        };

        for (var i = 2; i <= n; i *= 2) {
          var mul = new Mul(cache[i / 2], cache[i / 2]);
          cache[i] = mul.expand().collect();
        } // if n is a power of 2, you're done!


        if (_.has(cache, n)) {
          return signed(cache[n]);
        } // otherwise decompose n into powers of 2 ...


        var indices = _.map(n.toString(2).split(""), function (str, i, list) {
          return Number(str) * Math.pow(2, list.length - i - 1);
        });

        indices = _.without(indices, 0); // ... then combine

        var mul = new Mul(_.pick(cache, indices)).expand().collect();
        return signed(mul);
      } else if (pow.exp instanceof Add) {
        // DEFINITELY want behind super-simplify() flag
        // e.g. x^(a+b) -> x^a*x^b
        var terms = _.map(pow.exp.terms, function (term) {
          return new Pow(pow.base, term).expand();
        });

        return new Mul(terms).expand();
      } else {
        return pow;
      }
    },
    factor: function factor() {
      var pow = this.recurse("factor");

      if (pow.base instanceof Mul) {
        var terms = _.map(pow.base.terms, function (term) {
          if (term instanceof Int && pow.exp.equals(Num.Div)) {
            // Anything that can be a Rational should be a Rational
            // e.g. 2^(-1) -> 1/2
            return new Rational(1, term.n);
          } else {
            return new Pow(term, pow.exp);
          }
        });

        return new Mul(terms);
      } else {
        return pow;
      }
    },
    collect: function collect(options) {
      if (this.base instanceof Pow) {
        // collect this first to avoid having to deal with float precision
        // e.g. sqrt(2)^2 -> 2, not 2.0000000000000004
        // e.g. (x^y)^z -> x^(yz)
        var base = this.base.base;
        var exp = Mul.createOrAppend(this.base.exp, this.exp);
        return new Pow(base, exp).collect(options);
      }

      var pow = this.recurse("collect", options);

      var isSimilarLog = function isSimilarLog(term) {
        return term instanceof Log && term.base.equals(pow.base);
      };

      if (pow.exp instanceof Num && pow.exp.eval() === 0) {
        // e.g. x^0 -> 1
        return Num.One;
      } else if (pow.exp instanceof Num && pow.exp.eval() === 1) {
        // e.g. x^1 -> x
        return pow.base;
      } else if (isSimilarLog(pow.exp)) {
        // e.g. b^(log_b(x)) -> x
        return pow.exp.power;
      } else if (pow.exp instanceof Mul && _.any(pow.exp.terms, isSimilarLog)) {
        // e.g. b^(2*y*log_b(x)) -> x^(2*y)
        var log = _.find(pow.exp.terms, isSimilarLog);

        var base = log.power;
        var exp = pow.exp.remove(log).flatten();
        return new Pow(base, exp).collect(options);
      } else if (pow.base instanceof Num && pow.exp instanceof Num) {
        // TODO(alex): Consider encapsualting this logic (and similar logic
        // elsewhere) into a separate Decimal class for user-entered floats
        if (options && options.preciseFloats) {
          // Avoid creating an imprecise float
          // e.g. 23^1.5 -> 12167^0.5, not ~110.304
          // If you take the root as specified by the denominator and
          // end up with more digits after the decimal point,
          // the result is imprecise. This works for rationals as well
          // as floats, but ideally rationals should be pre-processed
          // e.g. (1/27)^(1/3) -> 1/3 to avoid most cases.
          // TODO(alex): Catch such cases and avoid converting to floats.
          var exp = pow.exp.asRational();
          var decimalsInBase = pow.base.getDecimalPlaces();
          var root = new Pow(pow.base, new Rational(1, exp.d));
          var decimalsInRoot = root.collect().getDecimalPlaces();

          if (decimalsInRoot > decimalsInBase) {
            // Collecting over this denominator would result in an
            // imprecise float, so avoid doing so.
            var newBase = new Pow(pow.base, new Int(exp.n)).collect();
            return new Pow(newBase, new Rational(1, exp.d));
          }
        } // e.g. 4^1.5 -> 8


        return pow.base.raiseToThe(pow.exp, options);
      } else {
        return pow;
      }
    },
    // checks whether this Pow represents user-entered division
    isDivide: function isDivide() {
      var isDiv = function isDiv(arg) {
        return arg instanceof Num && arg.hints.divide;
      };

      return isDiv(this.exp) || this.exp instanceof Mul && _.any(this.exp.terms, isDiv);
    },
    // assuming this Pow represents user-entered division, returns the denominator
    asDivide: function asDivide() {
      if (this.exp instanceof Num) {
        if (this.exp.eval() === -1) {
          return this.base;
        } else {
          var negated = this.exp.negate();
          negated.hints = _.clone(this.exp.hints);
          negated.hints.divide = false;
          return new Pow(this.base, negated);
        }
      } else if (this.exp instanceof Mul) {
        return new Pow(this.base, this.exp.factorOut());
      } else {
        error("called asDivide() on an Expr that wasn't a Num or Mul");
      }
    },
    isRoot: function isRoot() {
      return this.exp instanceof Rational && this.exp.hints.root;
    },
    isSquaredTrig: function isSquaredTrig() {
      return this.base instanceof Trig && !this.base.isInverse() && this.exp instanceof Num && this.exp.eval() === 2;
    },
    // extract whatever denominator makes sense, ignoring hints
    // if negative exponent, will recursively include the base's denominator as well
    getDenominator: function getDenominator() {
      if (this.exp instanceof Num && this.exp.eval() === -1) {
        return Mul.createOrAppend(this.base, this.base.getDenominator()).flatten();
      } else if (this.exp.isNegative()) {
        var pow = new Pow(this.base, Mul.handleNegative(this.exp).collect());
        return Mul.createOrAppend(pow, pow.collect().getDenominator()).flatten();
      } else if (this.base instanceof Num) {
        return new Pow(this.base.getDenominator(), this.exp).collect();
      } else {
        return Num.One;
      }
    },
    findGCD: function findGCD(factor) {
      var base, exp;

      if (factor instanceof Pow) {
        base = factor.base;
        exp = factor.exp;
      } else {
        base = factor;
        exp = Num.One;
      } // GCD is only relevant if same base


      if (this.base.equals(base)) {
        if (this.exp.equals(exp)) {
          // exact match
          // e.g. GCD(x^y^z, x^y^z) -> x^y^z
          return this;
        } else if (this.exp instanceof Num && exp instanceof Num) {
          // two numerical exponents
          // e.g. GCD(x^3, x^2) -> x^2
          return new Pow(this.base, Num.min(this.exp, exp)).collect();
        } else if (this.exp instanceof Num || exp instanceof Num) {
          // one numerical exponent
          // e.g. GCD(x^2, x^y) -> 1
          return Num.One;
        }

        var expA = this.exp.asMul().partition();
        var expB = exp.asMul().partition();

        if (expA[1].equals(expB[1])) {
          // exponents match except for coefficient
          // e.g. GCD(x^3y, x^y) -> x^y
          var coefficient = Num.min(expA[0].reduce(), expB[0].reduce());
          var mul = new Mul(coefficient, expA[1].flatten()).flatten();
          return new Pow(base, mul).collect();
        }
      }

      return Num.One;
    },
    isPositive: function isPositive() {
      if (this.base.isPositive()) {
        return true;
      }

      var exp = this.exp.simplify();
      return exp instanceof Int && exp.eval() % 2 === 0;
    },
    asPositiveFactor: function asPositiveFactor() {
      if (this.isPositive()) {
        return this;
      } else {
        var exp = this.exp.simplify();

        if (exp instanceof Int) {
          var n = exp.eval();

          if (n > 2) {
            // e.g. x^3 -> x^2
            return new Pow(this.base, new Int(n - 1));
          } else if (n < -2) {
            // e.g. x^-3 -> x^-2
            return new Pow(this.base, new Int(n + 1));
          }
        }

        return Num.One;
      }
    }
  });

  _.extend(Pow, {
    sqrt: function sqrt(arg) {
      return new Pow(arg, Num.Sqrt);
    },
    nthroot: function nthroot(radicand, degree) {
      var exp = Mul.fold(Mul.handleDivide(new Int(1), degree)); // FIXME(johnsullivan): If oneOverDegree ends up being a pow object,
      //     this "root" hint is lost between here and when tex() is called.

      return new Pow(radicand, exp.addHint("root"));
    }
  });
  /* logarithm */


  function Log(base, power) {
    this.base = base;
    this.power = power;
  }

  Log.prototype = new Expr();

  _.extend(Log.prototype, {
    func: Log,
    args: function args() {
      return [this.base, this.power];
    },
    eval: function _eval(vars, options) {
      return Math.log(this.power.eval(vars, options)) / Math.log(this.base.eval(vars, options));
    },
    codegen: function codegen() {
      return "(Math.log(" + this.power.codegen() + ") / Math.log(" + this.base.codegen() + "))";
    },
    print: function print() {
      var power = "(" + this.power.print() + ")";

      if (this.isNatural()) {
        return "ln" + power;
      } else {
        return "log_(" + this.base.print() + ") " + power;
      }
    },
    tex: function tex() {
      var power = "(" + this.power.tex() + ")";

      if (this.isNatural()) {
        return "\\ln" + power;
      } else {
        return "\\log_{" + this.base.tex() + "}" + power;
      }
    },
    collect: function collect(options) {
      var log = this.recurse("collect", options);

      if (log.power instanceof Num && log.power.eval() === 1) {
        // e.g. ln(1) -> 0
        return Num.Zero;
      } else if (log.base.equals(log.power)) {
        // e.g. log_b(b) -> 1
        return Num.One;
      } else if (log.power instanceof Pow && log.power.base.equals(log.base)) {
        // e.g. log_b(b^x) -> x
        return log.power.exp;
      } else {
        return log;
      }
    },
    expand: function expand() {
      var log = this.recurse("expand");

      if (log.power instanceof Mul) {
        // might want behind super-simplify() flag
        // e.g. ln(xy) -> ln(x) + ln(y)
        var terms = _.map(log.power.terms, function (term) {
          // need to expand again in case new log powers are Pows
          return new Log(log.base, term).expand();
        });

        return new Add(terms);
      } else if (log.power instanceof Pow) {
        // e.g. ln(x^y) -> y*ln(x)
        return new Mul(log.power.exp, new Log(log.base, log.power.base).expand()).flatten();
      } else if (!log.isNatural()) {
        // e.g. log_b(x) -> ln(x)/ln(b)
        return Mul.handleDivide(new Log(Const.e, log.power), new Log(Const.e, log.base));
      } else {
        return log;
      }
    },
    hints: _.extend(Log.prototype.hints, {
      open: false
    }),
    isPositive: function isPositive() {
      var log = this.collect();

      if (log.base instanceof Num && log.power instanceof Num) {
        return this.eval() > 0;
      } else {
        return false;
      }
    },
    needsExplicitMul: function needsExplicitMul() {
      return false;
    },
    isNatural: function isNatural() {
      return this.base.equals(Const.e);
    }
  });

  _.extend(Log, {
    natural: function natural() {
      return Const.e;
    },
    common: function common() {
      return Num.Ten;
    },
    create: function create(base, power) {
      var log = new Log(base, power);

      if (!power.hints.parens) {
        log = log.addHint("open");
      }

      return log;
    }
  });
  /* trigonometric functions */


  function Trig(type, arg) {
    this.type = type;
    this.arg = arg;
  }

  Trig.prototype = new Expr();

  _.extend(Trig.prototype, {
    func: Trig,
    args: function args() {
      return [this.type, this.arg];
    },
    functions: {
      sin: {
        eval: Math.sin,
        codegen: "Math.sin((",
        tex: "\\sin",
        expand: function expand() {
          return this;
        }
      },
      cos: {
        eval: Math.cos,
        codegen: "Math.cos((",
        tex: "\\cos",
        expand: function expand() {
          return this;
        }
      },
      tan: {
        eval: Math.tan,
        codegen: "Math.tan((",
        tex: "\\tan",
        expand: function expand() {
          return Mul.handleDivide(Trig.sin(this.arg), Trig.cos(this.arg));
        }
      },
      csc: {
        eval: function _eval(arg) {
          return 1 / Math.sin(arg);
        },
        codegen: "(1/Math.sin(",
        tex: "\\csc",
        expand: function expand() {
          return Mul.handleDivide(Num.One, Trig.sin(this.arg));
        }
      },
      sec: {
        eval: function _eval(arg) {
          return 1 / Math.cos(arg);
        },
        codegen: "(1/Math.cos(",
        tex: "\\sec",
        expand: function expand() {
          return Mul.handleDivide(Num.One, Trig.cos(this.arg));
        }
      },
      cot: {
        eval: function _eval(arg) {
          return 1 / Math.tan(arg);
        },
        codegen: "(1/Math.tan(",
        tex: "\\cot",
        expand: function expand() {
          return Mul.handleDivide(Trig.cos(this.arg), Trig.sin(this.arg));
        }
      },
      arcsin: {
        eval: Math.asin,
        codegen: "Math.asin((",
        tex: "\\arcsin"
      },
      arccos: {
        eval: Math.acos,
        codegen: "Math.acos((",
        tex: "\\arccos"
      },
      arctan: {
        eval: Math.atan,
        codegen: "Math.atan((",
        tex: "\\arctan"
      },
      arccsc: {
        eval: function _eval(arg) {
          return Math.asin(1 / arg);
        },
        codegen: "Math.asin(1/(",
        tex: "\\operatorname{arccsc}"
      },
      arcsec: {
        eval: function _eval(arg) {
          return Math.acos(1 / arg);
        },
        codegen: "Math.acos(1/(",
        tex: "\\operatorname{arcsec}"
      },
      arccot: {
        eval: function _eval(arg) {
          return Math.atan(1 / arg);
        },
        codegen: "Math.atan(1/(",
        tex: "\\operatorname{arccot}"
      },
      sinh: {
        eval: function _eval(arg) {
          return (Math.exp(arg) - Math.exp(-arg)) / 2;
        },
        codegen: function codegen(argStr) {
          return "((Math.exp(" + argStr + ") - Math.exp(-(" + argStr + "))) / 2)";
        },
        tex: "\\sinh",
        expand: function expand() {
          return this;
        }
      },
      cosh: {
        eval: function _eval(arg) {
          return (Math.exp(arg) + Math.exp(-arg)) / 2;
        },
        codegen: function codegen(argStr) {
          return "((Math.exp(" + argStr + ") + Math.exp(-(" + argStr + "))) / 2)";
        },
        tex: "\\cosh",
        expand: function expand() {
          return this;
        }
      },
      tanh: {
        eval: function _eval(arg) {
          return (Math.exp(arg) - Math.exp(-arg)) / (Math.exp(arg) + Math.exp(-arg));
        },
        codegen: function codegen(argStr) {
          return "(" + "(Math.exp(" + argStr + ") - Math.exp(-(" + argStr + ")))" + " / " + "(Math.exp(" + argStr + ") + Math.exp(-(" + argStr + ")))" + ")";
        },
        tex: "\\tanh",
        expand: function expand() {
          return Mul.handleDivide(Trig.sinh(this.arg), Trig.cosh(this.arg));
        }
      },
      csch: {
        eval: function _eval(arg) {
          return 2 / (Math.exp(arg) - Math.exp(-arg));
        },
        codegen: function codegen(argStr) {
          return "(2 / (Math.exp(" + argStr + ") - Math.exp(-(" + argStr + "))))";
        },
        tex: "\\csch",
        expand: function expand() {
          return Mul.handleDivide(Num.One, Trig.sinh(this.arg));
        }
      },
      sech: {
        eval: function _eval(arg) {
          return 2 / (Math.exp(arg) + Math.exp(-arg));
        },
        codegen: function codegen(argStr) {
          return "(2 / (Math.exp(" + argStr + ") + Math.exp(-(" + argStr + "))))";
        },
        tex: "\\sech",
        expand: function expand() {
          return Mul.handleDivide(Num.One, Trig.cosh(this.arg));
        }
      },
      coth: {
        eval: function _eval(arg) {
          return (Math.exp(arg) + Math.exp(-arg)) / (Math.exp(arg) - Math.exp(-arg));
        },
        codegen: function codegen(argStr) {
          return "(" + "(Math.exp(" + argStr + ") + Math.exp(-(" + argStr + ")))" + " / " + "(Math.exp(" + argStr + ") - Math.exp(-(" + argStr + ")))" + ")";
        },
        tex: "\\coth",
        expand: function expand() {
          return Mul.handleDivide(Trig.cosh(this.arg), Trig.sinh(this.arg));
        }
      }
    },
    isEven: function isEven() {
      return _.contains(["cos", "sec"], this.type);
    },
    isInverse: function isInverse() {
      return this.type.indexOf("arc") === 0;
    },
    isBasic: function isBasic() {
      return _.contains(["sin", "cos"], this.type);
    },
    eval: function _eval(vars, options) {
      var func = this.functions[this.type].eval;
      var arg = this.arg.eval(vars, options);
      return func(arg);
    },
    codegen: function codegen() {
      var func = this.functions[this.type].codegen;

      if (typeof func === "function") {
        return func(this.arg.codegen());
      } else if (typeof func === "string") {
        return func + this.arg.codegen() + "))";
      } else {
        throw new Error("codegen not implemented for " + this.type);
      }
    },
    print: function print() {
      return this.type + "(" + this.arg.print() + ")";
    },
    tex: function tex(options) {
      var func = this.functions[this.type].tex;
      var arg = "(" + this.arg.tex() + ")";
      return options && options.split ? [func, arg] : func + arg;
    },
    hints: _.extend(Trig.prototype.hints, {
      open: false
    }),
    isPositive: function isPositive() {
      var trig = this.collect();

      if (trig.arg instanceof Num) {
        return this.eval() > 0;
      } else {
        return false;
      }
    },
    completeParse: function completeParse() {
      if (this.exp) {
        var pow = new Pow(this, this.exp);
        this.exp = undefined;
        return pow;
      } else {
        return this;
      }
    },
    // TODO(alex): does every new node type need to redefine these?
    needsExplicitMul: function needsExplicitMul() {
      return false;
    },
    expand: function expand() {
      var trig = this.recurse("expand");

      if (!trig.isInverse()) {
        // e.g. tan(x) -> sin(x)/cos(x)
        var expand = trig.functions[trig.type].expand;
        return _.bind(expand, trig)();
      } else {
        return trig;
      }
    },
    collect: function collect(options) {
      var trig = this.recurse("collect", options);

      if (!trig.isInverse() && trig.arg.isNegative()) {
        var arg;

        if (trig.arg instanceof Num) {
          arg = trig.arg.abs();
        } else {
          arg = Mul.handleDivide(trig.arg, Num.Neg).collect(options);
        }

        if (trig.isEven()) {
          // e.g. cos(-x) -> cos(x)
          return new Trig(trig.type, arg);
        } else {
          // e.g. sin(-x) -> -sin(x)
          return new Mul(Num.Neg, new Trig(trig.type, arg));
        }
      } else {
        return trig;
      }
    }
  });

  _.extend(Trig, {
    create: function create(pair, arg) {
      var type = pair[0];
      var exp = pair[1];

      if (exp && exp.equals(Num.Neg)) {
        // e.g. sin^-1(x) -> arcsin(x)
        type = "arc" + type;
        exp = undefined;
      }

      var trig = new Trig(type, arg);

      if (!arg.hints.parens) {
        trig = trig.addHint("open");
      }

      if (exp) {
        trig.exp = exp;
      }

      return trig;
    },
    sin: function sin(arg) {
      return new Trig("sin", arg);
    },
    cos: function cos(arg) {
      return new Trig("cos", arg);
    },
    sinh: function sinh(arg) {
      return new Trig("sinh", arg);
    },
    cosh: function cosh(arg) {
      return new Trig("cosh", arg);
    }
  });

  function Abs(arg) {
    this.arg = arg;
  }

  Abs.prototype = new Expr();

  _.extend(Abs.prototype, {
    func: Abs,
    args: function args() {
      return [this.arg];
    },
    eval: function _eval(vars, options) {
      return Math.abs(this.arg.eval(vars, options));
    },
    codegen: function codegen() {
      return "Math.abs(" + this.arg.codegen() + ")";
    },
    print: function print() {
      return "abs(" + this.arg.print() + ")";
    },
    tex: function tex() {
      return "\\left|" + this.arg.tex() + "\\right|";
    },
    collect: function collect(options) {
      var abs = this.recurse("collect", options);

      if (abs.arg.isPositive()) {
        // e.g. |2^x| -> 2^x
        return abs.arg;
      } else if (abs.arg instanceof Num) {
        // e.g. |-2| -> 2
        return abs.arg.abs();
      } else if (abs.arg instanceof Mul) {
        // e.g. |-2*pi*x| -> 2*pi*|x|
        var terms = _.groupBy(abs.arg.terms, function (term) {
          if (term.isPositive()) {
            return "positive";
          } else if (term instanceof Num) {
            return "number";
          } else {
            return "other";
          }
        });

        var positives = terms.positive.concat(_.invoke(terms.number, "abs"));

        if (terms.other.length) {
          positives.push(new Abs(new Mul(terms.other).flatten()));
        }

        return new Mul(positives).flatten();
      } else {
        return abs;
      }
    },
    // this should definitely be behind a super-simplify flag
    expand: function expand() {
      var abs = this.recurse("expand");

      if (abs.arg instanceof Mul) {
        // e.g. |xyz| -> |x|*|y|*|z|
        var terms = _.map(abs.arg.terms, function (term) {
          return new Abs(term);
        });

        return new Mul(terms);
      } else {
        return abs;
      }
    },
    isPositive: function isPositive() {
      return true;
    }
  });
  /* equation */


  function Eq(left, type, right) {
    this.left = left;
    this.type = type;
    this.right = right;
  }

  Eq.prototype = new Expr();

  _.extend(Eq.prototype, {
    func: Eq,
    args: function args() {
      return [this.left, this.type, this.right];
    },
    needsExplicitMul: function needsExplicitMul() {
      return false;
    },
    print: function print() {
      return this.left.print() + this.type + this.right.print();
    },
    signs: {
      "=": " = ",
      "<": " < ",
      ">": " > ",
      "<>": " \\ne ",
      "<=": " \\le ",
      ">=": " \\ge "
    },
    tex: function tex() {
      return this.left.tex() + this.signs[this.type] + this.right.tex();
    },
    normalize: function normalize() {
      var eq = this.recurse("normalize");

      if (_.contains([">", ">="], eq.type)) {
        // inequalities should have the smaller side on the left
        return new Eq(eq.right, eq.type.replace(">", "<"), eq.left);
      } else {
        return eq;
      }
    },
    // convert this equation to an expression set to zero
    // the expression is normalized to a canonical form
    // e.g. y/2=x/4 -> y/2-x/4(=0) -> 2y-x(=0)
    // unless unfactored is specified, will then divide through
    asExpr: function asExpr(unfactored) {
      var isZero = function isZero(expr) {
        return expr instanceof Num && expr.isSimple() && expr.eval() === 0;
      }; // first convert to a sequence of additive terms


      var terms = [];

      if (this.left instanceof Add) {
        terms = _.clone(this.left.terms);
      } else if (!isZero(this.left)) {
        terms = [this.left];
      }

      if (this.right instanceof Add) {
        terms = terms.concat(this.right.negate().terms);
      } else if (!isZero(this.right)) {
        terms.push(this.right.negate());
      }

      var isInequality = !this.isEquality(); // Collect over each term individually to transform simple expressions
      // into numbers that might have denominators, taking into account
      // float precision. We have to be very careful to not introduce any
      // irrational floats before asExpr() returns, because by definition
      // they do not have exact denominators...

      terms = _.invoke(terms, "collect", {
        preciseFloats: true
      }); // ...and we multiply through by every denominator.

      for (var i = 0; i < terms.length; i++) {
        var denominator = terms[i].getDenominator(); // Can't multiply inequalities by non 100% positive factors

        if (isInequality && !denominator.isPositive()) {
          denominator = denominator.asPositiveFactor();
        }

        if (!denominator.equals(Num.One)) {
          terms = _.map(terms, function (term) {
            return Mul.createOrAppend(term, denominator).simplify({
              once: true,
              preciseFloats: true
            });
          });
        }
      }

      var add = new Add(terms).flatten();
      return unfactored ? add : this.divideThrough(add);
    },
    // divide through by every common factor in the expression
    // e.g. 2y-4x(=0) -> y-2x(=0)
    // TODO(alex): Make it an option to only divide by variables/expressions
    // guaranteed to be nonzero
    divideThrough: function divideThrough(expr) {
      var isInequality = !this.isEquality();
      var simplified = expr.simplify({
        once: true
      });
      var factored = simplified.factor({
        keepNegative: isInequality
      });

      if (!(factored instanceof Mul)) {
        return expr;
      }

      var terms = factored.terms;

      var isAdd = function isAdd(term) {
        return term instanceof Add;
      };

      var hasVar = function hasVar(term) {
        return !!term.getVars().length;
      };

      var isOne = function isOne(term) {
        return term.equals(Num.One);
      };

      var grouped = _.groupBy(terms, isAdd);

      var adds = grouped[true] || [];
      var others = grouped[false] || [];

      if (adds.length && this.isEquality()) {
        // keep only Adds
        // e.g. 2xy(z+1)(=0) -> z+1(=0)
        return new Mul(adds).flatten();
      }

      var denominator = others;

      if (!adds.length) {
        // if no Adds, keep all variable terms to preserve meaning
        // e.g. 42xyz(=0) -> xyz(=0)
        denominator = _.reject(denominator, hasVar);
      }

      if (isInequality) {
        // can't divide inequalities by non 100% positive factors
        // e.g. 42x^2y(z+1)(=0) -> y(z+1)(=0)
        denominator = _.invoke(denominator, "asPositiveFactor");
      } // don't need to divide by one


      denominator = _.reject(denominator, isOne);
      denominator = _.map(denominator, function (term) {
        return new Pow(term, Num.Div);
      });
      var dividedResult = new Mul(terms.concat(denominator)).collect(); // If the end result is the same as the original factoring,
      // rollback the factoring and discard all intermediate steps.

      if (dividedResult.equals(factored)) {
        return simplified;
      } else {
        return dividedResult;
      }
    },
    isEquality: function isEquality() {
      return _.contains(["=", "<>"], this.type);
    },
    compare: function compare(other) {
      // expression comparisons are handled by Expr.compare()
      if (!(other instanceof Eq)) {
        return false;
      }

      var eq1 = this.normalize();
      var eq2 = other.normalize();

      if (eq1.type !== eq2.type) {
        return false;
      } // need to collect to properly factor out common factors
      // e.g x+2x=6 -> 3x=6 -> 3x-6(=0) -> x-2(=0)


      var expr1 = eq1.divideThrough(eq1.asExpr(
      /* unfactored */
      true).collect());
      var expr2 = eq2.divideThrough(eq2.asExpr(
      /* unfactored */
      true).collect());

      if (eq1.isEquality()) {
        // equals and not-equals can be subtracted either way
        return expr1.compare(expr2) || expr1.compare(Mul.handleNegative(expr2));
      } else {
        return expr1.compare(expr2);
      }
    },
    // should only be done after compare() returns true to avoid false positives
    sameForm: function sameForm(other) {
      var eq1 = this.normalize();
      var eq2 = other.normalize();
      var same = eq1.left.sameForm(eq2.left) && eq1.right.sameForm(eq2.right);

      if (eq1.isEquality()) {
        // equals and not-equals can be commutative with respect to the sign
        return same || eq1.left.sameForm(eq2.right) && eq1.right.sameForm(eq2.left);
      } else {
        return same;
      }
    },
    // we don't want to override collect because it would turn y=x into y-x(=0)
    // instead, we ask if the equation was in that form, would it be simplified?
    isSimplified: function isSimplified() {
      var expr = this.asExpr(
      /* unfactored */
      true);
      var simplified = this.divideThrough(expr).simplify();
      return expr.equals(simplified) && this.left.isSimplified() && this.right.isSimplified();
    }
  });

  _.extend(Eq.prototype, {
    // Assumptions: Expression is of the form a+bx, and we solve for x
    solveLinearEquationForVariable: function solveLinearEquationForVariable(variable) {
      var expr = this.asExpr();

      if (!expr.is(Add) || expr.terms.length !== 2) {
        throw new Error("Can only handle linear equations of the form " + "a + bx (= 0)");
      }

      var hasVar = function hasVar(term) {
        return term.has(Var) && _.contains(term.getVars(), variable.symbol);
      };

      var a, b;

      if (hasVar(expr.terms[0])) {
        a = Mul.handleNegative(expr.terms[1]);
        b = Mul.handleDivide(expr.terms[0], variable);
      } else {
        a = Mul.handleNegative(expr.terms[0]);
        b = Mul.handleDivide(expr.terms[1], variable);
      }

      return Mul.handleDivide(a, b).simplify();
    }
  });
  /* abstract symbol node */


  function Symbol() {}

  Symbol.prototype = new Expr();

  _.extend(Symbol.prototype, {
    needsExplicitMul: function needsExplicitMul() {
      return false;
    },
    findGCD: function findGCD(factor) {
      if (factor instanceof Symbol || factor instanceof Num) {
        return this.equals(factor) ? this : Num.One;
      } else {
        return factor.findGCD(this);
      }
    }
  });
  /* function variable */


  function Func(symbol, arg) {
    this.symbol = symbol;
    this.arg = arg;
  }

  Func.prototype = new Symbol();

  _.extend(Func.prototype, {
    func: Func,
    args: function args() {
      return [this.symbol, this.arg];
    },
    print: function print() {
      return this.symbol + "(" + this.arg.print() + ")";
    },
    tex: function tex() {
      return this.symbol + "(" + this.arg.tex() + ")";
    },
    eval: function _eval(vars, options) {
      var arg = this.arg;
      var func = vars[this.symbol];

      var newVars = _.extend(_.clone(vars), {
        x: arg.eval(vars, options)
      });

      var parsedFunc = KAS.parse(func, options);

      if (parsedFunc.parsed) {
        return parsedFunc.expr.eval(newVars, options);
      } // If parsedFunc isn't actually parsed, return its error


      return parsedFunc;
    },
    codegen: function codegen() {
      return 'vars["' + this.symbol + '"](' + this.arg.codegen() + ')';
    },
    getUnits: function getUnits() {
      return this.arg.getUnits();
    },
    getVars: function getVars(excludeFunc) {
      if (excludeFunc) {
        return this.arg.getVars();
      } else {
        return _.union(this.arg.getVars(), [this.symbol]).sort();
      }
    },
    getConsts: function getConsts() {
      return this.arg.getConsts();
    }
  });
  /* variable */


  function Var(symbol, subscript) {
    this.symbol = symbol;
    this.subscript = subscript;
  }

  Var.prototype = new Symbol();

  _.extend(Var.prototype, {
    func: Var,
    args: function args() {
      return [this.symbol, this.subscript];
    },
    exprArgs: function exprArgs() {
      return [];
    },
    recurse: function recurse() {
      return this;
    },
    print: function print() {
      var sub = "";

      if (this.subscript) {
        sub = "_(" + this.subscript.print() + ")";
      }

      return this.symbol + sub;
    },
    // Provide a way to easily evalate expressions with the common case,
    // subscripts that consist of a single number or symbol e.g. x_a or x_42
    prettyPrint: function prettyPrint() {
      var sub = this.subscript;

      if (sub && (sub instanceof Num || sub instanceof Symbol)) {
        return this.symbol + "_" + sub.print();
      } else {
        return this.print();
      }
    },
    tex: function tex() {
      var sub = "";

      if (this.subscript) {
        sub = "_{" + this.subscript.tex() + "}";
      }

      var prefix = this.symbol.length > 1 ? "\\" : "";
      return prefix + this.symbol + sub;
    },
    repr: function repr() {
      return "Var(" + this.print() + ")";
    },
    eval: function _eval(vars, options) {
      return vars[this.prettyPrint()];
    },
    codegen: function codegen() {
      return 'vars["' + this.prettyPrint() + '"]';
    },
    getVars: function getVars() {
      return [this.prettyPrint()];
    },
    isPositive: function isPositive() {
      return false;
    }
  });
  /* constant */


  function Const(symbol) {
    this.symbol = symbol;
  }

  Const.prototype = new Symbol();

  _.extend(Const.prototype, {
    func: Const,
    args: function args() {
      return [this.symbol];
    },
    recurse: function recurse() {
      return this;
    },
    eval: function _eval(vars, options) {
      if (this.symbol === "pi") {
        return Math.PI;
      } else if (this.symbol === "e") {
        return Math.E;
      }
    },
    codegen: function codegen() {
      if (this.symbol === "pi") {
        return "Math.PI";
      } else if (this.symbol === "e") {
        return "Math.E";
      }
    },
    print: function print() {
      return this.symbol;
    },
    tex: function tex() {
      if (this.symbol === "pi") {
        return "\\pi ";
      } else if (this.symbol === "e") {
        return "e";
      }
    },
    isPositive: function isPositive() {
      return this.eval() > 0;
    },
    abs: function abs() {
      if (this.eval() > 0) {
        return this;
      } else {
        return Mul.handleNegative(this);
      }
    },
    getConsts: function getConsts() {
      return [this.print()];
    }
  });

  Const.e = new Const("e");
  Const.pi = new Const("pi");
  /* abstract number node */

  function Num() {}

  Num.prototype = new Expr();

  _.extend(Num.prototype, {
    repr: function repr() {
      return this.print();
    },
    strip: function strip() {
      return this.abs();
    },
    recurse: function recurse() {
      return this;
    },
    codegen: function codegen() {
      return this.print();
    },
    // takes another Num and returns a new Num
    add: abstract,
    mul: abstract,
    // returns this Num's additive inverse
    negate: abstract,
    isSubtract: function isSubtract() {
      return this.hints.subtract;
    },
    // return the absolute value of the number
    abs: abstract,
    needsExplicitMul: function needsExplicitMul() {
      return true;
    },
    findGCD: abstract,
    isPositive: function isPositive() {
      return this.eval() > 0;
    },
    isNegative: function isNegative() {
      return this.eval() < 0;
    },
    asPositiveFactor: function asPositiveFactor() {
      return this.isPositive() ? this : this.abs();
    },
    // hints for interpreting and rendering user input
    hints: _.extend(Num.prototype.hints, {
      negate: false,
      subtract: false,
      divide: false,
      root: false,
      fraction: false,
      entered: false
    }),
    // whether a number is considered simple (one term)
    // e.g. for reals, ints and floats are simple
    isSimple: abstract,
    // Based on http://stackoverflow.com/a/10454560/2571482
    getDecimalPlaces: function getDecimalPlaces() {
      var match = ("" + this.n).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);

      if (match) {
        return Math.max(0, // Number of digits right of decimal point
        (match[1] ? match[1].length : 0) - ( // Adjust for scientific notation
        match[2] ? +match[2] : 0));
      } else {
        return 0;
      }
    },
    asRational: abstract
  });
  /* rational number (n: numerator, d: denominator) */


  function Rational(numerator, denominator) {
    var n = numerator;
    var d = denominator;

    if (d < 0) {
      n = -n;
      d = -d;
    }

    this.n = n;
    this.d = d;
  }

  Rational.prototype = new Num();

  _.extend(Rational.prototype, {
    func: Rational,
    args: function args() {
      return [this.n, this.d];
    },
    eval: function _eval() {
      return this.n / this.d;
    },
    print: function print() {
      return this.n.toString() + "/" + this.d.toString();
    },
    tex: function tex() {
      var tex = "\\frac{" + Math.abs(this.n).toString() + "}{" + this.d.toString() + "}";
      return this.n < 0 ? "-" + tex : tex;
    },
    add: function add(num, options) {
      if (num instanceof Rational) {
        return new Rational(this.n * num.d + this.d * num.n, this.d * num.d).collect();
      } else {
        return num.add(this, options);
      }
    },
    mul: function mul(num, options) {
      if (num instanceof Rational) {
        return new Rational(this.n * num.n, this.d * num.d).collect();
      } else {
        return num.mul(this, options);
      }
    },
    collect: function collect() {
      var gcd = Num.findGCD(this.n, this.d);
      var n = this.n / gcd;
      var d = this.d / gcd;

      if (d === 1) {
        return new Int(n);
      } else {
        return new Rational(n, d);
      }
    },
    negate: function negate() {
      return new Rational(-this.n, this.d);
    },
    abs: function abs() {
      return new Rational(Math.abs(this.n), this.d);
    },
    findGCD: function findGCD(factor) {
      // Attempt to factor out common numerators and denominators to return
      // a Rational instead of a Float
      if (factor instanceof Rational) {
        // For more background, see
        // http://math.stackexchange.com/questions/151081/gcd-of-rationals
        var numerator = Num.findGCD(this.n * factor.d, factor.n * this.d);
        var denominator = this.d * factor.d; // Create the rational, then call .collect() to simplify it

        return new Rational(numerator, denominator).collect();
      } else if (factor instanceof Int) {
        return new Rational(Num.findGCD(this.n, factor.n), this.d);
      } else {
        return factor.findGCD(this);
      }
    },
    // for now, assuming that exp is a Num
    raiseToThe: function raiseToThe(exp) {
      if (exp instanceof Int) {
        var positive = exp.eval() > 0;
        var abs = exp.abs().eval();
        var n = Math.pow(this.n, abs);
        var d = Math.pow(this.d, abs);

        if (positive) {
          return new Rational(n, d).collect();
        } else {
          return new Rational(d, n).collect();
        }
      } else {
        return new Float(this.eval()).raiseToThe(exp);
      }
    },
    getDenominator: function getDenominator() {
      return new Int(this.d);
    },
    isSimple: function isSimple() {
      return false;
    },
    asRational: function asRational() {
      return this;
    }
  });
  /* integer (n: numerator/number) */


  function Int(number) {
    this.n = number;
  }

  Int.prototype = new Rational(0, 1);

  _.extend(Int.prototype, {
    func: Int,
    args: function args() {
      return [this.n];
    },
    print: function print() {
      return this.n.toString();
    },
    tex: function tex() {
      return this.n.toString();
    },
    negate: function negate() {
      return new Int(-this.n);
    },
    abs: function abs() {
      return new Int(Math.abs(this.n));
    },
    isSimple: function isSimple() {
      return true;
    },
    findGCD: function findGCD(factor) {
      if (factor instanceof Int) {
        return new Int(Num.findGCD(this.n, factor.n));
      } else {
        return factor.findGCD(this);
      }
    }
  });

  _.extend(Int, {
    create: function create(n) {
      return new Int(n).addHint("entered");
    }
  });
  /* float (n: number) */


  function Float(number) {
    this.n = number;
  }

  Float.prototype = new Num();

  _.extend(Float.prototype, {
    func: Float,
    args: function args() {
      return [this.n];
    },
    eval: function _eval() {
      return this.n;
    },
    // TODO(alex): when we internationalize number parsing/display
    // we should make sure to use the appropriate decimal mark here
    print: function print() {
      return this.n.toString();
    },
    tex: function tex() {
      return this.n.toString();
    },
    add: function add(num, options) {
      if (options && options.preciseFloats) {
        return Float.toDecimalPlaces(this.n + num.eval(), Math.max(this.getDecimalPlaces(), num.getDecimalPlaces()));
      } else {
        return new Float(this.n + num.eval()).collect();
      }
    },
    mul: function mul(num, options) {
      if (options && options.preciseFloats) {
        return Float.toDecimalPlaces(this.n * num.eval(), this.getDecimalPlaces() + num.getDecimalPlaces());
      } else {
        return new Float(this.n * num.eval()).collect();
      }
    },
    collect: function collect() {
      // We used to simplify Floats to Ints here whenever possible, but no
      // longer do so in order to preserve significant figures.
      return this;
    },
    negate: function negate() {
      return new Float(-this.n);
    },
    abs: function abs() {
      return new Float(Math.abs(this.n));
    },
    findGCD: function findGCD(factor) {
      if (factor instanceof Num) {
        return new Float(Num.findGCD(this.eval(), factor.eval())).collect();
      } else {
        return factor.findGCD(this);
      }
    },
    // for now, assuming that exp is a Num
    raiseToThe: function raiseToThe(exp, options) {
      if (options && options.preciseFloats && exp instanceof Int && exp.n > 1) {
        return Float.toDecimalPlaces(new Pow(this, exp).eval(), this.getDecimalPlaces() * exp.n);
      } else {
        return new Float(new Pow(this, exp).eval()).collect();
      }
    },
    // only to be used on non-repeating decimals (e.g. user-provided)
    asRational: function asRational() {
      var parts = this.n.toString().split(".");

      if (parts.length === 1) {
        return new Rational(this.n, 1);
      } else {
        var numerator = Number(parts.join(""));
        var denominator = Math.pow(10, parts[1].length);
        return new Rational(numerator, denominator).collect();
      }
    },
    getDenominator: function getDenominator() {
      return this.asRational().getDenominator();
    },
    isSimple: function isSimple() {
      return true;
    }
  });

  _.extend(Float, {
    create: function create(n) {
      return new Float(n).addHint("entered");
    },
    // Account for floating point imprecision by explicitly controlling the
    // number of decimal places in common operations (e.g. +, *, ^)
    toDecimalPlaces: function toDecimalPlaces(n, places) {
      return new Float(+n.toFixed(Math.min(places, 20))).collect();
    }
  }); // static methods and fields that are best defined on Num


  _.extend(Num, {
    negativeOne: function negativeOne(hint) {
      if (hint === "subtract") {
        return Num.Sub;
      } else if (hint === "divide") {
        return Num.Div;
      } else {
        return Num.Neg;
      }
    },
    // find the greatest common denominator
    findGCD: function findGCD(a, b) {
      var mod;
      a = Math.abs(a);
      b = Math.abs(b); // Euclid's method doesn't handle non-integers very well. For now
      // we just say we can't pull out a common factor. It might be
      // reasonable to do better than this in the future.

      if (a !== Math.floor(a) || b !== Math.floor(b)) {
        return 1;
      }

      while (b) {
        mod = a % b;
        a = b;
        b = mod;
      }

      return a;
    },
    min: function min() {
      return _.min(_.toArray(arguments), function (num) {
        return num.eval();
      });
    },
    max: function max() {
      return _.max(_.toArray(arguments), function (num) {
        return num.eval();
      });
    }
  });

  Num.Neg = new Int(-1).addHint("negate");
  Num.Sub = new Int(-1).addHint("subtract");
  Num.Div = new Int(-1).addHint("divide");
  Num.Sqrt = new Rational(1, 2).addHint("root");
  Num.Zero = new Int(0);
  Num.One = new Int(1);
  Num.Ten = new Int(10); // set identities here

  Add.prototype.identity = Num.Zero;
  Mul.prototype.identity = Num.One;
  var parser = KAS.parser;

  var parseError = function parseError(str, hash) {
    // return int location of parsing error
    throw new Error(hash.loc.first_column);
  }; // expose concrete nodes to parser scope
  // see http://zaach.github.io/jison/docs/#sharing-scope


  parser.yy = {
    Add: Add,
    Mul: Mul,
    Pow: Pow,
    Log: Log,
    Trig: Trig,
    Eq: Eq,
    Abs: Abs,
    Func: Func,
    Const: Const,
    Var: Var,
    Int: Int,
    Float: Float,
    parseError: parseError,
    constants: ["e"],
    symbolLexer: function symbolLexer(symbol) {
      if (_.contains(parser.yy.constants, symbol)) {
        return "CONST";
      } else if (_.contains(parser.yy.functions, symbol)) {
        return "FUNC";
      } else {
        return "VAR";
      }
    }
  };

  KAS.parse = function (input, options) {
    try {
      if (options && options.functions) {
        // reserve the symbol "i" for complex numbers
        parser.yy.functions = _.without(options.functions, "i");
      } else {
        parser.yy.functions = [];
      } // If ',' is the decimal dividor in your country, replace any ','s
      // with '.'s.
      // This isn't perfect, since the output will all still have '.'s.
      // TODO(jack): Fix the output to have ','s in this case


      if (options && options.decimal_separator) {
        input = input.split(options.decimal_separator).join(".");
      }

      var expr = parser.parse(input).completeParse();
      return {
        parsed: true,
        expr: expr
      };
    } catch (e) {
      return {
        parsed: false,
        error: e.message
      };
    }
  };
  /* unit */


  function Unit(symbol) {
    this.symbol = symbol;
  }

  Unit.prototype = new Symbol(); // If possible, replace unit prefixes with a multiplication.
  //
  // "g" -> Unit("g")
  // "kg" -> 1000 * Unit("g")

  var unprefixify = function unprefixify(symbol) {
    if (_.has(baseUnits, symbol) || _.has(derivedUnits, symbol)) {
      return new Unit(symbol);
    } // check for prefix


    var prefix = Object.keys(siPrefixes).find(function (testPrefix) {
      return new RegExp("^" + testPrefix).test(symbol);
    });

    if (prefix) {
      var base = symbol.replace(new RegExp("^" + prefix), ""); // It's okay to be here if either:
      // * `base` is a base unit (the seven units listed in baseUnits)
      // * `base` is a derived unit which allows prefixes
      //
      // Otherwise, we're trying to parse a unit label which is not
      // allowed (mwk, mBTU, etc).

      if (_.has(baseUnits, base) || derivedUnits[base] && derivedUnits[base].prefixes === hasPrefixes) {
        return new Mul(siPrefixes[prefix], new Unit(base));
      } else {
        throw new Error(base + " does not allow prefixes");
      }
    } else {
      return new Unit(symbol);
    }
  };

  KAS.unitParse = function (input) {
    try {
      var parseResult = KAS.unitParser.parse(input); // parseResult looks like:
      // {
      //   magnitude: "5",
      //   unit: {
      //     num: [
      //       { name: "s", pow: 2 }
      //     ],
      //     denom: [
      //       { name: "kg", pow: 1 }
      //     ]
      //   }
      // }
      //
      // denom is optionally null

      var unitArray = [];
      parseResult.unit.num.forEach(function (unitSpec) {
        unitArray.push(new Pow(unprefixify(unitSpec.name), new Int(unitSpec.pow)));
      });
      parseResult.unit.denom.forEach(function (unitSpec) {
        unitArray.push(new Pow(unprefixify(unitSpec.name), new Int(-1 * unitSpec.pow)));
      });
      var unit = new Mul(unitArray).flatten();

      if (parseResult.type === "unitMagnitude") {
        // in the first case we have a magnitude coefficient as well as the
        // unit itself.
        var coefArray = [new Float(+parseResult.magnitude)].concat(unitArray);
        var expr = new Mul(coefArray);
        return {
          parsed: true,
          unit: unit,
          expr: expr,
          coefficient: parseResult.magnitude,
          type: parseResult.type
        };
      } else {
        // in the second case it's just the unit with no magnitude.
        return {
          parsed: true,
          unit: unit,
          type: parseResult.type
        };
      }
    } catch (e) {
      return {
        parsed: false,
        error: e.message
      };
    }
  };

  _.extend(Unit.prototype, {
    func: Unit,
    args: function args() {
      return [this.symbol];
    },
    recurse: function recurse() {
      return this;
    },
    eval: function _eval(vars, options) {
      // This is called when comparing units. A unit doesn't affect the
      // numerical value of its coefficient, so this needs to be 1.
      //
      // On the other hand, things must not evaluate to the same thing if
      // they don't have the same type. I believe that's also true - form is
      // checked before numerical equivalence. I do not know where, though.
      // However, there are a couple tests checking this.
      return 1;
    },
    getUnits: function getUnits() {
      return [{
        unit: this.symbol,
        pow: 1
      }];
    },
    codegen: function codegen() {
      return "1";
    },
    print: function print() {
      return this.symbol;
    },
    tex: function tex() {
      return this.symbol;
    },
    // Simplify units by replacing prefixes with multiplication
    collect: function collect(options) {
      if (_.has(baseUnits, this.symbol)) {
        return this;
      } else if (_.has(derivedUnits, this.symbol)) {
        return derivedUnits[this.symbol].conversion;
      } else {
        throw new Error("could not understand unit: " + this.symbol);
      }
    }
  });

  var baseUnits = {
    m: new Unit("m"),
    // Note: kg is the SI base unit but we use g for consistency
    g: new Unit("g"),
    s: new Unit("s"),
    A: new Unit("A"),
    K: new Unit("K"),
    mol: new Unit("mol"),
    cd: new Unit("cd")
  };
  var siPrefixes = {
    a: new Pow(new Int(10), new Int(-18)),
    f: new Pow(new Int(10), new Int(-15)),
    p: new Pow(new Int(10), new Int(-12)),
    n: new Pow(new Int(10), new Int(-9)),
    u: new Pow(new Int(10), new Int(-6)),
    m: new Pow(new Int(10), new Int(-3)),
    c: new Pow(new Int(10), new Int(-2)),
    d: new Pow(new Int(10), new Int(-1)),
    da: new Int(10),
    h: new Pow(new Int(10), new Int(2)),
    k: new Pow(new Int(10), new Int(3)),
    M: new Pow(new Int(10), new Int(6)),
    G: new Pow(new Int(10), new Int(9)),
    T: new Pow(new Int(10), new Int(12)),
    P: new Pow(new Int(10), new Int(15)),
    E: new Pow(new Int(10), new Int(18)),
    // http://en.wikipedia.org/wiki/Metric_prefix#.22Hella.22_prefix_proposal
    hella: new Pow(new Int(10), new Int(27))
  }; // Use these two values to mark a unit as either SI-prefixable or not.

  var hasPrefixes = {};
  var hasntPrefixes = {};

  var makeAlias = function makeAlias(str, prefixes) {
    var splits = str.split("|");
    var coefficientStr = splits[0].trim();
    var unitsStr = splits[1].trim();
    var coefficient = Num.One;

    if (coefficientStr !== "") {
      coefficient = KAS.parse(coefficientStr).expr;
    }

    var numdenomStr = unitsStr.split("/");
    var numdenom = [coefficient];

    if (numdenomStr[0]) {
      numdenomStr[0].split(" ").filter(function (x) {
        return x !== "";
      }).map(function (x) {
        numdenom.push(new Unit(x));
      });
    }

    if (numdenomStr[1]) {
      numdenomStr[1].split(" ").filter(function (x) {
        return x !== "";
      }).map(function (x) {
        numdenom.push(new Pow(new Unit(x), Num.Div));
      });
    }

    return {
      conversion: new Mul(numdenom),
      prefixes: prefixes
    };
  }; // This is a mapping of derived units (or different names for a unit) to their
  // definitions. For example, an inch is defined as 0.0254 m.
  //
  // Definitions don't need to be in terms of base units. For example, tsp is
  // defined in terms of tbsp (which is defined in terms of cup -> gal -> L ->
  // m^3). However, units must get simpler. I.e. there's no loop checking.
  //
  // makeAlias takes two parameters:
  // * a string specifying the simplification to perform
  //   - a required pipe separates the constant factor from the base units
  //   - the constant factor is parsed by KAS
  //   - the base units are in a simple format which disallows exponents and
  //     requires multiplicands to be space-separated ("m m" rather than "m^2)
  //     with an optional "/" separating numerator and denominator
  //   - prefixes are not allowed to be used in the converted to units
  //     (note that this restriction, the format of the string, and the choice to
  //     use a string in the first place are made out of laziness to minimize
  //     both typing and parsing)
  // * a boolean specifying whether or not it's acceptable to use SI units
  //
  // Where possible, these units are taken from "The International System of
  // Units (SI)" 8th edition (2006).


  var derivedUnits = {
    // mass
    // The atomic mass unit / dalton.
    Da: makeAlias("1.6605388628 x 10^-24 | g", hasPrefixes),
    u: makeAlias("| Da", hasntPrefixes),
    // length
    "meter": makeAlias("| m", hasntPrefixes),
    "meters": makeAlias("| m", hasntPrefixes),
    "in": makeAlias("254 / 10000 | m", hasntPrefixes),
    "ft": makeAlias("3048  / 10000 | m", hasntPrefixes),
    "yd": makeAlias("9144  / 10000 | m", hasntPrefixes),
    "mi": makeAlias("1609344 / 1000 | m", hasntPrefixes),
    "ly": makeAlias("9.4607 x 10^15 | m", hasntPrefixes),
    "nmi": makeAlias("1852 | m", hasntPrefixes),
    "Å": makeAlias("10^-10 | m", hasntPrefixes),
    "pc": makeAlias("3.0857 x 10^16 | m", hasntPrefixes),
    // time
    "min": makeAlias("60 | s", hasntPrefixes),
    "hr": makeAlias("3600 | s", hasntPrefixes),
    "sec": makeAlias("| s", hasntPrefixes),
    // TODO(joel) make day work
    "day": makeAlias("86400 | s", hasntPrefixes),
    "wk": makeAlias("604800 | s", hasntPrefixes),
    "fortnight": makeAlias("14 | day", hasntPrefixes),
    "shake": makeAlias("10^-8 | s", hasntPrefixes),
    "olympiad": makeAlias("126200000 | s", hasntPrefixes),
    // temperature
    "°C": makeAlias("1 | K", hasntPrefixes),
    "°F": makeAlias("5/9 | K", hasntPrefixes),
    "°R": makeAlias("5/9 | K", hasntPrefixes),
    // electric charge
    "e": makeAlias("1.6021765314 x 10^-19 | C", hasntPrefixes),
    // speed
    "c": makeAlias("299792458 | m / s", hasntPrefixes),
    "kn": makeAlias("514/1000 | m / s", hasntPrefixes),
    "kt": makeAlias("| kn", hasntPrefixes),
    "knot": makeAlias("| kn", hasntPrefixes),
    // energy
    "J": makeAlias("| N m", hasPrefixes),
    "BTU": makeAlias("1060 | J", hasntPrefixes),
    "cal": makeAlias("4184 / 1000 | J", hasPrefixes),
    "eV": makeAlias("1.602176514 x 10^-19 | J", hasPrefixes),
    "erg": makeAlias("10^−7 | J", hasPrefixes),
    // power
    "W": makeAlias("| J / s", hasPrefixes),
    "H-e": makeAlias("80 | W", hasntPrefixes),
    // force
    "N": makeAlias("1000 | g m / s s", hasPrefixes),
    // "lb": makeAlias("4448 / 1000 | N", hasntPrefixes),
    // 4.4482216152605
    "lb": makeAlias("4448221615 / 1000000000 | N", hasntPrefixes),
    "dyn": makeAlias("10^-5 | N", hasntPrefixes),
    // pressure
    "Pa": makeAlias("1 | N / m m m", hasPrefixes),
    "bar": makeAlias("10^5 | Pa", hasPrefixes),
    "㏔": makeAlias("1/1000 | bar", hasntPrefixes),
    "㍴": makeAlias("| bar", hasntPrefixes),
    "atm": makeAlias("101325 | Pa", hasntPrefixes),
    "Torr": makeAlias("1/760 | atm", hasntPrefixes),
    "mmHg": makeAlias("| Torr", hasntPrefixes),
    // area
    "ha": makeAlias("10^4 | m m", hasntPrefixes),
    "b": makeAlias("10^−28 | m m", hasPrefixes),
    "barn": makeAlias("| b", hasPrefixes),
    "acre": makeAlias("4046.87 | m m", hasntPrefixes),
    "skilodge": makeAlias("10^-31 | m m", hasntPrefixes),
    "outhouse": makeAlias("10^-34 | m m", hasntPrefixes),
    "shed": makeAlias("10^-52 | m m", hasntPrefixes),
    // volume
    "L": makeAlias("1/1000 | m m m", hasPrefixes),
    "gal": makeAlias("3785/1000 | L", hasPrefixes),
    "cup": makeAlias("1/16 | gal", hasntPrefixes),
    "qt": makeAlias("1/4 | gal", hasntPrefixes),
    "quart": makeAlias("| qt", hasntPrefixes),
    "p": makeAlias("1/8 | gal", hasntPrefixes),
    "pt": makeAlias("| p", hasntPrefixes),
    "pint": makeAlias("| p", hasntPrefixes),
    "fl oz": makeAlias("1/8 | cup", hasntPrefixes),
    "fl. oz.": makeAlias("1/8 | cup", hasntPrefixes),
    "tbsp": makeAlias("1/16 | cup", hasntPrefixes),
    "tsp": makeAlias("1/3 | tbsp", hasntPrefixes),
    // rotational
    // "rad":
    "rev": makeAlias("2 pi | rad", hasntPrefixes),
    "deg": makeAlias("180 pi | rad", hasntPrefixes),
    "°": makeAlias("| deg", hasntPrefixes),
    "arcminute": makeAlias("1/60 | deg", hasntPrefixes),
    "arcsec": makeAlias("1/3600 | deg", hasntPrefixes),
    // dimensionless
    // "B": makeAlias("10 | dB", hasntPrefixes), // XXX danger - logarithmic
    // "dB"
    // "nP"
    "Hu": makeAlias("1000 | dB", hasPrefixes),
    "dozen": makeAlias("12 |", hasntPrefixes),
    // XXX
    "mol": makeAlias("6.0221412927 x 10^23 |", hasPrefixes),
    "%": makeAlias("1/100 |", hasntPrefixes),
    "percent": makeAlias("| %", hasntPrefixes),
    "ppm": makeAlias("1/1000000 |", hasntPrefixes),
    // electric / magnetic
    "V": makeAlias("1000 | g m m / s s C", hasPrefixes),
    "C": makeAlias("| A s", hasPrefixes),
    "ampere": makeAlias("| A", hasntPrefixes),
    "Ω": makeAlias("| V / A", hasPrefixes),
    "ohm": makeAlias("| Ω", hasntPrefixes),
    "F": makeAlias("| C / V", hasPrefixes),
    "H": makeAlias("| ohm s", hasPrefixes),
    "T": makeAlias("1000 | g / C s", hasPrefixes),
    "Wb": makeAlias("1000 | g m m / C s", hasPrefixes),
    // photometry
    // TODO not sure this is right
    "lm": makeAlias("pi x 10^4 | cd / m m", hasntPrefixes),
    "lx": makeAlias("| lm / m m", hasntPrefixes),
    "nit": makeAlias("| cd / m m", hasntPrefixes),
    "sb": makeAlias("10^4 | cd / m m", hasntPrefixes),
    "stilb": makeAlias("1 | sb", hasntPrefixes),
    "apostilb": makeAlias("1 / pi x 10^(-4) | sb", hasntPrefixes),
    "blondel": makeAlias("| apostilb", hasntPrefixes),
    "asb": makeAlias("| apostilb", hasntPrefixes),
    "la": makeAlias("| lm", hasntPrefixes),
    "Lb": makeAlias("| lm", hasntPrefixes),
    "sk": makeAlias("10^-7 | lm", hasntPrefixes),
    "skot": makeAlias("| sk", hasntPrefixes),
    "bril": makeAlias("10^-11 | lm", hasntPrefixes),
    // other
    "Hz": makeAlias("| / s", hasPrefixes)
  };
  KAS.Add = Add;
  KAS.Mul = Mul;
  KAS.Pow = Pow;
  KAS.Log = Log;
  KAS.Eq = Eq;
  KAS.Trig = Trig;
  KAS.Abs = Abs;
  KAS.Func = Func;
  KAS.Var = Var;
  KAS.Const = Const;
  KAS.Unit = Unit;
  KAS.Rational = Rational;
  KAS.Int = Int;
  KAS.Float = Float;
  KAS.Zero = Num.Zero;
  KAS.One = Num.One;
})(KAS);
/* TODO(charlie): fix these lint errors (http://eslint.org/docs/rules): */

/* eslint-disable no-var, no-undef, comma-dangle, indent, max-len */


(function (KAS) {
  // assumes that both expressions have already been parsed
  // TODO(alex): be able to pass a random() function to compare()
  KAS.compare = function (expr1, expr2, options) {
    var defaults = {
      form: false,
      // check that the two expressions have the same form
      simplify: false // check that the second expression is simplified

    };
    /* more possible options:
        allow ratios e.g. 3/1 and 3 should both be accepted for something like slope
        allow student to choose their own variables names
    */

    if (options !== undefined) {
      options = _.extend(defaults, options);
    } else {
      options = defaults;
    } // variable check


    var vars = expr1.sameVars(expr2);

    if (!vars.equal) {
      var message = null;

      if (vars.equalIgnoringCase) {
        message = "Some of your variables are in the wrong case (upper vs. lower).";
      }

      return {
        equal: false,
        message: message
      };
    } // semantic check


    if (!expr1.compare(expr2)) {
      return {
        equal: false,
        message: null
      };
    } // syntactic check


    if (options.form && !expr1.sameForm(expr2)) {
      return {
        equal: false,
        message: "Your answer is not in the correct form."
      };
    } // syntactic check


    if (options.simplify && !expr1.isSimplified()) {
      return {
        equal: false,
        message: "Your answer is not fully expanded and simplified."
      };
    }

    return {
      equal: true,
      message: null
    };
  };
})(KAS);

var module$g = {
  exports: {}
};
/*
 * Number Utils
 * A number is a js-number, e.g. 5.12
 */

var _$1M = _underscore__default["default"];
var DEFAULT_TOLERANCE = 1e-9;
var EPSILON = Math.pow(2, -42);
var knumber$c = {
  DEFAULT_TOLERANCE: DEFAULT_TOLERANCE,
  EPSILON: EPSILON,
  is: function is(x) {
    return _$1M.isNumber(x) && !_$1M.isNaN(x);
  },
  equal: function equal(x, y, tolerance) {
    // Checking for undefined makes this function behave nicely
    // with vectors of different lengths that are _.zip'd together
    if (x == null || y == null) {
      return x === y;
    } // We check === here so that +/-Infinity comparisons work correctly


    if (x === y) {
      return true;
    }

    if (tolerance == null) {
      tolerance = DEFAULT_TOLERANCE;
    }

    return Math.abs(x - y) < tolerance;
  },
  sign: function sign(x, tolerance) {
    return knumber$c.equal(x, 0, tolerance) ? 0 : Math.abs(x) / x;
  },
  isInteger: function isInteger(num, tolerance) {
    return knumber$c.equal(Math.round(num), num, tolerance);
  },
  // Round a number to a certain number of decimal places
  round: function round(num, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(num * factor) / factor;
  },
  // Round num to the nearest multiple of increment
  // i.e. roundTo(83, 5) -> 85
  roundTo: function roundTo(num, increment) {
    return Math.round(num / increment) * increment;
  },
  floorTo: function floorTo(num, increment) {
    return Math.floor(num / increment) * increment;
  },
  ceilTo: function ceilTo(num, increment) {
    return Math.ceil(num / increment) * increment;
  },

  /**
   * toFraction
   *
   * Returns a [numerator, denominator] array rational representation
   * of `decimal`
   *
   * See http://en.wikipedia.org/wiki/Continued_fraction for implementation
   * details
   *
   * toFraction(4/8) => [1, 2]
   * toFraction(0.66) => [33, 50]
   * toFraction(0.66, 0.01) => [2/3]
   * toFraction(283 + 1/3) => [850, 3]
   */
  toFraction: function toFraction(decimal, tolerance, max_denominator) {
    max_denominator = max_denominator || 1000;
    tolerance = tolerance || EPSILON; // can't be 0
    // Initialize everything to compute successive terms of
    // continued-fraction approximations via recurrence relation

    var n = [1, 0],
        d = [0, 1];
    var a = Math.floor(decimal);
    var rem = decimal - a;

    while (d[0] <= max_denominator) {
      if (knumber$c.equal(n[0] / d[0], decimal, tolerance)) {
        return [n[0], d[0]];
      }

      n = [a * n[0] + n[1], n[0]];
      d = [a * d[0] + d[1], d[0]];
      a = Math.floor(1 / rem);
      rem = 1 / rem - a;
    } // We failed to find a nice rational representation,
    // so return an irrational "fraction"


    return [decimal, 1];
  }
};
module$g.exports = knumber$c;
var _numberJs = module$g.exports;

var module$f = {
  exports: {}
};
/*
 * Vector Utils 
 * A vector is an array of numbers e.g. [0, 3, 4].
 */

var _$1L = _underscore__default["default"];
var knumber$b = _numberJs;

function arraySum$1(array) {
  return _$1L.reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}

function arrayProduct(array) {
  return _$1L.reduce(array, function (memo, arg) {
    return memo * arg;
  }, 1);
}

var kvector$h = {
  is: function is(vec, dimension) {
    if (!_$1L.isArray(vec)) {
      return false;
    }

    if (dimension !== undefined && vec.length !== dimension) {
      return false;
    }

    return _$1L.all(vec, knumber$b.is);
  },
  // Normalize to a unit vector
  normalize: function normalize(v) {
    return kvector$h.scale(v, 1 / kvector$h.length(v));
  },
  // Length/magnitude of a vector
  length: function length(v) {
    return Math.sqrt(kvector$h.dot(v, v));
  },
  // Dot product of two vectors
  dot: function dot(a, b) {
    var vecs = _$1L.toArray(arguments);

    var zipped = _$1L.zip.apply(_$1L, vecs);

    var multiplied = _$1L.map(zipped, arrayProduct);

    return arraySum$1(multiplied);
  },

  /* vector-add multiple [x, y] coords/vectors
   *
   * kvector.add([1, 2], [3, 4]) -> [4, 6]
   */
  add: function add() {
    var points = _$1L.toArray(arguments);

    var zipped = _$1L.zip.apply(_$1L, points);

    return _$1L.map(zipped, arraySum$1);
  },
  subtract: function subtract(v1, v2) {
    return _$1L.map(_$1L.zip(v1, v2), function (dim) {
      return dim[0] - dim[1];
    });
  },
  negate: function negate(v) {
    return _$1L.map(v, function (x) {
      return -x;
    });
  },
  // Scale a vector
  scale: function scale(v1, scalar) {
    return _$1L.map(v1, function (x) {
      return x * scalar;
    });
  },
  equal: function equal(v1, v2, tolerance) {
    // _.zip will nicely deal with the lengths, going through
    // the length of the longest vector. knumber.equal then
    // returns false for any number compared to the undefined
    // passed in if one of the vectors is shorter.
    return _$1L.all(_$1L.zip(v1, v2), function (pair) {
      return knumber$b.equal(pair[0], pair[1], tolerance);
    });
  },
  codirectional: function codirectional(v1, v2, tolerance) {
    // The origin is trivially codirectional with all other vectors.
    // This gives nice semantics for codirectionality between points when
    // comparing their difference vectors.
    if (knumber$b.equal(kvector$h.length(v1), 0, tolerance) || knumber$b.equal(kvector$h.length(v2), 0, tolerance)) {
      return true;
    }

    v1 = kvector$h.normalize(v1);
    v2 = kvector$h.normalize(v2);
    return kvector$h.equal(v1, v2, tolerance);
  },
  collinear: function collinear(v1, v2, tolerance) {
    return kvector$h.codirectional(v1, v2, tolerance) || kvector$h.codirectional(v1, kvector$h.negate(v2), tolerance);
  },
  // Convert a cartesian coordinate into a radian polar coordinate
  polarRadFromCart: function polarRadFromCart(v) {
    var radius = kvector$h.length(v);
    var theta = Math.atan2(v[1], v[0]); // Convert angle range from [-pi, pi] to [0, 2pi]

    if (theta < 0) {
      theta += 2 * Math.PI;
    }

    return [radius, theta];
  },
  // Converts a cartesian coordinate into a degree polar coordinate
  polarDegFromCart: function polarDegFromCart(v) {
    var polar = kvector$h.polarRadFromCart(v);
    return [polar[0], polar[1] * 180 / Math.PI];
  },

  /* Convert a polar coordinate into a cartesian coordinate
   *
   * Examples:
   * cartFromPolarRad(5, Math.PI)
   * cartFromPolarRad([5, Math.PI])
   */
  cartFromPolarRad: function cartFromPolarRad(radius, theta) {
    if (_$1L.isUndefined(theta)) {
      theta = radius[1];
      radius = radius[0];
    }

    return [radius * Math.cos(theta), radius * Math.sin(theta)];
  },

  /* Convert a polar coordinate into a cartesian coordinate
   *
   * Examples:
   * cartFromPolarDeg(5, 30)
   * cartFromPolarDeg([5, 30])
   */
  cartFromPolarDeg: function cartFromPolarDeg(radius, theta) {
    if (_$1L.isUndefined(theta)) {
      theta = radius[1];
      radius = radius[0];
    }

    return kvector$h.cartFromPolarRad(radius, theta * Math.PI / 180);
  },
  // Rotate vector
  rotateRad: function rotateRad(v, theta) {
    var polar = kvector$h.polarRadFromCart(v);
    var angle = polar[1] + theta;
    return kvector$h.cartFromPolarRad(polar[0], angle);
  },
  rotateDeg: function rotateDeg(v, theta) {
    var polar = kvector$h.polarDegFromCart(v);
    var angle = polar[1] + theta;
    return kvector$h.cartFromPolarDeg(polar[0], angle);
  },
  // Angle between two vectors
  angleRad: function angleRad(v1, v2) {
    return Math.acos(kvector$h.dot(v1, v2) / (kvector$h.length(v1) * kvector$h.length(v2)));
  },
  angleDeg: function angleDeg(v1, v2) {
    return kvector$h.angleRad(v1, v2) * 180 / Math.PI;
  },
  // Vector projection of v1 onto v2
  projection: function projection(v1, v2) {
    var scalar = kvector$h.dot(v1, v2) / kvector$h.dot(v2, v2);
    return kvector$h.scale(v2, scalar);
  },
  // Round each number to a certain number of decimal places
  round: function round(vec, precision) {
    return _$1L.map(vec, function (elem, i) {
      return knumber$b.round(elem, precision[i] || precision);
    });
  },
  // Round each number to the nearest increment
  roundTo: function roundTo(vec, increment) {
    return _$1L.map(vec, function (elem, i) {
      return knumber$b.roundTo(elem, increment[i] || increment);
    });
  },
  floorTo: function floorTo(vec, increment) {
    return _$1L.map(vec, function (elem, i) {
      return knumber$b.floorTo(elem, increment[i] || increment);
    });
  },
  ceilTo: function ceilTo(vec, increment) {
    return _$1L.map(vec, function (elem, i) {
      return knumber$b.ceilTo(elem, increment[i] || increment);
    });
  }
};
module$f.exports = kvector$h;
var _vectorJs = module$f.exports;

var module$e = {
  exports: {}
};
/*
 * Point Utils
 * A point is an array of two numbers e.g. [0, 0].
 */

var _$1K = _underscore__default["default"];
var kvector$g = _vectorJs;
var knumber$a = _numberJs;
var kpoint$h = {
  // Rotate point (around origin unless a center is specified)
  rotateRad: function rotateRad(point, theta, center) {
    if (center === undefined) {
      return kvector$g.rotateRad(point, theta);
    } else {
      return kvector$g.add(center, kvector$g.rotateRad(kvector$g.subtract(point, center), theta));
    }
  },
  rotateDeg: function rotateDeg(point, theta, center) {
    if (center === undefined) {
      return kvector$g.rotateDeg(point, theta);
    } else {
      return kvector$g.add(center, kvector$g.rotateDeg(kvector$g.subtract(point, center), theta));
    }
  },
  // Distance between two points
  distanceToPoint: function distanceToPoint(point1, point2) {
    return kvector$g.length(kvector$g.subtract(point1, point2));
  },
  // Distance between point and line
  distanceToLine: function distanceToLine(point, line) {
    var lv = kvector$g.subtract(line[1], line[0]);
    var pv = kvector$g.subtract(point, line[0]);
    var projectedPv = kvector$g.projection(pv, lv);
    var distancePv = kvector$g.subtract(projectedPv, pv);
    return kvector$g.length(distancePv);
  },
  // Reflect point over line
  reflectOverLine: function reflectOverLine(point, line) {
    var lv = kvector$g.subtract(line[1], line[0]);
    var pv = kvector$g.subtract(point, line[0]);
    var projectedPv = kvector$g.projection(pv, lv);
    var reflectedPv = kvector$g.subtract(kvector$g.scale(projectedPv, 2), pv);
    return kvector$g.add(line[0], reflectedPv);
  },

  /**
   * Compares two points, returning -1, 0, or 1, for use with
   * Array.prototype.sort
   *
   * Note: This technically doesn't satisfy the total-ordering
   * requirements of Array.prototype.sort unless equalityTolerance
   * is 0. In some cases very close points that compare within a
   * few equalityTolerances could appear in the wrong order.
   */
  compare: function compare(point1, point2, equalityTolerance) {
    if (point1.length !== point2.length) {
      return point1.length - point2.length;
    }

    for (var i = 0; i < point1.length; i++) {
      if (!knumber$a.equal(point1[i], point2[i], equalityTolerance)) {
        return point1[i] - point2[i];
      }
    }

    return 0;
  }
};

_$1K.extend(kpoint$h, {
  // Check if a value is a point
  is: kvector$g.is,
  // Add and subtract vector(s)
  addVector: kvector$g.add,
  addVectors: kvector$g.add,
  subtractVector: kvector$g.subtract,
  equal: kvector$g.equal,
  // Convert from cartesian to polar and back
  polarRadFromCart: kvector$g.polarRadFromCart,
  polarDegFromCart: kvector$g.polarDegFromCart,
  cartFromPolarRad: kvector$g.cartFromPolarRad,
  cartFromPolarDeg: kvector$g.cartFromPolarDeg,
  // Rounding
  round: kvector$g.round,
  roundTo: kvector$g.roundTo,
  floorTo: kvector$g.floorTo,
  ceilTo: kvector$g.ceilTo
});

module$e.exports = kpoint$h;
var _pointJs = module$e.exports;

var module$d = {
  exports: {}
};
/*
 * Ray Utils
 * A ray is an array of an endpoint and another point along the ray.
 * For example, [[0, 0], [1, 0]] is the ray starting at the origin and
 * traveling along the positive x-axis.
 */

var kvector$f = _vectorJs;
var kpoint$g = _pointJs;
var kray$2 = {
  equal: function equal(ray1, ray2, tolerance) {
    // Compare the directions of the rays
    var v1 = kvector$f.subtract(ray1[1], ray1[0]);
    var v2 = kvector$f.subtract(ray2[1], ray2[0]);
    var sameOrigin = kpoint$g.equal(ray1[0], ray2[0]);
    var codirectional = kvector$f.codirectional(v1, v2, tolerance);
    return sameOrigin && codirectional;
  }
};
module$d.exports = kray$2;
var _rayJs = module$d.exports;

var module$c = {
  exports: {}
};
/*
 * Line Utils
 * A line is an array of two points e.g. [[-5, 0], [5, 0]].
 */

var kpoint$f = _pointJs;
var kvector$e = _vectorJs;
var kline$3 = {
  distanceToPoint: function distanceToPoint(line, point) {
    return kpoint$f.distanceToLine(point, line);
  },
  reflectPoint: function reflectPoint(line, point) {
    return kpoint$f.reflectOverLine(point, line);
  },
  midpoint: function midpoint(line) {
    return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];
  },
  equal: function equal(line1, line2, tolerance) {
    // TODO: A nicer implementation might just check collinearity of
    // vectors using underscore magick
    // Compare the directions of the lines
    var v1 = kvector$e.subtract(line1[1], line1[0]);
    var v2 = kvector$e.subtract(line2[1], line2[0]);

    if (!kvector$e.collinear(v1, v2, tolerance)) {
      return false;
    } // If the start point is the same for the two lines, then they are the same


    if (kpoint$f.equal(line1[0], line2[0])) {
      return true;
    } // Make sure that the direction to get from line1 to
    // line2 is the same as the direction of the lines


    var line1ToLine2Vector = kvector$e.subtract(line2[0], line1[0]);
    return kvector$e.collinear(v1, line1ToLine2Vector, tolerance);
  }
};
module$c.exports = kline$3;
var _lineJs = module$c.exports;

var module$b = {
  exports: {}
};
module$b.exports = {
  number: _numberJs,
  vector: _vectorJs,
  point: _pointJs,
  line: _lineJs,
  ray: _rayJs
};
var _kmath3 = module$b.exports;

var _module_$39 = {
  exports: {}
};
var knumber$9 = _kmath3.number;
var KhanMath$d = {
  // Simplify formulas before display
  cleanMath: function cleanMath(expr) {
    return typeof expr === "string" ? expr.replace(/\+\s*-/g, "- ").replace(/-\s*-/g, "+ ").replace(/\^1/g, "") : expr;
  },
  // Bound a number by 1e-6 and 1e20 to avoid exponents after toString
  bound: function bound(num) {
    if (num === 0) {
      return num;
    } else if (num < 0) {
      return -KhanMath$d.bound(-num);
    } else {
      return Math.max(1e-6, Math.min(num, 1e20));
    }
  },
  factorial: function factorial(x) {
    if (x <= 1) {
      return x;
    } else {
      return x * KhanMath$d.factorial(x - 1);
    }
  },
  getGCD: function getGCD(a, b) {
    if (arguments.length > 2) {
      var rest = [].slice.call(arguments, 1);
      return KhanMath$d.getGCD(a, KhanMath$d.getGCD(...rest));
    } else {
      var mod;
      a = Math.abs(a);
      b = Math.abs(b);

      while (b) {
        mod = a % b;
        a = b;
        b = mod;
      }

      return a;
    }
  },
  getLCM: function getLCM(a, b) {
    if (arguments.length > 2) {
      var rest = [].slice.call(arguments, 1);
      return KhanMath$d.getLCM(a, KhanMath$d.getLCM(...rest));
    } else {
      return Math.abs(a * b) / KhanMath$d.getGCD(a, b);
    }
  },
  primes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97],
  isPrime: function isPrime(n) {
    if (n <= 1) {
      return false;
    } else if (n < 101) {
      return !!$__default["default"].grep(KhanMath$d.primes, function (p, i) {
        return Math.abs(p - n) <= 0.5;
      }).length;
    } else {
      if (n <= 1 || n > 2 && n % 2 === 0) {
        return false;
      } else {
        for (var i = 3, sqrt = Math.sqrt(n); i <= sqrt; i += 2) {
          if (n % i === 0) {
            return false;
          }
        }
      }

      return true;
    }
  },
  getPrimeFactorization: function getPrimeFactorization(number) {
    if (number === 1) {
      return [];
    } else if (KhanMath$d.isPrime(number)) {
      return [number];
    }

    var maxf = Math.sqrt(number);

    for (var f = 2; f <= maxf; f++) {
      if (number % f === 0) {
        return $__default["default"].merge(KhanMath$d.getPrimeFactorization(f), KhanMath$d.getPrimeFactorization(number / f));
      }
    }
  },
  // Round a number to the nearest increment
  // E.g., if increment = 30 and num = 40, return 30. if increment = 30 and
  //     num = 45, return 60.
  roundToNearest: function roundToNearest(increment, num) {
    return Math.round(num / increment) * increment;
  },
  // Round a number to a certain number of decimal places
  roundTo: function roundTo(precision, num) {
    var factor = Math.pow(10, precision).toFixed(5);
    return Math.round((num * factor).toFixed(5)) / factor;
  },

  /**
   * Return a string of num rounded to a fixed precision decimal places,
   * with an approx symbol if num had to be rounded, and trailing 0s
   */
  toFixedApprox: function toFixedApprox(num, precision) {
    // TODO(aria): Make this locale-dependent like KhanUtil.localeToFixed
    var fixedStr = num.toFixed(precision);

    if (knumber$9.equal(+fixedStr, num)) {
      return fixedStr;
    } else {
      return "\\approx " + fixedStr;
    }
  },

  /**
   * Return a string of num rounded to precision decimal places, with an
   * approx symbol if num had to be rounded, but no trailing 0s if it was
   * not rounded.
   */
  roundToApprox: function roundToApprox(num, precision) {
    var fixed = KhanMath$d.roundTo(precision, num);

    if (knumber$9.equal(fixed, num)) {
      return String(fixed);
    } else {
      return KhanMath$d.toFixedApprox(num, precision);
    }
  },
  // toFraction(4/8) => [1, 2]
  // toFraction(0.666) => [333, 500]
  // toFraction(0.666, 0.001) => [2, 3]
  //
  // tolerance can't be bigger than 1, sorry
  toFraction: function toFraction(decimal, tolerance) {
    if (tolerance == null) {
      tolerance = Math.pow(2, -46);
    }

    if (decimal < 0 || decimal > 1) {
      var fract = decimal % 1;
      fract += fract < 0 ? 1 : 0;
      var nd = KhanMath$d.toFraction(fract, tolerance);
      nd[0] += Math.round(decimal - fract) * nd[1];
      return nd;
    } else if (Math.abs(Math.round(Number(decimal)) - decimal) <= tolerance) {
      return [Math.round(decimal), 1];
    } else {
      var loN = 0;
      var loD = 1;
      var hiN = 1;
      var hiD = 1;
      var midN = 1;
      var midD = 2;

      while (true) {
        // eslint-disable-line no-constant-condition
        if (Math.abs(Number(midN / midD) - decimal) <= tolerance) {
          return [midN, midD];
        } else if (midN / midD < decimal) {
          loN = midN;
          loD = midD;
        } else {
          hiN = midN;
          hiD = midD;
        }

        midN = loN + hiN;
        midD = loD + hiD;
      }
    }
  },
  // Returns the format (string) of a given numeric string
  // Note: purposively more inclusive than answer-types' predicate.forms
  // That is, it is not necessarily true that interpreted input are numeric
  getNumericFormat: function getNumericFormat(text) {
    text = $__default["default"].trim(text);
    text = text.replace(/\u2212/, "-").replace(/([+-])\s+/g, "$1");

    if (text.match(/^[+-]?\d+$/)) {
      return "integer";
    } else if (text.match(/^[+-]?\d+\s+\d+\s*\/\s*\d+$/)) {
      return "mixed";
    }

    var fraction = text.match(/^[+-]?(\d+)\s*\/\s*(\d+)$/);

    if (fraction) {
      return parseFloat(fraction[1]) > parseFloat(fraction[2]) ? "improper" : "proper";
    } else if (text.replace(/[,. ]/g, "").match(/^\d+$/)) {
      return "decimal";
    } else if (text.match(/(pi?|\u03c0|t(?:au)?|\u03c4|pau)/)) {
      return "pi";
    } else {
      return null;
    }
  },
  // Returns a string of the number in a specified format
  toNumericString: function toNumericString(number, format) {
    if (number == null) {
      return "";
    } else if (number === 0) {
      return "0"; // otherwise it might end up as 0% or 0pi
    }

    if (format === "percent") {
      return number * 100 + "%";
    }

    if (format === "pi") {
      var fraction = knumber$9.toFraction(number / Math.PI);
      var numerator = Math.abs(fraction[0]);
      var denominator = fraction[1];

      if (knumber$9.isInteger(numerator)) {
        var sign = number < 0 ? "-" : "";
        var pi = "\u03C0";
        return sign + (numerator === 1 ? "" : numerator) + pi + (denominator === 1 ? "" : "/" + denominator);
      }
    }

    if (["proper", "improper", "mixed", "fraction"].includes(format)) {
      var _fraction = knumber$9.toFraction(number);

      var _numerator = Math.abs(_fraction[0]);

      var _denominator = _fraction[1];

      var _sign = number < 0 ? "-" : "";

      if (_denominator === 1) {
        return _sign + _numerator; // for integers, irrational, d > 1000
      } else if (format === "mixed") {
        var modulus = _numerator % _denominator;
        var integer = (_numerator - modulus) / _denominator;
        return _sign + (integer ? integer + " " : "") + modulus + "/" + _denominator;
      } // otherwise proper, improper, or fraction


      return _sign + _numerator + "/" + _denominator;
    } // otherwise (decimal, float, long long)


    return String(number);
  }
};
_module_$39.exports = KhanMath$d;
var _utilMathJs = _module_$39.exports;

var _module_$38 = {
  exports: {}
};
/* eslint-disable object-curly-spacing */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* global i18n:false */

var $$5 = $__default["default"];
var _$1J = _underscore__default["default"];
var KhanMath$c = _utilMathJs;
var MAXERROR_EPSILON = Math.pow(2, -42);
/*
 * Answer types
 *
 * Utility for creating answerable questions displayed in exercises
 *
 * Different answer types produce different kinds of input displays, and do
 * different kinds of checking on the solutions.
 *
 * Each of the objects contain two functions, setup and createValidator.
 *
 * The setup function takes a solutionarea and solution, and performs setup
 * within the solutionarea, and then returns an object which contains:
 *
 * answer: a function which, when called, will retrieve the current answer from
 *         the solutionarea, which can then be validated using the validator
 *         function
 * validator: a function returned from the createValidator function (defined
 *            below)
 * solution: the correct answer to the problem
 * showGuess: a function which, when given a guess, shows the guess within the
 *            provided solutionarea
 * showGuessCustom: a function which displays parts of a guess that are not
 *                  within the solutionarea; currently only used for custom
 *                  answers
 *
 * The createValidator function only takes a solution, and it returns a
 * function which can be used to validate an answer.
 *
 * The resulting validator function returns:
 * - true: if the answer is fully correct
 * - false: if the answer is incorrect
 * - "" (the empty string): if no answer has been provided (e.g. the answer box
 *   is left unfilled)
 * - a string: if there is some slight error
 *
 * In most cases, setup and createValidator don't really need the solution DOM
 * element so we have setupFunctional and createValidatorFunctional for them
 * which take only $solution.text() and $solution.data(). This makes it easier
 * to reuse specific answer types.
 *
 * TODO(alpert): Think of a less-absurd name for createValidatorFunctional.
 *
 */

var KhanAnswerTypes$6 = {
  /*
   * predicate answer type
   *
   * performs simple predicate-based checking of a numeric solution, with
   * different kinds of number formats
   *
   * Uses the data-forms option on the solution to choose which number formats
   * are acceptable. Available data-forms:
   *
   * - integer:  3
   * - proper:   3/5
   * - improper: 5/3
   * - pi:       3 pi
   * - log:      log(5)
   * - percent:  15%
   * - mixed:    1 1/3
   * - decimal:  1.7
   *
   * The solution should be a predicate of the form:
   *
   * function(guess, maxError) {
   *     return abs(guess - 3) < maxError;
   * }
   *
   */
  predicate: {
    defaultForms: "integer, proper, improper, mixed, decimal",
    createValidatorFunctional: function createValidatorFunctional(predicate, options) {
      // Extract the options from the given solution object
      options = _$1J.extend({
        simplify: "required",
        ratio: false,
        forms: KhanAnswerTypes$6.predicate.defaultForms
      }, options);
      var acceptableForms; // this is maintaining backwards compatibility
      // TODO(merlob) fix all places that depend on this, then delete

      if (!_$1J.isArray(options.forms)) {
        acceptableForms = options.forms.split(/\s*,\s*/);
      } else {
        acceptableForms = options.forms;
      } // TODO(jack): remove options.inexact in favor of options.maxError


      if (options.inexact === undefined) {
        // If we aren't allowing inexact, ensure that we don't have a
        // large maxError as well.
        options.maxError = 0;
      } // Allow a small tolerance on maxError, to avoid numerical
      // representation issues (2.3 should be correct for a solution of
      // 2.45 with maxError=0.15).


      options.maxError = +options.maxError + MAXERROR_EPSILON; // If percent is an acceptable form, make sure it's the last one
      // in the list so we don't prematurely complain about not having
      // a percent sign when the user entered the correct answer in a
      // different form (such as a decimal or fraction)

      if (_$1J.contains(acceptableForms, "percent")) {
        acceptableForms = _$1J.without(acceptableForms, "percent");
        acceptableForms.push("percent");
      } // Take text looking like a fraction, and turn it into a number


      var fractionTransformer = function fractionTransformer(text) {
        text = text // Replace unicode minus sign with hyphen
        .replace(/\u2212/, "-") // Remove space after +, -
        .replace(/([+-])\s+/g, "$1") // Remove leading/trailing whitespace
        .replace(/(^\s*)|(\s*$)/gi, ""); // Extract numerator and denominator

        var match = text.match(/^([+-]?\d+)\s*\/\s*([+-]?\d+)$/);
        var parsedInt = parseInt(text, 10);

        if (match) {
          var num = parseFloat(match[1]);
          var denom = parseFloat(match[2]);
          var simplified = denom > 0 && (options.ratio || match[2] !== "1") && KhanMath$c.getGCD(num, denom) === 1;
          return [{
            value: num / denom,
            exact: simplified
          }];
        } else if (!isNaN(parsedInt) && "" + parsedInt === text) {
          return [{
            value: parsedInt,
            exact: true
          }];
        }

        return [];
      };
      /*
       * Different forms of numbers
       *
       * Each function returns a list of objects of the form:
       *
       * {
       *    value: numerical value,
       *    exact: true/false
       * }
       */


      var forms = {
        // integer, which is encompassed by decimal
        integer: function integer(text) {
          // Compare the decimal form to the decimal form rounded to
          // an integer. Only accept if the user actually entered an
          // integer.
          var decimal = forms.decimal(text);
          var rounded = forms.decimal(text, 1);

          if (decimal[0].value != null && decimal[0].value === rounded[0].value || decimal[1].value != null && decimal[1].value === rounded[1].value) {
            return decimal;
          }

          return [];
        },
        // A proper fraction
        proper: function proper(text) {
          return $$5.map(fractionTransformer(text), function (o) {
            // All fractions that are less than 1
            if (Math.abs(o.value) < 1) {
              return [o];
            } else {
              return [];
            }
          });
        },
        // an improper fraction
        improper: function improper(text) {
          return $$5.map(fractionTransformer(text), function (o) {
            // All fractions that are greater than 1
            if (Math.abs(o.value) >= 1) {
              return [o];
            } else {
              return [];
            }
          });
        },
        // pi-like numbers
        pi: function pi(text) {
          var match;
          var possibilities = []; // Replace unicode minus sign with hyphen

          text = text.replace(/\u2212/, "-"); // - pi
          // (Note: we also support \pi (for TeX), p, tau (and \tau,
          // and t), pau.)

          if (match = text.match(/^([+-]?)\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            possibilities = [{
              value: parseFloat(match[1] + "1"),
              exact: true
            }]; // 5 / 6 pi
          } else if (match = text.match(/^([+-]?\s*\d+\s*(?:\/\s*[+-]?\s*\d+)?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i // eslint-disable-line max-len
          )) {
            possibilities = fractionTransformer(match[1]); // 4 5 / 6 pi
          } else if (match = text.match(/^([+-]?)\s*(\d+)\s*([+-]?\d+)\s*\/\s*([+-]?\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i // eslint-disable-line max-len
          )) {
            var sign = parseFloat(match[1] + "1");
            var integ = parseFloat(match[2]);
            var num = parseFloat(match[3]);
            var denom = parseFloat(match[4]);
            var simplified = num < denom && KhanMath$c.getGCD(num, denom) === 1;
            possibilities = [{
              value: sign * (integ + num / denom),
              exact: simplified
            }]; // 5 pi / 6
          } else if (match = text.match(/^([+-]?\s*\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\s*\d+))?$/i // eslint-disable-line max-len
          )) {
            possibilities = fractionTransformer(match[1] + "/" + match[3]); // - pi / 4
          } else if (match = text.match(/^([+-]?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\d+))?$/i // eslint-disable-line max-len
          )) {
            possibilities = fractionTransformer(match[1] + "1/" + match[3]); // 0
          } else if (text === "0") {
            possibilities = [{
              value: 0,
              exact: true
            }]; // 0.5 pi (fallback)
          } else if (match = text.match(/^(.+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i // eslint-disable-line max-len
          )) {
            possibilities = forms.decimal(match[1]);
          } else {
            possibilities = _$1J.reduce(KhanAnswerTypes$6.predicate.defaultForms.split(/\s*,\s*/), function (memo, form) {
              return memo.concat(forms[form](text));
            }, []); // If the answer is a floating point number that's
            // near a multiple of pi, mark is as being possibly
            // an approximation of pi.  We actually check if
            // it's a plausible approximation of pi/12, since
            // sometimes the correct answer is like pi/3 or pi/4.
            // We also say it's a pi-approximation if it involves
            // x/7 (since 22/7 is an approximation of pi.)
            // Never mark an integer as being an approximation
            // of pi.

            var approximatesPi = false;
            var number = parseFloat(text);

            if (!isNaN(number) && number !== parseInt(text)) {
              var piMult = Math.PI / 12;
              var roundedNumber = piMult * Math.round(number / piMult);

              if (Math.abs(number - roundedNumber) < 0.01) {
                approximatesPi = true;
              }
            } else if (text.match(/\/\s*7/)) {
              approximatesPi = true;
            }

            if (approximatesPi) {
              _$1J.each(possibilities, function (possibility) {
                possibility.piApprox = true;
              });
            }

            return possibilities;
          }

          var multiplier = Math.PI;

          if (text.match(/\\?tau|t|\u03c4/)) {
            multiplier = Math.PI * 2;
          } // We're taking an early stand along side xkcd in the
          // inevitable ti vs. pau debate... http://xkcd.com/1292


          if (text.match(/pau/)) {
            multiplier = Math.PI * 1.5;
          }

          $$5.each(possibilities, function (ix, possibility) {
            possibility.value *= multiplier;
          });
          return possibilities;
        },
        // Converts '' to 1 and '-' to -1 so you can write "[___] x"
        // and accept sane things
        coefficient: function coefficient(text) {
          var possibilities = []; // Replace unicode minus sign with hyphen

          text = text.replace(/\u2212/, "-");

          if (text === "") {
            possibilities = [{
              value: 1,
              exact: true
            }];
          } else if (text === "-") {
            possibilities = [{
              value: -1,
              exact: true
            }];
          }

          return possibilities;
        },
        // simple log(c) form
        log: function log(text) {
          var match;
          var possibilities = []; // Replace unicode minus sign with hyphen

          text = text.replace(/\u2212/, "-");
          text = text.replace(/[ \(\)]/g, "");

          if (match = text.match(/^log\s*(\S+)\s*$/i)) {
            possibilities = forms.decimal(match[1]);
          } else if (text === "0") {
            possibilities = [{
              value: 0,
              exact: true
            }];
          }

          return possibilities;
        },
        // Numbers with percent signs
        percent: function percent(text) {
          text = $$5.trim(text); // store whether or not there is a percent sign

          var hasPercentSign = false;

          if (text.indexOf("%") === text.length - 1) {
            text = $$5.trim(text.substring(0, text.length - 1));
            hasPercentSign = true;
          }

          var transformed = forms.decimal(text);
          $$5.each(transformed, function (ix, t) {
            t.exact = hasPercentSign;
            t.value = t.value / 100;
          });
          return transformed;
        },
        // Mixed numbers, like 1 3/4
        mixed: function mixed(text) {
          var match = text // Replace unicode minus sign with hyphen
          .replace(/\u2212/, "-") // Remove space after +, -
          .replace(/([+-])\s+/g, "$1") // Extract integer, numerator and denominator
          .match(/^([+-]?)(\d+)\s+(\d+)\s*\/\s*(\d+)$/);

          if (match) {
            var sign = parseFloat(match[1] + "1");
            var integ = parseFloat(match[2]);
            var num = parseFloat(match[3]);
            var denom = parseFloat(match[4]);
            var simplified = num < denom && KhanMath$c.getGCD(num, denom) === 1;
            return [{
              value: sign * (integ + num / denom),
              exact: simplified
            }];
          }

          return [];
        },
        // Decimal numbers -- compare entered text rounded to
        // 'precision' Reciprical of the precision against the correct
        // answer. We round to 1/1e10 by default, which is healthily
        // less than machine epsilon but should be more than any real
        // decimal answer would use. (The 'integer' answer type uses
        // precision == 1.)
        decimal: function decimal(text, precision) {
          if (precision == null) {
            precision = 1e10;
          }

          var normal = function normal(text) {
            text = $$5.trim(text);
            var match = text // Replace unicode minus sign with hyphen
            .replace(/\u2212/, "-") // Remove space after +, -
            .replace(/([+-])\s+/g, "$1") // Extract integer, numerator and denominator. If
            // commas or spaces are used, they must be in the
            // "correct" places
            .match(/^([+-]?(?:\d{1,3}(?:[, ]?\d{3})*\.?|\d{0,3}(?:[, ]?\d{3})*\.(?:\d{3}[, ]?)*\d{1,3}))$/ // eslint-disable-line max-len
            ); // You can't start a number with `0,`, to prevent us
            // interpeting '0.342' as correct for '342'

            var badLeadingZero = text.match(/^0[0,]*,/);

            if (match && !badLeadingZero) {
              var x = parseFloat(match[1].replace(/[, ]/g, ""));

              if (options.inexact === undefined) {
                x = Math.round(x * precision) / precision;
              }

              return x;
            }
          };

          var commas = function commas(text) {
            text = text.replace(/([\.,])/g, function (_, c) {
              return c === "." ? "," : ".";
            });
            return normal(text);
          };

          return [{
            value: normal(text),
            exact: true
          }, {
            value: commas(text),
            exact: true
          }];
        }
      }; // validator function

      return function (guess) {
        // The fallback variable is used in place of the answer, if no
        // answer is provided (i.e. the field is left blank)
        var fallback = options.fallback != null ? "" + options.fallback : "";
        guess = $$5.trim(guess) || fallback;
        var score = {
          empty: guess === "",
          correct: false,
          message: null,
          guess: guess
        }; // iterate over all the acceptable forms, and if one of the
        // answers is correct, return true

        $$5.each(acceptableForms, function (i, form) {
          var transformed = forms[form](guess);

          for (var j = 0, l = transformed.length; j < l; j++) {
            var val = transformed[j].value;
            var exact = transformed[j].exact;
            var piApprox = transformed[j].piApprox; // If a string was returned, and it exactly matches,
            // return true

            if (predicate(val, options.maxError)) {
              // If the exact correct number was returned,
              // return true
              if (exact || options.simplify === "optional") {
                score.correct = true;
                score.message = options.message || null; // If the answer is correct, don't say it's
                // empty. This happens, for example, with the
                // coefficient type where guess === "" but is
                // interpreted as "1" which is correct.

                score.empty = false;
              } else if (form === "percent") {
                // Otherwise, an error was returned
                score.empty = true;
                score.message = i18n._("Your answer is almost correct, " + "but it is missing a " + "<code>\\%</code> at the end.");
              } else {
                if (options.simplify !== "enforced") {
                  score.empty = true;
                }

                score.message = i18n._("Your answer is almost correct, " + "but it needs to be simplified.");
              }

              return false;
            } else if (piApprox && predicate(val, Math.abs(val * 0.001))) {
              score.empty = true;
              score.message = i18n._("Your answer is close, but you may " + "have approximated pi. Enter your " + "answer as a multiple of pi, like " + "<code>12\\ \\text{pi}</code> or " + "<code>2/3\\ \\text{pi}</code>");
            }
          }
        });

        if (score.correct === false) {
          var interpretedGuess = false;

          _$1J.each(forms, function (form) {
            var anyAreNaN = _$1J.any(form(guess), function (t) {
              return t.value != null && !_$1J.isNaN(t.value);
            });

            if (anyAreNaN) {
              interpretedGuess = true;
            }
          });

          if (!interpretedGuess) {
            score.empty = true;
            score.message = i18n._("We could not understand your " + "answer. Please check your answer for extra " + "text or symbols.");
            return score;
          }
        }

        return score;
      };
    }
  },

  /*
   * number answer type
   *
   * wraps the predicate answer type to performs simple number-based checking
   * of a solution
   */
  number: {
    convertToPredicate: function convertToPredicate(correct, options) {
      // TODO(alpert): Don't think this $.trim is necessary
      var correctFloat = parseFloat($$5.trim(correct));
      return [function (guess, maxError) {
        return Math.abs(guess - correctFloat) < maxError;
      }, $$5.extend({}, options, {
        type: "predicate"
      })];
    },
    createValidatorFunctional: function createValidatorFunctional(correct, options) {
      return KhanAnswerTypes$6.predicate.createValidatorFunctional(...KhanAnswerTypes$6.number.convertToPredicate(correct, options));
    }
  },

  /*
   * The expression answer type parses a given expression or equation
   * and semantically compares it to the solution. In addition, instant
   * feedback is provided by rendering the last answer that fully parsed.
   *
   * Parsing options:
   * functions (e.g. data-functions="f g h")
   *     A space or comma separated list of single-letter variables that
   *     should be interpreted as functions. Case sensitive. "e" and "i"
   *     are reserved.
   *
   *     no functions specified: f(x+y) == fx + fy
   *     with "f" as a function: f(x+y) != fx + fy
   *
   * Comparison options:
   * same-form (e.g. data-same-form)
   *     If present, the answer must match the solution's structure in
   *     addition to evaluating the same. Commutativity and excess negation
   *     are ignored, but all other changes will trigger a rejection. Useful
   *     for requiring a particular form of an equation, or if the answer
   *     must be factored.
   *
   *     example question:    Factor x^2 + x - 2
   *     example solution:    (x-1)(x+2)
   *     accepted answers:    (x-1)(x+2), (x+2)(x-1), ---(-x-2)(-1+x), etc.
   *     rejected answers:    x^2+x-2, x*x+x-2, x(x+1)-2, (x-1)(x+2)^1, etc.
   *     rejection message:   Your answer is not in the correct form
   *
   * simplify (e.g. data-simplify)
   *     If present, the answer must be fully expanded and simplified. Use
   *     carefully - simplification is hard and there may be bugs, or you
   *     might not agree on the definition of "simplified" used. You will
   *     get an error if the provided solution is not itself fully expanded
   *     and simplified.
   *
   *     example question:    Simplify ((n*x^5)^5) / (n^(-2)*x^2)^-3
   *     example solution:    x^31 / n
   *     accepted answers:    x^31 / n, x^31 / n^1, x^31 * n^(-1), etc.
   *     rejected answers:    (x^25 * n^5) / (x^(-6) * n^6), etc.
   *     rejection message:   Your answer is not fully expanded and simplified
   *
   * Rendering options:
   * times (e.g. data-times)
   *     If present, explicit multiplication (such as between numbers) will
   *     be rendered with a cross/x symbol (TeX: \times) instead of the usual
   *     center dot (TeX: \cdot).
   *
   *     normal rendering:    2 * 3^x -> 2 \cdot 3^{x}
   *     but with "times":    2 * 3^x -> 2 \times 3^{x}
   */
  expression: {
    parseSolution: function parseSolution(solutionString, options) {
      var solution = KAS.parse(solutionString, options);

      if (!solution.parsed) {
        throw new Error("The provided solution (" + solutionString + ") didn't parse.");
      } else if (options.simplified && !solution.expr.isSimplified()) {
        throw new Error("The provided solution (" + solutionString + ") isn't fully expanded and simplified.");
      } else {
        solution = solution.expr;
      }

      return solution;
    },
    createValidatorFunctional: function createValidatorFunctional(solution, options) {
      return function (guess) {
        var score = {
          empty: false,
          correct: false,
          message: null,
          guess: guess
        }; // Don't bother parsing an empty input

        if (!guess) {
          score.empty = true;
          return score;
        }

        var answer = KAS.parse(guess, options); // An unsuccessful parse doesn't count as wrong

        if (!answer.parsed) {
          score.empty = true;
          return score;
        } // Solution will need to be parsed again if we're creating
        // this from a multiple question type


        if (typeof solution === "string") {
          solution = KhanAnswerTypes$6.expression.parseSolution(solution, options);
        }

        var result = KAS.compare(answer.expr, solution, options);

        if (result.equal) {
          // Correct answer
          score.correct = true;
        } else if (result.message) {
          // Nearly correct answer
          score.message = result.message;
        } else {
          // Replace x with * and see if it would have been correct
          var answerX = KAS.parse(guess.replace(/[xX]/g, "*"), options);

          if (answerX.parsed) {
            var resultX = KAS.compare(answerX.expr, solution, options);

            if (resultX.equal) {
              score.empty = true;
              score.message = "I'm a computer. I only " + "understand multiplication if you use an " + "asterisk (*) as the multiplication sign.";
            } else if (resultX.message) {
              score.message = resultX.message + " Also, " + "I'm a computer. I only " + "understand multiplication if you use an " + "asterisk (*) as the multiplication sign.";
            }
          }
        }

        return score;
      };
    }
  }
};
_module_$38.exports = KhanAnswerTypes$6;
var _utilAnswerTypesJs = _module_$38.exports;

/* eslint-disable brace-style, comma-dangle, indent, max-len, no-var, one-var, prefer-spread */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var _$1I = _underscore__default["default"];
var KhanAnswerTypes$5 = _utilAnswerTypesJs;

var nestedMap$2 = function nestedMap(children, func, context) {
  if (_$1I.isArray(children)) {
    return _$1I.map(children, function (child) {
      return nestedMap(child, func);
    });
  } else {
    return func.call(context, children);
  }
};

var Util$q = {
  /**
   * Used to compare equality of two input paths, which are represented as
   * arrays of strings.
   */
  inputPathsEqual(a, b) {
    if (a == null || b == null) {
      return a == null === (b == null);
    }

    return a.length === b.length && a.every((item, index) => {
      return b[index] === item;
    });
  },

  nestedMap: nestedMap$2,
  rWidgetParts: /^\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]$/,
  rWidgetRule: /^\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]/,
  rTypeFromWidgetId: /^([a-z-]+) ([0-9]+)$/,
  snowman: "\u2603",
  noScore: {
    type: "points",
    earned: 0,
    total: 0,
    message: null
  },
  seededRNG: function seededRNG(seed) {
    var randomSeed = seed;
    return function () {
      // Robert Jenkins' 32 bit integer hash function.
      var seed = randomSeed;
      seed = seed + 0x7ed55d16 + (seed << 12) & 0xffffffff;
      seed = (seed ^ 0xc761c23c ^ seed >>> 19) & 0xffffffff;
      seed = seed + 0x165667b1 + (seed << 5) & 0xffffffff;
      seed = (seed + 0xd3a2646c ^ seed << 9) & 0xffffffff;
      seed = seed + 0xfd7046c5 + (seed << 3) & 0xffffffff;
      seed = (seed ^ 0xb55a4f09 ^ seed >>> 16) & 0xffffffff;
      return (randomSeed = seed & 0xfffffff) / 0x10000000;
    };
  },
  // Shuffle an array using a given random seed or function.
  // If `ensurePermuted` is true, the input and ouput are guaranteed to be
  // distinct permutations.
  shuffle: function shuffle(array, randomSeed, ensurePermuted) {
    // Always return a copy of the input array
    var shuffled = _$1I.clone(array); // Handle edge cases (input array is empty or uniform)


    if (!shuffled.length || _$1I.all(shuffled, function (value) {
      return _$1I.isEqual(value, shuffled[0]);
    })) {
      return shuffled;
    }

    var random;

    if (_$1I.isFunction(randomSeed)) {
      random = randomSeed;
    } else {
      random = Util$q.seededRNG(randomSeed);
    }

    do {
      // Fischer-Yates shuffle
      for (var top = shuffled.length; top > 0; top--) {
        var newEnd = Math.floor(random() * top),
            temp = shuffled[newEnd];
        shuffled[newEnd] = shuffled[top - 1];
        shuffled[top - 1] = temp;
      }
    } while (ensurePermuted && _$1I.isEqual(array, shuffled));

    return shuffled;
  },
  // In IE8, split doesn't work right. Implement it ourselves.
  split: "x".split(/(.)/g).length ? function (str, r) {
    return str.split(r);
  } : function (str, r) {
    // Based on Steven Levithan's MIT-licensed split, available at
    // http://blog.stevenlevithan.com/archives/cross-browser-split
    var output = [];
    var lastIndex = r.lastIndex = 0;
    var match;

    while (match = r.exec(str)) {
      output.push(str.slice(lastIndex, match.index));
      output.push.apply(output, match.slice(1));
      lastIndex = match.index + match[0].length;
    }

    output.push(str.slice(lastIndex));
    return output;
  },

  /**
   * Given two score objects for two different widgets, combine them so that
   * if one is wrong, the total score is wrong, etc.
   */
  combineScores: function combineScores(scoreA, scoreB) {
    var message;

    if (scoreA.type === "points" && scoreB.type === "points") {
      if (scoreA.message && scoreB.message && scoreA.message !== scoreB.message) {
        // TODO(alpert): Figure out how to combine messages usefully
        message = null;
      } else {
        message = scoreA.message || scoreB.message;
      }

      return {
        type: "points",
        earned: scoreA.earned + scoreB.earned,
        total: scoreA.total + scoreB.total,
        message: message
      };
    } else if (scoreA.type === "points" && scoreB.type === "invalid") {
      return scoreB;
    } else if (scoreA.type === "invalid" && scoreB.type === "points") {
      return scoreA;
    } else if (scoreA.type === "invalid" && scoreB.type === "invalid") {
      if (scoreA.message && scoreB.message && scoreA.message !== scoreB.message) {
        // TODO(alpert): Figure out how to combine messages usefully
        message = null;
      } else {
        message = scoreA.message || scoreB.message;
      }

      return {
        type: "invalid",
        message: message
      };
    }
  },
  keScoreFromPerseusScore: function keScoreFromPerseusScore(score, guess, state) {
    if (score.type === "points") {
      return {
        empty: false,
        correct: score.earned >= score.total,
        message: score.message,
        guess: guess,
        state: state
      };
    } else if (score.type === "invalid") {
      return {
        empty: true,
        correct: false,
        message: score.message,
        guess: guess,
        state: state
      };
    } else {
      throw new Error("Invalid score type: " + score.type);
    }
  },

  /**
   * Return the first valid interpretation of 'text' as a number, in the form
   * {value: 2.3, exact: true}.
   */
  firstNumericalParse: function firstNumericalParse(text) {
    // TODO(alpert): This is sort of hacky...
    var first;
    var val = KhanAnswerTypes$5.predicate.createValidatorFunctional(function (ans) {
      first = ans;
      return true;
      /* break */
    }, {
      simplify: "optional",
      inexact: true,
      forms: "integer, proper, improper, pi, log, mixed, decimal"
    });
    val(text);
    return first;
  },
  stringArrayOfSize: function stringArrayOfSize(size) {
    return _$1I.times(size, function () {
      return "";
    });
  },

  /**
   * For a graph's x or y dimension, given the tick step,
   * the ranges extent (e.g. [-10, 10]), the pixel dimension constraint,
   * and the grid step, return a bunch of configurations for that dimension.
   *
   * Example:
   *      gridDimensionConfig(10, [-50, 50], 400, 5)
   *
   * Returns: {
   *      scale: 4,
   *      snap: 2.5,
   *      tickStep: 2,
   *      unityLabel: true
   * };
   */
  gridDimensionConfig: function gridDimensionConfig(absTickStep, extent, dimensionConstraint, gridStep) {
    var scale = Util$q.scaleFromExtent(extent, dimensionConstraint);
    var stepPx = absTickStep * scale;
    var unityLabel = stepPx > 30;
    return {
      scale: scale,
      tickStep: absTickStep / gridStep,
      unityLabel: unityLabel
    };
  },

  /**
   * Given the range, step, and boxSize, calculate the reasonable gridStep.
   * Used for when one was not given explicitly.
   *
   * Example:
   *      getGridStep([[-10, 10], [-10, 10]], [1, 1], 340)
   *
   * Returns: [1, 1]
   */
  getGridStep: function getGridStep(range, step, boxSize) {
    return _$1I.times(2, function (i) {
      var scale = Util$q.scaleFromExtent(range[i], boxSize);
      var gridStep = Util$q.gridStepFromTickStep(step[i], scale);
      return gridStep;
    });
  },
  snapStepFromGridStep: function snapStepFromGridStep(gridStep) {
    return _$1I.map(gridStep, function (step) {
      return step / 2;
    });
  },

  /**
   * Given the range and a dimension, come up with the appropriate
   * scale.
   * Example:
   *      scaleFromExtent([-25, 25], 500) // returns 10
   */
  scaleFromExtent: function scaleFromExtent(extent, dimensionConstraint) {
    var span = extent[1] - extent[0];
    var scale = dimensionConstraint / span;
    return scale;
  },

  /**
   * Return a reasonable tick step given extent and dimension.
   * (extent is [begin, end] of the domain.)
   * Example:
   *      tickStepFromExtent([-10, 10], 300) // returns 2
   */
  tickStepFromExtent: function tickStepFromExtent(extent, dimensionConstraint) {
    var span = extent[1] - extent[0];
    var tickFactor; // If single number digits

    if (15 < span && span <= 20) {
      tickFactor = 23; // triple digit or decimal
    } else if (span > 100 || span < 5) {
      tickFactor = 10; // double digit
    } else {
      tickFactor = 16;
    }

    var constraintFactor = dimensionConstraint / 500;
    var desiredNumTicks = tickFactor * constraintFactor;
    return Util$q.tickStepFromNumTicks(span, desiredNumTicks);
  },

  /**
   * Given the tickStep and the graph's scale, find a
   * grid step.
   * Example:
   *      gridStepFromTickStep(200, 0.2) // returns 100
   */
  gridStepFromTickStep: function gridStepFromTickStep(tickStep, scale) {
    var tickWidth = tickStep * scale;
    var x = tickStep;
    var y = Math.pow(10, Math.floor(Math.log(x) / Math.LN10));
    var leadingDigit = Math.floor(x / y);

    if (tickWidth < 25) {
      return tickStep;
    }

    if (tickWidth < 50) {
      if (leadingDigit === 5) {
        return tickStep;
      } else {
        return tickStep / 2;
      }
    }

    if (leadingDigit === 1) {
      return tickStep / 2;
    }

    if (leadingDigit === 2) {
      return tickStep / 4;
    }

    if (leadingDigit === 5) {
      return tickStep / 5;
    }
  },

  /**
   * Find a good tick step for the desired number of ticks in the range
   * Modified from d3.scale.linear: d3_scale_linearTickRange.
   * Thanks, mbostock!
   * Example:
   *      tickStepFromNumTicks(50, 6) // returns 10
   */
  tickStepFromNumTicks: function tickStepFromNumTicks(span, numTicks) {
    var step = Math.pow(10, Math.floor(Math.log(span / numTicks) / Math.LN10));
    var err = numTicks / span * step; // Filter ticks to get closer to the desired count.

    if (err <= 0.15) {
      step *= 10;
    } else if (err <= 0.35) {
      step *= 5;
    } else if (err <= 0.75) {
      step *= 2;
    } // Round start and stop values to step interval.


    return step;
  },

  /**
   * Constrain tick steps intended for desktop size graphs
   * to something more suitable for mobile size graphs.
   * Specifically, we aim for 10 or fewer ticks per graph axis.
   */
  constrainedTickStepsFromTickSteps: function constrainedTickStepsFromTickSteps(tickSteps, ranges) {
    var steps = [];

    for (var i = 0; i < 2; i++) {
      var span = ranges[i][1] - ranges[i][0];
      var numTicks = span / tickSteps[i];

      if (numTicks <= 10) {
        // Will displays fine on mobile
        steps[i] = tickSteps[i];
      } else if (numTicks <= 20) {
        // Will be crowded on mobile, so hide every other tick
        steps[i] = tickSteps[i] * 2;
      } else {
        // Fallback in case we somehow have more than 20 ticks
        // Note: This shouldn't happen due to GraphSettings.validStep
        steps[i] = Util$q.tickStepFromNumTicks(span, 10);
      }
    }

    return steps;
  },

  /**
   * Transparently update deprecated props so that the code to deal
   * with them only lives in one place: (Widget).deprecatedProps
   *
   * For example, if a boolean `foo` was deprecated in favor of a
   * number 'bar':
   *      deprecatedProps: {
   *          foo: function(props) {
   *              return {bar: props.foo ? 1 : 0};
   *          }
   *      }
   */
  DeprecationMixin: {
    // This lifecycle stage is only called before first render
    componentWillMount: function componentWillMount() {
      var newProps = {};

      _$1I.each(this.deprecatedProps, function (func, prop) {
        if (_$1I.has(this.props, prop)) {
          _$1I.extend(newProps, func(this.props));
        }
      }, this);

      if (!_$1I.isEmpty(newProps)) {
        // Set new props directly so that widget renders correctly
        // when it first mounts, even though these will be overwritten
        // almost immediately afterwards...
        _$1I.extend(this.props, newProps); // ...when we propagate the new props upwards and they come
        // back down again.


        setTimeout(this.props.onChange, 0, newProps);
      }
    }
  },

  /**
   * Approximate equality on numbers and primitives.
   */
  eq: function eq(x, y) {
    if (_$1I.isNumber(x) && _$1I.isNumber(y)) {
      return Math.abs(x - y) < 1e-9;
    } else {
      return x === y;
    }
  },

  /**
   * Deep approximate equality on primitives, numbers, arrays, and objects.
   */
  deepEq: function deepEq(x, y) {
    if (_$1I.isArray(x) && _$1I.isArray(y)) {
      if (x.length !== y.length) {
        return false;
      }

      for (var i = 0; i < x.length; i++) {
        if (!Util$q.deepEq(x[i], y[i])) {
          return false;
        }
      }

      return true;
    } else if (_$1I.isArray(x) || _$1I.isArray(y)) {
      return false;
    } else if (_$1I.isFunction(x) && _$1I.isFunction(y)) {
      return Util$q.eq(x, y);
    } else if (_$1I.isFunction(x) || _$1I.isFunction(y)) {
      return false;
    } else if (_$1I.isObject(x) && _$1I.isObject(y)) {
      return x === y || _$1I.all(x, function (v, k) {
        return Util$q.deepEq(y[k], v);
      }) && _$1I.all(y, function (v, k) {
        return Util$q.deepEq(x[k], v);
      });
    } else if (_$1I.isObject(x) || _$1I.isObject(y)) {
      return false;
    } else {
      return Util$q.eq(x, y);
    }
  },

  /**
   * Query String Parser
   *
   * Original from:
   * http://stackoverflow.com/questions/901115/get-querystring-values-in-javascript/2880929#2880929
   */
  parseQueryString: function parseQueryString(query) {
    query = query || window.location.search.substring(1);

    var urlParams = {},
        e,
        a = /\+/g,
        // Regex for replacing addition symbol with a space
    r = /([^&=]+)=?([^&]*)/g,
        d = function d(s) {
      return decodeURIComponent(s.replace(a, " "));
    };

    while (e = r.exec(query)) {
      urlParams[d(e[1])] = d(e[2]);
    }

    return urlParams;
  },

  /**
   * Query string adder
   * Works for URLs without #.
   * Original from:
   * http://stackoverflow.com/questions/5999118/add-or-update-query-string-parameter
   */
  updateQueryString: function updateQueryString(uri, key, value) {
    value = encodeURIComponent(value);
    var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
    var separator = uri.indexOf("?") !== -1 ? "&" : "?";

    if (uri.match(re)) {
      return uri.replace(re, "$1" + key + "=" + value + "$2");
    } else {
      return uri + separator + key + "=" + value;
    }
  },

  /**
   * A more strict encodeURIComponent that escapes `()'!`s
   * Especially useful for creating URLs that are embeddable in markdown
   *
   * Adapted from
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
   * This function and the above original available under the
   * CC-BY-SA 2.5 license.
   */
  strongEncodeURIComponent: function strongEncodeURIComponent(str) {
    return encodeURIComponent(str) // Note that although RFC3986 reserves "!", RFC5987 does not,
    // so we do not need to escape it
    .replace(/['()!]/g, window.escape) // i.e., %27 %28 %29
    .replace(/\*/g, "%2A");
  },
  // There are certain widgets where we don't want to provide the "answered"
  // highlight indicator.
  // The issue with just using the `graded` flag on questions is that showing
  // that a certain widget is ungraded can sometimes reveal the answer to a
  // question ("is this transformation possible? if so, do it")
  // This is kind of a hack to get around this.
  widgetShouldHighlight: function widgetShouldHighlight(widget) {
    if (!widget) {
      return false;
    }

    var HIGHLIGHT_BAR_BLACKLIST = ["measurer", "protractor"];
    return !_$1I.contains(HIGHLIGHT_BAR_BLACKLIST, widget.type);
  },

  /**
   * If a widget says that it is empty once it is graded.
   * Trying to encapsulate references to the score format.
   */
  scoreIsEmpty: function scoreIsEmpty(score) {
    // HACK(benkomalo): ugh. this isn't great; the Perseus score objects
    // overload the type "invalid" for what should probably be three
    // distinct cases:
    //  - truly empty or not fully filled out
    //  - invalid or malformed inputs
    //  - "almost correct" like inputs where the widget wants to give
    //  feedback (e.g. a fraction needs to be reduced, or `pi` should
    //  be used instead of 3.14)
    //
    //  Unfortunately the coercion happens all over the place, as these
    //  Perseus style score objects are created *everywhere* (basically
    //  in every widget), so it's hard to change now. We assume that
    //  anything with a "message" is not truly empty, and one of the
    //  latter two cases for now.
    return score.type === "invalid" && (!score.message || score.message.length === 0);
  },

  /**
   * Extracts the location of a touch or mouse event, allowing you to pass
   * in a "mouseup", "mousedown", or "mousemove" event and receive the
   * correct coordinates. Shouldn't be used with "vmouse" events.
   *
   * The Util.touchHandlers are used to track the current state of the touch
   * event, such as whether or not the user is currently pressed down (either
   * through touch or mouse) on the screen.
   */
  touchHandlers: {
    pointerDown: false,
    currentTouchIdentifier: null
  },
  resetTouchHandlers: function resetTouchHandlers() {
    _$1I.extend(Util$q.touchHandlers, {
      pointerDown: false,
      currentTouchIdentifier: null
    });
  },
  extractPointerLocation: function extractPointerLocation(event) {
    var touchOrEvent;

    if (Util$q.touchHandlers.pointerDown) {
      // Look for the touch matching the one we're tracking; ignore others
      if (Util$q.touchHandlers.currentTouchIdentifier != null) {
        var len = event.changedTouches ? event.changedTouches.length : 0;

        for (var i = 0; i < len; i++) {
          if (event.changedTouches[i].identifier === Util$q.touchHandlers.currentTouchIdentifier) {
            touchOrEvent = event.changedTouches[i];
          }
        }
      } else {
        touchOrEvent = event;
      }

      var isEndish = event.type === "touchend" || event.type === "touchcancel";

      if (touchOrEvent && isEndish) {
        Util$q.touchHandlers.pointerDown = false;
        Util$q.touchHandlers.currentTouchIdentifier = null;
      }
    } else {
      // touchstart or mousedown
      Util$q.touchHandlers.pointerDown = true;

      if (event.changedTouches) {
        touchOrEvent = event.changedTouches[0];
        Util$q.touchHandlers.currentTouchIdentifier = touchOrEvent.identifier;
      } else {
        touchOrEvent = event;
      }
    }

    if (touchOrEvent) {
      return {
        left: touchOrEvent.pageX,
        top: touchOrEvent.pageY
      };
    }
  },

  /**
   * Pass this function as the touchstart for an element to
   * avoid sending the touch to the mobile scratchpad
   */
  captureScratchpadTouchStart: function captureScratchpadTouchStart(e) {
    e.stopPropagation();
  },
  getImageSize: function getImageSize(url, callback) {
    var img = new Image();

    img.onload = function () {
      // IE 11 seems to have problems calculating the heights of svgs
      // if they're not in the DOM. To solve this, we add the element to
      // the dom, wait for a rerender, and use `.clientWidth` and
      // `.clientHeight`. I think we could also solve the problem by
      // adding the image to the document before setting the src, but then
      // the experience would be worse for other browsers.
      if (img.width === 0 && img.height === 0) {
        document.body.appendChild(img);

        _$1I.defer(function () {
          callback(img.clientWidth, img.clientHeight);
          document.body.removeChild(img);
        });
      } else {
        callback(img.width, img.height);
      }
    };

    img.src = getRealImageUrl(url);
  },
  textarea: {
    /**
     * Gets the word right before where the textarea cursor is
     *
     * @param {Element} textarea - The textarea DOM element
     * @return {JSON} - An object with the word and its starting and ending positions in the textarea
     */
    getWordBeforeCursor: function getWordBeforeCursor(textarea) {
      var text = textarea.value;
      var endPos = textarea.selectionStart - 1;
      var startPos = Math.max(text.lastIndexOf("\n", endPos), text.lastIndexOf(" ", endPos)) + 1;
      return {
        string: text.substring(startPos, endPos + 1),
        pos: {
          start: startPos,
          end: endPos
        }
      };
    },

    /**
     * Moves the textarea cursor at the specified position
     *
     * @param {Element} textarea - The textarea DOM element
     * @param {int} pos - The position where the cursor will be moved
     */
    moveCursor: function moveCursor(textarea, pos) {
      textarea.selectionStart = pos;
      textarea.selectionEnd = pos;
    }
  }
};
Util$q.random = Util$q.seededRNG(new Date().getTime() & 0xffffffff);

/**
 * This is a TreeMapper that only has mappers specified for its leaf nodes; its
 * array mapper is the identity function.
 *
 * This is the TreeMapper initially returned by `buildMapper`. It allows you to
 * change the types of your ContentMapper and HintMapper, which is safe because
 * none of the other mappers that depend on those types (aka ArrayMapper) have
 * been specified yet. (Or, more specifically, the ArrayMapper is currently
 * `identity`, which can trivially vary with the ContentMapper and HintMapper's
 * types.)
 *
 * Once you call `setArrayMapper`, however, we move to the other class:
 * TreeMapperForLeavesAndCollections.
 */

class TreeMapperJustForLeaves {
  constructor(content, hint, tags) {
    this.content = content;
    this.hint = hint;
    this.tags = tags;
    this.array = identity;
  }

  setContentMapper(newContentMapper) {
    return new TreeMapperJustForLeaves(newContentMapper, this.hint, this.tags);
  }

  setHintMapper(newHintMapper) {
    return new TreeMapperJustForLeaves(this.content, newHintMapper, this.tags);
  }

  setTagsMapper(newTagsMapper) {
    return new TreeMapperJustForLeaves(this.content, this.hint, newTagsMapper);
  }

  setArrayMapper(newArrayMapper) {
    return new TreeMapperForLeavesAndCollections(this.content, this.hint, this.tags, newArrayMapper);
  }

  mapTree(tree, shape) {
    return mapTree(tree, shape, [], this);
  }

}
/**
 * This is a TreeMapper that already has an ArrayMapper specified, so its
 * ContentMapper and HintMapper are now locked in.
 */


class TreeMapperForLeavesAndCollections {
  constructor(content, hint, tags, array) {
    this.content = content;
    this.hint = hint;
    this.tags = tags;
    this.array = array;
  }

  setArrayMapper(newArrayMapper) {
    return new TreeMapperForLeavesAndCollections(this.content, this.hint, this.tags, newArrayMapper);
  }

  mapTree(tree, shape) {
    return mapTree(tree, shape, [], this);
  }

}

function identity(x) {
  return x;
}
/**
 * Return a new TreeMapper that will perform a no-op transformation on an input
 * tree. To make it useful, chain any combination of `setContentMapper`,
 * `setHintMapper`, `setTagMapper`, and `setArrayMapper` to specify
 * transformations for the individual node types.
 */


function buildMapper() {
  return new TreeMapperJustForLeaves(identity, identity, identity);
}
/**
 * Copy the given tree, apply the corresponding transformation specified in the
 * TreeMapper to each node, and return the resulting tree.
 */

function mapTree(tree, shape, path, mappers) {
  // We trust the shape of the multi-item to match the shape provided at
  // runtime. Therefore, in each shape branch, we cast the node to `any` and
  // reinterpret it as the expected node type.
  if (shape.type === "content") {
    var content = tree;
    return mappers.content(content, shape, path);
  } else if (shape.type === "hint") {
    var hint = tree;
    return mappers.hint(hint, shape, path);
  } else if (shape.type === "tags") {
    var tags = tree;
    return mappers.tags(tags, shape, path);
  } else if (shape.type === "array") {
    var array = tree;

    if (!Array.isArray(array)) {
      throw new Error("Invalid object of type \"".concat(typeof array, "\" found at path ") + "".concat(["<root>"].concat(path).join("."), ". Expected array."));
    }

    var elementShape = shape.elementShape;
    var mappedElements = array.map((inner, i) => mapTree(inner, elementShape, path.concat(i), mappers));
    return mappers.array(mappedElements, array, shape, path);
  } else if (shape.type === "object") {
    var object = tree;

    if (object && typeof object !== "object") {
      throw new Error("Invalid object of type \"".concat(typeof object, "\" found at ") + "path ".concat(["<root>"].concat(path).join("."), ". Expected ") + "\"object\" type.");
    }

    var valueShapes = shape.shape;

    if (!valueShapes) {
      throw new Error("Unexpected shape ".concat(JSON.stringify(shape), " at path ") + "".concat(["<root>"].concat(path).join("."), "."));
    }

    var newObject = {};
    Object.keys(valueShapes).forEach(key => {
      if (!(key in object)) {
        throw new Error("Key \"".concat(key, "\" is missing from shape at path ") + "".concat(["<root>"].concat(path).join("."), "."));
      }

      newObject[key] = mapTree(object[key], valueShapes[key], path.concat(key), mappers);
    });
    return newObject;
  } else {
    throw new Error("unexpected shape type ".concat(shape.type));
  }
}

/**
 * A work-in-progress of _ methods for objects.
 * That is, they take an object as a parameter,
 * and return an object instead of an array.
 *
 * TODO(aria): Move this out of interactive2
 */

var _$1H = _underscore__default["default"];
/**
 * Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */

var pluck = function pluck(table, subKey) {
  return _$1H.object(_$1H.map(table, function (value, key) {
    return [key, value[subKey]];
  }));
};
/**
 * Maps an object to an object
 *
 * > mapObject({a: '1', b: '2'}, (value, key) => {
 *       return value + 1;
 *   });
 * {a: 2, b: 3}
 */

var mapObject = function mapObject(obj, lambda) {
  var result = {};

  _$1H.each(_$1H.keys(obj), function (key) {
    result[key] = lambda(obj[key], key);
  });

  return result;
};
/**
 * Maps an array to an object
 *
 * > mapObjectFromArray(['a', 'b'], function(elem) {
 *       return elem + elem;
 *   });
 * {a: 'aa', b: 'bb'}
 */

var mapObjectFromArray = function mapObjectFromArray(arr, lambda) {
  var result = {};

  _$1H.each(arr, function (elem) {
    result[elem] = lambda(elem);
  });

  return result;
};
var _objective_Js = {
  pluck: pluck,
  mapObject: mapObject,
  mapObjectFromArray: mapObjectFromArray
};

var linterContextProps = PropTypes.shape({
  contentType: PropTypes.string,
  highlightLint: PropTypes.bool,
  paths: PropTypes.arrayOf(PropTypes.string),
  stack: PropTypes.arrayOf(PropTypes.string)
});
var linterContextDefault = {
  contentType: '',
  highlightLint: false,
  paths: [],
  stack: []
};

/**
 * This is the base class for all Selector types. The key method that all
 * selector subclasses must implement is match(). It takes a TraversalState
 * object (from a TreeTransformer traversal) and tests whether the selector
 * matches at the current node. See the comment at the start of this file for
 * more details on the match() method.
 */
class Selector {
  static parse(selectorText) {
    return new Parser(selectorText).parse();
  }
  /**
   * Return an array of the nodes that matched or null if no match.
   * This is the base class so we just throw an exception. All Selector
   * subclasses must provide an implementation of this method.
   */


  match(state) {
    throw new Error("Selector subclasses must implement match()");
  }
  /**
   * Selector subclasses all define a toString() method primarily
   * because it makes it easy to write parser tests.
   */


  toString() {
    return "Unknown selector class";
  }

}
/**
 * This class implements a parser for the selector grammar. Pass the source
 * text to the Parser() constructor, and then call the parse() method to
 * obtain a corresponding Selector object. parse() throws an exception
 * if there are syntax errors in the selector.
 *
 * This class is not exported, and you don't need to use it directly.
 * Instead call the static Selector.parse() method.
 */

class Parser {
  constructor(s) {
    // Normalize whitespace:
    // - remove leading and trailing whitespace
    // - replace runs of whitespace with single space characters
    s = s.trim().replace(/\s+/g, " "); // Convert the string to an array of tokens. Note that the TOKENS
    // pattern ignores spaces that do not appear before identifiers
    // or the * wildcard.

    this.tokens = s.match(Parser.TOKENS) || [];
    this.tokenIndex = 0;
  } // Return the next token or the empty string if there are no more


  nextToken() {
    return this.tokens[this.tokenIndex] || "";
  } // Increment the token index to "consume" the token we were looking at
  // and move on to the next one.


  consume() {
    this.tokenIndex++;
  } // Return true if the current token is an identifier or false otherwise


  isIdentifier() {
    // The Parser.TOKENS regexp ensures that we only have to check
    // the first character of a token to know what kind of token it is.
    var c = this.tokens[this.tokenIndex][0];
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
  } // Consume space tokens until the next token is not a space.


  skipSpace() {
    while (this.nextToken() === " ") {
      this.consume();
    }
  } // Parse a comma-separated sequence of tree selectors. This is the
  // entry point for the Parser class and the only method that clients
  // ever need to call.


  parse() {
    // We expect at least one tree selector
    var ts = this.parseTreeSelector(); // Now see what's next

    var token = this.nextToken(); // If there is no next token then we're done parsing and can return
    // the tree selector object we got above

    if (!token) {
      return ts;
    } // Otherwise, there is more go come and we're going to need a
    // list of tree selectors


    var treeSelectors = [ts];

    while (token) {
      // The only character we allow after a tree selector is a comma
      if (token === ",") {
        this.consume();
      } else {
        throw new ParseError$2("Expected comma");
      } // And if we saw a comma, then it must be followed by another
      // tree selector


      treeSelectors.push(this.parseTreeSelector());
      token = this.nextToken();
    } // If we parsed more than one tree selector, return them in a
    // SelectorList object.


    return new SelectorList(treeSelectors);
  } // Parse a sequence of node selectors linked together with
  // hierarchy combinators: space, >, + and ~.


  parseTreeSelector() {
    this.skipSpace(); // Ignore space after a comma, for example
    // A tree selector must begin with a node selector

    var ns = this.parseNodeSelector();

    for (;;) {
      // Now check the next token. If there is none, or if it is a
      // comma, then we're done with the treeSelector. Otherwise
      // we expect a combinator followed by another node selector.
      // If we don't see a combinator, we throw an error. If we
      // do see a combinator and another node selector then we
      // combine the current node selector with the new node selector
      // using a Selector subclass that depends on the combinator.
      var token = this.nextToken();

      if (!token || token === ",") {
        break;
      } else if (token === " ") {
        this.consume();
        ns = new AncestorCombinator(ns, this.parseNodeSelector());
      } else if (token === ">") {
        this.consume();
        ns = new ParentCombinator(ns, this.parseNodeSelector());
      } else if (token === "+") {
        this.consume();
        ns = new PreviousCombinator(ns, this.parseNodeSelector());
      } else if (token === "~") {
        this.consume();
        ns = new SiblingCombinator(ns, this.parseNodeSelector());
      } else {
        throw new ParseError$2("Unexpected token: " + token);
      }
    }

    return ns;
  } // Parse a single node selector.
  // For now, this is just a node type or a wildcard.
  //
  // TODO(davidflanagan): we may need to extend this with attribute
  // selectors like 'heading[level=3]', or with pseudo-classes like
  // paragraph:first-child


  parseNodeSelector() {
    // First, skip any whitespace
    this.skipSpace();
    var t = this.nextToken();

    if (t === "*") {
      this.consume();
      return new AnyNode();
    } else if (this.isIdentifier()) {
      this.consume();
      return new TypeSelector(t);
    }

    throw new ParseError$2("Expected node type");
  }

} // We break the input string into tokens with this regexp. Token types
// are identifiers, integers, punctuation and spaces. Note that spaces
// tokens are only returned when they appear before an identifier or
// wildcard token and are otherwise omitted.


Parser.TOKENS = /([a-zA-Z][\w-]*)|(\d+)|[^\s]|(\s(?=[a-zA-Z\*]))/g;
/**
 * This is a trivial Error subclass that the Parser uses to signal parse errors
 */

class ParseError$2 extends Error {
  constructor(message) {
    super(message);
  }

}
/**
 * This Selector subclass is a list of selectors. It matches a node if any of
 * the selectors on the list matches the node. It considers the selectors in
 * order, and returns the array of nodes returned by whichever one matches
 * first.
 */


class SelectorList extends Selector {
  constructor(selectors) {
    super();
    this.selectors = selectors;
  }

  match(state) {
    for (var i = 0; i < this.selectors.length; i++) {
      var s = this.selectors[i];
      var result = s.match(state);

      if (result) {
        return result;
      }
    }

    return null;
  }

  toString() {
    var result = "";

    for (var i = 0; i < this.selectors.length; i++) {
      result += i > 0 ? ", " : "";
      result += this.selectors[i].toString();
    }

    return result;
  }

}
/**
 * This trivial Selector subclass implements the '*' wildcard and
 * matches any node.
 */


class AnyNode extends Selector {
  match(state) {
    return [state.currentNode()];
  }

  toString() {
    return "*";
  }

}
/**
 * This selector subclass implements the <IDENTIFIER> part of the grammar.
 * it matches any node whose `type` property is a specified string
 */


class TypeSelector extends Selector {
  constructor(type) {
    super();
    this.type = type;
  }

  match(state) {
    var node = state.currentNode();

    if (node.type === this.type) {
      return [node];
    } else {
      return null;
    }
  }

  toString() {
    return this.type;
  }

}
/**
 * This selector subclass is the superclass of the classes that implement
 * matching for the four combinators. It defines left and right properties for
 * the two selectors that are to be combined, but does not define a match
 * method.
 */


class SelectorCombinator extends Selector {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
  }

}
/**
 * This Selector subclass implements the space combinator. It matches if the
 * right selector matches the current node and the left selector matches some
 * ancestor of the current node.
 */


class AncestorCombinator extends SelectorCombinator {
  constructor(left, right) {
    super(left, right);
  }

  match(state) {
    var rightResult = this.right.match(state);

    if (rightResult) {
      state = state.clone();

      while (state.hasParent()) {
        state.goToParent();
        var leftResult = this.left.match(state);

        if (leftResult) {
          return leftResult.concat(rightResult);
        }
      }
    }

    return null;
  }

  toString() {
    return this.left.toString() + " " + this.right.toString();
  }

}
/**
 * This Selector subclass implements the > combinator. It matches if the
 * right selector matches the current node and the left selector matches
 * the parent of the current node.
 */


class ParentCombinator extends SelectorCombinator {
  constructor(left, right) {
    super(left, right);
  }

  match(state) {
    var rightResult = this.right.match(state);

    if (rightResult) {
      if (state.hasParent()) {
        state = state.clone();
        state.goToParent();
        var leftResult = this.left.match(state);

        if (leftResult) {
          return leftResult.concat(rightResult);
        }
      }
    }

    return null;
  }

  toString() {
    return this.left.toString() + " > " + this.right.toString();
  }

}
/**
 * This Selector subclass implements the + combinator. It matches if the
 * right selector matches the current node and the left selector matches
 * the immediate previous sibling of the current node.
 */


class PreviousCombinator extends SelectorCombinator {
  constructor(left, right) {
    super(left, right);
  }

  match(state) {
    var rightResult = this.right.match(state);

    if (rightResult) {
      if (state.hasPreviousSibling()) {
        state = state.clone();
        state.goToPreviousSibling();
        var leftResult = this.left.match(state);

        if (leftResult) {
          return leftResult.concat(rightResult);
        }
      }
    }

    return null;
  }

  toString() {
    return this.left.toString() + " + " + this.right.toString();
  }

}
/**
 * This Selector subclass implements the ~ combinator. It matches if the
 * right selector matches the current node and the left selector matches
 * any previous sibling of the current node.
 */


class SiblingCombinator extends SelectorCombinator {
  constructor(left, right) {
    super(left, right);
  }

  match(state) {
    var rightResult = this.right.match(state);

    if (rightResult) {
      state = state.clone();

      while (state.hasPreviousSibling()) {
        state.goToPreviousSibling();
        var leftResult = this.left.match(state);

        if (leftResult) {
          return leftResult.concat(rightResult);
        }
      }
    }

    return null;
  }

  toString() {
    return this.left.toString() + " ~ " + this.right.toString();
  }

}

/**
 * A Rule object describes a Gorgon lint rule. See the comment at the top of
 * this file for detailed description.
 */

class Rule {
  // The comment at the top of this file has detailed docs for
  // this constructor and its arguments
  constructor(name, severity, selector, pattern, lint, applies) {
    if (!selector && !pattern) {
      throw new Error("Lint rules must have a selector or pattern");
    }

    this.name = name || "unnamed rule";
    this.severity = severity || Rule.Severity.BULK_WARNING;
    this.selector = selector || Rule.DEFAULT_SELECTOR;
    this.pattern = pattern || null; // If we're called with an error message instead of a function then
    // use a default function that will return the message.

    if (typeof lint === "function") {
      this.lint = lint;
      this.message = null;
    } else {
      this.lint = this._defaultLintFunction;
      this.message = lint;
    }

    this.applies = applies || function () {
      return true;
    };
  } // A factory method for use with rules described in JSON files
  // See the documentation at the start of this file for details.


  static makeRule(options) {
    return new Rule(options.name, options.severity, options.selector ? Selector.parse(options.selector) : null, Rule.makePattern(options.pattern), options.lint || options.message, options.applies);
  } // Check the node n to see if it violates this lint rule.  A return value
  // of false means there is no lint.  A returned object indicates a lint
  // error. See the documentation at the top of this file for details.


  check(node, traversalState, content, context) {
    // First, see if we match the selector.
    // If no selector was passed to the constructor, we use a
    // default selector that matches text nodes.
    var selectorMatch = this.selector.match(traversalState); // If the selector did not match, then we're done

    if (!selectorMatch) {
      return null;
    } // If the selector matched, then see if the pattern matches


    var patternMatch;

    if (this.pattern) {
      patternMatch = content.match(this.pattern);
    } else {
      // If there is no pattern, then just match all of the content.
      // Use a fake RegExp match object to represent this default match.
      patternMatch = Rule.FakePatternMatch(content, content, 0);
    } // If there was a pattern and it didn't match, then we're done


    if (!patternMatch) {
      return null;
    }

    try {
      // If we get here, then the selector and pattern have matched
      // so now we call the lint function to see if there is lint.
      var error = this.lint(traversalState, content, selectorMatch, patternMatch, context);

      if (!error) {
        return null; // No lint; we're done
      } else if (typeof error === "string") {
        // If the lint function returned a string we assume it
        // applies to the entire content of the node and return it.
        return {
          rule: this.name,
          severity: this.severity,
          message: error,
          start: 0,
          end: content.length
        };
      } else {
        // If the lint function returned an object, then we just
        // add the rule name to the message, start and end.
        return {
          rule: this.name,
          severity: this.severity,
          message: error.message,
          start: error.start,
          end: error.end
        };
      }
    } catch (e) {
      // If the lint function threw an exception we handle that as
      // a special type of lint. We want the user to see the lint
      // warning in this case (even though it is out of their control)
      // so that the bug gets reported. Otherwise we'd never know that
      // a rule was failing.
      return {
        rule: "lint-rule-failure",
        message: "Exception in rule ".concat(this.name, ": ").concat(e.message, "\nStack trace:\n").concat(e.stack),
        start: 0,
        end: content.length
      };
    }
  } // This internal method is the default lint function that we use when a
  // rule is defined without a function. This is useful for rules where the
  // selector and/or pattern match are enough to indicate lint. This
  // function unconditionally returns the error message that was passed in
  // place of a function, but also adds start and end properties that
  // specify which particular portion of the node content matched the
  // pattern.


  _defaultLintFunction(state, content, selectorMatch, patternMatch) {
    return {
      message: this.message || "",
      start: patternMatch.index,
      end: patternMatch.index + patternMatch[0].length
    };
  } // The makeRule() factory function uses this static method to turn its
  // argument into a RegExp. If the argument is already a RegExp, we just
  // return it. Otherwise, we compile it into a RegExp and return that.
  // The reason this is necessary is that Rule.makeRule() is designed for
  // use with data from JSON files and JSON files can't include RegExp
  // literals. Strings passed to this function do not need to be delimited
  // with / characters unless you want to include flags for the RegExp.
  //
  // Examples:
  //
  //   input ""        ==> output null
  //   input /foo/     ==> output /foo/
  //   input "foo"     ==> output /foo/
  //   input "/foo/i"  ==> output /foo/i
  //


  static makePattern(pattern) {
    if (!pattern) {
      return null;
    } else if (pattern instanceof RegExp) {
      return pattern;
    } else if (pattern[0] === "/") {
      var lastSlash = pattern.lastIndexOf("/");
      var expression = pattern.substring(1, lastSlash);
      var flags = pattern.substring(lastSlash + 1);
      return new RegExp(expression, flags);
    } else {
      return new RegExp(pattern);
    }
  } // This static method returns an string array with index and input
  // properties added, in order to simulate the return value of the
  // String.match() method. We use it when a Rule has no pattern and we
  // want to simulate a match on the entire content string.


  static FakePatternMatch(input, match, index) {
    var result = [match];
    result.index = index;
    result.input = input;
    return result;
  }

}

_defineProperty(Rule, "Severity", {
  ERROR: 1,
  WARNING: 2,
  GUIDELINE: 3,
  BULK_WARNING: 4
});

Rule.DEFAULT_SELECTOR = Selector.parse("text");

var _module_$37 = {
  exports: {}
};
// can't match specific widget types directly, this rule implements
// a number of image widget related rules in one place. This should
// slightly increase efficiency, but it means that if there is more
// than one problem with an image widget, the user will only see one
// problem at a time.

_module_$37.exports = Rule.makeRule({
  name: "image-widget",
  severity: Rule.Severity.BULK_WARNING,
  selector: "widget",
  lint: function lint(state, content, nodes, match, context) {
    // This rule only looks at image widgets
    if (state.currentNode().widgetType !== "image") {
      return;
    } // If it can't find a definition for the widget it does nothing


    var widget = context && context.widgets && context.widgets[state.currentNode().id];

    if (!widget) {
      return;
    } // Make sure there is alt text


    var alt = widget.options.alt;

    if (!alt) {
      return "Images should have alt text:\nfor accessibility, all images should have a text description.\nAdd a description in the \"Alt Text\" box of the image widget.";
    } // Make sure the alt text it is not trivial


    if (alt.trim().length < 8) {
      return "Images should have alt text:\nfor accessibility, all images should have descriptive alt text.\nThis image's alt text is only ".concat(alt.trim().length, " characters long.");
    } // Make sure there is no math in the caption


    if (widget.options.caption && widget.options.caption.match(/[^\\]\$/)) {
      return "No math in image captions:\nDon't include math expressions in image captions.";
    }
  }
});
var _imageWidgetJs = _module_$37.exports;

var _module_$36 = {
  exports: {}
};
_module_$36.exports = Rule.makeRule({
  name: "image-spaces-around-urls",
  severity: Rule.Severity.ERROR,
  selector: "image",
  lint: function lint(state, content, nodes, match, context) {
    var image = nodes[0];
    var url = image.target; // The markdown parser strips leading and trailing spaces for us,
    // but they're still a problem for our translation process, so
    // we need to go check for them in the unparsed source string
    // if we have it.

    if (context && context.content) {
      // Find the url in the original content and make sure that the
      // character before is '(' and the character after is ')'
      var index = context.content.indexOf(url);

      if (index === -1) {
        // It is not an error if we didn't find it.
        return;
      }

      if (context.content[index - 1] !== "(" || context.content[index + url.length] !== ")") {
        return "Whitespace before or after image url:\nFor images, don't include any space or newlines after '(' or before ')'.\nWhitespace in image URLs causes translation difficulties.";
      }
    }
  }
});
var _imageSpacesAroundUrlsJs = _module_$36.exports;

var _module_$35 = {
  exports: {}
};
// Math and code hold their content directly and do not have text nodes
// beneath them (unlike the HTML DOM) so this rule automatically does not
// apply inside $$ or ``.

_module_$35.exports = Rule.makeRule({
  name: "unbalanced-code-delimiters",
  severity: Rule.Severity.ERROR,
  pattern: /[`~]+/,
  message: "Unbalanced code delimiters:\ncode blocks should begin and end with the same type and number of delimiters"
});
var _unbalancedCodeDelimitersJs = _module_$35.exports;

var _module_$34 = {
  exports: {}
};
// Math and code hold their content directly and do not have text nodes
// beneath them (unlike the HTML DOM) so this rule automatically does not
// apply inside $$ or ``.

_module_$34.exports = Rule.makeRule({
  name: "math-without-dollars",
  severity: Rule.Severity.GUIDELINE,
  pattern: /\\\w+{[^}]*}|{|}/,
  message: "This looks like LaTeX:\ndid you mean to put it inside dollar signs?"
});
var _mathWithoutDollarsJs = _module_$34.exports;

var _module_$33 = {
  exports: {}
};
_module_$33.exports = Rule.makeRule({
  name: "profanity",
  // This list could obviously be expanded a lot, but I figured we
  // could start with https://en.wikipedia.org/wiki/Seven_dirty_words
  pattern: /\b(shit|piss|fuck|cunt|cocksucker|motherfucker|tits)\b/i,
  message: "Avoid profanity"
});
var _profanityJs = _module_$33.exports;

var _module_$32 = {
  exports: {}
};
_module_$32.exports = Rule.makeRule({
  name: "widget-in-table",
  severity: Rule.Severity.BULK_WARNING,
  selector: "table widget",
  message: "Widget in table:\ndo not put widgets inside of tables."
});
var _widgetInTableJs = _module_$32.exports;

var _module_$31 = {
  exports: {}
};
_module_$31.exports = Rule.makeRule({
  name: "unescaped-dollar",
  severity: Rule.Severity.ERROR,
  selector: "unescapedDollar",
  message: "Unescaped dollar sign:\nDollar signs must appear in pairs or be escaped as \\$"
});
var _unescapedDollarJs = _module_$31.exports;

var _module_$30 = {
  exports: {}
};
_module_$30.exports = Rule.makeRule({
  name: "table-missing-cells",
  severity: Rule.Severity.WARNING,
  selector: "table",
  lint: function lint(state, content, nodes, match) {
    var table = nodes[0];
    var headerLength = table.header.length;
    var rowLengths = table.cells.map(r => r.length);

    for (var r = 0; r < rowLengths.length; r++) {
      if (rowLengths[r] !== headerLength) {
        return "Table rows don't match header:\nThe table header has ".concat(headerLength, " cells, but\nRow ").concat(r + 1, " has ").concat(rowLengths[r], " cells.");
      }
    }
  }
});
var _tableMissingCellsJs = _module_$30.exports;

var _module_$2$ = {
  exports: {}
};
_module_$2$.exports = Rule.makeRule({
  name: "nested-lists",
  severity: Rule.Severity.WARNING,
  selector: "list list",
  message: "Nested lists:\nnested lists are hard to read on mobile devices;\ndo not use additional indentation."
});
var _nestedListsJs = _module_$2$.exports;

var _module_$2_ = {
  exports: {}
};
_module_$2_.exports = Rule.makeRule({
  name: "math-text-empty",
  severity: Rule.Severity.WARNING,
  selector: "math, blockMath",
  pattern: /\\text{\s*}/,
  message: "Empty \\text{} block in math expression"
});
var _mathTextEmptyJs = _module_$2_.exports;

var _module_$2Z = {
  exports: {}
};
_module_$2Z.exports = Rule.makeRule({
  name: "math-starts-with-space",
  severity: Rule.Severity.GUIDELINE,
  selector: "math, blockMath",
  pattern: /^\s*(~|\\qquad|\\quad|\\,|\\;|\\:|\\ |\\!|\\enspace|\\phantom)/,
  message: "Math starts with space:\nmath should not be indented. Do not begin math expressions with\nLaTeX space commands like ~, \\;, \\quad, or \\phantom"
});
var _mathStartsWithSpaceJs = _module_$2Z.exports;

var _module_$2Y = {
  exports: {}
};
_module_$2Y.exports = Rule.makeRule({
  name: "math-nested",
  severity: Rule.Severity.ERROR,
  selector: "math, blockMath",
  pattern: /\\text{[^$}]*\$[^$}]*\$[^}]*}/,
  message: "Nested math:\nDon't nest math expressions inside \\text{} blocks"
});
var _mathNestedJs = _module_$2Y.exports;

var _module_$2X = {
  exports: {}
};
_module_$2X.exports = Rule.makeRule({
  name: "math-frac",
  severity: Rule.Severity.GUIDELINE,
  selector: "math, blockMath",
  pattern: /\\frac[ {]/,
  message: "Use \\dfrac instead of \\frac in your math expressions."
});
var _mathFracJs = _module_$2X.exports;

var _module_$2W = {
  exports: {}
};
_module_$2W.exports = Rule.makeRule({
  name: "math-font-size",
  severity: Rule.Severity.GUIDELINE,
  selector: "math, blockMath",
  // eslint-disable-next-line max-len
  pattern: /\\(tiny|Tiny|small|large|Large|LARGE|huge|Huge|scriptsize|normalsize)\s*{/,
  message: "Math font size:\nDon't change the default font size with \\Large{} or similar commands"
});
var _mathFontSizeJs = _module_$2W.exports;

var _module_$2V = {
  exports: {}
};
_module_$2V.exports = Rule.makeRule({
  name: "math-empty",
  severity: Rule.Severity.WARNING,
  selector: "math, blockMath",
  pattern: /^$/,
  message: "Empty math: don't use $$ in your markdown."
});
var _mathEmptyJs = _module_$2V.exports;

var _module_$2U = {
  exports: {}
};
_module_$2U.exports = Rule.makeRule({
  name: "math-align-linebreaks",
  severity: Rule.Severity.WARNING,
  selector: "blockMath",
  pattern: /\\begin{align}.*[^\\](\\{2,3}[^\\]|\\{5,}).*\\end{align}/,
  message: "Use four backslashes between lines of an align block"
});
var _mathAlignLinebreaksJs = _module_$2U.exports;

var _module_$2T = {
  exports: {}
};
_module_$2T.exports = Rule.makeRule({
  name: "math-align-extra-break",
  severity: Rule.Severity.WARNING,
  selector: "blockMath",
  pattern: /(\\{2,})\s*\\end{align}/,
  message: "Extra space at end of block:\nDon't end an align block with backslashes"
});
var _mathAlignExtraBreakJs = _module_$2T.exports;

var _module_$2S = {
  exports: {}
};
_module_$2S.exports = Rule.makeRule({
  name: "math-adjacent",
  severity: Rule.Severity.WARNING,
  selector: "blockMath+blockMath",
  message: "Adjacent math blocks:\ncombine the blocks between \\begin{align} and \\end{align}"
});
var _mathAdjacentJs = _module_$2S.exports;

var _module_$2R = {
  exports: {}
};
_module_$2R.exports = Rule.makeRule({
  name: "long-paragraph",
  severity: Rule.Severity.GUIDELINE,
  selector: "paragraph",
  pattern: /^.{501,}/,
  lint: function lint(state, content, nodes, match) {
    return "Paragraph too long:\nThis paragraph is ".concat(content.length, " characters long.\nShorten it to 500 characters or fewer.");
  }
});
var _longParagraphJs = _module_$2R.exports;

var _module_$2Q = {
  exports: {}
};
_module_$2Q.exports = Rule.makeRule({
  name: "link-click-here",
  severity: Rule.Severity.WARNING,
  selector: "link",
  pattern: /click here/i,
  message: "Inappropriate link text:\nDo not use the words \"click here\" in links."
});
var _linkClickHereJs = _module_$2Q.exports;

var _module_$2P = {
  exports: {}
};
_module_$2P.exports = Rule.makeRule({
  name: "image-in-table",
  severity: Rule.Severity.BULK_WARNING,
  selector: "table image",
  message: "Image in table:\ndo not put images inside of tables."
});
var _imageInTableJs = _module_$2P.exports;

var _module_$2O = {
  exports: {}
};
_module_$2O.exports = Rule.makeRule({
  name: "image-alt-text",
  severity: Rule.Severity.BULK_WARNING,
  selector: "image",
  lint: function lint(state, content, nodes, match) {
    var image = nodes[0];

    if (!image.alt || !image.alt.trim()) {
      return "Images should have alt text:\nfor accessibility, all images should have alt text.\nSpecify alt text inside square brackets after the !.";
    } else if (image.alt.length < 8) {
      return "Images should have alt text:\nfor accessibility, all images should have descriptive alt text.\nThis image's alt text is only ".concat(image.alt.length, " characters long.");
    }
  }
});
var _imageAltTextJs = _module_$2O.exports;

var _module_$2N = {
  exports: {}
};
// capitalized even in a title-case heading.  See
// http://blog.apastyle.org/apastyle/2012/03/title-case-and-sentence-case-capitalization-in-apa-style.html

var littleWords = {
  and: true,
  nor: true,
  but: true,
  the: true,
  for: true
};

function isCapitalized(word) {
  var c = word[0];
  return c === c.toUpperCase();
}

_module_$2N.exports = Rule.makeRule({
  name: "heading-title-case",
  severity: Rule.Severity.GUIDELINE,
  selector: "heading",
  pattern: /[^\s:]\s+[A-Z]+[a-z]/,
  locale: "en",
  lint: function lint(state, content, nodes, match) {
    // We want to assert that heading text is in sentence case, not
    // title case. The pattern above requires a capital letter at the
    // start of the heading and allows them after a colon, or in
    // acronyms that are all capitalized.
    //
    // But we can't warn just because the pattern matched because
    // proper nouns are also allowed bo be capitalized. We're not
    // going to do dictionary lookup to check for proper nouns, so
    // we try a heuristic: if the title is more than 3 words long
    // and if all the words are capitalized or are on the list of
    // words that don't get capitalized, then we'll assume that
    // the heading is incorrectly in title case and will warn.
    // But if there is at least one non-capitalized long word then
    // we're not in title case and we should not warn.
    //
    // TODO(davidflanagan): if this rule causes a lot of false
    // positives, we should tweak it or remove it. Note that it will
    // fail for headings like "World War II in Russia"
    //
    // TODO(davidflanagan): This rule is specific to English.
    // It is marked with a locale property above, but that is NYI
    //
    // for APA style rules for title case
    var heading = content.trim();
    var words = heading.split(/\s+/); // Remove the first word and the little words

    words.shift();
    words = words.filter(w => w.length > 2 && !littleWords.hasOwnProperty(w)); // If there are at least 3 remaining words and all
    // are capitalized, then the heading is in title case.

    if (words.length >= 3 && words.every(w => isCapitalized(w))) {
      return "Title-case heading:\nThis heading appears to be in title-case, but should be sentence-case.\nOnly capitalize the first letter and proper nouns.";
    }
  }
});
var _headingTitleCaseJs = _module_$2N.exports;

var _module_$2M = {
  exports: {}
};
_module_$2M.exports = Rule.makeRule({
  name: "heading-sentence-case",
  severity: Rule.Severity.GUIDELINE,
  selector: "heading",
  pattern: /^\W*[a-z]/,
  // first letter is lowercase
  message: "First letter is lowercase:\nthe first letter of a heading should be capitalized."
});
var _headingSentenceCaseJs = _module_$2M.exports;

var _module_$2L = {
  exports: {}
};
_module_$2L.exports = Rule.makeRule({
  name: "heading-level-skip",
  severity: Rule.Severity.WARNING,
  selector: "heading ~ heading",
  lint: function lint(state, content, nodes, match) {
    var currentHeading = nodes[1];
    var previousHeading = nodes[0]; // A heading can have a level less than, the same as
    // or one more than the previous heading. But going up
    // by 2 or more levels is not right

    if (currentHeading.level > previousHeading.level + 1) {
      return "Skipped heading level:\nthis heading is level ".concat(currentHeading.level, " but\nthe previous heading was level ").concat(previousHeading.level);
    }
  }
});
var _headingLevelSkipJs = _module_$2L.exports;

var _module_$2K = {
  exports: {}
};
_module_$2K.exports = Rule.makeRule({
  name: "heading-level-1",
  severity: Rule.Severity.WARNING,
  selector: "heading",
  lint: function lint(state, content, nodes, match) {
    if (nodes[0].level === 1) {
      return "Don't use level-1 headings:\nBegin headings with two or more # characters.";
    }
  }
});
var _headingLevel1Js = _module_$2K.exports;

var _module_$2J = {
  exports: {}
};
_module_$2J.exports = Rule.makeRule({
  name: "extra-content-spacing",
  selector: "paragraph",
  pattern: /\s+$/,
  applies: function applies(context) {
    return context.contentType === 'article';
  },
  message: "No extra whitespace at the end of content blocks."
});
var _extraContentSpacingJs = _module_$2J.exports;

var _module_$2I = {
  exports: {}
};
_module_$2I.exports = Rule.makeRule({
  name: "double-spacing-after-terminal",
  severity: Rule.Severity.BULK_WARNING,
  selector: "paragraph",
  pattern: /[.!\?] {2}/i,
  message: "Use a single space after a sentence-ending period, or\nany other kind of terminal punctuation."
});
var _doubleSpacingAfterTerminalJs = _module_$2I.exports;

var _module_$2H = {
  exports: {}
};
_module_$2H.exports = Rule.makeRule({
  name: "blockquoted-widget",
  severity: Rule.Severity.WARNING,
  selector: "blockQuote widget",
  message: "Blockquoted widget:\nwidgets should not be indented."
});
var _blockquotedWidgetJs = _module_$2H.exports;

var _module_$2G = {
  exports: {}
};
_module_$2G.exports = Rule.makeRule({
  name: "blockquoted-math",
  severity: Rule.Severity.WARNING,
  selector: "blockQuote math, blockQuote blockMath",
  message: "Blockquoted math:\nmath should not be indented."
});
var _blockquotedMathJs = _module_$2G.exports;

// Return the portion of a URL between // and /. This is the authority
// portion which is usually just the hostname, but may also include
// a username, password or port. We don't strip those things out because
// we typically want to reject any URL that includes them
var HOSTNAME = /\/\/([^\/]+)/; // Return the hostname of the URL, with any "www." prefix removed.
// If this is a relative URL with no hostname, return an empty string.

function getHostname(url) {
  if (!url) {
    return "";
  }

  var match = url.match(HOSTNAME);
  return match ? match[1] : "";
} // This list of domains that count as internal domains is from

var _module_$2F = {
  exports: {}
};
_module_$2F.exports = Rule.makeRule({
  name: "absolute-url",
  severity: Rule.Severity.GUIDELINE,
  selector: "link, image",
  lint: function lint(state, content, nodes, match) {
    var url = nodes[0].target;
    var hostname = getHostname(url);

    if (hostname === "khanacademy.org" || hostname.endsWith(".khanacademy.org")) {
      return "Don't use absolute URLs:\nWhen linking to KA content or images, omit the\nhttps://www.khanacademy.org URL prefix.\nUse a relative URL beginning with / instead.";
    }
  }
});
var _absoluteUrlJs = _module_$2F.exports;

var _module_$2E = {
  exports: {}
};
// This should probably be converted to use import and to export
// and object that maps rule names to rules. Also, maybe this should
// be an auto-generated file with a script that updates it any time
// we add a new rule?

_module_$2E.exports = [_absoluteUrlJs, _blockquotedMathJs, _blockquotedWidgetJs, _doubleSpacingAfterTerminalJs, _extraContentSpacingJs, _headingLevel1Js, _headingLevelSkipJs, _headingSentenceCaseJs, _headingTitleCaseJs, _imageAltTextJs, _imageInTableJs, _linkClickHereJs, _longParagraphJs, _mathAdjacentJs, _mathAlignExtraBreakJs, _mathAlignLinebreaksJs, _mathEmptyJs, _mathFontSizeJs, _mathFracJs, _mathNestedJs, _mathStartsWithSpaceJs, _mathTextEmptyJs, _nestedListsJs, _tableMissingCellsJs, _unescapedDollarJs, _widgetInTableJs, _profanityJs, _mathWithoutDollarsJs, _unbalancedCodeDelimitersJs, _imageSpacesAroundUrlsJs, _imageWidgetJs];
var _rulesAllRulesJs = _module_$2E.exports;

var _module_$2D = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types */

/**
 * A stripped version of Icon.jsx from webapp. Takes an SVG icon and renders it
 * inline like Font Awesome did.
 *
 * If you are looking for an icon that we've used before you should look in
 * webapp's `icon-paths.js` which is a reference file for all the SVG paths
 * that we've used. You'll need to copy the object from that file into
 * whichever file you're using the icon and explicitly pass it in to the
 * <InlineIcon/> React component.
 *
 * We assume that the viewBox is cropped and aligned to (0, 0), but icons can
 * be defined differently. At some point we might want to add these attributes
 * to `icon-paths.js`, but for now this is a fairly safe assumption.
 *
 * Sample usage:
 *
 *   const editIcon = {
 *      path: "M41.209 53.753l5.39 0l0 5.39l3.136 0l6.468-6.517-8.477-8.526-6.517 6.517l0 3.136zm33.173-34.937q-.882-.882-1.862.049l-19.6 19.6q-.931.98-.049 1.862t1.862-.049l19.6-19.6q.931-.98.049-1.862zm-38.563 45.668l0-16.121l37.632-37.632 16.17 16.121-37.632 37.632l-16.17 0zm43.022-12.397l0 10.633q-.049 6.713-4.753 11.417t-11.368 4.704l-46.599 0q-6.713 0-11.417-4.753t-4.704-11.368l0-46.599q0-6.664 4.753-11.417t11.368-4.704l46.599 0q3.528 0 6.566 1.372.833.392.98 1.323t-.49 1.617l-2.744 2.744q-.784.784-1.96.441t-2.352-.343l-46.599 0q-3.675 0-6.321 2.646t-2.646 6.321l0 46.599q0 3.675 2.646 6.321t6.321 2.646l46.599 0q3.675 0 6.321-2.646t2.646-6.321l0-7.056q0-.735.49-1.225l3.577-3.577q.833-.833 1.96-.392t1.127 1.617zm7.203-51.646q2.254 0 3.773 1.568l8.526 8.526q1.568 1.568 1.568 3.822t-1.568 3.773l-5.145 5.145-16.121-16.121 5.145-5.145q1.568-1.568 3.822-1.568z", // @Nolint
 *      width: 100,
 *      height: 78.912,
 *   };
 *   <InlineIcon {...editIcon} />
 *
 */

var React$2e = _react__default["default"];

var InlineIcon$k = _ref => {
  var {
    path,
    width,
    height,
    style = {},
    title
  } = _ref;
  return /*#__PURE__*/React$2e.createElement("svg", {
    role: "img",
    "aria-hidden": !title,
    style: _objectSpread2({
      verticalAlign: "middle"
    }, style),
    width: "".concat(width / height, "em"),
    height: "1em",
    viewBox: "0 0 ".concat(width, " ").concat(height)
  }, !!title && /*#__PURE__*/React$2e.createElement("title", null, title), /*#__PURE__*/React$2e.createElement("path", {
    d: path,
    fill: "currentColor"
  }));
};

InlineIcon$k.propTypes = {
  // An SVG path to render.
  path: PropTypes.string.isRequired,
  // The path's viewBox dimensions.
  // We set the viewport height to 1em and scale the width accordingly.
  height: PropTypes.number.isRequired,
  width: PropTypes.number.isRequired,
  style: PropTypes.object,
  // A11y description for this icon. If absent, icon is marked
  // aria-hidden=true
  title: PropTypes.string
};
_module_$2D.exports = InlineIcon$k;
var _componentsInlineIconJsx = _module_$2D.exports;

// Generated by running:
// `node less-to-js.js 'stylesheets/exercise-content-package/variables.less'`
// @baseFontFamily =        "Proxima Nova"; sans-serif;
var baseFontFamily = "'Proxima Nova',sans-serif"; // @boldFontFamily =        "Proxima Nova Semibold"; sans-serif;

var boldFontFamily = "'Proxima Nova Semibold',sans-serif"; // @green:                 #76a005;

var kaGreen = "#71B307"; // @blue:                  #1c758a;

var blue = "#1C758A"; // @gray:                  #aaa;

var red = "#FFBABA"; // @questionWidth:         480px;

var grayLight = "#AAAAAA"; // @grayLighter:           #ddd;
var white = '#FFFFFF';
var gray97 = '#F6F7F7';
var gray95 = '#F0F1F2';
var gray85 = '#D6D8DA';
var gray76 = '#BABEC2';
var gray68 = '#888D93';
var gray17 = '#21242c';
var warning1 = '#F86700';

var pureSmMin = "568px"; // @pure-md-min: 768px;

var pureMdMin = "768px"; // @pure-lg-min: 1024px;

var pureLgMin = "1024px"; // @pure-xl-min: 1280px;

var pureXlMin = "1280px"; // @pure-xs-max: (@pure-sm-min - 1);

var pureXsMax = "567px"; // @pure-sm-max: (@pure-md-min - 1);

var pureSmMax = "767px"; // @pure-md-max: (@pure-lg-min - 1);

var pureMdMax = "1023px"; // @pure-lg-max: (@pure-xl-min - 1);

var pureLgMax = "1279px"; // @tableBackgroundAccent: #f9f9f9; // for striping

var tableBackgroundAccent = "#F9F9F9";

var satBlue = "#0084CE"; // @satSelectedBackgroundColor: #e4f3f9;

var satSelectedBackgroundColor = "#E4F3F9"; // @satActiveBackgroundColor: #d0edf4;

var satActiveBackgroundColor = "#D0EDF4"; // @satCorrectColor:       #009900;

var satCorrectColor = "#009900"; // @satCorrectBorderColor: #00cc00;

var satCorrectBorderColor = "#00CC00"; // @satCorrectBackgroundColor: #e4f7e4;

var satCorrectBackgroundColor = "#E4F7E4"; // @satIncorrectColor:     #990000;

var satIncorrectColor = "#990000"; // @satIncorrectBorderColor: #cc5252;

var satIncorrectBorderColor = "#CC5252"; // @satIncorrectBackgroundColor: #f2ebeb;

var satIncorrectBackgroundColor = "#F2EBEB"; // @zIndexScratchPad: 1;

var zIndexAboveScratchpad = "2"; // @zIndexInteractiveComponent: @zIndexAboveScratchpad + 1;

var zIndexInteractiveComponent = "3"; // @zIndexCurrentlyDragging: @zIndexInteractiveComponent + 1;

var phoneMargin = 16;
var negativePhoneMargin = -16;
var hintBorderWidth = 4; // The 'base unit' -- our new typography and layout styles are defined in
// terms of multiples of the 'base unit'.

var baseUnitPx = 16;
var interactiveSizes = {
  defaultBoxSize: 400,
  defaultBoxSizeSmall: 288
};
var circleSize = 24;
var radioMarginWidth = 2;
var warningColor = "#f86700";
var warningColorHover = "#df5c00";
var publishBlockingErrorColor = "#be2612";
var radioBorderColor$1 = gray76;
var checkedColor = kaGreen;

/**
 * This component renders "lint" nodes in a markdown parse tree. Lint nodes
 * are inserted into the tree by the Gorgon linter (see src/gorgon/gorgon.js).
 *
 * This component serves multiple purposes
 *
 * 1) It renders a small circle in the right margin to indicate that there
 * is lint on (or near) that line.
 *
 * 2) The area around the circle is hoverable: when the mouse moves over it
 * the linty content is highlighted and a tooltip is displayed that explains
 * what the problem is.
 *
 * 3) The hoverable area is also an HTML <a> tag. Clicking on it opens
 * a new tab and links to additional details about the specific lint rule.
 *
 * The CSS required to position the circles in the right margin is tricky
 * and it does not always work perfectly. When lint occurs on a block element
 * that has a right margin (like anything blockquoted) the circle will appear
 * to the left of where it belongs.  And if there is more
 **/

var React$2d = _react__default["default"];
var ReactDOM$E = _reactDom__default["default"];
var InlineIcon$j = _componentsInlineIconJsx;
var exclamationIcon = {
  path: "M6 11a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm0-9a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1z",
  // eslint-disable-line max-len
  height: 12,
  width: 12
};
var Lint$1 = createReactClass({
  displayName: "Lint",
  propTypes: {
    // The children are the linty content we're highlighting
    children: PropTypes.node,
    // Inline lint is highlighted differently than block lint.
    inline: PropTypes.bool,
    // This is the text that appears in the tooltip
    message: PropTypes.string.isRequired,
    // This is used as the fragment id (hash) in the URL of the link
    ruleName: PropTypes.string.isRequired,
    // Lint warnings inside tables are handled specially
    insideTable: PropTypes.bool.isRequired,
    // How important this lint message is for the editor. Severity goes
    // from 1 (indicating an error) to 4 (offline reporting only)
    severity: PropTypes.number
  },
  getInitialState: function getInitialState() {
    return {
      tooltipAbove: true
    };
  },
  componentDidMount: function componentDidMount() {
    this._positionTimeout = window.setTimeout(this.getPosition);
  },
  componentWillUnmount: function componentWillUnmount() {
    window.clearTimeout(this._positionTimeout);
  },
  // We can't call setState in componentDidMount without risking a render
  // thrash, and we can't call getBoundingClientRect in render, so we
  // borrow a timeout approach from learnstorm-dashboard.jsx and set our
  // state once the component has mounted and we can get what we need.
  getPosition: function getPosition() {
    var rect = ReactDOM$E.findDOMNode(this).getBoundingClientRect(); // TODO(scottgrant): This is a magic number! We don't know the size
    // of the tooltip at this point, so we're arbitrarily choosing a
    // point at which to flip the tooltip's position.

    this.setState({
      tooltipAbove: rect.top > 100
    });
  },
  // Render the <a> element that holds the indicator icon and the tooltip
  // We pass different styles for the inline and block cases
  renderLink: function renderLink(style) {
    var tooltipAbove = this.state.tooltipAbove;
    var severityStyle;
    var warningText;
    var warningTextStyle;

    if (this.props.severity === 1) {
      severityStyle = styles$r.indicatorError;
      warningText = "Error";
      warningTextStyle = styles$r.publishBlockingError;
    } else if (this.props.severity === 2) {
      severityStyle = styles$r.indicatorWarning;
      warningText = "Warning";
      warningTextStyle = styles$r.warning;
    } else {
      severityStyle = styles$r.indicatorGuideline;
      warningText = "Recommendation";
      warningTextStyle = styles$r.warning;
    }

    return /*#__PURE__*/React$2d.createElement("a", {
      href: "https://khanacademy.org/r/linter-rules#" + this.props.ruleName,
      target: "lint-help-window",
      className: aphrodite.css(style)
    }, /*#__PURE__*/React$2d.createElement("span", {
      className: aphrodite.css(styles$r.indicator, severityStyle)
    }, this.props.severity === 1 && /*#__PURE__*/React$2d.createElement(InlineIcon$j, exclamationIcon)), /*#__PURE__*/React$2d.createElement("div", {
      className: aphrodite.css(styles$r.tooltip, tooltipAbove && styles$r.tooltipAbove)
    }, this.props.message.split("\n\n").map((m, i) => /*#__PURE__*/React$2d.createElement("p", {
      key: i,
      className: aphrodite.css(styles$r.tooltipParagraph)
    }, /*#__PURE__*/React$2d.createElement("span", {
      className: aphrodite.css(warningTextStyle)
    }, warningText, ":", " "), m)), /*#__PURE__*/React$2d.createElement("div", {
      className: aphrodite.css(styles$r.tail, tooltipAbove && styles$r.tailAbove)
    })));
  },
  // The main render method surrounds linty content with a block or
  // inline container and the link element that displays the indicator
  // and holds the tooltip.
  render: function render() {
    if (this.props.insideTable) {
      // If we're inside a table, then linty nodes just get
      // a simple wrapper that allows them to be highlighted
      if (this.props.inline) {
        return /*#__PURE__*/React$2d.createElement("span", {
          "data-lint-inside-table": "true"
        }, this.props.children);
      } else {
        return /*#__PURE__*/React$2d.createElement("div", {
          "data-lint-inside-table": "true"
        }, this.props.children);
      }
    } else {
      if (this.props.inline) {
        return /*#__PURE__*/React$2d.createElement("span", {
          className: aphrodite.css(styles$r.lintContainer)
        }, this.renderLink(styles$r.inlineHoverTarget), /*#__PURE__*/React$2d.createElement("span", null, this.props.children));
      } else {
        return /*#__PURE__*/React$2d.createElement("div", {
          className: aphrodite.css(styles$r.lintContainer)
        }, this.renderLink(styles$r.hoverTarget), /*#__PURE__*/React$2d.createElement("div", null, this.props.children));
      }
    }
  }
});
var styles$r = aphrodite.StyleSheet.create({
  // This is the class of the outermost element.
  // We use relative positioning so that the lint indicator can be
  // positioned absolutely relative to the position of the linty container.
  lintContainer: {
    position: "relative"
  },
  // This is the main class for block lint. It is applied to the link element
  // that is also the hover target.
  hoverTarget: {
    // Absolute positioning relative to the lintContainer element
    position: "absolute",
    // Top of the hover target is aligned with the top of the linty block
    top: 0,
    // We want the hover target in the right margin. It is 24px wide, but
    // we have to offset it another 16px because of margins in the
    // Perseus content. I'm not sure where the 16px margin is set
    // so if that changes, this number will also have to be changed.
    // This is the part of the CSS that doesn't work right when
    // applied to things like blockquotes that have different right
    // margins.
    right: -40,
    // The hover target is a 24x24 block element.
    display: "block",
    width: 24,
    height: 24,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover
    ":hover div": {
      display: "block"
    },
    // The linty content is in a <div> sibling that follows the
    // hover target. This style highlights it on hover. We do an outline
    // rather than a border so we don't affect the layout. We could also
    // set the background color, but we don't because we can't reliably
    // set the text color of this block element. We could use
    // filter: invert(100%) if we want more visual change on hover here.
    ":hover ~ div": {
      outline: "1px solid " + warningColor
    },
    // If the div sibling is a table, then we may be displaying
    // lint warnings about errors inside that table. In that case
    // we want to highlight any linty descendants of the table
    ":hover ~ div div[data-lint-inside-table]": {
      outline: "1px solid " + warningColor
    },
    ":hover ~ div span[data-lint-inside-table]": {
      backgroundColor: warningColor,
      color: white
    }
  },
  // This is how we position the hover target for inline lint.
  inlineHoverTarget: {
    // For inline lint we position the hover target with a float:right
    // We can't use absolute positioning as we do in the block case
    // because the horizontal position is not predictable in the
    // inline case.
    float: "right",
    // We still have to make the hover target relative so that the
    // tooltip can be positioned relative to it.
    position: "relative",
    // See the comment above about the extra 16px of offset needed here.
    marginRight: -40,
    // The hover target is a 24x24 block. Same as the block case
    display: "block",
    width: 24,
    height: 24,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover.
    // This is the same as the block case.
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover. This is the same as the block case.
    ":hover div": {
      display: "block"
    },
    // The linty content is in a <span> sibling that follows the
    // hover target. This style highlights it on hover. In this case
    // we can just set the foreground and background color to really
    // draw attention to the linty content.
    ":hover ~ span": {
      backgroundColor: warningColor,
      color: white
    }
  },
  // This is the class for the lint indicator in the margin.
  indicator: {
    alignItems: 'center',
    borderRadius: 4,
    color: 'white',
    display: 'flex',
    fontSize: 12,
    height: 8,
    justifyContent: 'center',
    margin: 8,
    width: 8
  },
  indicatorError: {
    backgroundColor: '#be2612',
    borderRadius: 8,
    height: 16,
    width: 16
  },
  indicatorWarning: {
    backgroundColor: '#f86700'
  },
  indicatorGuideline: {
    backgroundColor: '#ffbe26'
  },
  // These are the styles for the tooltip
  tooltip: {
    // Absolute positioning relative to the lint indicator circle.
    position: "absolute",
    right: -12,
    // The tooltip is hidden by default; only displayed on hover
    display: "none",
    // When it is displayed, it goes on top!
    zIndex: "1000",
    // These styles control what the tooltip looks like
    color: white,
    backgroundColor: gray17,
    opacity: "0.9",
    fontFamily: baseFontFamily,
    fontSize: "12px",
    lineHeight: "15px",
    width: "320px",
    borderRadius: "4px"
  },
  // If we're going to render the tooltip above the warning circle, we use
  // the previous rules in tooltip, but change the position slightly.
  tooltipAbove: {
    bottom: 32
  },
  // We give the tooltip a little triangular "tail" that points down at
  // the lint indicator circle. This is inside the tooltip and positioned
  // relative to it. It also shares the opacity of the tooltip. We're using
  // the standard CSS trick for drawing triangles with a thick border.
  tail: {
    position: "absolute",
    top: -12,
    right: 16,
    width: 0,
    height: 0,
    // This is the CSS triangle trick
    borderLeft: "8px solid transparent",
    borderRight: "8px solid transparent",
    borderBottom: "12px solid " + gray17
  },
  tailAbove: {
    bottom: -12,
    borderBottom: "none",
    borderTop: "12px solid " + gray17,
    top: "auto"
  },
  // Each warning in the tooltip is its own <p>. They are 12 pixels from
  // the edges of the tooltip and 12 pixels from each other.
  tooltipParagraph: {
    margin: 12
  },
  // The text "Warning" inside the tooltip is highlighted like this
  warning: {
    color: warningColor,
    fontFamily: boldFontFamily
  },
  // The text "Publish-blocking error" instide the tooltip is highlighted
  // like this
  publishBlockingError: {
    color: publishBlockingErrorColor
  }
});

var module$a = {
  exports: {}
};
(function () {
  /**
   * KaTeX A11y
   * A library for converting KaTeX math into readable strings.
   */
  // NOTE(jeresig): We need to keep this file as pure ES5 to avoid import
  // problems into webapp.

  /* eslint-disable no-var */
  var katex = _katex__default["default"];
  var stringMap = {
    "(": "left parenthesis",
    ")": "right parenthesis",
    "[": "open bracket",
    "]": "close bracket",
    "\\{": "left brace",
    "\\}": "right brace",
    "\\lvert": "open vertical bar",
    "\\rvert": "close vertical bar",
    "|": "vertical bar",
    "\\uparrow": "up arrow",
    "\\Uparrow": "up arrow",
    "\\downarrow": "down arrow",
    "\\Downarrow": "down arrow",
    "\\updownarrow": "up down arrow",
    "\\leftarrow": "left arrow",
    "\\Leftarrow": "left arrow",
    "\\rightarrow": "right arrow",
    "\\Rightarrow": "right arrow",
    "\\langle": "open angle",
    "\\rangle": "close angle",
    "\\lfloor": "open floor",
    "\\rfloor": "close floor",
    "\\int": "integral",
    "\\intop": "integral",
    "\\lim": "limit",
    "\\ln": "natural log",
    "\\log": "log",
    "\\sin": "sine",
    "\\cos": "cosine",
    "\\tan": "tangent",
    "\\cot": "cotangent",
    "\\sum": "sum",
    "/": "slash",
    ",": "comma",
    ".": "point",
    "-": "negative",
    "+": "plus",
    "~": "tilde",
    ":": "colon",
    "?": "question mark",
    "'": "apostrophe",
    "\\%": "percent",
    " ": "space",
    "\\ ": "space",
    "\\$": "dollar sign",
    "\\angle": "angle",
    "\\degree": "degree",
    "\\circ": "circle",
    "\\vec": "vector",
    "\\triangle": "triangle",
    "\\pi": "pi",
    "\\prime": "prime",
    "\\infty": "infinity",
    "\\alpha": "alpha",
    "\\beta": "beta",
    "\\gamma": "gamma",
    "\\omega": "omega",
    "\\theta": "theta",
    "\\sigma": "sigma",
    "\\lambda": "lambda",
    "\\tau": "tau",
    "\\Delta": "delta",
    "\\delta": "delta",
    "\\mu": "mu",
    "\\rho": "rho",
    "\\nabla": "del",
    "\\ell": "ell",
    "\\ldots": "dots"
  };
  var powerMap = {
    "\\prime": "prime",
    "\\degree": "degree",
    "\\circ": "degree"
  };
  var openMap = {
    "|": "open vertical bar",
    ".": ""
  };
  var closeMap = {
    "|": "close vertical bar",
    ".": ""
  };
  var binMap = {
    "+": "plus",
    "-": "minus",
    "\\pm": "plus minus",
    "\\cdot": "dot",
    "*": "times",
    "/": "divided by",
    "\\times": "times",
    "\\div": "divided by",
    "\\circ": "circle",
    "\\bullet": "bullet"
  };
  var relMap = {
    "=": "equals",
    "\\approx": "approximately equals",
    "\\neq": "does not equal",
    "\\ne": "does not equal",
    "\\geq": "is greater than or equal to",
    "\\ge": "is greater than or equal to",
    "\\leq": "is less than or equal to",
    "\\le": "is less than or equal to",
    ">": "is greater than",
    "<": "is less than",
    "\\leftarrow": "left arrow",
    "\\Leftarrow": "left arrow",
    "\\rightarrow": "right arrow",
    "\\Rightarrow": "right arrow",
    ":": "colon"
  };

  var buildString = function buildString(str, type, a11yStrings) {
    if (!str) {
      return;
    }

    var ret;

    if (type === "open") {
      ret = str in openMap ? openMap[str] : stringMap[str] || str;
    } else if (type === "close") {
      ret = str in closeMap ? closeMap[str] : stringMap[str] || str;
    } else if (type === "bin") {
      ret = binMap[str] || str;
    } else if (type === "rel") {
      ret = relMap[str] || str;
    } else {
      ret = stringMap[str] || str;
    } // If nothing was found and it's not a plain string or number


    if (ret === str && !/^\w+$/.test(str)) {
      // This is likely a case that we'll need to handle
      throw new Error("KaTeX a11y " + type + " string not found: " + str);
    } // If the text to add is a number and there is already a string
    // in the list and the last string is a number then we should
    // combine them into a single number


    if (/^\d+$/.test(ret) && a11yStrings.length > 0 && /^\d+$/.test(a11yStrings[a11yStrings.length - 1])) {
      a11yStrings[a11yStrings.length - 1] += ret;
    } else if (ret) {
      a11yStrings.push(ret);
    }
  };

  var buildRegion = function buildRegion(a11yStrings, callback) {
    var region = [];
    a11yStrings.push(region);
    callback(region);
  };

  var typeHandlers = {
    accent: function accent(tree, a11yStrings) {
      buildRegion(a11yStrings, function (a11yStrings) {
        buildA11yStrings(tree.value.base, a11yStrings);
        a11yStrings.push("with");
        buildA11yStrings(tree.value.label, a11yStrings);
        a11yStrings.push("on top");
      });
    },
    bin: function bin(tree, a11yStrings) {
      buildString(tree.value, "bin", a11yStrings);
    },
    close: function close(tree, a11yStrings) {
      buildString(tree.value, "close", a11yStrings);
    },
    color: function color(tree, a11yStrings) {
      var color = tree.value.color.replace(/katex-/, "");
      buildRegion(a11yStrings, function (a11yStrings) {
        a11yStrings.push("start color " + color);
        buildA11yStrings(tree.value.value, a11yStrings);
        a11yStrings.push("end color " + color);
      });
    },
    delimsizing: function delimsizing(tree, a11yStrings) {
      if (tree.value.value && tree.value.value !== ".") {
        buildString(tree.value.value, "normal", a11yStrings);
      }
    },
    genfrac: function genfrac(tree, a11yStrings) {
      buildRegion(a11yStrings, function (a11yStrings) {
        // NOTE: Not sure if this is a safe assumption
        // hasBarLine true -> fraction, false -> binomial
        if (tree.value.hasBarLine) {
          a11yStrings.push("start fraction");
          buildString(tree.value.leftDelim, "open", a11yStrings);
          buildA11yStrings(tree.value.numer, a11yStrings);
          a11yStrings.push("divided by");
          buildA11yStrings(tree.value.denom, a11yStrings);
          buildString(tree.value.rightDelim, "close", a11yStrings);
          a11yStrings.push("end fraction");
        } else {
          a11yStrings.push("start binomial");
          buildString(tree.value.leftDelim, "open", a11yStrings);
          buildA11yStrings(tree.value.numer, a11yStrings);
          a11yStrings.push("over");
          buildA11yStrings(tree.value.denom, a11yStrings);
          buildString(tree.value.rightDelim, "close", a11yStrings);
          a11yStrings.push("end binomial");
        }
      });
    },
    inner: function inner(tree, a11yStrings) {
      buildA11yStrings(tree.value, a11yStrings);
    },
    katex: function katex(tree, a11yStrings) {
      a11yStrings.push("KaTeX");
    },
    kern: function kern(tree, a11yStrings) {// No op: we don't attempt to present kerning information
      // to the screen reader.
    },
    leftright: function leftright(tree, a11yStrings) {
      buildRegion(a11yStrings, function (a11yStrings) {
        buildString(tree.value.left, "open", a11yStrings);
        buildA11yStrings(tree.value.body, a11yStrings);
        buildString(tree.value.right, "close", a11yStrings);
      });
    },
    lap: function lap(tree, a11yStrings) {
      buildA11yStrings(tree.value.body, a11yStrings);
    },
    mathord: function mathord(tree, a11yStrings) {
      buildA11yStrings(tree.value, a11yStrings);
    },
    op: function op(tree, a11yStrings) {
      buildString(tree.value.body, "normal", a11yStrings);
    },
    open: function open(tree, a11yStrings) {
      buildString(tree.value, "open", a11yStrings);
    },
    ordgroup: function ordgroup(tree, a11yStrings) {
      buildA11yStrings(tree.value, a11yStrings);
    },
    overline: function overline(tree, a11yStrings) {
      buildRegion(a11yStrings, function (a11yStrings) {
        a11yStrings.push("start overline");
        buildA11yStrings(tree.value.body, a11yStrings);
        a11yStrings.push("end overline");
      });
    },
    phantom: function phantom(tree, a11yStrings) {
      a11yStrings.push("empty space");
    },
    punct: function punct(tree, a11yStrings) {
      buildString(tree.value, "punct", a11yStrings);
    },
    raisebox: function raisebox(tree, a11yStrings) {
      buildA11yStrings(tree.value, a11yStrings);
    },
    rel: function rel(tree, a11yStrings) {
      buildString(tree.value, "rel", a11yStrings);
    },
    rlap: function rlap(tree, a11yStrings) {
      buildA11yStrings(tree.value.body, a11yStrings);
    },
    rule: function rule(tree, a11yStrings) {
      // NOTE: Is there something more useful that we can put here?
      a11yStrings.push("rule");
    },
    sizing: function sizing(tree, a11yStrings) {
      buildA11yStrings(tree.value.value, a11yStrings);
    },
    spacing: function spacing(tree, a11yStrings) {
      a11yStrings.push("space");
    },
    styling: function styling(tree, a11yStrings) {
      // We ignore the styling and just pass through the contents
      buildA11yStrings(tree.value.value, a11yStrings);
    },
    sqrt: function sqrt(tree, a11yStrings) {
      buildRegion(a11yStrings, function (a11yStrings) {
        if (tree.value.index) {
          a11yStrings.push("root");
          a11yStrings.push("start index");
          buildA11yStrings(tree.value.index, a11yStrings);
          a11yStrings.push("end index");
        }

        a11yStrings.push("square root of");
        buildA11yStrings(tree.value.body, a11yStrings);
        a11yStrings.push("end square root");
      });
    },
    supsub: function supsub(tree, a11yStrings) {
      if (tree.value.base) {
        buildA11yStrings(tree.value.base, a11yStrings);
      }

      if (tree.value.sub) {
        buildRegion(a11yStrings, function (a11yStrings) {
          a11yStrings.push("start subscript");
          buildA11yStrings(tree.value.sub, a11yStrings);
          a11yStrings.push("end subscript");
        });
      }

      var sup = tree.value.sup;

      if (sup) {
        // There are some cases that just read better if we don't have
        // the extra start/end baggage, so we skip the extra text
        var newPower = powerMap[sup];
        var supValue = sup.value; // The value stored inside the sup property is not always
        // consistent. It could be a string (handled above), an object
        // with a string property in value, or an array of objects that
        // have a value property.

        if (!newPower && supValue) {
          // If supValue is an object and it has a length of 1 we assume
          // it's an array that has only a single item in it. This is the
          // case that we care about and we only check that one value.
          if (typeof supValue === "object" && supValue.length === 1) {
            newPower = powerMap[supValue[0].value]; // This is the case where it's a string in the value property
          } else {
            newPower = powerMap[supValue];
          }
        }

        buildRegion(a11yStrings, function (a11yStrings) {
          if (newPower) {
            a11yStrings.push(newPower);
            return;
          }

          a11yStrings.push("start superscript");
          buildA11yStrings(tree.value.sup, a11yStrings);
          a11yStrings.push("end superscript");
        });
      }
    },
    text: function text(tree, a11yStrings) {
      if (typeof tree.value !== "string") {
        buildA11yStrings(tree.value.body, a11yStrings);
      } else {
        buildString(tree, "normal", a11yStrings);
      }
    },
    textord: function textord(tree, a11yStrings) {
      buildA11yStrings(tree.value, a11yStrings);
    }
  };

  var buildA11yStrings = function buildA11yStrings(tree, a11yStrings) {
    a11yStrings = a11yStrings || []; // Handle strings

    if (typeof tree === "string") {
      buildString(tree, "normal", a11yStrings); // Handle arrays
    } else if (tree.constructor === Array) {
      for (var i = 0; i < tree.length; i++) {
        buildA11yStrings(tree[i], a11yStrings);
      } // Everything else is assumed to be an object...

    } else {
      if (!tree.type || !(tree.type in typeHandlers)) {
        throw new Error("KaTeX a11y un-recognized type: " + tree.type);
      } else {
        typeHandlers[tree.type](tree, a11yStrings);
      }
    }

    return a11yStrings;
  };

  var renderStrings = function renderStrings(a11yStrings, a11yNode) {
    var doc = a11yNode.ownerDocument;

    for (var i = 0; i < a11yStrings.length; i++) {
      var a11yString = a11yStrings[i];

      if (i > 0) {
        // Note: We insert commas in (not just spaces) to provide
        // screen readers with some "breathing room". When inserting the
        // commas the screen reader knows to pause slightly and it provides
        // an overall better listening experience.
        a11yNode.appendChild(doc.createTextNode(", "));
      }

      if (typeof a11yString === "string") {
        a11yNode.appendChild(doc.createTextNode(a11yString));
      } else {
        var newBaseNode = doc.createElement("span"); // NOTE(jeresig): We may want to add in a tabIndex property
        // to the node here, in order to support keyboard navigation.

        a11yNode.appendChild(newBaseNode);
        renderStrings(a11yString, newBaseNode);
      }
    }
  };

  var parseMath = function parseMath(text) {
    // NOTE: `katex` is a global. We assume it has been imported somehow.
    //
    // colorIsTextColor is an option added in KaTeX 0.9.0 for backward
    // compatibility. It makes \color parse like \textcolor. We use it
    // in the KA webapp, and need it here because the tests are written
    // assuming it is set.
    return katex.__parse(text, {
      colorIsTextColor: true
    });
  };

  var render = function render(text, a11yNode) {
    var tree = parseMath(text);
    var a11yStrings = buildA11yStrings(tree);
    renderStrings(a11yStrings, a11yNode);
  };

  var flatten = function flatten(array) {
    var result = [];
    array.forEach(function (item) {
      if (Array.isArray(item)) {
        result = result.concat(flatten(item));
      } else {
        result.push(item);
      }
    });
    return result;
  };

  var renderString = function renderString(text) {
    var tree = parseMath(text);
    var a11yStrings = buildA11yStrings(tree);
    return flatten(a11yStrings).join(", ");
  };

  if (typeof module$a !== "undefined") {
    module$a.exports = {
      render: render,
      renderString: renderString,
      parseMath: parseMath
    };
  } else {
    this.katexA11yRender = render;
  }
}).call(module$a.exports);
var _katexA11yJs = module$a.exports;

var module$9 = {
  exports: {}
};
/**
 * For math rendered using KaTex and/or MathJax. Use me like <TeX>2x + 3</TeX>.
 */

/* global MathJax */

var PureRenderMixin = _reactAddonsPureRenderMixin__default["default"];
var React$2c = _react__default["default"];
var ReactDOM$D = _reactDom__default["default"];
var createReactClass$8 = _createReactClass__default["default"];
var PropTypes$8 = _propTypes__default["default"];
var katex$1 = _katex__default["default"];
var katexA11y = _katexA11yJs;
var pendingScripts = [];
var pendingCallbacks = [];
var needsProcess = false; // For creating unique element ids required by the aria-describedby attribute

var describedByIdCounter = 0;

var _process = (script, callback) => {
  pendingScripts.push(script);
  pendingCallbacks.push(callback);

  if (!needsProcess) {
    needsProcess = true;
    setTimeout(doProcess, 0);
  }
};

var unProcess = script => {
  var scriptIndex = pendingScripts.indexOf(script);
  pendingScripts.splice(scriptIndex, 1);
  pendingCallbacks.splice(scriptIndex, 1);
}; // NOTE(aria): Stubbed out now that this is outside of KA


var loadMathJax = callback => callback();

var doProcess = () => {
  loadMathJax(() => {
    MathJax.Hub.Queue(function () {
      var oldElementScripts = MathJax.Hub.elementScripts;

      MathJax.Hub.elementScripts = element => pendingScripts;

      try {
        return MathJax.Hub.Process(null, () => {
          // Trigger all of the pending callbacks before clearing them
          // out.
          for (var callback of pendingCallbacks) {
            callback();
          }

          pendingScripts = [];
          pendingCallbacks = [];
          needsProcess = false;
        });
      } catch (e) {
        // IE8 requires `catch` in order to use `finally`
        throw e;
      } finally {
        MathJax.Hub.elementScripts = oldElementScripts;
      }
    });
  });
}; // Make content only visible to screen readers.
// Both collegeboard.org and Bootstrap 3 use this exact implementation.


var srOnly = {
  border: 0,
  clip: "rect(0,0,0,0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px"
};
var TeX$9 = createReactClass$8({
  displayName: "TeX",
  propTypes: {
    children: PropTypes$8.node,
    katexOptions: PropTypes$8.any,
    onClick: PropTypes$8.func,
    onRender: PropTypes$8.func,
    style: PropTypes$8.any
  },
  mixins: [PureRenderMixin],
  getDefaultProps: function getDefaultProps() {
    return {
      katexOptions: {
        // There was a breaking change in the behavior of \color{}
        // in KaTeX 0.8.0. KA content relies on the old behavior
        // so we set this option to retain that old behavior even
        // though it is not purely compatible with LaTeX.
        // See https://github.com/Khan/KaTeX/blob/master/README.md
        // for details on this option.
        colorIsTextColor: true
      },
      // Called after math is rendered or re-rendered
      onRender: function onRender() {},
      onClick: null
    };
  },
  // TODO(joshuan): Once we are using React 16.3+,
  // migrate to getDerivedStateFromProps
  getInitialState: function getInitialState() {
    return {
      mounted: false,
      katexHtml: this.getKatexHtml(this.props)
    };
  },
  componentDidMount: function componentDidMount() {
    this._root = ReactDOM$D.findDOMNode(this); // Needed so that the initial client render matches SSR.
    // eslint-disable-next-line react/no-did-mount-set-state

    this.setState({
      mounted: true
    });

    if (this.refs.katex.childElementCount > 0) {
      // If we already rendered katex in the render function, we don't
      // need to render anything here.
      this.props.onRender(this._root);
      return;
    }

    var text = this.props.children;
    this.setScriptText(text);
    this.process(() => this.props.onRender(this._root));
  },
  // TODO(joshuan): If you are updating to React 16.3+, migrate to
  // getDerivedStateFromProps
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.children !== this.props.children || JSON.stringify(nextProps.katexOptions) !== JSON.stringify(this.props.katexOptions)) {
      this.setState({
        katexHtml: this.getKatexHtml(nextProps)
      });
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    if (this.props.children !== prevProps.children) {
      this.maybeUnprocess(); // If we already rendered katex in the render function, we don't
      // need to render anything here.

      if (this.refs.katex.childElementCount > 0) {
        if (this.script) {
          // If we successfully rendered KaTeX, check if there's
          // lingering MathJax from the last render, and if so remove it.
          loadMathJax(() => {
            var jax = MathJax.Hub.getJaxFor(this.script);

            if (jax) {
              jax.Remove();
            }
          });
        }

        this.props.onRender();
        return;
      }

      var newText = this.props.children;

      if (this.script) {
        loadMathJax(() => {
          MathJax.Hub.Queue(() => {
            var jax = MathJax.Hub.getJaxFor(this.script);

            if (jax) {
              return jax.Text(newText, this.props.onRender);
            } else {
              this.setScriptText(newText);
              this.process(this.props.onRender);
            }
          });
        });
      } else {
        this.setScriptText(newText);
        this.process(this.props.onRender);
      }
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this.maybeUnprocess();

    if (this.script) {
      loadMathJax(() => {
        var jax = MathJax.Hub.getJaxFor(this.script);

        if (jax) {
          jax.Remove();
        }
      });
    }
  },

  getKatexHtml(props) {
    // Try to render the math content with KaTeX.
    // If this fails, componentDidUpdate() will notice and
    // use MathJAX instead.
    try {
      return {
        __html: katex$1.renderToString(props.children, props.katexOptions)
      };
    } catch (e) {
      // By catching the exception here and returning null
      // we will fall back to asyncronously rendering with
      // MathJAX.
      //
      // NOTE: formerly we only returned null if the error
      // was a parse error from Katex and re-threw any other errors.
      // But https://khanacademy.atlassian.net/browse/CP-879 and
      // https://khanacademy.atlassian.net/browse/CP-1742 were caused
      // by regular TypeError exceptions in Katex, so we might as
      // well fall back to MathJAX in that case as well. (The Katex
      // bug is fixed in the latest version and will stop happening
      // when we upgrade webapp to use Katex 1.0.)
      //
      // TODO: We could use Raven.captureMessage() to send a message
      // to Sentry when these errors occur if we want to get serious
      // about eliminating them. Such a message should include
      // window.location, props.children (the string of katex source)
      // and the error itself.
      return null;
    }
  },

  process: function process(callback) {
    this.hasProcessed = false;

    _process(this.script, () => {
      this.hasProcessed = true;
      callback && callback();
    });
  },
  maybeUnprocess: function maybeUnprocess() {
    // Sometimes, we end up rendering this component with some MathJax-only
    // math before very quickly switching over to some other math, before
    // MathJax has had a time to render. We want to remove the previously
    // queued render so that we don't accidentally render some math that we
    // don't want displayed.
    if (this.script && !this.hasProcessed) {
      unProcess(this.script);
    }
  },
  setScriptText: function setScriptText(text) {
    if (!this.script) {
      this.script = document.createElement("script");
      this.script.type = "math/tex";
      ReactDOM$D.findDOMNode(this.refs.mathjax).appendChild(this.script);
    }

    if ("text" in this.script) {
      // IE8, etc
      this.script.text = text;
    } else {
      this.script.textContent = text;
    }
  },
  render: function render() {
    var {
      katexHtml
    } = this.state; // If we successfully parsed with KaTeX, then try parse the
    // same math text to an english rendering that can be read
    // by screen readers. Our katexA11y module is out of date and
    // not well maintained, so it can not always transform math
    // into readable english. We ignore any exceptions it throws.

    var katexA11yHtml = null;
    var describedById = null;

    if (katexHtml) {
      try {
        katexA11yHtml = {
          __html: katexA11y.renderString(this.props.children)
        }; // The server and the client will not necessarily use the same
        // ID, and the initial client markup must match the server
        // markup. Thus, we only add an ID once we've rendered once.

        if (this.state.mounted) {
          describedById = "katex-".concat(++describedByIdCounter);
        }
      } catch (e) {// Nothing
      }
    }

    return /*#__PURE__*/React$2c.createElement("span", {
      style: this.props.style,
      onClick: this.props.onClick
    }, /*#__PURE__*/React$2c.createElement("span", {
      ref: "mathjax"
    }), /*#__PURE__*/React$2c.createElement("span", {
      ref: "katex",
      dangerouslySetInnerHTML: katexHtml,
      "aria-hidden": !!katexA11yHtml,
      "aria-describedby": describedById
    }), /*#__PURE__*/React$2c.createElement("span", {
      dangerouslySetInnerHTML: katexA11yHtml,
      id: describedById,
      style: srOnly
    }));
  }
});
module$9.exports = TeX$9;
var _reactComponentsTexJsx = module$9.exports;

var _module_$2C = {
  exports: {}
};
/* eslint-disable no-var, object-curly-spacing */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals KA */

var _$1G = _underscore__default["default"];
var SimpleMarkdown$2 = _simpleMarkdown__default["default"];
var TeX$8 = _reactComponentsTexJsx;
var Util$p = Util$q;
var Lint = Lint$1;
/**
 * This match function matches math in `$`s, such as:
 *
 * $y = x + 1$
 *
 * It functions roughly like the following regex:
 * /\$([^\$]*)\$/
 *
 * Unfortunately, math may have other `$`s inside it, as
 * long as they are inside `{` braces `}`, mostly for
 * `\text{ $math$ }`.
 *
 * To parse this, we can't use a regex, since we
 * should support arbitrary nesting (even though
 * MathJax actually only supports two levels of nesting
 * here, which we *could* parse with a regex).
 *
 * Non-regex matchers like this are now a first-class
 * concept in simple-markdown. Yay!
 *
 * This can also match block-math, which is math alone in a paragraph.
 */

var mathMatcher = (source, state, isBlock) => {
  var length = source.length;
  var index = 0; // When looking for blocks, skip over leading spaces

  if (isBlock) {
    if (state.inline) {
      return null;
    }

    while (index < length && source[index] === " ") {
      index++;
    }
  } // Our source must start with a "$"


  if (!(index < length && source[index] === "$")) {
    return null;
  }

  index++;
  var startIndex = index;
  var braceLevel = 0; // Loop through the source, looking for a closing '$'
  // closing '$'s only count if they are not escaped with
  // a `\`, and we are not in nested `{}` braces.

  while (index < length) {
    var character = source[index];

    if (character === "\\") {
      // Consume both the `\` and the escaped char as a single
      // token.
      // This is so that the second `$` in `$\\$` closes
      // the math expression, since the first `\` is escaping
      // the second `\`, but the second `\` is not escaping
      // the second `$`.
      // This also handles the case of escaping `$`s or
      // braces `\{`
      index++;
    } else if (braceLevel <= 0 && character === "$") {
      var endIndex = index + 1;

      if (isBlock) {
        // Look for two trailing newlines after the closing `$`
        var match = /^(?: *\n){2,}/.exec(source.slice(endIndex));
        endIndex = match ? endIndex + match[0].length : null;
      } // Return an array that looks like the results of a
      // regex's .exec function:
      // capture[0] is the whole string
      // capture[1] is the first "paren" match, which is the
      //   content of the math here, as if we wrote the regex
      //   /\$([^\$]*)\$/


      if (endIndex) {
        return [source.substring(0, endIndex), source.substring(startIndex, index)];
      }

      return null;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    } else if (character === "\n" && source[index - 1] === "\n") {
      // This is a weird case we supported in the old
      // math implementation--double newlines break
      // math. I'm preserving it for now because content
      // creators might have questions with single '$'s
      // in paragraphs...
      return null;
    }

    index++;
  } // we didn't find a closing `$`


  return null;
};

var mathMatch = (source, state) => mathMatcher(source, state, false);

var blockMathMatch = (source, state) => mathMatcher(source, state, true);

var TITLED_TABLE_REGEX = new RegExp("^\\|\\| +(.*) +\\|\\| *\\n" + "(" + // The simple-markdown nptable regex, without
// the leading `^`
SimpleMarkdown$2.defaultRules.nptable.match.regex.source.substring(1) + ")");
var crowdinJiptMatcher = SimpleMarkdown$2.blockRegex(/^(crwdns.*)\n\s*\n/);

var rules$1 = _$1G.extend({}, SimpleMarkdown$2.defaultRules, {
  // NOTE: basically ignored by JIPT. wraps everything at the outer layer
  columns: {
    order: -2,
    match: SimpleMarkdown$2.blockRegex(/^([\s\S]*\n\n)={5,}\n\n([\s\S]*)/),
    parse: (capture, _parse, state) => {
      return {
        col1: _parse(capture[1], state),
        col2: _parse(capture[2], state)
      };
    },
    react: (node, output, state) => {
      return /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "perseus-two-columns",
        key: state.key
      }, /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "perseus-column"
      }, /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "perseus-column-content"
      }, output(node.col1, state))), /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "perseus-column"
      }, /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "sat-header-grafting-area"
      }), /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "perseus-column-content"
      }, /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "sat-skill-subscore-grafting-area"
      }), output(node.col2, state), /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "sat-grafting-area"
      }))));
    }
  },
  // Match paragraphs consisting solely of crowdin IDs
  // (they look roughly like crwdns9238932:0), which means that
  // crowdin is going to take the DOM node that ID is rendered into
  // and count it as the top-level translation node. They mutate this
  // node, so we need to make sure it is an outer node, not an inner
  // span. So here we parse this separately and just output the
  // raw string, which becomes the body of the <QuestionParagraph>
  // created by the Renderer.
  // This currently (2015-09-01) affects only articles, since
  // for exercises the renderer just renders the crowdin id to the
  // renderer div.
  crowdinId: {
    order: -1,
    match: (source, state, prevCapture) => {
      // Only match on the just-in-place translation site
      if (state.isJipt) {
        return crowdinJiptMatcher(source, state, prevCapture);
      } else {
        return null;
      }
    },
    parse: (capture, _parse2, state) => ({
      id: capture[1]
    }),
    react: (node, output, state) => node.id
  },
  // This is pretty much horrible, but we have a regex here to capture an
  // entire table + a title. capture[1] is the title. capture[2] of the
  // regex is a copy of the simple-markdown nptable regex. Then we turn
  // our capture[2] into tableCapture[0], and any further captures in
  // our table regex into tableCapture[1..], and we pass tableCapture to
  // our nptable regex
  titledTable: {
    // process immediately before nptables
    order: SimpleMarkdown$2.defaultRules.nptable.order - 0.5,
    match: SimpleMarkdown$2.blockRegex(TITLED_TABLE_REGEX),
    parse: (capture, _parse3, state) => {
      var title = SimpleMarkdown$2.parseInline(_parse3, capture[1], state); // Remove our [0] and [1] captures, and pass the rest to
      // the nptable parser

      var tableCapture = _$1G.rest(capture, 2);

      var table = SimpleMarkdown$2.defaultRules.nptable.parse(tableCapture, _parse3, state);
      return {
        title: title,
        table: table
      };
    },
    react: (node, output, state) => {
      var contents;

      if (!node.table) {
        contents = "//invalid table//";
      } else {
        var tableOutput = SimpleMarkdown$2.defaultRules.table.react(node.table, output, state);
        var caption = /*#__PURE__*/_react__default["default"].createElement("caption", {
          key: "caption",
          className: "perseus-table-title"
        }, output(node.title, state)); // Splice the caption into the table's children with the
        // caption as the first child.

        contents = /*#__PURE__*/_react__default["default"].cloneElement(tableOutput, null, [caption, ...tableOutput.props.children]);
      } // Note: if the DOM structure changes, edit the Zoomable wrapper
      // in src/renderer.jsx.


      return /*#__PURE__*/_react__default["default"].createElement("div", {
        className: "perseus-titled-table",
        key: state.key
      }, contents);
    }
  },
  widget: {
    order: SimpleMarkdown$2.defaultRules.link.order - 0.75,
    match: SimpleMarkdown$2.inlineRegex(Util$p.rWidgetRule),
    parse: (capture, _parse4, state) => {
      return {
        id: capture[1],
        widgetType: capture[2]
      };
    },
    react: (node, output, state) => {
      // The actual output is handled in the renderer, where
      // we know the current widget props/state. This is
      // just a stub for testing.
      return /*#__PURE__*/_react__default["default"].createElement("em", {
        key: state.key
      }, "[Widget: ", node.id, "]");
    }
  },
  blockMath: {
    order: SimpleMarkdown$2.defaultRules.codeBlock.order + 0.5,
    match: blockMathMatch,
    parse: (capture, _parse5, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      // The actual output is handled in the renderer, because
      // it needs to pass in an `onRender` callback prop. This
      // is just a stub for testing.
      return /*#__PURE__*/_react__default["default"].createElement(TeX$8, {
        key: state.key
      }, node.content);
    }
  },
  math: {
    order: SimpleMarkdown$2.defaultRules.link.order - 0.25,
    match: mathMatch,
    parse: (capture, _parse6, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      // The actual output is handled in the renderer, because
      // it needs to pass in an `onRender` callback prop. This
      // is just a stub for testing.
      return /*#__PURE__*/_react__default["default"].createElement(TeX$8, {
        key: state.key
      }, node.content);
    }
  },
  unescapedDollar: {
    order: SimpleMarkdown$2.defaultRules.link.order - 0.24,
    match: SimpleMarkdown$2.inlineRegex(/^(?!\\)\$/),
    parse: (capture, _parse7, state) => {
      return {};
    },
    react: (node, output, state) => {
      // Unescaped dollar signs render correctly, but result in
      // untranslatable text after the i18n python linter flags it
      return "$";
    }
  },
  fence: _$1G.extend({}, SimpleMarkdown$2.defaultRules.fence, {
    parse: (capture, _parse8, state) => {
      var node = SimpleMarkdown$2.defaultRules.fence.parse(capture, _parse8, state); // support screenreader-only text with ```alt

      if (node.lang === "alt") {
        return {
          type: "codeBlock",
          lang: "alt",
          // default codeBlock parsing doesn't parse the contents.
          // We need to parse the contents for things like table
          // support :).
          // The \n\n is because the inside of the codeblock might
          // not end in double newlines for block rules, because
          // ordinarily we don't parse this :).
          content: _parse8(node.content + "\n\n", state)
        };
      } else {
        return node;
      }
    }
  }),
  // Extend the SimpleMarkdown link parser to make the link
  // zero-rating-friendly if necessary. No changes will be made for
  // non-zero-rated requests, but zero-rated requests will be re-pointed at
  // either the zero-rated version of khanacademy.org or the external link
  // warning interstitial. We also replace the default <a /> tag with a custom
  // element, if necessary.
  link: _$1G.extend({}, SimpleMarkdown$2.defaultRules.link, {
    react: function react(node, output, state) {
      var link = SimpleMarkdown$2.defaultRules.link.react(node, output, state);
      var href = link.props.href; // TODO(charlie): Move this logic out of Perseus and into webapp via
      // the <Link /> component that is now injected as a dependency.

      if (typeof KA !== "undefined" && KA.isZeroRated) {
        if (href.match(/https?:\/\/[^\/]*khanacademy.org/)) {
          href = href.replace("khanacademy.org", "zero.khanacademy.org");
        } else {
          href = "/zero/external-link?url=" + encodeURIComponent(href);
        }
      }

      var newProps = _objectSpread2(_objectSpread2({}, link.props), {}, {
        href
      });

      if (state.baseElements && state.baseElements.Link) {
        return state.baseElements.Link(newProps);
      } else {
        return /*#__PURE__*/_react__default["default"].cloneElement(link, newProps);
      }
    }
  }),
  codeBlock: _$1G.extend({}, SimpleMarkdown$2.defaultRules.codeBlock, {
    react: (node, output, state) => {
      // ideally this should be a different rule, with only an
      // output function, but right now that breaks the parser.
      if (node.lang === "alt") {
        return /*#__PURE__*/_react__default["default"].createElement("div", {
          key: state.key,
          className: "perseus-markdown-alt perseus-sr-only"
        }, output(node.content, state));
      } else {
        return SimpleMarkdown$2.defaultRules.codeBlock.react(node, output, state);
      }
    }
  }),
  list: _$1G.extend({}, SimpleMarkdown$2.defaultRules.list, {
    match: (source, state, prevCapture) => {
      // Since lists can contain double newlines and we have special
      // handling of double newlines while parsing jipt content, just
      // disable the list parser.
      if (state.isJipt) {
        return null;
      } else {
        return SimpleMarkdown$2.defaultRules.list.match(source, state, prevCapture);
      }
    }
  }),
  // The lint rule never actually matches anything.
  // We check for lint after parsing, and, if we find any, we
  // transform the tree to add lint nodes. This rule is here
  // just for the react() function
  lint: {
    order: 1000,
    match: s => null,
    parse: (capture, _parse9, state) => ({}),
    react: (node, output, state) => {
      return /*#__PURE__*/_react__default["default"].createElement(Lint, {
        message: node.message,
        ruleName: node.ruleName,
        inline: isInline(node.content),
        insideTable: node.insideTable,
        severity: node.severity
      }, output(node.content, state));
    }
  }
}); // Return true if the specified parse tree node represents inline content
// and false otherwise. We need this so that lint nodes can figure out whether
// they should behave as an inline wrapper or a block wrapper


function isInline(node) {
  return !!(node && node.type && inlineNodeTypes.hasOwnProperty(node.type));
}

var inlineNodeTypes = {
  text: true,
  math: true,
  unescapedDollar: true,
  link: true,
  img: true,
  strong: true,
  u: true,
  em: true,
  del: true,
  code: true
};
var builtParser$1 = SimpleMarkdown$2.parserFor(rules$1);

var parse$3 = (source, state) => {
  var paragraphedSource = source + "\n\n";
  return builtParser$1(paragraphedSource, _$1G.extend({
    inline: false
  }, state));
};

var inlineParser = (source, state) => {
  return builtParser$1(source, _$1G.extend({
    inline: true
  }, state));
};
/**
 * Traverse all of the nodes in the Perseus Markdown AST. The callback is
 * called for each node in the AST.
 */


var traverseContent = (ast, cb) => {
  if (_$1G.isArray(ast)) {
    _$1G.each(ast, node => traverseContent(node, cb));
  } else if (_$1G.isObject(ast)) {
    cb(ast);

    if (ast.type === "table") {
      traverseContent(ast.header, cb);
      traverseContent(ast.cells, cb);
    } else if (ast.type === "list") {
      traverseContent(ast.items, cb);
    } else if (ast.type === "titledTable") {
      traverseContent(ast.table, cb);
    } else if (ast.type === "columns") {
      traverseContent(ast.col1, cb);
      traverseContent(ast.col2, cb);
    } else if (_$1G.isArray(ast.content)) {
      traverseContent(ast.content, cb);
    }
  }
};
/**
 * Pull out text content from a Perseus Markdown AST.
 * Returns an array of strings.
 */


var getContent = ast => {
  // Simplify logic by dealing with a single AST node at a time
  if (_$1G.isArray(ast)) {
    return _$1G.flatten(_$1G.map(ast, getContent));
  } // Base case: This is where we actually extract text content


  if (ast.content && _$1G.isString(ast.content)) {
    // Collapse whitespace within content unless it is code
    if (ast.type.toLowerCase().indexOf("code") !== -1) {
      // In case this is the sole child of a paragraph,
      // prevent whitespace from being trimmed later
      return ["", ast.content, ""];
    } else {
      return [ast.content.replace(/\s+/g, " ")];
    }
  } // Recurse through child AST nodes
  // Assumptions made:
  // 1) Child AST nodes are either direct properties or inside
  //    arbitrarily nested lists that are direct properties.
  // 2) Only AST nodes have a 'type' property.


  var children = _$1G.chain(ast).values().flatten().filter(object => object != null && _$1G.has(object, "type")).value();

  if (!children.length) {
    return [];
  } else {
    var nestedContent = getContent(children);

    if (ast.type === "paragraph" && nestedContent.length) {
      // Trim whitespace before or after a paragraph
      nestedContent[0] = nestedContent[0].replace(/^\s+/, "");
      var last = nestedContent.length - 1;
      nestedContent[last] = nestedContent[last].replace(/\s+$/, "");
    }

    return nestedContent;
  }
};
/**
 * Count the number of characters in Perseus Markdown source.
 * Markdown markup and widget references are ignored.
 */


var characterCount = source => {
  var ast = parse$3(source);
  var content = getContent(ast).join("");
  return content.length;
};

_module_$2C.exports = {
  characterCount: characterCount,
  traverseContent: traverseContent,
  parse: parse$3,
  parseInline: inlineParser,
  reactFor: SimpleMarkdown$2.reactFor,
  ruleOutput: SimpleMarkdown$2.ruleOutput(rules$1, "react"),
  basicOutput: SimpleMarkdown$2.reactFor(SimpleMarkdown$2.ruleOutput(rules$1, "react")),
  sanitizeUrl: SimpleMarkdown$2.sanitizeUrl
};
var _perseusMarkdownJsx = _module_$2C.exports;

// This is the TreeTransformer class described in detail at the
// top of this file.
class TreeTransformer {
  // To create a tree transformer, just pass the root node of the tree
  constructor(root) {
    this.root = root;
  } // A utility function for determing whether an arbitrary value is a node


  static isNode(n) {
    return n && typeof n === "object" && typeof n.type === "string";
  } // Determines whether a value is a node with type "text" and has
  // a text-valued `content` property.


  static isTextNode(n) {
    return TreeTransformer.isNode(n) && n.type === "text" && typeof n.content === "string";
  } // This is the main entry point for the traverse() method. See the comment
  // at the top of this file for a detailed description. Note that this
  // method just creates a new TraversalState object to use for this
  // traversal and then invokes the internal _traverse() method to begin the
  // recursion.


  traverse(f) {
    this._traverse(this.root, new TraversalState(this.root), f);
  } // Do a post-order traversal of node and its descendants, invoking the
  // callback function f() once for each node and returning the concatenated
  // text content of the node and its descendants. f() is passed three
  // arguments: the current node, a TraversalState object representing the
  // current state of the traversal, and a string that holds the
  // concatenated text of the node and its descendants.
  //
  // This private method holds all the traversal logic and implementation
  // details. Note that this method uses the TraversalState object to store
  // information about the structure of the tree.


  _traverse(n, state, f) {
    var content = "";

    if (TreeTransformer.isNode(n)) {
      // If we were called on a node object, then we handle it
      // this way.
      var node = n; // safe cast; we just tested
      // Put the node on the stack before recursing on its children

      state._containers.push(node);

      state._ancestors.push(node); // Record the node's text content if it has any.
      // Usually this is for nodes with a type property of "text",
      // but other nodes types like "math" may also have content.


      if (typeof node.content === "string") {
        content = node.content;
      } // Recurse on the node. If there was content above, then there
      // probably won't be any children to recurse on, but we check
      // anyway.
      //
      // If we wanted to make the traversal completely specific to the
      // actual Perseus parse trees that we'll be dealing with we could
      // put a switch statement here to dispatch on the node type
      // property with specific recursion steps for each known type of
      // node.


      var keys = Object.keys(node);
      keys.forEach(key => {
        // Never recurse on the type property
        if (key === "type") {
          return;
        } // Ignore properties that are null or primitive and only
        // recurse on objects and arrays. Note that we don't do a
        // isNode() check here. That is done in the recursive call to
        // _traverse(). Note that the recursive call on each child
        // returns the text content of the child and we add that
        // content to the content for this node. Also note that we
        // push the name of the property we're recursing over onto a
        // TraversalState stack.


        var value = node[key];

        if (value && typeof value === "object") {
          state._indexes.push(key);

          content += this._traverse(value, state, f);

          state._indexes.pop();
        }
      }); // Restore the stacks after recursing on the children

      state._currentNode = state._ancestors.pop();

      state._containers.pop(); // And finally call the traversal callback for this node.  Note
      // that this is post-order traversal. We call the callback on the
      // way back up the tree, not on the way down.  That way we already
      // know all the content contained within the node.


      f(node, state, content);
    } else if (Array.isArray(n)) {
      // If we were called on an array instead of a node, then
      // this is the code we use to recurse.
      var nodes = n; // Push the array onto the stack. This will allow the
      // TraversalState object to locate siblings of this node.

      state._containers.push(nodes); // Now loop through this array and recurse on each element in it.
      // Before recursing on an element, we push its array index on a
      // TraversalState stack so that the TraversalState sibling methods
      // can work. Note that TraversalState methods can alter the length
      // of the array, and change the index of the current node, so we
      // are careful here to test the array length on each iteration and
      // to reset the index when we pop the stack. Also note that we
      // concatentate the text content of the children.


      var index = 0;

      while (index < nodes.length) {
        state._indexes.push(index);

        content += this._traverse(nodes[index], state, f); // Casting to convince Flow that this is a number

        index = state._indexes.pop() + 1;
      } // Pop the array off the stack. Note, however, that we do not call
      // the traversal callback on the array. That function is only
      // called for nodes, not arrays of nodes.


      state._containers.pop();
    } // The _traverse() method always returns the text content of
    // this node and its children. This is the one piece of state that
    // is not tracked in the TraversalState object.


    return content;
  }

} // An instance of this class is passed to the callback function for
// each node traversed. The class itself is not exported, but its
// methods define the API available to the traversal callback.

/**
 * This class represents the state of a tree traversal. An instance is created
 * by the traverse() method of the TreeTransformer class to maintain the state
 * for that traversal, and the instance is passed to the traversal callback
 * function for each node that is traversed. This class is not intended to be
 * instantiated directly, but is exported so that its type can be used for
 * Flow annotaions.
 **/

class TraversalState {
  // The constructor just stores the root node and creates empty stacks.
  constructor(root) {
    this.root = root; // When the callback is called, this property will hold the
    // node that is currently being traversed.

    this._currentNode = null; // This is a stack of the objects and arrays that we've
    // traversed through before reaching the currentNode.
    // It is different than the ancestors array.

    this._containers = new Stack(); // This stack has the same number of elements as the _containers
    // stack. The last element of this._indexes[] is the index of
    // the current node in the object or array that is the last element
    // of this._containers[]. If the last element of this._containers[] is
    // an array, then the last element of this stack will be a number.
    // Otherwise if the last container is an object, then the last index
    // will be a string property name.

    this._indexes = new Stack(); // This is a stack of the ancestor nodes of the current one.
    // It is different than the containers[] stack because it only
    // includes nodes, not arrays.

    this._ancestors = new Stack();
  }
  /**
   * Return the current node in the traversal. Any time the traversal
   * callback is called, this method will return the name value as the
   * first argument to the callback.
   */


  currentNode() {
    return this._currentNode || this.root;
  }
  /**
   * Return the parent of the current node, if there is one, or null.
   */


  parent() {
    return this._ancestors.top();
  }
  /**
   * Return an array of ancestor nodes. The first element of this array is
   * the same as this.parent() and the last element is the root node. If we
   * are currently at the root node, the the returned array will be empty.
   * This method makes a copy of the internal state, so modifications to the
   * returned array have no effect on the traversal.
   */


  ancestors() {
    return this._ancestors.values();
  }
  /**
   * Return the next sibling of this node, if it has one, or null otherwise.
   */


  nextSibling() {
    var siblings = this._containers.top(); // If we're at the root of the tree or if the parent is an
    // object instead of an array, then there are no siblings.


    if (!siblings || !Array.isArray(siblings)) {
      return null;
    } // The top index is a number because the top container is an array


    var index = this._indexes.top();

    if (siblings.length > index + 1) {
      return siblings[index + 1];
    } else {
      return null; // There is no next sibling
    }
  }
  /**
   * Return the previous sibling of this node, if it has one, or null
   * otherwise.
   */


  previousSibling() {
    var siblings = this._containers.top(); // If we're at the root of the tree or if the parent is an
    // object instead of an array, then there are no siblings.


    if (!siblings || !Array.isArray(siblings)) {
      return null;
    } // The top index is a number because the top container is an array


    var index = this._indexes.top();

    if (index > 0) {
      return siblings[index - 1];
    } else {
      return null; // There is no previous sibling
    }
  }
  /**
   * Remove the next sibling node (if there is one) from the tree.  Returns
   * the removed sibling or null. This method makes it easy to traverse a
   * tree and concatenate adjacent text nodes into a single node.
   */


  removeNextSibling() {
    var siblings = this._containers.top();

    if (siblings && Array.isArray(siblings)) {
      // top index is a number because top container is an array
      var index = this._indexes.top();

      if (siblings.length > index + 1) {
        return siblings.splice(index + 1, 1)[0];
      }
    }

    return null;
  }
  /**
   * Replace the current node in the tree with the specified nodes.  If no
   * nodes are passed, this is a node deletion. If one node (or array) is
   * passed, this is a 1-for-1 replacement. If more than one node is passed
   * then this is a combination of deletion and insertion.  The new node or
   * nodes will not be traversed, so this method can safely be used to
   * reparent the current node node beneath a new parent.
   *
   * This method throws an error if you attempt to replace the root node of
   * the tree.
   */


  replace() {
    var parent = this._containers.top();

    if (!parent) {
      throw new Error("Can't replace the root of the tree");
    } // The top of the container stack is either an array or an object
    // and the top of the indexes stack is a corresponding array index
    // or object property. This is hard for Flow, so we have to do some
    // unsafe casting and be careful when we use which cast version


    var parentIsArray = Array.isArray(parent);
    var array = parent;

    var index = this._indexes.top();

    var object = parent;

    var property = this._indexes.top();

    for (var _len = arguments.length, replacements = new Array(_len), _key = 0; _key < _len; _key++) {
      replacements[_key] = arguments[_key];
    }

    if (parentIsArray) {
      // For an array parent we just splice the new nodes in
      array.splice(index, 1, ...replacements); // Adjust the index to account for the changed array length.
      // We don't want to traverse any of the newly inserted nodes.

      this._indexes.pop();

      this._indexes.push(index + replacements.length - 1);
    } else {
      // For an object parent we care how many new nodes there are
      if (replacements.length === 0) {
        // Deletion
        delete object[property];
      } else if (replacements.length === 1) {
        // Replacement
        object[property] = replacements[0];
      } else {
        // Replace one node with an array of nodes
        object[property] = replacements;
      }
    }
  }
  /**
   * Returns true if the current node has a previous sibling and false
   * otherwise. If this method returns false, then previousSibling() will
   * return null, and goToPreviousSibling() will throw an error.
   */


  hasPreviousSibling() {
    return Array.isArray(this._containers.top()) && this._indexes.top() > 0;
  }
  /**
   * Modify this traversal state object to have the state it would have had
   * when visiting the previous sibling. Note that you may want to use
   * clone() to make a copy before modifying the state object like this.
   * This mutator method is not typically used during ordinary tree
   * traversals, but is used by the Selector class for matching multi-node
   * selectors.
   */


  goToPreviousSibling() {
    if (!this.hasPreviousSibling()) {
      throw new Error("goToPreviousSibling(): node has no previous sibling");
    }

    this._currentNode = this.previousSibling(); // Since we know that we have a previous sibling, we know that
    // the value on top of the stack is a number, but we have to do
    // this unsafe cast because Flow doesn't know that.

    var index = this._indexes.pop();

    this._indexes.push(index - 1);
  }
  /**
   * Returns true if the current node has an ancestor and false otherwise.
   * If this method returns false, then the parent() method will return
   * null and goToParent() will throw an error
   */


  hasParent() {
    return this._ancestors.size() !== 0;
  }
  /**
   * Modify this object to look like it will look when we (later) visit the
   * parent node of this node. You should not modify the instance passed to
   * the tree traversal callback. Instead, make a copy with the clone()
   * method and modify that.  This mutator method is not typically used
   * during ordinary tree traversals, but is used by the Selector class for
   * matching multi-node selectors that involve parent and ancestor
   * selectors.
   */


  goToParent() {
    if (!this.hasParent()) {
      throw new Error("goToParent(): node has no ancestor");
    }

    this._currentNode = this._ancestors.pop(); // We need to pop the containers and indexes stacks at least once
    // and more as needed until we restore the invariant that
    // this._containers.top()[this.indexes.top()] === this._currentNode
    //

    while (this._containers.size() && // This is safe, but easier to just disable flow than do casts
    // $FlowFixMe
    this._containers.top()[this._indexes.top()] !== this._currentNode) {
      this._containers.pop();

      this._indexes.pop();
    }
  }
  /**
   * Return a new TraversalState object that is a copy of this one.
   * This method is useful in conjunction with the mutating methods
   * goToParent() and goToPreviousSibling().
   */


  clone() {
    var clone = new TraversalState(this.root);
    clone._currentNode = this._currentNode;
    clone._containers = this._containers.clone();
    clone._indexes = this._indexes.clone();
    clone._ancestors = this._ancestors.clone();
    return clone;
  }
  /**
   * Returns true if this TraversalState object is equal to that
   * TraversalState object, or false otherwise. This method exists
   * primarily for use by our unit tests.
   */


  equals(that) {
    return this.root === that.root && this._currentNode === that._currentNode && this._containers.equals(that._containers) && this._indexes.equals(that._indexes) && this._ancestors.equals(that._ancestors);
  }

}
/**
 * This class is an internal utility that just treats an array as a stack
 * and gives us a top() method so we don't have to write expressions like
 * `ancestors[ancestors.length-1]`. The values() method automatically
 * copies the internal array so we don't have to worry about client code
 * modifying our internal stacks. The use of this Stack abstraction makes
 * the TraversalState class simpler in a number of places.
 */

class Stack {
  constructor(array) {
    this.stack = array ? array.slice(0) : [];
  }
  /** Push a value onto the stack. */


  push(v) {
    this.stack.push(v);
  }
  /** Pop a value off of the stack. */


  pop() {
    return this.stack.pop();
  }
  /** Return the top value of the stack without popping it. */


  top() {
    return this.stack[this.stack.length - 1];
  }
  /** Return a copy of the stack as an array */


  values() {
    return this.stack.slice(0);
  }
  /** Return the number of elements in the stack */


  size() {
    return this.stack.length;
  }
  /** Return a string representation of the stack */


  toString() {
    return this.stack.toString();
  }
  /** Return a shallow copy of the stack */


  clone() {
    return new Stack(this.stack);
  }
  /**
   * Compare this stack to another and return true if the contents of
   * the two arrays are the same.
   */


  equals(that) {
    if (!that || !that.stack || that.stack.length !== this.stack.length) {
      return false;
    }

    for (var i = 0; i < this.stack.length; i++) {
      if (this.stack[i] !== that.stack[i]) {
        return false;
      }
    }

    return true;
  }

}

var _module_$2B = {
  exports: {}
};

var allLintRules = _rulesAllRulesJs.filter(r => r.severity < Rule.Severity.BULK_WARNING); //
// Run the Gorgon linter over the specified markdown parse tree,
// with the specified context object, and
// return a (possibly empty) array of lint warning objects.  If the
// highlight argument is true, this function also modifies the parse
// tree to add "lint" nodes that can be visually rendered,
// highlighting the problems for the user. The optional rules argument
// is an array of Rule objects specifying which lint rules should be
// applied to this parse tree. When omitted, a default set of rules is used.
//
// The context object may have additional properties that some lint
// rules require:
//
//   context.content is the source content string that was parsed to create
//   the parse tree.
//
//   context.widgets is the widgets object associated
//   with the content string
//
// TODO: to make this even more general, allow the first argument to be
// a string and run the parser over it in that case? (but ignore highlight
// in that case). This would allow the one function to be used for both
// online linting and batch linting.
//


function runLinter(tree, context, highlight, rules) {
  rules = rules || allLintRules;
  var warnings = [];
  var tt = new TreeTransformer(tree); // The markdown parser often outputs adjacent text nodes. We
  // coalesce them before linting for efficiency and accuracy.

  tt.traverse((node, state, content) => {
    if (TreeTransformer.isTextNode(node)) {
      var next = state.nextSibling();

      while (TreeTransformer.isTextNode(next)) {
        node.content += next.content;
        state.removeNextSibling();
        next = state.nextSibling();
      }
    }
  }); // HTML tables are complicated, and the CSS we use in
  // ../components/lint.jsx to display lint does not work to
  // correctly position the lint indicators in the margin when the
  // lint is inside a table. So as a workaround we keep track of all
  // the lint that appears within a table and move it up to the
  // table element itself.
  //
  // It is not ideal to have to do this here,
  // but it is cleaner here than fixing up the lint during rendering
  // in perseus-markdown.jsx. If our lint display was simpler and
  // did not require indicators in the margin, this wouldn't be a
  // problem. Or, if we modified the lint display stuff so that
  // indicator positioning and tooltip display were both handled
  // with JavaScript (instead of pure CSS), then we could avoid this
  // issue too. But using JavaScript has its own downsides: there is
  // risk that the linter JavaScript would interfere with
  // widget-related Javascript.

  var tableWarnings = [];
  var insideTable = false; // Traverse through the nodes of the parse tree. At each node, loop
  // through the array of lint rules and check whether there is a
  // lint violation at that node.

  tt.traverse((node, state, content) => {
    var nodeWarnings = []; // If our rule is only designed to be tested against a particular
    // content type and we're not in that content type, we don't need to
    // consider that rule.

    var applicableRules = rules.filter(r => r.applies(context)); // Generate a stack so we can identify our position in the tree in
    // lint rules

    var stack = [...context.stack];
    stack.push(node.type);

    var nodeContext = _objectSpread2(_objectSpread2({}, context), {}, {
      stack: stack.join('.')
    });

    applicableRules.forEach(rule => {
      var warning = rule.check(node, state, content, nodeContext);

      if (warning) {
        // The start and end locations are relative to this
        // particular node, and so are not generally very useful.
        // TODO: When the markdown parser saves the node
        // locations in the source string then we can add
        // these numbers to that one and get and absolute
        // character range that will be useful
        if (warning.start || warning.end) {
          warning.target = content.substring(warning.start, warning.end);
        } // Add the warning to the list of all lint we've found


        warnings.push(warning); // If we're going to be highlighting lint, then we also
        // need to keep track of warnings specific to this node.

        if (highlight) {
          nodeWarnings.push(warning);
        }
      }
    }); // If we're not highlighting lint in the tree, then we're done
    // traversing this node.

    if (!highlight) {
      return;
    } // If the node we are currently at is a table, and there was lint
    // inside the table, then we want to add that lint here


    if (node.type === "table") {
      if (tableWarnings.length) {
        nodeWarnings.push(...tableWarnings);
      } // We're not in a table anymore, and don't have to remember
      // the warnings for the table


      insideTable = false;
      tableWarnings = [];
    } else if (!insideTable) {
      // Otherwise, if we are not already inside a table, check
      // to see if we've entered one. Because this is a post-order
      // traversal we'll see the table contents before the table itself.
      // Note that once we're inside the table, we don't have to
      // do this check each time... We can just wait until we ascend
      // up to the table, then we'll know we're out of it.
      insideTable = state.ancestors().some(n => n.type === "table");
    } // If we are inside a table and there were any warnings on
    // this node, then we need to save the warnings for display
    // on the table itself


    if (insideTable && nodeWarnings.length) {
      tableWarnings.push(...nodeWarnings);
    } // If there were any warnings on this node, and if we're highlighting
    // lint, then reparent the node so we can highlight it. Note that
    // a single node can have multiple warnings. If this happends we
    // concatenate the warnings and newline separate them. (The lint.jsx
    // component that displays the warnings may want to convert the
    // newlines into <br> tags.) We also provide a lint rule name
    // so that lint.jsx can link to a document that provides more details
    // on that particular lint rule. If there is more than one warning
    // we only link to the first rule, however.
    //
    // Note that even if we're inside a table, we still reparent the
    // linty node so that it can be highlighted. We just make a note
    // of whether this lint is inside a table or not.


    if (nodeWarnings.length) {
      nodeWarnings.sort((a, b) => {
        return a.severity - b.severity;
      });

      if (node.type !== "text" || nodeWarnings.length > 1) {
        // If the linty node is not a text node, or if there is more
        // than one warning on a text node, then reparent the entire
        // node under a new lint node and put the warnings there.
        state.replace({
          type: "lint",
          content: node,
          message: nodeWarnings.map(w => w.message).join("\n\n"),
          ruleName: nodeWarnings[0].rule,
          insideTable: insideTable,
          severity: nodeWarnings[0].severity
        });
      } else {
        //
        // Otherwise, it is a single warning on a text node, and we
        // only want to highlight the actual linty part of that string
        // of text. So we want to replace the text node with (in the
        // general case) three nodes:
        //
        // 1) A new text node that holds the non-linty prefix
        //
        // 2) A lint node that is the parent of a new text node
        // that holds the linty part
        //
        // 3) A new text node that holds the non-linty suffix
        //
        // If the lint begins and/or ends at the boundaries of the
        // original text node, then nodes 1 and/or 3 won't exist, of
        // course.
        //
        // Note that we could generalize this to work with multple
        // warnings on a text node as long as the warnings are
        // non-overlapping. Hopefully, though, multiple warnings in a
        // single text node will be rare in practice. Also, we don't
        // have a good way to display multiple lint indicators on a
        // single line, so keeping them combined in that case might
        // be the best thing, anyway.
        //
        var _content = node.content; // Text nodes have content

        var warning = nodeWarnings[0]; // There is only one warning.
        // These are the lint boundaries within the content

        var start = warning.start || 0;
        var end = warning.end || _content.length;

        var prefix = _content.substring(0, start);

        var lint = _content.substring(start, end);

        var suffix = _content.substring(end);

        var replacements = []; // What we'll replace the node with
        // The prefix text node, if there is one

        if (prefix) {
          replacements.push({
            type: "text",
            content: prefix
          });
        } // The lint node wrapped around the linty text


        replacements.push({
          type: "lint",
          content: {
            type: "text",
            content: lint
          },
          message: warning.message,
          ruleName: warning.rule,
          insideTable: insideTable,
          severity: warning.severity
        }); // The suffix node, if there is one

        if (suffix) {
          replacements.push({
            type: "text",
            content: suffix
          });
        } // Now replace the lint text node with the one to three
        // nodes in the replacement array


        state.replace(...replacements);
      }
    }
  });
  return warnings;
}

function pushContextStack(context, name) {
  var stack = context.stack || [];
  return _objectSpread2(_objectSpread2({}, context), {}, {
    stack: stack.concat(name)
  });
} //
// TODO(davidflanagan):
// Revisit these exports once we've got gorgon integrated into Perseus.
// Do we really need to export all of these things, or can we export a
// smaller set of functionality to enable both bulk linting by tools/gorgon.js
// and online linting?
//
// TODO(davidflanagan): switch from require to import
//


_module_$2B.exports = {
  runLinter,
  parse: _perseusMarkdownJsx.parse,
  pushContextStack,
  rules: allLintRules
};
var _gorgonGorgonJs = _module_$2B.exports;

var _module_$2A = {
  exports: {}
};
/**
 * Preprocess TeX code to convert things that KaTeX doesn't know how to handle
 * to things is does.
 */

_module_$2A.exports = texCode => texCode // Replace uses of \begin{align}...\end{align} which KaTeX doesn't
// support (yet) with \begin{aligned}...\end{aligned} which renders
// the same is supported by KaTeX.  It does the same for align*.
// TODO(kevinb) update content to use aligned instead of align.
.replace(/\{align[*]?\}/g, "{aligned}") // Replace non-breaking spaces with regular spaces.
.replace(/[\u00a0]/g, " ");

var _utilKatexPreprocessJs = _module_$2A.exports;

var _module_$2z = {
  exports: {}
};
/**
 * Simple version of jQuery's Deferred.
 */

class Deferred$2 {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }

  then(callback) {
    return this.promise.then(callback);
  }

}

_module_$2z.exports = Deferred$2;
var _deferredJs = _module_$2z.exports;

var _module_$2y = {
  exports: {}
};
/**
 * Zooms child to fit with tap-to-zoom behavior.
 */

var React$2b = _react__default["default"];
var ReactDOM$C = _reactDom__default["default"];
var Deferred$1 = _deferredJs;
var Zoomable$1 = createReactClass({
  displayName: "Zoomable",
  propTypes: {
    animateHeight: PropTypes.bool,
    children: PropTypes.element.isRequired,

    /**
     * Optional function that allows customizations in zooming.
     *
     * Defaults to just using the bounding client rect of the first DOM
     * element of this component.
     *
     * @return {Object} bounds object with `width` and `height` properties
     */
    computeChildBounds: PropTypes.func,
    // If this prop is specified, we wait until the deferred is resolved
    // before measuring the child element.  This is necessary in cases
    // where the child size depends on whether or not resources, such as
    // fonts, have been loaded.
    readyToMeasureDeferred: PropTypes.shape({
      then: PropTypes.func.isRequired,
      reject: PropTypes.func.isRequired
    }).isRequired
  },

  getDefaultProps() {
    var deferred = new Deferred$1();
    deferred.resolve();
    return {
      animateHeight: false,
      readyToMeasureDeferred: deferred,
      computeChildBounds: parentNode => {
        var firstChild = parentNode.firstElementChild;
        return {
          // The +1 is a fudge factor to make sure any border on the
          // content isn't clipped by the the container it's in.
          width: firstChild.offsetWidth + 1,
          height: firstChild.offsetHeight + 1
        };
      }
    };
  },

  getInitialState() {
    return {
      visible: false,
      marginBottomPx: 0,
      zoomed: true
    };
  },

  componentDidMount() {
    this._node = ReactDOM$C.findDOMNode(this);
    this.props.readyToMeasureDeferred.then(() => {
      if (this.isMounted()) {
        this.scaleChildToFit(false);

        if (window.MutationObserver) {
          this._observer = new MutationObserver(mutations => {
            if (this.isMounted()) {
              for (var mutation of mutations) {
                if (mutation.target !== this._node) {
                  // Only act on mutations of children
                  this.scaleChildToFit(this.state.zoomed);
                  break;
                }
              }
            }
          });

          this._observer.observe(this._node, {
            childList: true,
            subtree: true,
            attributes: true
          });
        }

        window.addEventListener("resize", this.reset);
      }
    });
  },

  componentWillUnmount() {
    window.removeEventListener("resize", this.reset);

    if (this._observer) {
      this._observer.disconnect();
    }
  },

  reset() {
    if (!this.isMounted()) {
      return;
    }

    if (!this.state.visible) {
      return;
    }

    this._originalWidth = null;
    this.setState({
      visible: false,
      compactHeight: null,
      expandedHeight: null,
      zoomed: true
    }, () => {
      this.scaleChildToFit(false);
    });
  },

  stopPropagationIfZoomed(e) {
    if (!this.state.zoomed) {
      // We only allow touch events (which trigger interactive elements)
      // to be propagated to children if we are already zoomed.
      e.stopPropagation();
    }
  },

  // TODO(benkomalo): call this on viewport width changes?
  // https://github.com/Khan/math-input/blob/master/src/components/math-keypad.js#L43
  scaleChildToFit(zoomed) {
    var parentBounds = {
      width: this._node.offsetWidth,
      height: this._node.offsetHeight
    };
    var childBounds = this.props.computeChildBounds(this._node, parentBounds);
    var childWidth = childBounds.width;
    var childHeight = childBounds.height;

    if (childWidth > parentBounds.width) {
      var scale = parentBounds.width / childWidth;
      this.setState({
        scale: scale,
        zoomed: zoomed,
        compactHeight: Math.ceil(scale * childHeight),
        expandedHeight: childHeight
      }); // TODO(charlie): Do this as a callback to `setState`. Something is
      // going wrong with that approach in initial testing.

      setTimeout(() => {
        // Only show it after the next paint, to allow for CSS
        // transitions to fade it in.
        if (this.isMounted()) {
          this.setState({
            visible: true
          });
        }
      });
    } else {
      this.setState({
        visible: true
      });
    }
  },

  handleClickIfZoomed(e) {
    if (!this.state.zoomed) {
      e.stopPropagation();
      this.handleClick();
    }
  },

  handleClick() {
    this.setState({
      zoomed: !this.state.zoomed
    });
  },

  render() {
    var {
      visible,
      scale,
      compactHeight,
      expandedHeight,
      zoomed
    } = this.state;
    var {
      animateHeight
    } = this.props;
    var property = animateHeight ? "opacity transform height" : "opacity transform"; // Since we're not using aphrodite, we have to prefix ourselves.

    /* eslint-disable indent */

    var transitionStyle = visible ? {
      transitionProperty: property,
      WebkitTransitionProperty: property,
      msTransitionProperty: property,
      transitionDuration: "0.3s",
      WebkitTransitionDuration: "0.3s",
      msTransitionDuration: "0.3s",
      transitionTimingFunction: "ease-out",
      WebkitTransitionTimingfunction: "ease-out",
      msTransitionTmingFunction: "ease-out"
    } : {};
    /* eslint-enable indent */
    // Do a fancy little slide as we fade the contents in the first time.

    var translateOffset = visible ? "" : " translate(0, 8px)";
    var transform = zoomed ? "scale(1, 1) ".concat(translateOffset) : "scale(".concat(scale, ", ").concat(scale, ") ").concat(translateOffset);

    var style = _objectSpread2({
      display: "block",
      width: "100%",
      height: zoomed ? expandedHeight : compactHeight,
      transform: transform,
      WebkitTransform: transform,
      msTransform: transform,
      transformOrigin: "0 0",
      WebkitTransformOrigin: "0 0",
      msTransformOrigin: "0 0",
      opacity: visible ? 1 : 0,
      WebkitTapHighlightColor: "transparent"
    }, transitionStyle);

    return /*#__PURE__*/React$2b.createElement("span", {
      onClick: this.handleClick,
      onClickCapture: this.handleClickIfZoomed,
      onTouchCancelCapture: this.stopPropagationIfZoomed,
      onTouchEndCapture: this.stopPropagationIfZoomed,
      onTouchStartCapture: this.stopPropagationIfZoomed,
      style: style
    }, this.props.children);
  }

});
_module_$2y.exports = Zoomable$1;
var _componentsZoomableJsx = _module_$2y.exports;

var _module_$2x = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types, react/sort-comp */

var React$2a = _react__default["default"];
var ReactDOM$B = _reactDom__default["default"];
var _$1F = _underscore__default["default"];
var textWidthCache = {};

function getTextWidth(text) {
  if (!textWidthCache[text]) {
    // Hacky way to guess the width of an input box
    var $test = $("<span>").text(text).appendTo("body");
    textWidthCache[text] = $test.width() + 5;
    $test.remove();
  }

  return textWidthCache[text];
}

var TextListEditor$6 = createReactClass({
  displayName: "TextListEditor",
  propTypes: {
    options: PropTypes.array,
    layout: PropTypes.string,
    onChange: PropTypes.func.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return {
      options: [],
      layout: "horizontal"
    };
  },
  getInitialState: function getInitialState() {
    return {
      items: this.props.options.concat("")
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      items: nextProps.options.concat("")
    });
  },
  render: function render() {
    var className = ["perseus-text-list-editor", "perseus-clearfix", "layout-" + this.props.layout].join(" ");

    var inputs = _$1F.map(this.state.items, function (item, i) {
      return /*#__PURE__*/React$2a.createElement("li", {
        key: i
      }, /*#__PURE__*/React$2a.createElement("input", {
        ref: "input_" + i,
        type: "text",
        value: item,
        onChange: this.onChange.bind(this, i),
        onKeyDown: this.onKeyDown.bind(this, i),
        style: {
          width: getTextWidth(item)
        }
      }));
    }, this);

    return /*#__PURE__*/React$2a.createElement("ul", {
      className: className
    }, inputs);
  },
  onChange: function onChange(index, event) {
    var items = _$1F.clone(this.state.items);

    items[index] = event.target.value;

    if (index === items.length - 1) {
      items = items.concat("");
    }

    this.setState({
      items: items
    });
    this.props.onChange(_$1F.compact(items));
  },
  onKeyDown: function onKeyDown(index, event) {
    var which = event.nativeEvent.keyCode; // Backspace deletes an empty input...

    if (which === 8
    /* backspace */
    && this.state.items[index] === "") {
      event.preventDefault();

      var items = _$1F.clone(this.state.items);

      var focusIndex = index === 0 ? 0 : index - 1;

      if (index === items.length - 1 && (index === 0 || items[focusIndex] !== "")) {
        // ...except for the last one, iff it is the only empty
        // input at the end.
        ReactDOM$B.findDOMNode(this.refs["input_" + focusIndex]).focus();
      } else {
        items.splice(index, 1);
        this.setState({
          items: items
        }, function () {
          ReactDOM$B.findDOMNode(this.refs["input_" + focusIndex]).focus();
        });
      } // Deleting the last character in the second-to-last input
      // removes it

    } else if (which === 8
    /* backspace */
    && this.state.items[index].length === 1 && index === this.state.items.length - 2) {
      event.preventDefault();

      var _items = _$1F.clone(this.state.items);

      _items.splice(index, 1);

      this.setState({
        items: _items
      });
      this.props.onChange(_$1F.compact(_items)); // Enter adds an option below the current one...
    } else if (which === 13
    /* enter */
    ) {
      event.preventDefault();

      var _items2 = _$1F.clone(this.state.items);

      var _focusIndex = index + 1;

      if (index === _items2.length - 2) {
        // ...unless the empty input is just below.
        ReactDOM$B.findDOMNode(this.refs["input_" + _focusIndex]).focus();
      } else {
        _items2.splice(_focusIndex, 0, "");

        this.setState({
          items: _items2
        }, function () {
          ReactDOM$B.findDOMNode(this.refs["input_" + _focusIndex]).focus();
        });
      }
    }
  }
});
_module_$2x.exports = TextListEditor$6;
var _componentsTextListEditorJsx = _module_$2x.exports;

var _module_$2w = {
  exports: {}
};
/**
 * Stub Tag Editor.
 *
 * This is stupidly used by Perseus Zero because I didn't implement
 * the <TagEditor> for Perseus Zero (since everyone wants me to
 * delete it anyways).
 *
 * This is a small wrapper for a TextListEditor that allows us to
 * edit raw Tag ID strings in perseus zero (please don't use this).
 *
 * It also gives a nicer interface for the group metadata editor
 * in local demo mode.
 */

var React$29 = _react__default["default"];
var TextListEditor$5 = _componentsTextListEditorJsx;
var EMPTY_ARRAY = [];
var StubTagEditor = createReactClass({
  displayName: "StubTagEditor",
  propTypes: {
    value: PropTypes.arrayOf(PropTypes.string),
    onChange: PropTypes.func.isRequired,
    showTitle: PropTypes.bool.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return {
      value: EMPTY_ARRAY,
      showTitle: true
    };
  },
  render: function render() {
    return /*#__PURE__*/React$29.createElement("div", null, this.props.showTitle && /*#__PURE__*/React$29.createElement("div", {
      style: {
        fontSize: 14
      }
    }, "Tags:"), /*#__PURE__*/React$29.createElement(TextListEditor$5, {
      options: this.props.value || EMPTY_ARRAY,
      layout: "vertical",
      onChange: this.props.onChange
    }));
  }
});
_module_$2w.exports = StubTagEditor;
var StubTagEditor$1 = _module_$2w.exports;

/* eslint-disable brace-style */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * [Most of] the Perseus client API.
 *
 * If making a change to this file, or otherwise to the perseus
 * API, you should increment:
 *  * the perseus api major version if it is a breaking change
 *  * the perseus api minor version if it is an additive-only change
 *  * nothing if it is purely a bug fix.
 *
 * Callbacks passed to Renderer/ItemRenderer:
 *  * onInputError:
 *    Called when there is an error grading a widget
 *  * onFocusChange: (newFocusPath, oldFocusPath, keypadDOMNode)
 *    Called when the user focus changes. The first two parameters are `path`
 *    arrays uniquely identifying the respect inputs. The third parameter,
 *    `keypadDOMNode`, is the DOM node of the custom keypad, or `null` if the
 *    keypad is disabled, which can be used by clients to accommodate for the
 *    appearance of the keypad on the screen.
 *    When focus changes to or from nothing being selected, `path` will be null.
 *  * interactionCallback: Called when the user interacts with a widget.
 *  * answerableCallback: Called with the current `answerability` of the
 *    problem, e.g. whether all required fields have input.
 *  * getAnotherHint: If provided, a button is rendered at the bottom of the
 *    hints (only when at least one hint has been shown, and not all hints
 *    have been shown) allowing the user to take another hint. This function
 *    is then called when the user clicks the button.
 *
 * Stable CSS ClassNames:
 * These are css class names that will continue to preserve their
 * semantic meaning across the same perseus api major version.
 */

var Options = {
  propTypes: PropTypes.shape({
    isArticle: PropTypes.bool.isRequired,
    satStyling: PropTypes.bool.isRequired,
    onInputError: PropTypes.func.isRequired,
    onFocusChange: PropTypes.func.isRequired,
    staticRender: PropTypes.bool.isRequired,
    GroupMetadataEditor: PropTypes.func.isRequired,
    showAlignmentOptions: PropTypes.bool.isRequired,
    readOnly: PropTypes.bool.isRequired,
    answerableCallback: PropTypes.func,
    getAnotherHint: PropTypes.func,
    interactionCallback: PropTypes.func,
    // A function that takes in the relative problem number (starts at
    // 0 and is incremented for each group widget), and the ID of the
    // group widget, then returns a react component that will be added
    // immediately above the renderer in the group widget. If the
    // function returns null, no annotation will be added.
    groupAnnotator: PropTypes.func.isRequired,
    // If imagePlaceholder or widgetPlaceholder are set, perseus will
    // render the placeholder instead of the image or widget node.
    imagePlaceholder: PropTypes.node,
    widgetPlaceholder: PropTypes.node,
    // Base React elements that can be used in place of the standard DOM
    // DOM elements. For example, when provided, <Link /> will be used
    // in place of <a />. This allows clients to provide pre-styled
    // components or components with custom behavior.
    baseElements: PropTypes.shape({
      // The <Link /> component provided here must adhere to the same
      // interface as React's base <a /> component.
      Link: PropTypes.func
    }),
    // Function that takes dimensions and returns a React component
    // to display while an image is loading
    imagePreloader: PropTypes.func,
    // Function that takes an object argument. The object should
    // include type and id, both strings, at least and can optionally
    // include a boolean "correct" value. This is used for keeping
    // track of widget interactions.
    trackInteraction: PropTypes.func,
    // A boolean that indicates whether or not a custom keypad is
    // being used.  For mobile web this will be the ProvidedKeypad
    // component.  In this situation we use the MathInput component
    // from the math-input repo instead of the existing perseus math
    // input components.
    // TODO(charlie): Make this mutually exclusive with `staticRender`.
    // Internally, we defer to `customKeypad` over `staticRender`, but
    // they should really be represented as an enum or some other data
    // structure that forbids them both being enabled at once.
    customKeypad: PropTypes.bool,
    // Indicates whether or not to use mobile styling.
    isMobile: PropTypes.bool,
    // A function, called with a bool indicating whether use of the
    // drawing area (scratchpad) should be allowed/disallowed.
    // Previously handled by `Khan.scratchpad.enable/disable`
    setDrawingAreaAvailable: PropTypes.func,
    // Whether to use the Draft.js editor or the legacy textarea
    useDraftEditor: PropTypes.bool,
    // Styling options that control the visual behavior of Perseus
    // items.
    // TODO(mdr): If we adopt this pattern, we'll need to think about
    //     how to make individual `styling` options be optional, and
    //     how to set their default values without overwriting provided
    //     values. For now, though, you must either specify all fields
    //     of `styling`, or omit the `styling` option entirely.
    styling: PropTypes.shape({
      // Which version of radio widget styles to use in non-SAT
      // contexts.
      //
      // "legacy" was the version of the widget display after XOM but
      // before we started adding MCR styles. It doesn't have support
      // for rationales. It has since been removed.
      //
      // "intermediate" is a design which adds several new additions
      // to the "legacy" styles such as:
      //  1. Using the XOM "desktop" styles (with a visible check icon
      //     and lines in between choices) on mobile devices.
      //  2. Designs for rationales
      //  3. Using the single-select styles for multi-select styles
      //
      // "final" is a design which will build off of the
      // "intermediate" designs and adds some improved designs as well
      // as:
      //  1. a/b/c/d/etc. letters inside of the prompt check box
      //  2. New iconography and styles to indicate choice correctness
      //
      // The "legacy" and "intermediate" designs will be A/B tested
      // against each other to ensure that its changes don't cause
      // problems due to the new designs. Once the "intermediate"
      // designs are finished, they will be A/B tested against the
      // "final" designs.
      //
      // If no flag is provided, "legacy" styles will be shown.
      //
      // TODO(emily): Remove this by Aug 1, 2017, at which point all
      //   callsites should have been switched to using the "final"
      //   designs.
      radioStyleVersion: PropTypes.oneOf(["intermediate", "final"])
    }),
    // The color used for the hint progress indicator (eg. 1 / 3)
    hintProgressColor: PropTypes.string
  }).isRequired,
  defaults: {
    isArticle: false,
    isMobile: false,
    satStyling: false,
    onInputError: function onInputError() {},
    onFocusChange: function onFocusChange() {},
    staticRender: false,
    GroupMetadataEditor: StubTagEditor$1,
    showAlignmentOptions: false,
    readOnly: false,
    groupAnnotator: function groupAnnotator() {
      return null;
    },
    baseElements: {
      Link: props => {
        return /*#__PURE__*/_react__namespace.createElement("a", props);
      }
    },
    setDrawingAreaAvailable: function setDrawingAreaAvailable() {},
    useDraftEditor: false,
    styling: {
      radioStyleVersion: "final"
    }
  }
};
var ClassNames = {
  RENDERER: "perseus-renderer",
  TWO_COLUMN_RENDERER: "perseus-renderer-two-columns",
  RESPONSIVE_RENDERER: "perseus-renderer-responsive",
  INPUT: "perseus-input",
  FOCUSED: "perseus-focused",
  RADIO: {
    OPTION: "perseus-radio-option",
    SELECTED: "perseus-radio-selected",
    OPTION_CONTENT: "perseus-radio-option-content"
  },
  INTERACTIVE: "perseus-interactive",
  CORRECT: "perseus-correct",
  INCORRECT: "perseus-incorrect",
  UNANSWERED: "perseus-unanswered",
  MOBILE: "perseus-mobile"
};
var _perseusApiJsx = {
  Options: Options,
  ClassNames: ClassNames
};

var _module_$2v = {
  exports: {}
};
var ApiOptions$x = _perseusApiJsx.Options;
var ApiOptionsProps$2 = {
  propTypes: {
    // TODO(mdr): Should this actually be objectOf(any)?
    apiOptions: PropTypes.any
  },

  getDefaultProps() {
    return {
      apiOptions: {}
    };
  },

  getApiOptions() {
    return _objectSpread2(_objectSpread2({}, ApiOptions$x.defaults), this.props.apiOptions);
  }

};
_module_$2v.exports = ApiOptionsProps$2;
var _mixinsApiOptionsPropsJs = _module_$2v.exports;

var _module_$2u = {
  exports: {}
};
/* eslint-disable no-console, no-var, space-before-function-paren */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var _$1E = _underscore__default["default"];
var DEFAULT_ALIGNMENT$1 = "block";
var DEFAULT_SUPPORTED_ALIGNMENTS = ["default"];
var DEFAULT_STATIC = false;
var DEFAULT_TRACKING = "";
var DEFAULT_LINTABLE = false;
var widgets = {};
var editors = {};
var Widgets$4 = {
  // Widgets must be registered to avoid circular dependencies with the
  // core Editor and Renderer components.
  register: function register(name, widget, editor) {
    widgets[name] = widget;
    editors[name] = editor;
  },
  registerMany: function registerMany(widgets) {
    widgets.forEach(_ref => {
      var [widget, editor] = _ref;
      widget && this.register(widget.name, widget, editor);
    });
    this.validateAlignments();
  },
  getWidget: function getWidget(name) {
    // TODO(alex): Consider referring to these as renderers to avoid
    // overloading "widget"
    if (!_$1E.has(widgets, name)) {
      return null;
    } // Allow widgets to specify a widget directly or via a function


    if (widgets[name].getWidget) {
      return widgets[name].getWidget();
    } else {
      return widgets[name].widget;
    }
  },
  getEditor: function getEditor(name) {
    return _$1E.has(editors, name) ? editors[name] : null;
  },
  getTransform: function getTransform(name) {
    return _$1E.has(widgets, name) ? widgets[name].transform || _$1E.identity : null;
  },
  getVersion: function getVersion(name) {
    var widgetInfo = widgets[name];

    if (widgetInfo) {
      return widgets[name].version || {
        major: 0,
        minor: 0
      };
    } else {
      return null;
    }
  },
  getVersionVector: function getVersionVector() {
    var version = {};

    _$1E.each(_$1E.keys(widgets), function (name) {
      version[name] = Widgets$4.getVersion(name);
    });

    return version;
  },
  getPublicWidgets: function getPublicWidgets() {
    // TODO(alex): Update underscore.js so that _.pick can take a function.
    return _$1E.pick(widgets, _$1E.reject(_$1E.keys(widgets), function (name) {
      return widgets[name].hidden;
    }));
  },
  isAccessible: function isAccessible(widgetInfo) {
    var accessible = widgets[widgetInfo.type].accessible;

    if (typeof accessible === "function") {
      return accessible(widgetInfo.options);
    } else {
      return !!accessible;
    }
  },
  getAllWidgetTypes: function getAllWidgetTypes() {
    return _$1E.keys(widgets);
  },
  upgradeWidgetInfoToLatestVersion: function upgradeWidgetInfoToLatestVersion(oldWidgetInfo) {
    var type = oldWidgetInfo.type;

    if (!_$1E.isString(type)) {
      throw new Error("widget type must be a string, but was: " + type);
    }

    var widgetExports = widgets[type];

    if (widgetExports == null) {
      // If we have a widget that isn't registered, we can't upgrade it
      // TODO(aria): Figure out what the best thing to do here would be
      return oldWidgetInfo;
    } // Unversioned widgets (pre-July 2014) are all implicitly 0.0


    var initialVersion = oldWidgetInfo.version || {
      major: 0,
      minor: 0
    };
    var latestVersion = widgetExports.version || {
      major: 0,
      minor: 0
    }; // If the widget version is later than what we understand (major
    // version is higher than latest, or major versions are equal and minor
    // version is higher than latest), don't perform any upgrades.

    if (initialVersion.major > latestVersion.major || initialVersion.major === latestVersion.major && initialVersion.minor > latestVersion.minor) {
      return oldWidgetInfo;
    } // We do a clone here so that it's safe to mutate the input parameter
    // in propUpgrades functions (which I will probably accidentally do at
    // some point, and we would like to not break when that happens).


    var newEditorProps = _$1E.clone(oldWidgetInfo.options) || {};
    var upgradePropsMap = widgetExports.propUpgrades || {}; // Empty props usually mean a newly created widget by the editor,
    // and are always considerered up-to-date.
    // Mostly, we'd rather not run upgrade functions on props that are
    // not complete.

    if (_$1E.keys(newEditorProps).length !== 0) {
      // We loop through all the versions after the current version of
      // the loaded widget, up to and including the latest version of the
      // loaded widget, and run the upgrade function to bring our loaded
      // widget's props up to that version.
      // There is a little subtlety here in that we call
      // upgradePropsMap[1] to upgrade *to* version 1,
      // (not from version 1).
      for (var nextVersion = initialVersion.major + 1; nextVersion <= latestVersion.major; nextVersion++) {
        if (upgradePropsMap[nextVersion]) {
          newEditorProps = upgradePropsMap[nextVersion](newEditorProps);
        } else if (typeof console !== "undefined" && console.warn) {
          // This is a warning because it is unlikely to be hit in
          // local testing, and a warning is slightly less scary in
          // prod than a `throw new Error`
          console.warn("No upgrade found for widget `" + type + "` from " + "major version `" + (nextVersion - 1) + "` to " + "major version `" + nextVersion + "` found. This " + "is necessary to render this `" + type + "` correctly."); // But try to keep going anyways (yolo!)
          // (Throwing an error here would just break the page
          // silently anyways, so that doesn't seem much better
          // than a halfhearted attempt to continue, however
          // shallow...)
        }
      }
    } // Minor version upgrades (eg. new optional props) don't have
    // transform functions. Instead, we fill in the new props with their
    // defaults.


    var defaultProps = editors[type].defaultProps;
    newEditorProps = _$1E.extend({}, defaultProps, newEditorProps);
    var alignment = oldWidgetInfo.alignment; // Widgets that support multiple alignments will "lock in" the
    // alignment to the alignment that would be listed first in the
    // select box. If the widget only supports one alignment, the
    // alignment value will likely just end up as "default".

    if (alignment == null || alignment === "default") {
      alignment = Widgets$4.getSupportedAlignments(type)[0];
    }

    var widgetStatic = oldWidgetInfo.static;

    if (widgetStatic == null) {
      widgetStatic = DEFAULT_STATIC;
    }

    return _$1E.extend({}, oldWidgetInfo, {
      // maintain other info, like type
      // After upgrading we guarantee that the version is up-to-date
      version: latestVersion,
      // Default graded to true (so null/undefined becomes true):
      graded: oldWidgetInfo.graded != null ? oldWidgetInfo.graded : true,
      alignment: alignment,
      static: widgetStatic,
      options: newEditorProps
    });
  },
  getRendererPropsForWidgetInfo: function getRendererPropsForWidgetInfo(widgetInfo, problemNum) {
    var type = widgetInfo.type;
    var widgetExports = widgets[type];

    if (widgetExports == null) {
      // The widget is not a registered widget
      // It shouldn't matter what we return here, but for consistency
      // we return the untransformed options, as if the widget did
      // not have a transform defined.
      return widgetInfo.options;
    }

    var transform;

    if (widgetInfo.static) {
      // There aren't a lot of real places where we'll have to default to
      // _.identity, but it's theoretically possile if someone changes
      // the JSON manually / we have to back out static support for a
      // widget.
      transform = this.getStaticTransform(type) || _$1E.identity;
    } else {
      transform = widgetExports.transform || _$1E.identity;
    } // widgetInfo.options are the widgetEditor's props:


    return transform(widgetInfo.options, problemNum);
  },
  traverseChildWidgets: function traverseChildWidgets(widgetInfo, traverseRenderer) {
    if (!traverseRenderer) {
      throw new Error("traverseRenderer must be provided, but was not");
    }

    if (!widgetInfo || !widgetInfo.type || !widgets[widgetInfo.type]) {
      return widgetInfo;
    }

    var widgetExports = widgets[widgetInfo.type];
    var props = widgetInfo.options;

    if (widgetExports.traverseChildWidgets && props) {
      var newProps = widgetExports.traverseChildWidgets(props, traverseRenderer);
      return _$1E.extend({}, widgetInfo, {
        options: newProps
      });
    } else {
      return widgetInfo;
    }
  },

  /**
   * Handling for the optional alignments for widgets
   * See widget-container.jsx for details on how alignments are implemented.
   */

  /**
   * Returns the list of supported alignments for the given (string) widget
   * type. This is used primarily at editing time to display the choices
   * for the user.
   *
   * Supported alignments are given as an array of strings in the exports of
   * a widget's _module_.
   */
  getSupportedAlignments: function getSupportedAlignments(type) {
    var widgetInfo = widgets[type];
    return widgetInfo && widgetInfo.supportedAlignments || DEFAULT_SUPPORTED_ALIGNMENTS;
  },

  /**
   * For the given (string) widget type, determine the default alignment for
   * the widget. This is used at rendering time to go from "default" alignment
   * to the actual alignment displayed on the screen.
   *
   * The default alignment is given either as a string (called
   * `defaultAlignment`) or a function (called `getDefaultAlignment`) on
   * the exports of a widget's _module_.
   */
  getDefaultAlignment: function getDefaultAlignment(type) {
    var widgetInfo = widgets[type];
    var alignment;

    if (!widgetInfo) {
      return DEFAULT_ALIGNMENT$1;
    }

    if (widgetInfo.getDefaultAlignment) {
      alignment = widgetInfo.getDefaultAlignment();
    } else {
      alignment = widgetInfo.defaultAlignment;
    }

    return alignment || DEFAULT_ALIGNMENT$1;
  },
  validAlignments: ["block", "inline-block", "inline", "float-left", "float-right", "full-width"],

  /**
   * Used at startup to fail fast if an alignment given by a widget is
   * invalid.
   */
  // TODO(alex): Change this to run as a testcase (vs. being run at runtime)
  validateAlignments: function validateAlignments() {
    _$1E.each(widgets, function (widgetInfo) {
      if (widgetInfo.defaultAlignment && !_$1E.contains(Widgets$4.validAlignments, widgetInfo.defaultAlignment)) {
        throw new Error("Widget '" + widgetInfo.displayName + "' has an invalid defaultAlignment value: " + widgetInfo.defaultAlignment);
      }

      if (widgetInfo.supportedAlignments) {
        var unknownAlignments = _$1E.difference(widgetInfo.supportedAlignments, Widgets$4.validAlignments);

        if (unknownAlignments.length) {
          throw new Error("Widget '" + widgetInfo.displayName + "' has an invalid value for supportedAlignments: " + unknownAlignments.join(" "));
        }
      }
    });
  },

  /**
   * Handling for static mode for widgets that support it.
   */

  /**
   * Returns true iff the widget supports static mode.
   * A widget implicitly supports static mode if it exports a
   * staticTransform function.
   */
  supportsStaticMode: function supportsStaticMode(type) {
    var widgetInfo = widgets[type];
    return widgetInfo && widgetInfo.staticTransform != null;
  },

  /**
   * Return the staticTransform function used to convert the editorProps to
   * the rendered widget state.
   */
  getStaticTransform: function getStaticTransform(type) {
    var widgetInfo = widgets[type];
    return widgetInfo && widgetInfo.staticTransform;
  },

  /**
   * Returns the tracking option for the widget. The default is "",
   * which means simply to track interactions once. The other available
   * option is "all" which means to track all interactions.
   */
  getTracking: function getTracking(type) {
    var widgetInfo = widgets[type];
    return widgetInfo && widgetInfo.tracking || DEFAULT_TRACKING;
  },

  /**
   * Returns true if this widget can include lintable markdown text
   * and supports a highlightLint prop, or false otherwise.
   */
  isLintable: function isLintable(type) {
    var widgetInfo = widgets[type];
    return widgetInfo && widgetInfo.isLintable || DEFAULT_LINTABLE;
  }
};
_module_$2u.exports = Widgets$4;
var Widgets$5 = _module_$2u.exports;

var smMax = 512;
var mdMax = 688;
var containerSizeClass = {
  SMALL: "small",
  MEDIUM: "medium",
  LARGE: "large",
  XLARGE: "xlarge"
};
var containerSizeClassPropType = PropTypes.oneOf(Object.values(containerSizeClass));
var getClassFromWidth = width => {
  if (!width) {
    return containerSizeClass.MEDIUM;
  }

  if (width <= smMax) {
    return containerSizeClass.SMALL;
  } else if (width <= mdMax) {
    return containerSizeClass.MEDIUM;
  } else {
    return containerSizeClass.LARGE;
  }
};
var getInteractiveBoxFromSizeClass = sizeClass => {
  if (sizeClass === containerSizeClass.SMALL) {
    return [interactiveSizes.defaultBoxSizeSmall, interactiveSizes.defaultBoxSizeSmall];
  } else {
    return [interactiveSizes.defaultBoxSize, interactiveSizes.defaultBoxSize];
  }
};

var _module_$2t = {
  exports: {}
};
/* eslint-disable comma-dangle, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var classNames$h = _classnames__default["default"];
var React$28 = _react__default["default"];
var ReactDOM$A = _reactDom__default["default"];
var Widgets$3 = Widgets$5;
var WidgetContainer$1 = createReactClass({
  displayName: "WidgetContainer",
  propTypes: {
    shouldHighlight: PropTypes.bool.isRequired,
    type: PropTypes.string,
    initialProps: PropTypes.object.isRequired,
    linterContext: linterContextProps
  },

  getDefaultProps() {
    return {
      linterContext: linterContextDefault
    };
  },

  getInitialState: function getInitialState() {
    return {
      // TODO(benkomalo): before we're mounted, we don't know how big
      // we're going to be, so just default to MEDIUM for now. :/ In the
      // future we can sniff with user-agents or something to get a
      // better approximation, to avoid flickers
      sizeClass: containerSizeClass.MEDIUM,
      widgetProps: this.props.initialProps
    };
  },

  componentDidMount() {
    // Only relay size class changes for mobile right now.  We may want to
    // this for desktop as well at some point in the future.
    if (this.state.widgetProps.apiOptions.isMobile) {
      var containerWidth = ReactDOM$A.findDOMNode(this).offsetWidth; // NOTE(benkomalo): in the common case, this won't change anything.
      // Unfortunately, it will cause a flash and re-layout on mobile,
      // but until we have better SSR or a more drastic way change to our
      // APIs that hints at the available size, we do have to measure DOM
      // unfortunately.

      /* eslint-disable react/no-did-mount-set-state */

      this.setState({
        sizeClass: getClassFromWidth(containerWidth)
      });
      /* eslint-enable react/no-did-mount-set-state */
    }
  },

  render: function render() {
    var className = classNames$h({
      "perseus-widget-container": true,
      "widget-highlight": this.props.shouldHighlight,
      "widget-nohighlight": !this.props.shouldHighlight
    });
    var type = this.props.type;
    var WidgetType = Widgets$3.getWidget(type);

    if (WidgetType == null) {
      // Just give up on invalid widget types
      return /*#__PURE__*/React$28.createElement("div", {
        className: className
      });
    }

    var alignment = this.state.widgetProps.alignment;

    if (alignment === "default") {
      alignment = Widgets$3.getDefaultAlignment(type);
    }

    className += " widget-" + alignment;
    var apiOptions = this.state.widgetProps.apiOptions; // Hack to prevent interaction with static widgets: we overlay a big
    // div on top of the widget and overflow: hidden the container.
    // Ideally widgets themselves should know how to prevent interaction.

    var isStatic = this.state.widgetProps.static || apiOptions.readOnly;
    var staticContainerStyles = {
      position: "relative",
      overflow: "visible"
    };
    var staticOverlayStyles = {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: 0,
      left: 0,
      zIndex: zIndexInteractiveComponent
    }; // Some widgets may include strings of markdown that we may
    // want to run the linter on. So if the widget is lintable,
    // and we've been asked to highlight lint, pass that property
    // on to the widget, and if the content is not lintable, make sure
    // to default to false.

    var linterContext = this.props.linterContext;

    if (!Widgets$3.isLintable(type)) {
      linterContext.highlightLint = false;
    } // Note: if you add more props here, please consider whether or not
    // it should be auto-serialized (e.g. used in scoreInput()). See
    // widget-jsonify-deprecated.jsx and widget-prop-blacklist.jsx
    // We default to an empty object for style instead of null
    // because of a strange bug where the static styles aren't applied
    // after toggling static mode.


    return /*#__PURE__*/React$28.createElement("div", {
      className: className,
      style: isStatic ? staticContainerStyles : {}
    }, /*#__PURE__*/React$28.createElement(WidgetType, _extends({}, this.state.widgetProps, {
      linterContext: linterContext,
      containerSizeClass: this.state.sizeClass,
      ref: "widget"
    })), isStatic && /*#__PURE__*/React$28.createElement("div", {
      style: staticOverlayStyles
    }));
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (this.props.type !== nextProps.type) {
      throw new Error("WidgetContainer can't change widget type; set a different " + "key instead to recreate the container.");
    }
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    return this.props.shouldHighlight !== nextProps.shouldHighlight || this.props.type !== nextProps.type || this.state.widgetProps !== nextState.widgetProps || this.state.sizeClass !== nextState.sizeClass;
  },
  getWidget: function getWidget() {
    return this.refs.widget;
  },
  replaceWidgetProps: function replaceWidgetProps(newWidgetProps) {
    this.setState({
      widgetProps: newWidgetProps
    });
  }
});
_module_$2t.exports = WidgetContainer$1;
var _widgetContainerJsx = _module_$2t.exports;

/* eslint-disable comma-dangle, max-len, no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */
// Derived from the MIT-licensed:
// https://github.com/fat/zoom.js/blob/fd4f3e43153da7596da0bade198e99f98b47791e/js/zoom.js
// NOTE(kevindangoor)
// This version zooms a new, absolutely positioned image element rather than
// scaling the original image element within a new container. The problem that
// I ran into was that we had a grandparent node with a z-index
// which caused the zoomed image to end up behind the overlay. We sidestep all
// of that by simplifying to just use a new image element.

/*global $*/

/*jshint browser:true, node:true */
var _module_$2s = {
  exports: {}
};
var exports$1 = _module_$2s.exports;
/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
// CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
// ============================================================

function transitionEnd() {
  var el = document.createElement("bootstrap");
  var transEndEventNames = {
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "transitionend",
    OTransition: "oTransitionEnd otransitionend",
    transition: "transitionend"
  };

  for (var name in transEndEventNames) {
    if (el.style[name] !== undefined) {
      return {
        end: transEndEventNames[name]
      };
    }
  }

  return false; // explicit for ie8 (  ._.)
} // http://blog.alexmaccaw.com/css-transitions


$.fn.emulateTransitionEnd = function (duration) {
  var called = false;
  var $el = this;
  $(this).one("bsTransitionEnd", function () {
    called = true;
  });

  var callback = function callback() {
    if (!called) {
      $($el).trigger($.support.transition.end);
    }
  };

  setTimeout(callback, duration);
  return this;
};

$(function () {
  $.support.transition = transitionEnd();

  if (!$.support.transition) {
    return;
  }

  $.event.special.bsTransitionEnd = {
    bindType: $.support.transition.end,
    delegateType: $.support.transition.end,
    handle: function handle(e) {
      if ($(e.target).is(this)) {
        return e.handleObj.handler.apply(this, arguments);
      }
    }
  };
});
/**
 * Changes the viewport meta tag to the given contentString. Invokes callback
 * after viewport meta tag changes have taken effect.
 *
 * TODO(david): Return a promise instead of invoking a callback.
 */

function changeViewportTag(contentString, callback) {
  var scrollX = window.scrollX;
  var scrollY = window.scrollY;
  var viewport = document.querySelector("meta[name=viewport]");

  if (viewport) {
    viewport.setAttribute("content", contentString);
  } else {
    $("head").append("<meta name=\"viewport\" content=\"".concat(contentString, "\">"));
  } // Hacky way to get the page to take the changes
  // From http://stackoverflow.com/a/36894653


  document.body.style.opacity = 0.9999; // ... and undo the temporary change.

  setTimeout(() => {
    document.body.style.opacity = 1; // ... which involves restoring the scroll position, which may have
    // changed.

    window.scrollTo(scrollX, scrollY); // Invoke callback on the next tick to wait for scroll position to have
    // finished resetting.

    callback && setTimeout(callback, 0);
  }, 0);
}
/**
 * The zoom service
 */


function _ZoomService() {}

_ZoomService.prototype._initialize = function (enableMobilePinch) {
  // Check to see if the service is already initialized
  if (this._$document) {
    return;
  }

  this._activeZoom = this._initialScrollPosition = this._initialTouchPosition = this._touchMoveListener = null;
  this._$document = $(document);
  this._$window = $(window);
  this._$body = $(document.body);
  this._boundClick = $.proxy(this._clickHandler, this);
  this._enableMobilePinch = enableMobilePinch;
};

_ZoomService.prototype.handleZoomClick = function (e, enableMobilePinch) {
  this._initialize(enableMobilePinch);

  var target = e.target;

  if (!target || target.tagName !== "IMG") {
    return;
  }

  if (this._$body.hasClass("zoom-overlay-open")) {
    return;
  }

  if (e.metaKey || e.ctrlKey) {
    return window.open(e.target.src, "_blank");
  }

  if (!enableMobilePinch && target.width >= window.innerWidth - Zoom$1.getOffset()) {
    return;
  }

  this._activeZoomClose(true); // Enable page zooming in (i.e. make sure there's no maximum-scale). Also,
  // disable page zoom out on mobile devices, because the container that the
  // image is placed in becomes bigger than the viewport if the page can be
  // zoomed out. We explored other fixes like fixing the overlay and page
  // size to be the viewport, but thought that might be even worse of a hack.
  // See for more info:
  // http://dbushell.com/2013/09/10/css-fixed-positioning-and-mobile-zoom/


  if (enableMobilePinch) {
    // Disable zoom out by setting minimum scale of 1 on the viewport tag.
    changeViewportTag("width=device-width, initial-scale=1, minimum-scale=1", () => this._zoom(target));
  } else {
    this._zoom(target);
  }

  if (!enableMobilePinch) {
    // todo(fat): probably worth throttling this
    this._$window.on("scroll.zoom", $.proxy(this._scrollHandler, this));

    this._$document.on("keyup.zoom", $.proxy(this._keyHandler, this));

    this._$document.on("touchstart.zoom", $.proxy(this._touchStart, this));
  } // we use a capturing phase here to prevent unintended js events
  // sadly no useCapture in jquery api (http://bugs.jquery.com/ticket/14953)


  document.addEventListener("click", this._boundClick, true);
  e.stopPropagation();
};

_ZoomService.prototype._zoom = function (target) {
  this._activeZoom = new Zoom$1(target, this._enableMobilePinch);

  this._activeZoom.zoomImage();
};

_ZoomService.prototype._activeZoomClose = function (forceDispose) {
  if (!this._activeZoom) {
    return;
  }

  if (forceDispose) {
    this._activeZoom.dispose();

    this._disposeActiveZoom();
  } else {
    // Reset any underlying page zoom in case the user had pinched to zoom.
    changeViewportTag("width=device-width, initial-scale=1, minimum-scale=1,\n            maximum-scale=1", () => {
      if (this._activeZoom) {
        this._activeZoom.close();

        this._disposeActiveZoom();
      }
    });
  }
};

_ZoomService.prototype._disposeActiveZoom = function () {
  this._$window.off(".zoom");

  this._$document.off(".zoom");

  document.removeEventListener("click", this._boundClick, true);
  this._activeZoom = null;
};

_ZoomService.prototype._scrollHandler = function (e) {
  if (this._initialScrollPosition === null) {
    this._initialScrollPosition = window.scrollY;
  }

  var deltaY = this._initialScrollPosition - window.scrollY;

  if (Math.abs(deltaY) >= 40) {
    this._activeZoomClose();
  }
};

_ZoomService.prototype._keyHandler = function (e) {
  if (e.keyCode === 27) {
    this._activeZoomClose();
  }
};

_ZoomService.prototype._clickHandler = function (e) {
  e.stopPropagation();
  e.preventDefault();

  this._activeZoomClose();
};

_ZoomService.prototype._touchStart = function (e) {
  // Our jQuery doesn't include `touches` in its event
  // TODO(kevindangoor) Remove `originalEvent` once jQuery is updated
  this._initialTouchPosition = e.originalEvent.touches[0].pageY;
  $(e.target).on("touchmove.zoom", $.proxy(this._touchMove, this));
};

_ZoomService.prototype._touchMove = function (e) {
  // Our jQuery doesn't include `touches` in its event
  // TODO(kevindangoor) Remove `originalEvent` once jQuery is updated
  if (Math.abs(e.originalEvent.touches[0].pageY - this._initialTouchPosition) > 10) {
    this._activeZoomClose();

    $(e.target).off("touchmove.zoom");
  }
};
/**
 * The zoom object
 */


function Zoom$1(img, enableMobilePinch) {
  this._fullHeight = this._fullWidth = this._overlay = null;
  this._targetImage = img;
  this._enableMobilePinch = enableMobilePinch;
  this._$body = $(document.body);
}
/** Margin around the image when in the "zoomed"/lightbox state. */


Zoom$1._OFFSET = 80;
Zoom$1._MAX_WIDTH = 2560;
Zoom$1._MAX_HEIGHT = 4096;

Zoom$1.getOffset = function (zoomToFitOnMobile) {
  return zoomToFitOnMobile ? 0 : Zoom$1._OFFSET;
};

Zoom$1.prototype.getOffset = function () {
  return Zoom$1.getOffset(this._enableMobilePinch);
};

Zoom$1.prototype.zoomImage = function () {
  var img = document.createElement("img");
  var $zoomedImage = $(img);

  img.onload = function () {
    // Load the image without specifying height and width so that we can find
    // the true height and width.
    this._fullHeight = Number(img.height);
    this._fullWidth = Number(img.width); // Set up our image to mirror the current image on the document.

    var imageOffset = this._imageOffset = $(this._targetImage).offset(); // Position the image using viewport-fixed coordinates so that it is
    // exactly over the image on the document.
    //
    // Said another way ... get the coordinates of the image relative to
    // the viewport, and use those to position our new image (which is
    // absolutely positioned within a full-bleed fixed-position container).

    var left = this._left = imageOffset.left - $(window).scrollLeft();
    var top = this._top = imageOffset.top - $(window).scrollTop();
    $zoomedImage.css({
      left: left,
      top: top,
      width: this._targetImage.width,
      height: this._targetImage.height
    });

    this._zoomOriginal();
  }.bind(this);

  img.src = this._targetImage.src;
  this.$zoomedImage = $zoomedImage;
};

Zoom$1.prototype._zoomOriginal = function () {
  this.$zoomedImage.addClass("zoom-img").attr("data-action", "zoom-out");
  $(this._targetImage).css("visibility", "hidden");
  this._backdrop = document.createElement("div");
  this._backdrop.className = "zoom-backdrop";
  document.body.appendChild(this._backdrop);
  this._overlay = document.createElement("div");
  this._overlay.className = "zoom-overlay";
  document.body.appendChild(this._overlay);

  this._overlay.appendChild(this.$zoomedImage[0]);

  this._calculateZoom();

  this._triggerAnimation();
};

Zoom$1.prototype._calculateZoom = function () {
  var originalFullImageWidth = this._fullWidth;
  var originalFullImageHeight = this._fullHeight;
  var viewportHeight = window.innerHeight - this.getOffset();
  var viewportWidth = window.innerWidth - this.getOffset();
  var maxScaleFactor = originalFullImageWidth / this._targetImage.width; // Zoom to fit the viewport.

  var imageAspectRatio = originalFullImageWidth / originalFullImageHeight;
  var viewportAspectRatio = viewportWidth / viewportHeight;

  if (originalFullImageWidth < viewportWidth && originalFullImageHeight < viewportHeight) {
    this._imgScaleFactor = maxScaleFactor;
  } else if (imageAspectRatio < viewportAspectRatio) {
    this._imgScaleFactor = viewportHeight / originalFullImageHeight * maxScaleFactor;
  } else {
    this._imgScaleFactor = viewportWidth / originalFullImageWidth * maxScaleFactor;
  }
};

Zoom$1.prototype._triggerAnimation = function () {
  var viewportY = $(window).scrollTop() + window.innerHeight / 2;
  var viewportX = $(window).scrollLeft() + window.innerWidth / 2;
  var scaleFactor = this._imgScaleFactor;
  var imageCenterY = this._imageOffset.top + this._targetImage.height / 2;
  var imageCenterX = this._imageOffset.left + this._targetImage.width / 2;
  this._translateY = (viewportY - imageCenterY) / scaleFactor;
  this._translateX = (viewportX - imageCenterX) / scaleFactor; // NOTE: This is re-used below.

  this._zoomedInTransformString = "\n        scale(".concat(scaleFactor, ")\n        translate3d(").concat(this._translateX, "px, ").concat(this._translateY, "px, 0)\n    ");
  this.$zoomedImage.css({
    transform: this._zoomedInTransformString
  }).addClass("zoom-transition").one($.support.transition.end, $.proxy(this._onZoomInFinish, this)).emulateTransitionEnd(300);

  this._$body.addClass("zoom-overlay-open");
};

Zoom$1.prototype._onZoomInFinish = function () {
  // Remove the transform on the image, but make it look exactly the same as
  // the image with the transform -- full-size and centered in the viewport
  // -- using margins + left/top + scroll
  //
  // We need to remove the transform for scrolling to work -- the browser
  // would still calculate the element position/sizing by its pre-transform
  // dimensions.
  var height = this._targetImage.height * this._imgScaleFactor;
  var width = this._targetImage.width * this._imgScaleFactor;
  var left = 0;
  var top = 0;
  var marginLeft = 0;
  var marginTop = 0;
  var scrollLeft = 0;
  var scrollTop = 0; // Horizontally center the image within the viewport, either by positioning
  // with CSS or scrolling the viewport.

  if (width < window.innerWidth) {
    left = "50%";
    marginLeft = -width / 2;
  } else {
    scrollLeft = (width - window.innerWidth) / 2;
  } // ... and similarly, vertically center the image within the viewport.


  if (height < window.innerHeight) {
    top = "50%";
    marginTop = -height / 2;
  } else {
    scrollTop = (height - window.innerHeight) / 2;
  }

  this.$zoomedImage.css({
    height: height,
    left: left,
    marginLeft: marginLeft,
    marginTop: marginTop,
    top: top,
    transform: "",
    width: width
  }).removeClass("zoom-transition");
  $(this._overlay).scrollLeft(scrollLeft).scrollTop(scrollTop);
};

Zoom$1.prototype.close = function () {
  this._$body.removeClass("zoom-overlay-open").addClass("zoom-overlay-transitioning"); // Upon closing the image, zoom it back out. Do this by first re-applying the
  // zoomed-in transform and resetting the CSS top/left + margins to what it
  // was right after zooming in -- basically undoing what we did in
  // _onZoomInFinish.
  // TODO(david): Adjust this translation of the transform to take into
  //     account the current scroll position of the image (if the user
  //     scrolled the image after it was zoomed).


  this.$zoomedImage.css({
    height: this._targetImage.height,
    left: this._left,
    marginLeft: 0,
    marginTop: 0,
    top: this._top,
    transform: this._zoomedInTransformString,
    width: this._targetImage.width
  }).removeClass("zoom-transition");
  $(this._overlay).scrollLeft(0).scrollTop(0); // ... now that the image and its container have been set up to be in the
  // same state as right at the end of the zoom-in animation, reset the
  // transform to scale(1) to achieve the zoom-out-into-image-on-document
  // animation.

  setTimeout(() => {
    this.$zoomedImage.css({
      transform: "scale(1)"
    }).addClass("zoom-transition").one($.support.transition.end, $.proxy(this.dispose, this)).emulateTransitionEnd(300);
  }, 10);
};

Zoom$1.prototype.dispose = function () {
  if (this.$zoomedImage && this.$zoomedImage[0].parentNode) {
    this.$zoomedImage.remove();
    this.$zoomedImage = null;

    this._overlay.parentNode.removeChild(this._overlay);

    this._backdrop.parentNode.removeChild(this._backdrop);

    this._$body.removeClass("zoom-overlay-transitioning");
  }

  $(this._targetImage).css("visibility", "visible");
};

exports$1.ZoomService = new _ZoomService();
var _zoomJs = _module_$2s.exports;

/*
    We are currently in a situation where Crowdin adds extra backslashes
    to some strings, but not all. However, we can trust that an individual
    string is in its entirety either escaped or not. This will allow us to use
    a heuristic to determine with a high probability whether a string is
    escaped or not, and thus whether to unescape it or not in
    our `before_dom_insert()` JIPT hook.

    TODO(aasmund): Delete this file when we have converted all our strings
    to the new, unescaped Crowdin format. Calls to `maybeUnescape()` should
    be deleted (unescaping will never be needed anymore).

    The heuristic is as follows:
    - For each LaTeX-like token (one or more backslashes followed by a special
      character or by at least one letter) in the string:
      - If the token cannot be unescaped (e.g. \e ), return the original string.
        Otherwise, we now have two candidate tokens: the original tokens
        and the escaped tokens.
      - For both the original and the unescaped token, compute a number that
        indicates *how* LaTeX-like the token is:
        - 6 if there's an odd number of backslashes followed by a valid LaTeX
          macro name (all backslashes but the last form a sequence of LaTeX
          newlines, and the last one starts the LaTeX macro)
        - 4 if there's one backslash followed by a dollar sign
          (this is likely intended to actually display a dollar sign)
        - 3 if there's an even number of backslashes (this is a sequence of
          LaTeX newlines, and the letters that follow are LaTeX math variables)
        - 2 if there are no backslashes (this is valid, but not LaTeX)
        - 1 if there's an odd number of backslashes (but more than one)
          followed by a dollar sign (our strings don't currently contain this)
        - 0 otherwise (if there's an odd number of backslashes followed by
          something that isn't a valid LaTeX macro name)
    - If exactly one of the candidate strings contains one or more tokens
      that scored 0, return the other string. Otherwise, return the string
      with the highest sum of token scores, choosing the unescaped string
      if there's a tie.

    This algorithm was implemented in Python and run against all of our current
    Crowdin strings (about 440,000), both in original form and escaped form.
    It *always* makes the correct guess for the original strings, and makes
    the wrong guess only for 30 of the escaped strings.
 */
// This regex captures sequences that might represent LaTeX or escape sequences

var MAYBE_LATEX_REGEX = /\\+([ !#$%*,.:;\[\]\^_{|}]|[a-zA-Z]*)/g; // These are the LaTeX macros that are currently in use in our strings.
// They were collected by applying the above regex to all of our
// Crowdin strings, and manually removing most invalid macro names. Macro name
// validity was tested by pasting the macros into the Perseus editor.
// Invalid macros would typically be the result of the regex finding a sequence
// of LaTeX newlines followed by regular text, e.g. "\\\\xy = z". However,
// there are some actual misspellings around, so we've kept those.
// Note that \$ is handled separately.

var LATEX_MACROS_LIST = [" ", "!", "#", "%", "*", ",", ".", ":", ";", "[", "]", "^", "_", "{", "|", "}", "alpha", "angle", "approx", "arccos", "arcsin", "arctan", "arrow", "bar", "barwedge", "begin", "beta", "bf", "big", "Big", "bigg", "Bigg", "bigl", "Bigl", "bigr", "Bigr", "bigstar", "bigtriangledown", "bigtriangleup", "binom", "blacklozenge", "blue", "blueA", "blueB", "blueC", "blueD", "blueE", "boldsymbol", "Box", "boxdot", "boxed", "bullet", "cancel", "cap", "cdot", "cdots", "checkmark", "chi", "circ", "circledcirc", "clubsuit", "colon", "color", "cong", "cos", "cot", "csc", "cup", "curvearrowright", "dagger", "dbinom", "ddots", "delta", "Delta", "det", "dfrac", "diamond", "diamondsuit", "displaystyle", "div", "dot", "dots", "downarrow", "Downarrow", "ell", "end", "enspace", "epsilon", "equiv", "eta", "fbox", "flat", "footnotesize", "frac", "frown", "gamma", "Gamma", "gcf", "ge", "geq", "gg", "goldB", "goldC", "goldD", "goldE", "gray", "grayD", "grayE", "grayF", "green", "greenB", "greenC", "greenD", "greenE", "gt", "hat", "hbox", "heartsuit", "hline", "hphantom", "huge", "Huge", "iff", "iiint", "iint", "implies", "in", "infty", "int", "intercal", "it", "kaBlue", "kappa", "kern", "lambda", "langle", "large", "Large", "LARGE", "lcm", "ldots", "le", "left", "leftarrow", "leftrightarrow", "Leftrightarrow", "leftrightharpoons", "leftroot", "leq", "lfloor", "lg", "lim", "limits", "llap", "ln", "log", "longrightarrow", "Longrightarrow", "lozenge", "lt", "lvert", "maroonB", "maroonC", "maroonD", "maroonE", "mathbb", "mathbf", "mathcal", "mathop", "mathrm", "mathsf", "max", "mbox", "mid", "mp", "mu", "nabla", "ne", "nearrow", "neq", "ngeq", "ngtr", "nleq", "nless", "normalsize", "not", "nu", "nx", "odot", "oint", "omega", "Omega", "operatorname", "oplus", "orange", "oslash", "otimes", "overbrace", "overleftarrow", "overleftrightarrow", "overline", "overrightarrow", "overset", "parallel", "partial", "perp", "phantom", "phi", "Phi", "pi", "pink", "pm", "prime", "propto", "psi", "Psi", "purple", "purpleA", "purpleC", "purpleD", "purpleE", "qquad", "quad", "raise", "rangle", "red", "redA", "redB", "redC", "redD", "redE", "rfloor", "rho", "right", "rightarrow", "Rightarrow", "rightleftharpoons", "rvert", "scriptsize", "scriptstyle", "searrow", "sec", "setminus", "sharp", "sigma", "Sigma", "sim", "simeq", "sin", "small", "space", "sqrt", "square", "stackrel", "star", "substack", "sum", "swarrow", "tan", "tan", "tau", "tealA", "tealB", "tealC", "tealD", "tealE", "text", "textbf", "textit", "textrm", "tfrac", "therefore", "theta", "Theta", "tilde", "times", "tiny", "to", "triangle", "triangleleft", "triangleright", "underbrace", "underline", "underset", "uparrow", "uproot", "varphi", "vdots", "vec", "veebar", "vert", "vphantom", "widehat", "xi", "xrightarrow", // These aren't valid LaTeX macros, but they are misspellings
// that also occur in our strings.
"Begin", "End", "inte", "lamba", "textb"];
var LATEX_MACROS = LATEX_MACROS_LIST.reduce(function (result, macro) {
  result[macro] = null;
  return result;
}, {}); // These escape sequences are the only ones that are in use. Note that newline,
// carriage return, tab, and backslash are the only characters we use that have
// standard escape sequences (we do not use vertical tab, form feed, etc.).
// We also expect that Unicode characters are never represented
// by their \u escape sequence.

var ESCAPE_SEQUENCES = {
  n: "\n",
  r: "\r",
  t: "\t",
  "\\": "\\"
}; // Returns a number representing how "LaTeX-like" a token is.
// Will only be run on tokens that match `MAYBE_LATEX_REGEX`, or the result of
// unescaping such a token. See the comment at the top of the file for details.

var getLatexLevel = function getLatexLevel(text) {
  var backslashCount = 0;

  while (backslashCount < text.length && text[backslashCount] === "\\") {
    backslashCount++;
  }

  if (backslashCount === 0) {
    return 2; // Valid, but doesn't contain any LaTeX syntax
  } else if (backslashCount % 2 === 0) {
    return 3; // Sequence of LaTeX newlines followed by other chars
  } else {
    // An odd number of backslashes would be a sequence of LaTeX newlines
    // followed by a LaTeX macro
    var maybeMacro = text.substring(backslashCount);

    if (maybeMacro === "$") {
      // Valid, but all our strings that use escaped dollars only have
      // one backslash, so this is likely wrong if there are more
      return backslashCount === 1 ? 4 : 1;
    } else {
      return LATEX_MACROS.hasOwnProperty(maybeMacro) ? 6 : 0;
    }
  }
};

var tryUnescape = function tryUnescape(text) {
  var i = 0;
  var result = "";

  while (i < text.length) {
    var c = text[i];

    if (c === "\\") {
      i += 1;

      if (i === text.length) {
        return null; // Odd number of backslashes - not unescapable
      }

      var e = text[i];

      if (ESCAPE_SEQUENCES.hasOwnProperty(e)) {
        result += ESCAPE_SEQUENCES[e];
      } else {
        return null; // Invalid escape sequence
      }
    } else {
      result += c;
    }

    i += 1;
  }

  return result;
};
var shouldUnescape = function shouldUnescape(text) {
  // - If there are no backslashes in the text, (un)escaping will have
  //   no effect, so we can't tell whether this string has been escaped
  //   by Crowdin. However, in order to help Manticore detect situations
  //   where the translation is escaped and the source string isn't,
  //   we will declare such strings not to be escaped.
  // - For each token that might be LaTeX:
  //   - Try to unescape it. If that fails, we can say for certain
  //     that `text` is not escaped.
  //   - Compute the LaTeX level (see the comment at the top of the file)
  //     for the original and the unescaped token, and sum these values over
  //     all the tokens. Also, keep track of whether any of the original
  //     or escaped tokens contain invalid LaTeX.
  // - If there existed invalid LaTeX only in the original tokens, we need to
  //   unescape; if there existed invalid LaTeX only in the escaped tokens,
  //   we need to keep the original.
  // - Otherwise, select the version with the highest LaTeX level, preferring
  //   the unescaped version if there's a tie (because most of our strings
  //   are currently in the "old Crowdin style", meaning that they
  //   are escaped).
  if (text.indexOf("\\") < 0) {
    return false;
  }

  var levelSumOriginal = 0;
  var levelSumUnescaped = 0;
  var anyInvalidLatexInOriginal = false;
  var anyInvalidLatexInUnescaped = false;
  var match;
  MAYBE_LATEX_REGEX.lastIndex = 0;

  while ((match = MAYBE_LATEX_REGEX.exec(text)) !== null) {
    var original = match[0];
    var unescaped = tryUnescape(original);

    if (unescaped === null) {
      return false;
    }

    var originalLevel = getLatexLevel(original);

    if (originalLevel === 0) {
      anyInvalidLatexInOriginal = true;
    }

    var unescapedLevel = getLatexLevel(unescaped);

    if (unescapedLevel === 0) {
      anyInvalidLatexInUnescaped = true;
    }

    levelSumOriginal += originalLevel;
    levelSumUnescaped += unescapedLevel;
  }

  if (anyInvalidLatexInOriginal !== anyInvalidLatexInUnescaped) {
    return anyInvalidLatexInOriginal;
  }

  return levelSumUnescaped >= levelSumOriginal;
}; // Unescape the given string if it seems to be escaped.

var maybeUnescape = function maybeUnescape(text) {
  if (shouldUnescape(text)) {
    return tryUnescape(text);
  } else {
    return text;
  }
}; // Unescape both of the given strings if the first one seems to be escaped.

var _module_$2r = {
  exports: {}
};
/**
 * Component to display an image (or other React components) while the desired
 * image is loading.
 *
 * Derived from
 * https://github.com/hzdg/react-imageloader/blob/master/src/index.js
 * to better suit our environment/build tools. Additionally, this one does
 * not introduce a wrapper element, which makes styling easier.
 */

var React$27 = _react__default["default"];
var Status = {
  PENDING: "pending",
  LOADING: "loading",
  LOADED: "loaded",
  FAILED: "failed"
};
var ImageLoader$1 = createReactClass({
  displayName: "ImageLoader",
  propTypes: {
    children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),
    imgProps: PropTypes.any,
    onError: PropTypes.func,
    onLoad: PropTypes.func,
    // When the DOM updates to replace the preloader with the image, or
    // vice-versa, we trigger this callback.
    onUpdate: PropTypes.func,
    preloader: PropTypes.func,
    src: PropTypes.string
  },
  getInitialState: function getInitialState(props) {
    return {
      status: this.props.src ? Status.LOADING : Status.PENDING
    };
  },
  componentDidMount: function componentDidMount() {
    if (this.state.status === Status.LOADING) {
      this.createLoader();
    }
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (this.props.src !== nextProps.src) {
      this.setState({
        status: nextProps.src ? Status.LOADING : Status.PENDING
      });
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    if (this.state.status === Status.LOADING && !this.img) {
      this.createLoader();
    }

    if (prevState.status !== this.state.status) {
      this.props.onUpdate();
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this.destroyLoader();
  },
  createLoader: function createLoader() {
    this.destroyLoader(); // We can only have one loader at a time.

    this.img = new Image();
    this.img.onload = this.handleLoad;
    this.img.onerror = this.handleError;
    this.img.src = this.props.src;
  },
  destroyLoader: function destroyLoader() {
    if (this.img) {
      this.img.onload = null;
      this.img.onerror = null;
      this.img = null;
    }
  },
  handleLoad: function handleLoad(event) {
    this.destroyLoader();
    this.setState({
      status: Status.LOADED
    });

    if (this.props.onLoad) {
      this.props.onLoad(event);
    }
  },
  handleError: function handleError(error) {
    this.destroyLoader();
    this.setState({
      status: Status.FAILED
    });

    if (this.props.onError) {
      this.props.onError(error);
    }
  },
  renderImg: function renderImg() {
    var {
      src,
      imgProps
    } = this.props;
    var props = {
      src
    };

    for (var k in imgProps) {
      if (imgProps.hasOwnProperty(k)) {
        props[k] = imgProps[k];
      }
    }

    return /*#__PURE__*/React$27.createElement("img", props);
  },
  render: function render() {
    switch (this.state.status) {
      case Status.LOADED:
        return this.renderImg();

      case Status.FAILED:
        if (this.props.children) {
          return this.props.children;
        }

        break;

      default:
        if (this.props.preloader) {
          return this.props.preloader();
        }

    }

    return null;
  }
});
_module_$2r.exports = ImageLoader$1;
var _componentsImageLoaderJsx = _module_$2r.exports;

var _module_$2q = {
  exports: {}
};
/**
 * MovableThing convenience methods
 *
 * Usually added to a Movable* class through
 * InteractiveUtils.addMovableHelperMethodsTo(), but these implementations
 * are simply for convenience.
 */

var _$1D = _underscore__default["default"];
var kpoint$e = _kmath3.point;
/* Local helper methods. */

function getKey(eventName, id) {
  return eventName + ":" + id;
}

function getEventName(key) {
  return key.split(":")[0];
}

var MovableHelperMethods$1 = {
  /**
   * Fire an onSomething type event to all functions in listeners
   */
  _fireEvent: function _fireEvent(listeners, currentValue, previousValue) {
    _$1D.invoke(listeners, "call", this, currentValue, previousValue);
  },

  /**
   * Combine the array of constraints functions
   * Returns either an [x, y] coordinate or false
   */
  _applyConstraints: function _applyConstraints(current, previous, extraOptions) {
    var skipRemaining = false;
    return _$1D.reduce(this.state.constraints, (memo, constraint) => {
      // A move that has been cancelled won't be propagated to later
      // constraints calls
      if (memo === false) {
        return false;
      }

      if (skipRemaining) {
        return memo;
      }

      var result = constraint.call(this, memo, previous, _objectSpread2({
        onSkipRemaining: () => {
          skipRemaining = true;
        }
      }, extraOptions));

      if (result === false) {
        // Returning false cancels the move
        return false;
      } else if (kpoint$e.is(result, 2)) {
        // Returning a coord from constraints overrides the move
        return result;
      } else if (result === true || result == null) {
        // Returning true or undefined allow the move to occur
        return memo;
      } else {
        // Anything else is an error
        throw new Error("Constraint returned invalid result: " + result);
      }
    }, current, this);
  },

  /**
   * Call all draw functions, and update our prevState for the next
   * draw function
   */
  draw: function draw() {
    var currState = this.cloneState();

    MovableHelperMethods$1._fireEvent.call(this, this.state.draw, currState, this.prevState);

    this.prevState = currState;
  },

  /**
   * Add a listener to any event: startMove, constraints, onMove, onMoveEnd,
   * etc. If a listener is already bound to the given eventName and id, then
   * it is overwritten by func.
   *
   * eventName: the string name of the event to listen to. one of:
   *   "onMoveStart", "onMove", "onMoveEnd", "draw", "remove"
   *
   * id: a string id that can be used to remove this event at a later time
   *   note: adding multiple listeners with the same id is undefined behavior
   *
   * func: the function to call when the event happens, which is called
   *   with the event's standard parameters [usually (coord, prevCoord) or
   *   (state, prevState)]
   */
  listen: function listen(eventName, id, func) {
    this._listenerMap = this._listenerMap || {}; // If there's an existing handler, replace it by using its index in
    // `this.state[eventName]`; otherwise, add this handler to the end

    var key = getKey(eventName, id);
    var index = this._listenerMap[key] = this._listenerMap[key] || this.state[eventName].length;
    this.state[eventName][index] = func;
  },

  /**
   * Remove a previously added listener, by the id specified in the
   * corresponding listen() call
   *
   * If the given id has not been registered already, this is a no-op
   */
  unlisten: function unlisten(eventName, id) {
    this._listenerMap = this._listenerMap || {};
    var key = getKey(eventName, id);
    var index = this._listenerMap[key];

    if (index !== undefined) {
      // Remove handler from list of event handlers and listenerMap
      this.state[eventName].splice(index, 1);
      delete this._listenerMap[key]; // Re-index existing events: if they occur after `index`, decrement

      var keys = _$1D.keys(this._listenerMap);

      _$1D.each(keys, function (key) {
        if (getEventName(key) === eventName && this._listenerMap[key] > index) {
          this._listenerMap[key]--;
        }
      }, this);
    }
  }
};
_module_$2q.exports = MovableHelperMethods$1;
var _movableHelperMethodsJs = _module_$2q.exports;

/**
 * Utility functions for writing Interactive2 movablethings
 */

var _$1C = _underscore__default["default"];
var MovableHelperMethods = _movableHelperMethodsJs;
/**
 * Compute the correct vendor-prefixed `transform`.
 */

var prefixedTransform = null;

function computePrefixedTransform() {
  // Temporary element for testing prefix validity
  var el = document.createElement("div");
  var prefixes = ["transform", "msTransform", "MozTransform", "WebkitTransform", "OTransform"];
  var correctPrefix = null;

  _$1C.each(prefixes, function (prefix) {
    if (typeof el.style[prefix] !== 'undefined') {
      correctPrefix = prefix;
    }
  });

  return correctPrefix;
}
/**
 * Compute whether the browser can use 3d transforms by trying to use the
 * translateZ transformation.
 */


var canUse3dTransform = null;

function computeCanUse3dTransform() {
  var el = document.createElement("div");
  var prefix = InteractiveUtil$7.getPrefixedTransform();
  el.style[prefix] = "translateZ(0px)";
  return !!el.style[prefix];
}

var InteractiveUtil$7 = {
  assert: function assert(isTrue, message) {
    if (!isTrue) {
      throw new Error("Assertion Error" + (message ? ": " + message : ""));
    }
  },

  /**
   * Create getters for this.state, based on the default state, `defaults`
   */
  createGettersFor: function createGettersFor(Class, defaults) {
    _$1C.each(_$1C.keys(defaults), function (key) {
      if (Class.prototype[key] === undefined) {
        Class.prototype[key] = function () {
          return this.state[key];
        };
      }
    });
  },

  /**
   * Add MovableHelperMethods methods to a MovableThing class
   */
  addMovableHelperMethodsTo: function addMovableHelperMethodsTo(Class) {
    _$1C.each(MovableHelperMethods, function (methodFunc, methodName) {
      if (Class.prototype[methodName] === undefined) {
        Class.prototype[methodName] = methodFunc;
      }
    });
  },

  /**
   * Turn a function or an array of functions into an array of functions
   */
  arrayify: function arrayify(funcOrArray) {
    if (funcOrArray == null) {
      return [];
    } else if (_$1C.isArray(funcOrArray)) {
      return _$1C.filter(_$1C.flatten(funcOrArray), _$1C.identity);
    } else {
      return [funcOrArray];
    }
  },

  /**
   * Convert all function-or-array arguments to arrays of functions
   */
  normalizeOptions: function normalizeOptions(arrayOptionNames, options) {
    // TODO(jack): Having to clone here is annoying; this
    // function should really just modify this.state in place
    // (and maybe be a function on MovableHelperMethods to get access
    // to this.state), which would also be nicer because we could
    // normalizeOptions once in this.modify
    var result = _$1C.clone(options);

    _$1C.each(arrayOptionNames, function (eventName) {
      var funcOrArray = options[eventName]; // Only propagate values which were set; not present values
      // shouldn't be added to options because we'd like them to
      // fall through to defaults

      if (funcOrArray !== undefined) {
        var funcArray = InteractiveUtil$7.arrayify(funcOrArray);
        result[eventName] = funcArray;
      }
    });

    return result;
  },

  /**
   * Get the correct vendor-prefixed `transform`.
   */
  getPrefixedTransform: function getPrefixedTransform() {
    // Cache result to avoid re-computation
    prefixedTransform = prefixedTransform || computePrefixedTransform();
    return prefixedTransform;
  },

  /**
   * Get whether the browser can use 3d transforms.
   */
  getCanUse3dTransform: function getCanUse3dTransform() {
    if (canUse3dTransform == null) {
      canUse3dTransform = computeCanUse3dTransform();
    }

    return canUse3dTransform;
  }
};
var getCanUse3dTransform = InteractiveUtil$7.getCanUse3dTransform;

var _module_$2p = {
  exports: {}
};
/**
 * Color constants we use throughout Perseus (originally on KhanUtil).
 *
 * Note that if the color palette changes substantially, it may also need to be
 * updated in khan-exercises and cherry-picked into graphie-to-png's
 * khan-exercises sub_module_, as graphie-to-png still relies on the palette
 * provided on KhanUtil.
 */

var KhanColors$g = {
  BLUE: "#6495ED",
  ORANGE: "#FFA500",
  PINK: "#FF00AF",
  GREEN: "#28AE7B",
  PURPLE: "#9D38BD",
  RED: "#DF0030",
  GRAY: "gray",
  BLACK: "black",
  LIGHT_BLUE: "#9AB8ED",
  LIGHT_ORANGE: "#EDD19B",
  LIGHT_PINK: "#ED9BD3",
  LIGHT_GREEN: "#9BEDCE",
  LIGHT_PURPLE: "#DA9BED",
  LIGHT_RED: "#ED9AAC",
  LIGHT_GRAY: "#ED9B9B",
  LIGHT_BLACK: "#ED9B9B",
  GRAY10: "#D6D6D6",
  GRAY20: "#CDCDCD",
  GRAY30: "#B3B3B3",
  GRAY40: "#9A9A9A",
  GRAY50: "#808080",
  GRAY60: "#666666",
  GRAY70: "#4D4D4D",
  GRAY80: "#333333",
  GRAY90: "#1A1A1A",
  BLUE_A: "#CCFAFF",
  BLUE_B: "#80F6FF",
  BLUE_C: "#63D9EA",
  BLUE_D: "#11ACCD",
  BLUE_E: "#0C7F99",
  TEAL_A: "#94FFF5",
  TEAL_B: "#26EDD5",
  TEAL_C: "#01D1C1",
  TEAL_D: "#01A995",
  TEAL_E: "#208170",
  GREEN_A: "#B6FFB0",
  GREEN_B: "#8AF281",
  GREEN_C: "#74CF70",
  GREEN_D: "#1FAB54",
  GREEN_E: "#0D923F",
  GOLD_A: "#FFD0A9",
  GOLD_B: "#FFBB71",
  GOLD_C: "#FF9C39",
  GOLD_D: "#E07D10",
  GOLD_E: "#A75A05",
  RED_A: "#FCA9A9",
  RED_B: "#FF8482",
  RED_C: "#F9685D",
  RED_D: "#E84D39",
  RED_E: "#BC2612",
  MAROON_A: "#FFBDE0",
  MAROON_B: "#FF92C6",
  MAROON_C: "#ED5FA6",
  MAROON_D: "#CA337C",
  MAROON_E: "#9E034E",
  PURPLE_A: "#DDD7FF",
  PURPLE_B: "#C6B9FC",
  PURPLE_C: "#AA87FF",
  PURPLE_D: "#7854AB",
  PURPLE_E: "#543B78",
  MINT_A: "#F5F9E8",
  MINT_B: "#EDF2DF",
  MINT_C: "#E0E5CC",
  GRAY_A: "#F6F7F7",
  GRAY_B: "#F0F1F2",
  GRAY_C: "#E3E5E6",
  GRAY_D: "#D6D8DA",
  GRAY_E: "#BABEC2",
  GRAY_F: "#888D93",
  GRAY_G: "#626569",
  GRAY_H: "#3B3E40",
  GRAY_I: "#21242C",
  KA_BLUE: "#314453",
  KA_GREEN: "#71B307",
  // Don't actually use _BACKGROUND! Make things transparent instead. The
  // background color used in exercises is subject to change at the whim
  // of any redesigns.
  _BACKGROUND: "#FDFDFD" // TODO(eater): Get rid of this altogether.

};
KhanColors$g.INTERACTING = KhanColors$g.KA_GREEN;
KhanColors$g.INTERACTIVE = KhanColors$g.KA_GREEN;
KhanColors$g.DYNAMIC = KhanColors$g.BLUE;
_module_$2p.exports = KhanColors$g;
var _utilColorsJs = _module_$2p.exports;

var _module_$2o = {
  exports: {}
};
/**
 * Default methods for a wrapped movable.
 */

var _$1B = _underscore__default["default"];
var InteractiveUtil$6 = InteractiveUtil$7;
var objective_$3 = _objective_Js;
var kvector$d = _kmath3.vector;
/*
 * These functions, when called on the wrapped object, simply pass the
 * arguments to the underlying Raphael object.
 */

var PASS_TO_RAPHAEL = ["attr", "animate"];

var WrappedDefaults$3 = _$1B.extend({
  transform: function transform(transformation) {
    var prefixedTransform = InteractiveUtil$6.getPrefixedTransform();
    this.wrapper.style[prefixedTransform] = transformation;
  },
  toFront: function toFront() {
    var parentNode = this.wrapper.parentNode; // TODO(emily): Sometimes, we call `.remove()` but then hold a
    // reference to this object, and sometimes call `.toFront` on it.
    // Notably, this happens in the reflection transformation in the
    // Transformer widget. This is a hacky fix. Make this less bad.

    if (parentNode) {
      parentNode.appendChild(this.wrapper);
    }
  },
  toBack: function toBack() {
    var parentNode = this.wrapper.parentNode;

    if (parentNode.firstChild !== this.wrapper) {
      parentNode.insertBefore(this.wrapper, parentNode.firstChild);
    }
  },
  remove: function remove() {
    this.visibleShape.remove();
    $__default["default"](this.wrapper).remove();
  },
  getMouseTarget: function getMouseTarget() {
    return this.visibleShape[0];
  },
  moveTo: function moveTo(point) {
    var delta = kvector$d.subtract(this.graphie.scalePoint(point), this.graphie.scalePoint(this.initialPoint));
    var do3dTransform = InteractiveUtil$6.getCanUse3dTransform();
    var transformation = "translateX(" + delta[0] + "px) " + "translateY(" + delta[1] + "px)" + (do3dTransform ? " translateZ(0)" : "");
    this.transform(transformation);
  },
  hide: function hide() {
    this.visibleShape.hide();
  },
  show: function show() {
    this.visibleShape.show();
  }
}, objective_$3.mapObjectFromArray(PASS_TO_RAPHAEL, function (attribute) {
  return function () {
    this.visibleShape[attribute](...arguments);
  };
}));

_module_$2o.exports = WrappedDefaults$3;
var _wrappedDefaultsJs = _module_$2o.exports;

var _module_$2n = {
  exports: {}
};
var _$1A = _underscore__default["default"];
var WrappedDefaults$2 = _wrappedDefaultsJs;
var DEFAULT_OPTIONS$2 = {
  center: null,
  // gets ignored in `graphie.fixedPath` if `null`
  createPath: null,
  // gets defaulted in `graphie.fixedPath` if `null`
  mouselayer: false
};

var WrappedPath$2 = function WrappedPath(graphie, points, options) {
  options = _$1A.extend({}, DEFAULT_OPTIONS$2, options); // Add `wrapper` and `visibleShape`

  _$1A.extend(this, graphie.fixedPath(points, options.center, options.createPath)); // Add remaining properties


  _$1A.extend(this, {
    graphie: graphie,
    initialPoint: graphie.scalePoint(_$1A.head(points))
  }); // Add to appropriate graphie layer


  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    this.wrapper.style.touchAction = "none";
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  }
};

_$1A.extend(WrappedPath$2.prototype, WrappedDefaults$2);

_module_$2n.exports = WrappedPath$2;
var _wrappedPathJs = _module_$2n.exports;

var _module_$2m = {
  exports: {}
};
var _$1z = _underscore__default["default"];
var InteractiveUtil$5 = InteractiveUtil$7;
var WrappedDefaults$1 = _wrappedDefaultsJs;
var kpoint$d = _kmath3.point;
var kvector$c = _kmath3.vector;
var KhanMath$b = _utilMathJs;
var DEFAULT_OPTIONS$1 = {
  thickness: 2,
  mouselayer: false
};

var WrappedLine$6 = function WrappedLine(graphie, start, end, options) {
  options = _$1z.extend({}, DEFAULT_OPTIONS$1, options); // Always make the line as large as possible and horizontal; this
  // simplifies a lot of the transforms, e.g., we can rotate by exactly the
  // angle of the argument points in `moveTo`.

  var initialStart = [graphie.range[0][0], 0];
  var initialEnd = [graphie.range[0][1], 0]; // Add `wrapper` and `visibleShape`

  _$1z.extend(this, graphie.fixedLine(initialStart, initialEnd, options.thickness));

  this.visibleShape.attr(options.normalStyle); // Save properties for computing transformations

  _$1z.extend(this, {
    graphie: graphie,
    initialPoint: graphie.scalePoint(initialStart),
    initialLength: kpoint$d.distanceToPoint(graphie.scalePoint(initialStart), graphie.scalePoint(initialEnd))
  }); // Add to appropriate graphie layer


  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    this.wrapper.style.touchAction = "none";
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  } // Move to argument points


  this.moveTo(start, end);
};

_$1z.extend(WrappedLine$6.prototype, WrappedDefaults$1, {
  getMouseTarget: function getMouseTarget() {
    return this.wrapper;
  },
  moveTo: function moveTo(start, end) {
    var scaledStart = this.graphie.scalePoint(start);
    var scaledEnd = this.graphie.scalePoint(end); // Compute transformation parameters

    var polarDiff = kvector$c.polarDegFromCart(kvector$c.subtract(scaledEnd, scaledStart));
    var lineLength = polarDiff[0];
    var angle = KhanMath$b.bound(polarDiff[1]);
    var delta = kvector$c.subtract(scaledStart, this.initialPoint);
    var scale = KhanMath$b.bound(lineLength / this.initialLength); // Construct and apply transformation string

    var do3dTransform = InteractiveUtil$5.getCanUse3dTransform();
    var transformation = "translateX(" + delta[0] + "px) " + "translateY(" + delta[1] + "px) " + (do3dTransform ? " translateZ(0)" : "") + "rotate(" + angle + "deg) " + "scaleX(" + scale + ") scaleY(1)";
    this.transform(transformation);
  }
});

_module_$2m.exports = WrappedLine$6;
var _interactive2WrappedLineJs = _module_$2m.exports;

var _module_$2l = {
  exports: {}
};
var _$1y = _underscore__default["default"];
var WrappedDefaults = _wrappedDefaultsJs;
var InteractiveUtil$4 = InteractiveUtil$7;
var kvector$b = _kmath3.vector;
var DEFAULT_OPTIONS = {
  maxScale: 1,
  mouselayer: false,
  shadow: false,
  disableMouseEventsOnWrapper: false
};

var WrappedEllipse$3 = function WrappedEllipse(graphie, center, radii, options) {
  options = _$1y.extend({}, DEFAULT_OPTIONS, options); // Add `wrapper`, `visibleShape`, and remaining properties.

  var fixedEllipse = graphie.fixedEllipse(center, radii, options.maxScale, options.padding);

  _$1y.extend(this, fixedEllipse, {
    graphie: graphie,
    initialPoint: center
  }); // Add to appropriate graphie layer


  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    this.wrapper.style.touchAction = "none";
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  }

  if (options.shadow) {
    var filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
    var wrapper = this.wrapper;
    wrapper.style.webkitFilter = filter;
    wrapper.style.filter = filter;

    this.moveTo = function (point) {
      var delta = kvector$b.subtract(this.graphie.scalePoint(point), this.graphie.scalePoint(this.initialPoint));
      var do3dTransform = InteractiveUtil$4.getCanUse3dTransform();
      var transform = "translateX(" + Math.round(delta[0]) + "px) " + "translateY(" + Math.round(delta[1]) + "px)" + (do3dTransform ? " translateZ(0)" : "");
      this.transform(transform);
    };
  }

  if (options.disableMouseEventsOnWrapper) {
    this.wrapper.style.pointerEvents = "none";
    this.visibleShape.node.style.pointerEvents = "auto";
  }
};

_$1y.extend(WrappedEllipse$3.prototype, WrappedDefaults);

_module_$2l.exports = WrappedEllipse$3;
var _wrappedEllipseJs = _module_$2l.exports;

var _module_$2k = {
  exports: {}
};
/* globals katex:false, MathJax:false, Exercises:false */

var KhanMath$a = _utilMathJs;

function findChildOrAdd(elem, className) {
  var $child = $__default["default"](elem).find("." + className);

  if ($child.length === 0) {
    return $__default["default"]("<span>").addClass(className).appendTo($__default["default"](elem));
  } else {
    return $child;
  }
}

function doCallback(elem, callback) {
  var tries = 0;

  (function check() {
    var height = elem.scrollHeight; // Heuristic to guess if the font has kicked in
    // so we have box metrics (magic number ick,
    // but this seems to work mostly-consistently)

    if (height > 18 || tries >= 10) {
      callback();
    } else {
      tries++;
      setTimeout(check, 100);
    }
  })();
}

_module_$2k.exports = {
  // Process a node and add math inside of it. This attempts to use KaTeX to
  // format the math, and if that fails it falls back to MathJax.
  //
  // elem: The element which the math should be added to.
  //
  // text: The text that should be formatted inside of the node. If the node
  //       has already had math formatted inside of it before, this doesn't
  //       have to be provided. If this is not provided, and the node hasn't
  //       been formatted before, the text content of the node is used.
  //
  // force: (optional) if the node has been processed before, then it will
  //        not be formatted again, unless this argument is true
  //
  // callback: (optional) a callback to be run after the math has been
  //           processed (note: this might be called synchronously or
  //           asynchronously, depending on whether KaTeX or MathJax is used)
  processMath: function processMath(elem, text, force, callback) {
    var $elem = $__default["default"](elem); // Only process if it hasn't been done before, or it is forced

    if ($elem.attr("data-math-formula") == null || force) {
      var $katexHolder = findChildOrAdd($elem, "katex-holder");
      var $mathjaxHolder = findChildOrAdd($elem, "mathjax-holder"); // Search for MathJax-y script tags inside of the node. These are
      // used by MathJax to denote the formula to be typeset. Before, we
      // would update the formula by updating the contents of the script
      // tag, which shouldn't happen any more, but we manage them just in
      // case.

      var script = $mathjaxHolder.find("script[type='math/tex']")[0]; // If text wasn't provided, we look in two places

      if (text == null) {
        if ($elem.attr("data-math-formula")) {
          // The old typeset formula
          text = $elem.attr("data-math-formula");
        } else if (script) {
          // The contents of the <script> tag
          text = script.text || script.textContent;
        }
      }

      text = text != null ? text + "" : ""; // Attempt to clean up some of the math

      text = KhanMath$a.cleanMath(text); // Store the formula that we're using

      $elem.attr("data-math-formula", text);

      if (Exercises.useKatex) {
        // Try to process the nodes with KaTeX first
        try {
          katex.render(text, $katexHolder[0]); // If that worked, and we previously formatted with
          // mathjax, do some mathjax cleanup

          if ($elem.attr("data-math-type") === "mathjax") {
            // Remove the old mathjax stuff
            var jax = MathJax.Hub.getJaxFor(script);

            if (jax) {
              var e = jax.SourceElement();

              if (e.previousSibling && e.previousSibling.className) {
                jax.Remove();
              }
            }
          }

          $elem.attr("data-math-type", "katex"); // Call the callback

          if (callback) {
            doCallback(elem, callback);
          }

          return;
        } catch (err) {
          // IE doesn't do instanceof correctly, so we resort to
          // manual checking

          /* jshint -W103 */
          if (err.__proto__ !== katex.ParseError.prototype) {
            throw err;
          }
          /* jshint +W103 */

        }
      } // Otherwise, fallback to MathJax
      // (Note: we don't need to do any katex cleanup here, because
      // KaTeX is smart and cleans itself up)


      $elem.attr("data-math-type", "mathjax"); // Update the script tag, or add one if necessary

      if (!script) {
        $mathjaxHolder.append("<script type='math/tex'>" + text.replace(/<\//g, "< /") + "</script>");
      } else {
        if ("text" in script) {
          // IE8, etc
          script.text = text;
        } else {
          script.textContent = text;
        }
      }

      if (typeof MathJax !== "undefined") {
        // Put the process, a debug log, and the callback into the
        // MathJax queue
        MathJax.Hub.Queue(["Reprocess", MathJax.Hub, $mathjaxHolder[0]]);
        MathJax.Hub.Queue(function () {
          KhanUtil.debugLog("MathJax done typesetting (" + text + ")");
        });

        if (callback) {
          MathJax.Hub.Queue(function () {
            var cb = MathJax.Callback(function () {});
            doCallback(elem, function () {
              callback();
              cb();
            });
            return cb;
          });
        }
      }
    }
  },
  processAllMath: function processAllMath(elem, force) {
    var $elem = $__default["default"](elem);
    $elem.filter("code").add($elem.find("code")).each(function () {
      var $this = $__default["default"](this);
      var text = $this.attr("data-math-formula");

      if (text == null) {
        text = $this.text();
        $this.empty();
      }

      KhanUtil.processMath(this, text, force);
    });
  },
  // Function to restore a node to a non-math-processed state
  cleanupMath: function cleanupMath(elem) {
    var $elem = $__default["default"](elem); // Only mess with it if it's been processed before

    if ($elem.attr("data-math-formula")) {
      // Remove MathJax remnants
      if (typeof MathJax !== "undefined") {
        var jax = MathJax.Hub.getJaxFor($elem.find("script")[0]);

        if (jax) {
          var e = jax.SourceElement();

          if (e.previousSibling && e.previousSibling.className) {
            jax.Remove();
          }
        }
      }

      $elem.text($elem.attr("data-math-formula"));
      $elem.attr("data-math-formula", null);
      $elem.attr("data-math-type", null);
    }

    return elem;
  },
  // Function to retrieve the formula of a typeset math node
  retrieveMathFormula: function retrieveMathFormula(elem) {
    return $__default["default"](elem).attr("data-math-formula");
  }
};
var _utilTexJs = _module_$2k.exports;

/*!
 * Raphael 1.5.2 - JavaScript Vector Library
 *
 * Copyright (c) 2010 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
 */
(function () {
  var setAttr;

  if ("".trim) {
    setAttr = function setAttr(node, att, value) {
      node.setAttribute(att, String(value).trim());
    };
  } else {
    setAttr = function setAttr(node, att, value) {
      node.setAttribute(att, String(value));
    };
  }

  function R() {
    if (R.is(arguments[0], array)) {
      var a = arguments[0],
          cnv = create[apply](R, a.splice(0, 3 + R.is(a[0], nu))),
          res = cnv.set();

      for (var i = 0, ii = a[length]; i < ii; i++) {
        var j = a[i] || {};
        elements[has](j.type) && res[push](cnv[j.type]().attr(j));
      }

      return res;
    }

    return create[apply](R, arguments);
  }

  R.version = "1.5.2";

  var separator = /[, ]+/,
      elements = {
    circle: 1,
    rect: 1,
    path: 1,
    ellipse: 1,
    text: 1,
    image: 1
  },
      formatrg = /\{(\d+)\}/g,
      proto = "prototype",
      has = "hasOwnProperty",
      doc = document,
      win = window,
      oldRaphael = {
    was: Object[proto][has].call(win, "Raphael"),
    is: win.Raphael
  },
      Paper = function Paper() {
    this.customAttributes = {};
  },
      paperproto,
      appendChild = "appendChild",
      apply = "apply",
      concat = "concat",
      supportsTouch = ("createTouch" in doc),
      E = "",
      S = " ",
      Str = String,
      split = "split",
      events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend orientationchange touchcancel gesturestart gesturechange gestureend"[split](S),
      touchMap = {
    mousedown: "touchstart",
    mousemove: "touchmove",
    mouseup: "touchend"
  },
      join = "join",
      length = "length",
      lowerCase = Str[proto].toLowerCase,
      math = Math,
      mmax = math.max,
      mmin = math.min,
      abs = math.abs,
      pow = math.pow,
      PI = math.PI,
      nu = "number",
      string = "string",
      array = "array",
      toString = "toString",
      fillString = "fill",
      objectToString = Object[proto][toString],
      push = "push",
      ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
      colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
      isnan = {
    "NaN": 1,
    "Infinity": 1,
    "-Infinity": 1
  },
      bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
      round = math.round,
      toFloat = parseFloat,
      toInt = parseInt,
      ms = " progid:DXImageTransform.Microsoft",
      upperCase = Str[proto].toUpperCase,
      availableAttrs = {
    blur: 0,
    "clip-rect": "0 0 1e9 1e9",
    cursor: "default",
    cx: 0,
    cy: 0,
    fill: "#fff",
    "fill-opacity": 1,
    font: '10px "Arial"',
    "font-family": '"Arial"',
    "font-size": "10",
    "font-style": "normal",
    "font-weight": 400,
    gradient: 0,
    height: 0,
    href: "http://raphaeljs.com/",
    opacity: 1,
    path: "M0,0",
    r: 0,
    rotation: 0,
    rx: 0,
    ry: 0,
    scale: "1 1",
    src: "",
    stroke: "#000",
    "stroke-dasharray": "",
    "stroke-linecap": "butt",
    "stroke-linejoin": "butt",
    "stroke-miterlimit": 0,
    "stroke-opacity": 1,
    "stroke-width": 1,
    target: "_blank",
    "text-anchor": "middle",
    title: "Raphael",
    translation: "0 0",
    width: 0,
    x: 0,
    y: 0
  },
      availableAnimAttrs = {
    along: "along",
    blur: nu,
    "clip-rect": "csv",
    cx: nu,
    cy: nu,
    fill: "colour",
    "fill-opacity": nu,
    "font-size": nu,
    height: nu,
    opacity: nu,
    path: "path",
    r: nu,
    rotation: "csv",
    rx: nu,
    ry: nu,
    scale: "csv",
    stroke: "colour",
    "stroke-opacity": nu,
    "stroke-width": nu,
    translation: "csv",
    width: nu,
    x: nu,
    y: nu
  },
      rp = "replace",
      animKeyFrames = /^(from|to|\d+%?)$/,
      commaSpaces = /\s*,\s*/,
      hsrg = {
    hs: 1,
    rg: 1
  },
      p2s = /,?([achlmqrstvxz]),?/gi,
      pathCommand = /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
      pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
      radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/,
      sortByKey = function sortByKey(a, b) {
    return a.key - b.key;
  };

  R.type = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML";

  if (R.type == "VML") {
    var d = doc.createElement("div"),
        b;
    d.innerHTML = '<v:shape adj="1"/>';
    b = d.firstChild;
    b.style.behavior = "url(#default#VML)";

    if (!(b && typeof b.adj == "object")) {
      return R.type = null;
    }

    d = null;
  }

  R.svg = !(R.vml = R.type == "VML");
  Paper[proto] = R[proto];
  paperproto = Paper[proto];
  R._id = 0;
  R._oid = 0;
  R.fn = {};

  R.is = function (o, type) {
    type = lowerCase.call(type);

    if (type == "finite") {
      return !isnan[has](+o);
    }

    return type == "null" && o === null || type == typeof o || type == "object" && o === Object(o) || type == "array" && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
  };

  R.angle = function (x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
      var x = x1 - x2,
          y = y1 - y2;

      if (!x && !y) {
        return 0;
      }

      return ((x < 0) * 180 + math.atan(-y / -x) * 180 / PI + 360) % 360;
    } else {
      return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
    }
  };

  R.rad = function (deg) {
    return deg % 360 * PI / 180;
  };

  R.deg = function (rad) {
    return rad * 180 / PI % 360;
  };

  R.snapTo = function (values, value, tolerance) {
    tolerance = R.is(tolerance, "finite") ? tolerance : 10;

    if (R.is(values, array)) {
      var i = values.length;

      while (i--) {
        if (abs(values[i] - value) <= tolerance) {
          return values[i];
        }
      }
    } else {
      values = +values;
      var rem = value % values;

      if (rem < tolerance) {
        return value - rem;
      }

      if (rem > values - tolerance) {
        return value - rem + values;
      }
    }

    return value;
  };

  function createUUID() {
    // http://www.ietf.org/rfc/rfc4122.txt
    var s = [],
        i = 0;

    for (; i < 32; i++) {
      s[i] = (~~(math.random() * 16))[toString](16);
    }

    s[12] = 4; // bits 12-15 of the time_hi_and_version field to 0010

    s[16] = (s[16] & 3 | 8)[toString](16); // bits 6-7 of the clock_seq_hi_and_reserved to 01

    return "r-" + s[join]("");
  }

  R.setWindow = function (newwin) {
    win = newwin;
    doc = win.document;
  }; // colour utilities


  var _toHex = function toHex(color) {
    if (R.vml) {
      // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
      var trim = /^\s+|\s+$/g;
      var bod;

      try {
        var docum = new ActiveXObject("htmlfile");
        docum.write("<body>");
        docum.close();
        bod = docum.body;
      } catch (e) {
        bod = createPopup().document.body;
      }

      var range = bod.createTextRange();
      _toHex = cacher(function (color) {
        try {
          bod.style.color = Str(color)[rp](trim, E);
          var value = range.queryCommandValue("ForeColor");
          value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16;
          return "#" + ("000000" + value[toString](16)).slice(-6);
        } catch (e) {
          return "none";
        }
      });
    } else {
      var i = doc.createElement("i");
      i.title = "Rapha\xebl Colour Picker";
      i.style.display = "none";
      doc.body[appendChild](i);
      _toHex = cacher(function (color) {
        i.style.color = color;
        return doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
      });
    }

    return _toHex(color);
  },
      hsbtoString = function hsbtoString() {
    return "hsb(" + [this.h, this.s, this.b] + ")";
  },
      hsltoString = function hsltoString() {
    return "hsl(" + [this.h, this.s, this.l] + ")";
  },
      rgbtoString = function rgbtoString() {
    return this.hex;
  };

  R.hsb2rgb = function (h, s, b, o) {
    if (R.is(h, "object") && "h" in h && "s" in h && "b" in h) {
      b = h.b;
      s = h.s;
      h = h.h;
      o = h.o;
    }

    return R.hsl2rgb(h, s, b / 2, o);
  };

  R.hsl2rgb = function (h, s, l, o) {
    if (R.is(h, "object") && "h" in h && "s" in h && "l" in h) {
      l = h.l;
      s = h.s;
      h = h.h;
    }

    if (h > 1 || s > 1 || l > 1) {
      h /= 360;
      s /= 100;
      l /= 100;
    }

    var rgb = {},
        channels = ["r", "g", "b"],
        t2,
        t1,
        t3;

    if (!s) {
      rgb = {
        r: l,
        g: l,
        b: l
      };
    } else {
      if (l < .5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (t3 * 6 < 1) {
          rgb[channels[i]] = t1 + (t2 - t1) * 6 * t3;
        } else if (t3 * 2 < 1) {
          rgb[channels[i]] = t2;
        } else if (t3 * 3 < 2) {
          rgb[channels[i]] = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          rgb[channels[i]] = t1;
        }
      }
    }

    rgb.r *= 255;
    rgb.g *= 255;
    rgb.b *= 255;
    rgb.hex = "#" + (16777216 | rgb.b | rgb.g << 8 | rgb.r << 16).toString(16).slice(1);
    R.is(o, "finite") && (rgb.opacity = o);
    rgb.toString = rgbtoString;
    return rgb;
  };

  R.rgb2hsb = function (red, green, blue) {
    if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
      blue = red.b;
      green = red.g;
      red = red.r;
    }

    if (green == null && R.is(red, string)) {
      var clr = R.getRGB(red);
      red = clr.r;
      green = clr.g;
      blue = clr.b;
    }

    if (red > 1 || green > 1 || blue > 1) {
      red /= 255;
      green /= 255;
      blue /= 255;
    }

    var max = mmax(red, green, blue),
        min = mmin(red, green, blue),
        hue,
        saturation,
        brightness = max;

    if (min == max) {
      return {
        h: 0,
        s: 0,
        b: max,
        toString: hsbtoString
      };
    } else {
      var delta = max - min;
      saturation = delta / max;

      if (red == max) {
        hue = (green - blue) / delta;
      } else if (green == max) {
        hue = 2 + (blue - red) / delta;
      } else {
        hue = 4 + (red - green) / delta;
      }

      hue /= 6;
      hue < 0 && hue++;
      hue > 1 && hue--;
    }

    return {
      h: hue,
      s: saturation,
      b: brightness,
      toString: hsbtoString
    };
  };

  R.rgb2hsl = function (red, green, blue) {
    if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
      blue = red.b;
      green = red.g;
      red = red.r;
    }

    if (green == null && R.is(red, string)) {
      var clr = R.getRGB(red);
      red = clr.r;
      green = clr.g;
      blue = clr.b;
    }

    if (red > 1 || green > 1 || blue > 1) {
      red /= 255;
      green /= 255;
      blue /= 255;
    }

    var max = mmax(red, green, blue),
        min = mmin(red, green, blue),
        h,
        s,
        l = (max + min) / 2,
        hsl;

    if (min == max) {
      hsl = {
        h: 0,
        s: 0,
        l: l
      };
    } else {
      var delta = max - min;
      s = l < .5 ? delta / (max + min) : delta / (2 - max - min);

      if (red == max) {
        h = (green - blue) / delta;
      } else if (green == max) {
        h = 2 + (blue - red) / delta;
      } else {
        h = 4 + (red - green) / delta;
      }

      h /= 6;
      h < 0 && h++;
      h > 1 && h--;
      hsl = {
        h: h,
        s: s,
        l: l
      };
    }

    hsl.toString = hsltoString;
    return hsl;
  };

  R._path2string = function () {
    return this.join(",")[rp](p2s, "$1");
  };

  function cacher(f, scope, postprocessor) {
    function newf() {
      var arg = Array[proto].slice.call(arguments, 0),
          args = arg[join]("\u25ba"),
          cache = newf.cache = newf.cache || {},
          count = newf.count = newf.count || [];

      if (cache[has](args)) {
        return postprocessor ? postprocessor(cache[args]) : cache[args];
      }

      count[length] >= 1e3 && delete cache[count.shift()];
      count[push](args);
      cache[args] = f[apply](scope, arg);
      return postprocessor ? postprocessor(cache[args]) : cache[args];
    }

    return newf;
  }

  R.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: "none",
        error: 1
      };
    }

    if (colour == "none") {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: "none"
      };
    }

    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = _toHex(colour));
    var red,
        green,
        blue,
        opacity,
        t,
        values,
        rgb = colour.match(colourRegExp);

    if (rgb) {
      if (rgb[2]) {
        blue = toInt(rgb[2].substring(5), 16);
        green = toInt(rgb[2].substring(3, 5), 16);
        red = toInt(rgb[2].substring(1, 3), 16);
      }

      if (rgb[3]) {
        blue = toInt((t = rgb[3].charAt(3)) + t, 16);
        green = toInt((t = rgb[3].charAt(2)) + t, 16);
        red = toInt((t = rgb[3].charAt(1)) + t, 16);
      }

      if (rgb[4]) {
        values = rgb[4][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
      }

      if (rgb[5]) {
        values = rgb[5][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        return R.hsb2rgb(red, green, blue, opacity);
      }

      if (rgb[6]) {
        values = rgb[6][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        return R.hsl2rgb(red, green, blue, opacity);
      }

      rgb = {
        r: red,
        g: green,
        b: blue
      };
      rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
      R.is(opacity, "finite") && (rgb.opacity = opacity);
      return rgb;
    }

    return {
      r: -1,
      g: -1,
      b: -1,
      hex: "none",
      error: 1
    };
  }, R);

  R.getColor = function (value) {
    var start = this.getColor.start = this.getColor.start || {
      h: 0,
      s: 1,
      b: value || .75
    },
        rgb = this.hsb2rgb(start.h, start.s, start.b);
    start.h += .075;

    if (start.h > 1) {
      start.h = 0;
      start.s -= .2;
      start.s <= 0 && (this.getColor.start = {
        h: 0,
        s: 1,
        b: start.b
      });
    }

    return rgb.hex;
  };

  R.getColor.reset = function () {
    delete this.start;
  }; // path utilities


  R.parsePathString = cacher(function (pathString) {
    if (!pathString) {
      return null;
    }

    var paramCounts = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    },
        data = [];

    if (R.is(pathString, array) && R.is(pathString[0], array)) {
      // rough assumption
      data = pathClone(pathString);
    }

    if (!data[length]) {
      Str(pathString)[rp](pathCommand, function (a, b, c) {
        var params = [],
            name = lowerCase.call(b);
        c[rp](pathValues, function (a, b) {
          b && params[push](+b);
        });

        if (name == "m" && params[length] > 2) {
          data[push]([b][concat](params.splice(0, 2)));
          name = "l";
          b = b == "m" ? "l" : "L";
        }

        while (params[length] >= paramCounts[name]) {
          data[push]([b][concat](params.splice(0, paramCounts[name])));

          if (!paramCounts[name]) {
            break;
          }
        }
      });
    }

    data[toString] = R._path2string;
    return data;
  });

  R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t,
        x = pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
        y = pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y,
        mx = p1x + 2 * t * (c1x - p1x) + t * t * (c2x - 2 * c1x + p1x),
        my = p1y + 2 * t * (c1y - p1y) + t * t * (c2y - 2 * c1y + p1y),
        nx = c1x + 2 * t * (c2x - c1x) + t * t * (p2x - 2 * c2x + c1x),
        ny = c1y + 2 * t * (c2y - c1y) + t * t * (p2y - 2 * c2y + c1y),
        ax = (1 - t) * p1x + t * c1x,
        ay = (1 - t) * p1y + t * c1y,
        cx = (1 - t) * c2x + t * p2x,
        cy = (1 - t) * c2y + t * p2y,
        alpha = 90 - math.atan((mx - nx) / (my - ny)) * 180 / PI;
    (mx > nx || my < ny) && (alpha += 180);
    return {
      x: x,
      y: y,
      m: {
        x: mx,
        y: my
      },
      n: {
        x: nx,
        y: ny
      },
      start: {
        x: ax,
        y: ay
      },
      end: {
        x: cx,
        y: cy
      },
      alpha: alpha
    };
  };

  var pathDimensions = cacher(function (path) {
    if (!path) {
      return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }

    path = path2curve(path);
    var x = 0,
        y = 0,
        X = [],
        Y = [],
        p;

    for (var i = 0, ii = path[length]; i < ii; i++) {
      p = path[i];

      if (p[0] == "M") {
        x = p[1];
        y = p[2];
        X[push](x);
        Y[push](y);
      } else {
        var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
        X = X[concat](dim.min.x, dim.max.x);
        Y = Y[concat](dim.min.y, dim.max.y);
        x = p[5];
        y = p[6];
      }
    }

    var xmin = mmin[apply](0, X),
        ymin = mmin[apply](0, Y);
    return {
      x: xmin,
      y: ymin,
      width: mmax[apply](0, X) - xmin,
      height: mmax[apply](0, Y) - ymin
    };
  }),
      pathClone = function pathClone(pathArray) {
    var res = [];

    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
      // rough assumption
      pathArray = R.parsePathString(pathArray);
    }

    for (var i = 0, ii = pathArray[length]; i < ii; i++) {
      res[i] = [];

      for (var j = 0, jj = pathArray[i][length]; j < jj; j++) {
        res[i][j] = pathArray[i][j];
      }
    }

    res[toString] = R._path2string;
    return res;
  },
      pathToRelative = cacher(function (pathArray) {
    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
      // rough assumption
      pathArray = R.parsePathString(pathArray);
    }

    var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;

    if (pathArray[0][0] == "M") {
      x = pathArray[0][1];
      y = pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[push](["M", x, y]);
    }

    for (var i = start, ii = pathArray[length]; i < ii; i++) {
      var r = res[i] = [],
          pa = pathArray[i];

      if (pa[0] != lowerCase.call(pa[0])) {
        r[0] = lowerCase.call(pa[0]);

        switch (r[0]) {
          case "a":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +(pa[6] - x).toFixed(3);
            r[7] = +(pa[7] - y).toFixed(3);
            break;

          case "v":
            r[1] = +(pa[1] - y).toFixed(3);
            break;

          case "m":
            mx = pa[1];
            my = pa[2];

          default:
            for (var j = 1, jj = pa[length]; j < jj; j++) {
              r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
            }

        }
      } else {
        r = res[i] = [];

        if (pa[0] == "m") {
          mx = pa[1] + x;
          my = pa[2] + y;
        }

        for (var k = 0, kk = pa[length]; k < kk; k++) {
          res[i][k] = pa[k];
        }
      }

      var len = res[i][length];

      switch (res[i][0]) {
        case "z":
          x = mx;
          y = my;
          break;

        case "h":
          x += +res[i][len - 1];
          break;

        case "v":
          y += +res[i][len - 1];
          break;

        default:
          x += +res[i][len - 2];
          y += +res[i][len - 1];
      }
    }

    res[toString] = R._path2string;
    return res;
  }, 0, pathClone),
      pathToAbsolute = cacher(function (pathArray) {
    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
      // rough assumption
      pathArray = R.parsePathString(pathArray);
    }

    var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;

    if (pathArray[0][0] == "M") {
      x = +pathArray[0][1];
      y = +pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[0] = ["M", x, y];
    }

    for (var i = start, ii = pathArray[length]; i < ii; i++) {
      var r = res[i] = [],
          pa = pathArray[i];

      if (pa[0] != upperCase.call(pa[0])) {
        r[0] = upperCase.call(pa[0]);

        switch (r[0]) {
          case "A":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +(pa[6] + x);
            r[7] = +(pa[7] + y);
            break;

          case "V":
            r[1] = +pa[1] + y;
            break;

          case "H":
            r[1] = +pa[1] + x;
            break;

          case "M":
            mx = +pa[1] + x;
            my = +pa[2] + y;

          default:
            for (var j = 1, jj = pa[length]; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }

        }
      } else {
        for (var k = 0, kk = pa[length]; k < kk; k++) {
          res[i][k] = pa[k];
        }
      }

      switch (r[0]) {
        case "Z":
          x = mx;
          y = my;
          break;

        case "H":
          x = r[1];
          break;

        case "V":
          y = r[1];
          break;

        case "M":
          mx = res[i][res[i][length] - 2];
          my = res[i][res[i][length] - 1];

        default:
          x = res[i][res[i][length] - 2];
          y = res[i][res[i][length] - 1];
      }
    }

    res[toString] = R._path2string;
    return res;
  }, null, pathClone),
      l2c = function l2c(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
  },
      q2c = function q2c(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3,
        _23 = 2 / 3;

    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
  },
      a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    var _120 = PI * 120 / 180,
        rad = PI / 180 * (+angle || 0),
        res = [],
        xy,
        rotate = cacher(function (x, y, rad) {
      var X = x * math.cos(rad) - y * math.sin(rad),
          Y = x * math.sin(rad) + y * math.cos(rad);
      return {
        x: X,
        y: Y
      };
    });

    if (!recursive) {
      xy = rotate(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      xy = rotate(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;
      var x = (x1 - x2) / 2,
          y = (y1 - y2) / 2;
      var h = x * x / (rx * rx) + y * y / (ry * ry);

      if (h > 1) {
        h = math.sqrt(h);
        rx = h * rx;
        ry = h * ry;
      }

      var rx2 = rx * rx,
          ry2 = ry * ry,
          k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
          cx = k * rx * y / ry + (x1 + x2) / 2,
          cy = k * -ry * x / rx + (y1 + y2) / 2,
          f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
          f2 = math.asin(((y2 - cy) / ry).toFixed(9));
      f1 = x1 < cx ? PI - f1 : f1;
      f2 = x2 < cx ? PI - f2 : f2;
      f1 < 0 && (f1 = PI * 2 + f1);
      f2 < 0 && (f2 = PI * 2 + f2);

      if (sweep_flag && f1 > f2) {
        f1 = f1 - PI * 2;
      }

      if (!sweep_flag && f2 > f1) {
        f2 = f2 - PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }

    var df = f2 - f1;

    if (abs(df) > _120) {
      var f2old = f2,
          x2old = x2,
          y2old = y2;
      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * math.cos(f2);
      y2 = cy + ry * math.sin(f2);
      res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }

    df = f2 - f1;
    var c1 = math.cos(f1),
        s1 = math.sin(f1),
        c2 = math.cos(f2),
        s2 = math.sin(f2),
        t = math.tan(df / 4),
        hx = 4 / 3 * rx * t,
        hy = 4 / 3 * ry * t,
        m1 = [x1, y1],
        m2 = [x1 + hx * s1, y1 - hy * c1],
        m3 = [x2 + hx * s2, y2 - hy * c2],
        m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];

    if (recursive) {
      return [m2, m3, m4][concat](res);
    } else {
      res = [m2, m3, m4][concat](res)[join]()[split](",");
      var newres = [];

      for (var i = 0, ii = res[length]; i < ii; i++) {
        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
      }

      return newres;
    }
  },
      findDotAtSegment = function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    return {
      x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
      y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
    };
  },
      curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x),
        b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
        c = p1x - c1x,
        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
        y = [p1y, p2y],
        x = [p1x, p2x],
        dot;
    abs(t1) > "1e12" && (t1 = .5);
    abs(t2) > "1e12" && (t2 = .5);

    if (t1 > 0 && t1 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
      x[push](dot.x);
      y[push](dot.y);
    }

    if (t2 > 0 && t2 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
      x[push](dot.x);
      y[push](dot.y);
    }

    a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
    b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
    c = p1y - c1y;
    t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
    t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
    abs(t1) > "1e12" && (t1 = .5);
    abs(t2) > "1e12" && (t2 = .5);

    if (t1 > 0 && t1 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
      x[push](dot.x);
      y[push](dot.y);
    }

    if (t2 > 0 && t2 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
      x[push](dot.x);
      y[push](dot.y);
    }

    return {
      min: {
        x: mmin[apply](0, x),
        y: mmin[apply](0, y)
      },
      max: {
        x: mmax[apply](0, x),
        y: mmax[apply](0, y)
      }
    };
  }),
      path2curve = cacher(function (path, path2) {
    var p = pathToAbsolute(path),
        p2 = path2 && pathToAbsolute(path2),
        attrs = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    },
        attrs2 = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    },
        processPath = function processPath(path, d) {
      var nx, ny;

      if (!path) {
        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
      }

      !(path[0] in {
        T: 1,
        Q: 1
      }) && (d.qx = d.qy = null);

      switch (path[0]) {
        case "M":
          d.X = path[1];
          d.Y = path[2];
          break;

        case "A":
          path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
          break;

        case "S":
          nx = d.x + (d.x - (d.bx || d.x));
          ny = d.y + (d.y - (d.by || d.y));
          path = ["C", nx, ny][concat](path.slice(1));
          break;

        case "T":
          d.qx = d.x + (d.x - (d.qx || d.x));
          d.qy = d.y + (d.y - (d.qy || d.y));
          path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
          break;

        case "Q":
          d.qx = path[1];
          d.qy = path[2];
          path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
          break;

        case "L":
          path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
          break;

        case "H":
          path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
          break;

        case "V":
          path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
          break;

        case "Z":
          path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
          break;
      }

      return path;
    },
        fixArc = function fixArc(pp, i) {
      if (pp[i][length] > 7) {
        pp[i].shift();
        var pi = pp[i];

        while (pi[length]) {
          pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
        }

        pp.splice(i, 1);
        ii = mmax(p[length], p2 && p2[length] || 0);
      }
    },
        fixM = function fixM(path1, path2, a1, a2, i) {
      if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
        path2.splice(i, 0, ["M", a2.x, a2.y]);
        a1.bx = 0;
        a1.by = 0;
        a1.x = path1[i][1];
        a1.y = path1[i][2];
        ii = mmax(p[length], p2 && p2[length] || 0);
      }
    };

    for (var i = 0, ii = mmax(p[length], p2 && p2[length] || 0); i < ii; i++) {
      p[i] = processPath(p[i], attrs);
      fixArc(p, i);
      p2 && (p2[i] = processPath(p2[i], attrs2));
      p2 && fixArc(p2, i);
      fixM(p, p2, attrs, attrs2, i);
      fixM(p2, p, attrs2, attrs, i);
      var seg = p[i],
          seg2 = p2 && p2[i],
          seglen = seg[length],
          seg2len = p2 && seg2[length];
      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
      attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
      attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
      attrs2.x = p2 && seg2[seg2len - 2];
      attrs2.y = p2 && seg2[seg2len - 1];
    }

    return p2 ? [p, p2] : p;
  }, null, pathClone),
      parseDots = cacher(function (gradient) {
    var dots = [];

    for (var i = 0, ii = gradient[length]; i < ii; i++) {
      var dot = {},
          par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
      dot.color = R.getRGB(par[1]);

      if (dot.color.error) {
        return null;
      }

      dot.color = dot.color.hex;
      par[2] && (dot.offset = par[2] + "%");
      dots[push](dot);
    }

    for (i = 1, ii = dots[length] - 1; i < ii; i++) {
      if (!dots[i].offset) {
        var start = toFloat(dots[i - 1].offset || 0),
            end = 0;

        for (var j = i + 1; j < ii; j++) {
          if (dots[j].offset) {
            end = dots[j].offset;
            break;
          }
        }

        if (!end) {
          end = 100;
          j = ii;
        }

        end = toFloat(end);
        var d = (end - start) / (j - i + 1);

        for (; i < j; i++) {
          start += d;
          dots[i].offset = start + "%";
        }
      }
    }

    return dots;
  }),
      getContainer = function getContainer(x, y, w, h) {
    var container;

    if (R.is(x, string) || R.is(x, "object")) {
      container = R.is(x, string) ? doc.getElementById(x) : x;

      if (container.tagName) {
        if (y == null) {
          return {
            container: container,
            width: container.style.pixelWidth || container.offsetWidth,
            height: container.style.pixelHeight || container.offsetHeight
          };
        } else {
          return {
            container: container,
            width: y,
            height: w
          };
        }
      }
    } else {
      return {
        container: 1,
        x: x,
        y: y,
        width: w,
        height: h
      };
    }
  },
      plugins = function plugins(con, add) {
    var that = this;

    for (var prop in add) {
      if (add[has](prop) && !(prop in con)) {
        switch (typeof add[prop]) {
          case "function":
            (function (f) {
              con[prop] = con === that ? f : function () {
                return f[apply](that, arguments);
              };
            })(add[prop]);

            break;

          case "object":
            con[prop] = con[prop] || {};
            plugins.call(this, con[prop], add[prop]);
            break;

          default:
            con[prop] = add[prop];
            break;
        }
      }
    }
  },
      tear = function tear(el, paper) {
    el == paper.top && (paper.top = el.prev);
    el == paper.bottom && (paper.bottom = el.next);
    el.next && (el.next.prev = el.prev);
    el.prev && (el.prev.next = el.next);
  },
      tofront = function tofront(el, paper) {
    if (paper.top === el) {
      return;
    }

    tear(el, paper);
    el.next = null;
    el.prev = paper.top;
    paper.top.next = el;
    paper.top = el;
  },
      toback = function toback(el, paper) {
    if (paper.bottom === el) {
      return;
    }

    tear(el, paper);
    el.next = paper.bottom;
    el.prev = null;
    paper.bottom.prev = el;
    paper.bottom = el;
  },
      insertafter = function insertafter(el, el2, paper) {
    tear(el, paper);
    el2 == paper.top && (paper.top = el);
    el2.next && (el2.next.prev = el);
    el.next = el2.next;
    el.prev = el2;
    el2.next = el;
  },
      insertbefore = function insertbefore(el, el2, paper) {
    tear(el, paper);
    el2 == paper.bottom && (paper.bottom = el);
    el2.prev && (el2.prev.next = el);
    el.prev = el2.prev;
    el2.prev = el;
    el.next = el2;
  },
      removed = function removed(methodname) {
    return function () {
      throw new Error("Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object");
    };
  };

  R.pathToRelative = pathToRelative; // SVG

  if (R.svg) {
    paperproto.svgns = "http://www.w3.org/2000/svg";
    paperproto.xlink = "http://www.w3.org/1999/xlink";

    round = function round(num) {
      return +num + (~~num === num) * .5;
    };

    var $ = function $(el, attr) {
      if (attr) {
        for (var key in attr) {
          if (attr[has](key)) {
            setAttr(el, key, Str(attr[key]));
          }
        }
      } else {
        el = doc.createElementNS(paperproto.svgns, el);
        el.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
        return el;
      }
    };

    R[toString] = function () {
      return "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };

    var thePath = function thePath(pathString, SVG) {
      var el = $("path");
      SVG.canvas && SVG.canvas[appendChild](el);
      var p = new Element(el, SVG);
      p.type = "path";
      setFillAndStroke(p, {
        fill: "none",
        stroke: "#000",
        path: pathString
      });
      return p;
    };

    var addGradientFill = function addGradientFill(o, gradient, SVG) {
      var type = "linear",
          fx = .5,
          fy = .5,
          s = o.style;
      gradient = Str(gradient)[rp](radial_gradient, function (all, _fx, _fy) {
        type = "radial";

        if (_fx && _fy) {
          fx = toFloat(_fx);
          fy = toFloat(_fy);
          var dir = (fy > .5) * 2 - 1;
          pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) && fy != .5 && (fy = fy.toFixed(5) - 1e-5 * dir);
        }

        return E;
      });
      gradient = gradient[split](/\s*\-\s*/);

      if (type == "linear") {
        var angle = gradient.shift();
        angle = -toFloat(angle);

        if (isNaN(angle)) {
          return null;
        }

        var vector = [0, 0, math.cos(angle * PI / 180), math.sin(angle * PI / 180)],
            max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
        vector[2] *= max;
        vector[3] *= max;

        if (vector[2] < 0) {
          vector[0] = -vector[2];
          vector[2] = 0;
        }

        if (vector[3] < 0) {
          vector[1] = -vector[3];
          vector[3] = 0;
        }
      }

      var dots = parseDots(gradient);

      if (!dots) {
        return null;
      }

      var id = o.getAttribute(fillString);
      id = id.match(/^url\(#(.*)\)$/);
      id && SVG.defs.removeChild(doc.getElementById(id[1]));
      var el = $(type + "Gradient");
      el.id = createUUID();
      $(el, type == "radial" ? {
        fx: fx,
        fy: fy
      } : {
        x1: vector[0],
        y1: vector[1],
        x2: vector[2],
        y2: vector[3]
      });
      SVG.defs[appendChild](el);

      for (var i = 0, ii = dots[length]; i < ii; i++) {
        var stop = $("stop");
        $(stop, {
          offset: dots[i].offset ? dots[i].offset : !i ? "0%" : "100%",
          "stop-color": dots[i].color || "#fff"
        });
        el[appendChild](stop);
      }

      $(o, {
        fill: "url(#" + el.id + ")",
        opacity: 1,
        "fill-opacity": 1
      });
      s.fill = E;
      s.opacity = 1;
      s.fillOpacity = 1;
      return 1;
    };

    var updatePosition = function updatePosition(o) {
      var bbox = o.getBBox();
      $(o.pattern, {
        patternTransform: R.format("translate({0},{1})", bbox.x, bbox.y)
      });
    };

    var setFillAndStroke = function setFillAndStroke(o, params) {
      var dasharray = {
        "": [0],
        "none": [0],
        "-": [3, 1],
        ".": [1, 1],
        "-.": [3, 1, 1, 1],
        "-..": [3, 1, 1, 1, 1, 1],
        ". ": [1, 3],
        "- ": [4, 3],
        "--": [8, 3],
        "- .": [4, 3, 1, 3],
        "--.": [8, 3, 1, 3],
        "--..": [8, 3, 1, 3, 1, 3]
      },
          node = o.node,
          attrs = o.attrs,
          rot = o.rotate(),
          addDashes = function addDashes(o, value) {
        value = dasharray[lowerCase.call(value)];

        if (value) {
          var width = o.attrs["stroke-width"] || "1",
              butt = {
            round: width,
            square: width,
            butt: 0
          }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
              dashes = [];
          var i = value[length];

          while (i--) {
            dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
          }

          $(node, {
            "stroke-dasharray": dashes[join](",")
          });
        }
      };

      params[has]("rotation") && (rot = params.rotation);
      var rotxy = Str(rot)[split](separator);

      if (!(rotxy.length - 1)) {
        rotxy = null;
      } else {
        rotxy[1] = +rotxy[1];
        rotxy[2] = +rotxy[2];
      }

      toFloat(rot) && o.rotate(0, true);

      for (var att in params) {
        if (params[has](att)) {
          if (!availableAttrs[has](att)) {
            continue;
          }

          var value = params[att];
          attrs[att] = value;

          switch (att) {
            case "blur":
              o.blur(value);
              break;

            case "rotation":
              o.rotate(value, true);
              break;

            case "href":
            case "title":
            case "target":
              var pn = node.parentNode;

              if (lowerCase.call(pn.tagName) != "a") {
                var hl = $("a");
                pn.insertBefore(hl, node);
                hl[appendChild](node);
                pn = hl;
              }

              if (att == "target" && value == "blank") {
                pn.setAttributeNS(o.paper.xlink, "show", "new");
              } else {
                pn.setAttributeNS(o.paper.xlink, att, value);
              }

              break;

            case "cursor":
              node.style.cursor = value;
              break;

            case "clip-rect":
              var rect = Str(value)[split](separator);

              if (rect[length] == 4) {
                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                var el = $("clipPath"),
                    rc = $("rect");
                el.id = createUUID();
                $(rc, {
                  x: rect[0],
                  y: rect[1],
                  width: rect[2],
                  height: rect[3]
                });
                el[appendChild](rc);
                o.paper.defs[appendChild](el);
                $(node, {
                  "clip-path": "url(#" + el.id + ")"
                });
                o.clip = rc;
              }

              if (!value) {
                var clip = doc.getElementById(node.getAttribute("clip-path")[rp](/(^url\(#|\)$)/g, E));
                clip && clip.parentNode.removeChild(clip);
                $(node, {
                  "clip-path": E
                });
                delete o.clip;
              }

              break;

            case "path":
              if (o.type == "path") {
                $(node, {
                  d: value ? attrs.path = pathToAbsolute(value) : "M0,0"
                });
              }

              break;

            case "width":
              setAttr(node, att, value);

              if (attrs.fx) {
                att = "x";
                value = attrs.x;
              } else {
                break;
              }

            case "x":
              if (attrs.fx) {
                value = -attrs.x - (attrs.width || 0);
              }

            case "rx":
              if (att == "rx" && o.type == "rect") {
                break;
              }

            case "cx":
              rotxy && (att == "x" || att == "cx") && (rotxy[1] += value - attrs[att]);
              setAttr(node, att, value);
              o.pattern && updatePosition(o);
              break;

            case "height":
              setAttr(node, att, value);

              if (attrs.fy) {
                att = "y";
                value = attrs.y;
              } else {
                break;
              }

            case "y":
              if (attrs.fy) {
                value = -attrs.y - (attrs.height || 0);
              }

            case "ry":
              if (att == "ry" && o.type == "rect") {
                break;
              }

            case "cy":
              rotxy && (att == "y" || att == "cy") && (rotxy[2] += value - attrs[att]);
              setAttr(node, att, value);
              o.pattern && updatePosition(o);
              break;

            case "r":
              if (o.type == "rect") {
                $(node, {
                  rx: value,
                  ry: value
                });
              } else {
                setAttr(node, att, value);
              }

              break;

            case "src":
              if (o.type == "image") {
                node.setAttributeNS(o.paper.xlink, "href", value);
              }

              break;

            case "stroke-width":
              node.style.strokeWidth = value; // Need following line for Firefox

              setAttr(node, att, value);

              if (attrs["stroke-dasharray"]) {
                addDashes(o, attrs["stroke-dasharray"]);
              }

              break;

            case "stroke-dasharray":
              addDashes(o, value);
              break;

            case "translation":
              var xy = Str(value)[split](separator);
              xy[0] = +xy[0] || 0;
              xy[1] = +xy[1] || 0;

              if (rotxy) {
                rotxy[1] += xy[0];
                rotxy[2] += xy[1];
              }

              translate.call(o, xy[0], xy[1]);
              break;

            case "scale":
              xy = Str(value)[split](separator);
              o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, isNaN(toFloat(xy[2])) ? null : +xy[2], isNaN(toFloat(xy[3])) ? null : +xy[3]);
              break;

            case fillString:
              var isURL = Str(value).match(ISURL);

              if (isURL) {
                el = $("pattern");
                var ig = $("image");
                el.id = createUUID();
                $(el, {
                  x: 0,
                  y: 0,
                  patternUnits: "userSpaceOnUse",
                  height: 1,
                  width: 1
                });
                $(ig, {
                  x: 0,
                  y: 0
                });
                ig.setAttributeNS(o.paper.xlink, "href", isURL[1]);
                el[appendChild](ig);
                var img = doc.createElement("img");
                img.style.cssText = "position:absolute;left:-9999em;top-9999em";

                img.onload = function () {
                  $(el, {
                    width: this.offsetWidth,
                    height: this.offsetHeight
                  });
                  $(ig, {
                    width: this.offsetWidth,
                    height: this.offsetHeight
                  });
                  doc.body.removeChild(this);
                  o.paper.safari();
                };

                doc.body[appendChild](img);
                img.src = isURL[1];
                o.paper.defs[appendChild](el);
                node.style.fill = "url(#" + el.id + ")";
                $(node, {
                  fill: "url(#" + el.id + ")"
                });
                o.pattern = el;
                o.pattern && updatePosition(o);
                break;
              }

              var clr = R.getRGB(value);

              if (!clr.error) {
                delete params.gradient;
                delete attrs.gradient;
                !R.is(attrs.opacity, "undefined") && R.is(params.opacity, "undefined") && $(node, {
                  opacity: attrs.opacity
                });
                !R.is(attrs["fill-opacity"], "undefined") && R.is(params["fill-opacity"], "undefined") && $(node, {
                  "fill-opacity": attrs["fill-opacity"]
                });
              } else if (({
                circle: 1,
                ellipse: 1
              }[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper)) {
                attrs.gradient = value;
                attrs.fill = "none";
                break;
              }

              clr[has]("opacity") && $(node, {
                "fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
              });

            case "stroke":
              clr = R.getRGB(value);
              setAttr(node, att, clr.hex);
              att == "stroke" && clr[has]("opacity") && $(node, {
                "stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
              });
              break;

            case "gradient":
              (({
                circle: 1,
                ellipse: 1
              })[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper);
              break;

            case "opacity":
              if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                $(node, {
                  "stroke-opacity": value > 1 ? value / 100 : value
                });
              }

            // fall

            case "fill-opacity":
              if (attrs.gradient) {
                var gradient = doc.getElementById(node.getAttribute(fillString)[rp](/^url\(#|\)$/g, E));

                if (gradient) {
                  var stops = gradient.getElementsByTagName("stop");
                  setAttr(stops[stops[length] - 1], "stop-opacity", value);
                }

                break;
              }

            default:
              att == "font-size" && (value = toInt(value, 10) + "px");
              var cssrule = att[rp](/(\-.)/g, function (w) {
                return upperCase.call(w.substring(1));
              });
              node.style[cssrule] = value; // Need following line for Firefox

              setAttr(node, att, value);
              break;
          }
        }
      }

      tuneText(o, params);

      if (rotxy) {
        o.rotate(rotxy.join(S));
      } else {
        toFloat(rot) && o.rotate(rot, true);
      }
    };

    var leading = 1.2,
        tuneText = function tuneText(el, params) {
      if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
        return;
      }

      var a = el.attrs,
          node = el.node,
          fontSize = node.firstChild ? toInt(doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

      if (params[has]("text")) {
        a.text = params.text;

        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }

        var texts = Str(params.text)[split]("\n");

        for (var i = 0, ii = texts[length]; i < ii; i++) {
          if (texts[i]) {
            var tspan = $("tspan");
            i && $(tspan, {
              dy: fontSize * leading,
              x: a.x
            });
            tspan[appendChild](doc.createTextNode(texts[i]));
            node[appendChild](tspan);
          }
        }
      } else {
        texts = node.getElementsByTagName("tspan");

        for (i = 0, ii = texts[length]; i < ii; i++) {
          i && $(texts[i], {
            dy: fontSize * leading,
            x: a.x
          });
        }
      }

      $(node, {
        y: a.y
      });
      var bb = el.getBBox(),
          dif = a.y - (bb.y + bb.height / 2);
      dif && R.is(dif, "finite") && $(node, {
        y: a.y + dif
      });
    },
        Element = function Element(node, svg) {
      this[0] = node;
      this.id = R._oid++;
      this.node = node;
      node.raphael = this;
      this.paper = svg;
      this.attrs = this.attrs || {};
      this.transformations = []; // rotate, translate, scale

      this._ = {
        tx: 0,
        ty: 0,
        rt: {
          deg: 0,
          cx: 0,
          cy: 0
        },
        sx: 1,
        sy: 1
      };
      !svg.bottom && (svg.bottom = this);
      this.prev = svg.top;
      svg.top && (svg.top.next = this);
      svg.top = this;
      this.next = null;
    };

    var elproto = Element[proto];

    Element[proto].rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }

      if (deg == null) {
        if (this._.rt.cx) {
          return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
        }

        return this._.rt.deg;
      }

      var bbox = this.getBBox();
      deg = Str(deg)[split](separator);

      if (deg[length] - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }

      deg = toFloat(deg[0]);

      if (cx != null && cx !== false) {
        this._.rt.deg = deg;
      } else {
        this._.rt.deg += deg;
      }

      cy == null && (cx = null);
      this._.rt.cx = cx;
      this._.rt.cy = cy;
      cx = cx == null ? bbox.x + bbox.width / 2 : cx;
      cy = cy == null ? bbox.y + bbox.height / 2 : cy;

      if (this._.rt.deg) {
        this.transformations[0] = R.format("rotate({0} {1} {2})", this._.rt.deg, cx, cy);
        this.clip && $(this.clip, {
          transform: R.format("rotate({0} {1} {2})", -this._.rt.deg, cx, cy)
        });
      } else {
        this.transformations[0] = E;
        this.clip && $(this.clip, {
          transform: E
        });
      }

      $(this.node, {
        transform: this.transformations[join](S)
      });
      return this;
    };

    Element[proto].hide = function () {
      !this.removed && (this.node.style.display = "none");
      return this;
    };

    Element[proto].show = function () {
      !this.removed && (this.node.style.display = "");
      return this;
    };

    Element[proto].remove = function () {
      if (this.removed) {
        return;
      }

      tear(this, this.paper);
      this.node.parentNode.removeChild(this.node);

      for (var i in this) {
        delete this[i];
      }

      this.removed = true;
    };

    Element[proto].getBBox = function () {
      if (this.removed) {
        return this;
      }

      if (this.type == "path") {
        return pathDimensions(this.attrs.path);
      }

      if (this.node.style.display == "none") {
        this.show();
        var hide = true;
      }

      var bbox = {};

      try {
        bbox = this.node.getBBox();
      } catch (e) {// Firefox 3.0.x plays badly here
      } finally {
        bbox = bbox || {};
      }

      if (this.type == "text") {
        bbox = {
          x: bbox.x,
          y: Infinity,
          width: 0,
          height: 0
        };

        for (var i = 0, ii = this.node.getNumberOfChars(); i < ii; i++) {
          var bb = this.node.getExtentOfChar(i);
          bb.y < bbox.y && (bbox.y = bb.y);
          bb.y + bb.height - bbox.y > bbox.height && (bbox.height = bb.y + bb.height - bbox.y);
          bb.x + bb.width - bbox.x > bbox.width && (bbox.width = bb.x + bb.width - bbox.x);
        }
      }

      hide && this.hide();
      return bbox;
    };

    Element[proto].attr = function (name, value) {
      if (this.removed) {
        return this;
      }

      if (name == null) {
        var res = {};

        for (var i in this.attrs) {
          if (this.attrs[has](i)) {
            res[i] = this.attrs[i];
          }
        }

        this._.rt.deg && (res.rotation = this.rotate());
        (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
        return res;
      }

      if (value == null && R.is(name, string)) {
        if (name == "translation") {
          return translate.call(this);
        }

        if (name == "rotation") {
          return this.rotate();
        }

        if (name == "scale") {
          return this.scale();
        }

        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
          return this.attrs.gradient;
        }

        return this.attrs[name];
      }

      if (value == null && R.is(name, array)) {
        var values = {};

        for (var j = 0, jj = name.length; j < jj; j++) {
          values[name[j]] = this.attr(name[j]);
        }

        return values;
      }

      if (value != null) {
        var params = {};
        params[name] = value;
      } else if (name != null && R.is(name, "object")) {
        params = name;
      }

      for (var key in this.paper.customAttributes) {
        if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
          var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
          this.attrs[key] = params[key];

          for (var subkey in par) {
            if (par[has](subkey)) {
              params[subkey] = par[subkey];
            }
          }
        }
      }

      setFillAndStroke(this, params);
      return this;
    };

    Element[proto].toFront = function () {
      if (this.removed) {
        return this;
      }

      this.node.parentNode[appendChild](this.node);
      var svg = this.paper;
      svg.top != this && tofront(this, svg);
      return this;
    };

    Element[proto].toBack = function () {
      if (this.removed) {
        return this;
      }

      if (this.node.parentNode.firstChild != this.node) {
        this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
        toback(this, this.paper);
        this.paper;
      }

      return this;
    };

    Element[proto].insertAfter = function (element) {
      if (this.removed) {
        return this;
      }

      var node = element.node || element[element.length - 1].node;

      if (node.nextSibling) {
        node.parentNode.insertBefore(this.node, node.nextSibling);
      } else {
        node.parentNode[appendChild](this.node);
      }

      insertafter(this, element, this.paper);
      return this;
    };

    Element[proto].insertBefore = function (element) {
      if (this.removed) {
        return this;
      }

      var node = element.node || element[0].node;
      node.parentNode.insertBefore(this.node, node);
      insertbefore(this, element, this.paper);
      return this;
    };

    Element[proto].blur = function (size) {
      // Experimental. No Safari support. Use it on your own risk.
      var t = this;

      if (+size !== 0) {
        var fltr = $("filter"),
            blur = $("feGaussianBlur");
        t.attrs.blur = size;
        fltr.id = createUUID();
        $(blur, {
          stdDeviation: +size || 1.5
        });
        fltr.appendChild(blur);
        t.paper.defs.appendChild(fltr);
        t._blur = fltr;
        $(t.node, {
          filter: "url(#" + fltr.id + ")"
        });
      } else {
        if (t._blur) {
          t._blur.parentNode.removeChild(t._blur);

          delete t._blur;
          delete t.attrs.blur;
        }

        t.node.removeAttribute("filter");
      }
    };

    var theCircle = function theCircle(svg, x, y, r) {
      var el = $("circle");
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        cx: x,
        cy: y,
        r: r,
        fill: "none",
        stroke: "#000"
      };
      res.type = "circle";
      $(el, res.attrs);
      return res;
    },
        theRect = function theRect(svg, x, y, w, h, r) {
      var el = $("rect");
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        width: w,
        height: h,
        r: r || 0,
        rx: r || 0,
        ry: r || 0,
        fill: "none",
        stroke: "#000"
      };
      res.type = "rect";
      $(el, res.attrs);
      return res;
    },
        theEllipse = function theEllipse(svg, x, y, rx, ry) {
      var el = $("ellipse");
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        cx: x,
        cy: y,
        rx: rx,
        ry: ry,
        fill: "none",
        stroke: "#000"
      };
      res.type = "ellipse";
      $(el, res.attrs);
      return res;
    },
        theImage = function theImage(svg, src, x, y, w, h) {
      var el = $("image");
      $(el, {
        x: x,
        y: y,
        width: w,
        height: h,
        preserveAspectRatio: "none"
      });
      el.setAttributeNS(svg.xlink, "href", src);
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        width: w,
        height: h,
        src: src
      };
      res.type = "image";
      return res;
    },
        theText = function theText(svg, x, y, text) {
      var el = $("text");
      $(el, {
        x: x,
        y: y,
        "text-anchor": "middle"
      });
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        "text-anchor": "middle",
        text: text,
        font: availableAttrs.font,
        stroke: "none",
        fill: "#000"
      };
      res.type = "text";
      setFillAndStroke(res, res.attrs);
      return res;
    },
        setSize = function setSize(width, height) {
      this.width = width || this.width;
      this.height = height || this.height;
      setAttr(this.canvas, "width", this.width);
      setAttr(this.canvas, "height", this.height);
      return this;
    },
        create = function create() {
      var con = getContainer[apply](0, arguments),
          container = con && con.container,
          x = con.x,
          y = con.y,
          width = con.width,
          height = con.height;

      if (!container) {
        throw new Error("SVG container not found.");
      }

      var cnvs = $("svg");
      x = x || 0;
      y = y || 0;
      width = width || 512;
      height = height || 342;
      $(cnvs, {
        xmlns: "http://www.w3.org/2000/svg",
        version: 1.1,
        width: width,
        height: height
      });

      if (container == 1) {
        cnvs.style.cssText = "position:absolute;left:" + x + "px;top:" + y + "px";
        doc.body[appendChild](cnvs);
      } else {
        if (container.firstChild) {
          container.insertBefore(cnvs, container.firstChild);
        } else {
          container[appendChild](cnvs);
        }
      }

      container = new Paper();
      container.width = width;
      container.height = height;
      container.canvas = cnvs;
      plugins.call(container, container, R.fn);
      container.clear();
      return container;
    };

    paperproto.clear = function () {
      var c = this.canvas;

      while (c.firstChild) {
        c.removeChild(c.firstChild);
      }

      this.bottom = this.top = null;
      (this.desc = $("desc"))[appendChild](doc.createTextNode("Created with Rapha\xebl"));
      c[appendChild](this.desc);
      c[appendChild](this.defs = $("defs"));
    };

    paperproto.remove = function () {
      this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);

      for (var i in this) {
        this[i] = removed(i);
      }
    };
  } // VML


  if (R.vml) {
    var map = {
      M: "m",
      L: "l",
      C: "c",
      Z: "x",
      m: "t",
      l: "r",
      c: "v",
      z: "x"
    },
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        coordsize = 1e3 + S + 1e3,
        zoom = 10,
        pathlike = {
      path: 1,
      rect: 1
    },
        path2vml = function path2vml(path) {
      var total = /[ahqstv]/ig,
          command = pathToAbsolute;
      Str(path).match(total) && (command = path2curve);
      total = /[clmz]/g;

      if (command == pathToAbsolute && !Str(path).match(total)) {
        var res = Str(path)[rp](bites, function (all, command, args) {
          var vals = [],
              isMove = lowerCase.call(command) == "m",
              res = map[command];
          args[rp](val, function (value) {
            if (isMove && vals[length] == 2) {
              res += vals + map[command == "m" ? "l" : "L"];
              vals = [];
            }

            vals[push](round(value * zoom));
          });
          return res + vals;
        });
        return res;
      }

      var pa = command(path),
          p,
          r;
      res = [];

      for (var i = 0, ii = pa[length]; i < ii; i++) {
        p = pa[i];
        r = lowerCase.call(pa[i][0]);
        r == "z" && (r = "x");

        for (var j = 1, jj = p[length]; j < jj; j++) {
          r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
        }

        res[push](r);
      }

      return res[join](S);
    };

    R[toString] = function () {
      return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };

    thePath = function thePath(pathString, vml) {
      var g = createNode("group");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = vml.coordsize;
      g.coordorigin = vml.coordorigin;
      var el = createNode("shape"),
          ol = el.style;
      ol.width = vml.width + "px";
      ol.height = vml.height + "px";
      el.coordsize = coordsize;
      el.coordorigin = vml.coordorigin;
      g[appendChild](el);
      var p = new Element(el, g, vml),
          attr = {
        fill: "none",
        stroke: "#000"
      };
      pathString && (attr.path = pathString);
      p.type = "path";
      p.path = [];
      p.Path = E;
      setFillAndStroke(p, attr);
      vml.canvas[appendChild](g);
      return p;
    };

    setFillAndStroke = function setFillAndStroke(o, params) {
      o.attrs = o.attrs || {};
      var node = o.node,
          a = o.attrs,
          s = node.style,
          xy,
          newpath = (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.r != a.r) && o.type == "rect",
          res = o;

      for (var par in params) {
        if (params[has](par)) {
          a[par] = params[par];
        }
      }

      if (newpath) {
        a.path = rectPath(a.x, a.y, a.width, a.height, a.r);
        o.X = a.x;
        o.Y = a.y;
        o.W = a.width;
        o.H = a.height;
      }

      params.href && (node.href = params.href);
      params.title && (node.title = params.title);
      params.target && (node.target = params.target);
      params.cursor && (s.cursor = params.cursor);
      "blur" in params && o.blur(params.blur);

      if (params.path && o.type == "path" || newpath) {
        node.path = path2vml(a.path);
      }

      if (params.rotation != null) {
        o.rotate(params.rotation, true);
      }

      if (params.translation) {
        xy = Str(params.translation)[split](separator);
        translate.call(o, xy[0], xy[1]);

        if (o._.rt.cx != null) {
          o._.rt.cx += +xy[0];
          o._.rt.cy += +xy[1];
          o.setBox(o.attrs, xy[0], xy[1]);
        }
      }

      if (params.scale) {
        xy = Str(params.scale)[split](separator);
        o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, +xy[2] || null, +xy[3] || null);
      }

      if ("clip-rect" in params) {
        var rect = Str(params["clip-rect"])[split](separator);

        if (rect[length] == 4) {
          rect[2] = +rect[2] + +rect[0];
          rect[3] = +rect[3] + +rect[1];
          var div = node.clipRect || doc.createElement("div"),
              dstyle = div.style,
              group = node.parentNode;
          dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);

          if (!node.clipRect) {
            dstyle.position = "absolute";
            dstyle.top = 0;
            dstyle.left = 0;
            dstyle.width = o.paper.width + "px";
            dstyle.height = o.paper.height + "px";
            group.parentNode.insertBefore(div, group);
            div[appendChild](group);
            node.clipRect = div;
          }
        }

        if (!params["clip-rect"]) {
          node.clipRect && (node.clipRect.style.clip = E);
        }
      }

      if (o.type == "image" && params.src) {
        node.src = params.src;
      }

      if (o.type == "image" && params.opacity) {
        node.filterOpacity = ms + ".Alpha(opacity=" + params.opacity * 100 + ")";
        s.filter = (node.filterMatrix || E) + (node.filterOpacity || E);
      }

      params.font && (s.font = params.font);
      params["font-family"] && (s.fontFamily = '"' + params["font-family"][split](",")[0][rp](/^['"]+|['"]+$/g, E) + '"');
      params["font-size"] && (s.fontSize = params["font-size"]);
      params["font-weight"] && (s.fontWeight = params["font-weight"]);
      params["font-style"] && (s.fontStyle = params["font-style"]);

      if (params.opacity != null || params["stroke-width"] != null || params.fill != null || params.stroke != null || params["stroke-width"] != null || params["stroke-opacity"] != null || params["fill-opacity"] != null || params["stroke-dasharray"] != null || params["stroke-miterlimit"] != null || params["stroke-linejoin"] != null || params["stroke-linecap"] != null) {
        node = o.shape || node;
        var fill = node.getElementsByTagName(fillString) && node.getElementsByTagName(fillString)[0],
            newfill = false;
        !fill && (newfill = fill = createNode(fillString));

        if ("fill-opacity" in params || "opacity" in params) {
          var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
          opacity = mmin(mmax(opacity, 0), 1);
          fill.opacity = opacity;
        }

        params.fill && (fill.on = true);

        if (fill.on == null || params.fill == "none") {
          fill.on = false;
        }

        if (fill.on && params.fill) {
          var isURL = params.fill.match(ISURL);

          if (isURL) {
            fill.src = isURL[1];
            fill.type = "tile";
          } else {
            fill.color = R.getRGB(params.fill).hex;
            fill.src = E;
            fill.type = "solid";

            if (R.getRGB(params.fill).error && (res.type in {
              circle: 1,
              ellipse: 1
            } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill)) {
              a.fill = "none";
              a.gradient = params.fill;
            }
          }
        }

        newfill && node[appendChild](fill);
        var stroke = node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0],
            newstroke = false;
        !stroke && (newstroke = stroke = createNode("stroke"));

        if (params.stroke && params.stroke != "none" || params["stroke-width"] || params["stroke-opacity"] != null || params["stroke-dasharray"] || params["stroke-miterlimit"] || params["stroke-linejoin"] || params["stroke-linecap"]) {
          stroke.on = true;
        }

        (params.stroke == "none" || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
        var strokeColor = R.getRGB(params.stroke);
        stroke.on && params.stroke && (stroke.color = strokeColor.hex);
        opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
        var width = (toFloat(params["stroke-width"]) || 1) * .75;
        opacity = mmin(mmax(opacity, 0), 1);
        params["stroke-width"] == null && (width = a["stroke-width"]);
        params["stroke-width"] && (stroke.weight = width);
        width && width < 1 && (opacity *= width) && (stroke.weight = 1);
        stroke.opacity = opacity;
        params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
        stroke.miterlimit = params["stroke-miterlimit"] || 8;
        params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");

        if (params["stroke-dasharray"]) {
          var dasharray = {
            "-": "shortdash",
            ".": "shortdot",
            "-.": "shortdashdot",
            "-..": "shortdashdotdot",
            ". ": "dot",
            "- ": "dash",
            "--": "longdash",
            "- .": "dashdot",
            "--.": "longdashdot",
            "--..": "longdashdotdot"
          };
          stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
        }

        newstroke && node[appendChild](stroke);
      }

      if (res.type == "text") {
        s = res.paper.span.style;
        a.font && (s.font = a.font);
        a["font-family"] && (s.fontFamily = a["font-family"]);
        a["font-size"] && (s.fontSize = a["font-size"]);
        a["font-weight"] && (s.fontWeight = a["font-weight"]);
        a["font-style"] && (s.fontStyle = a["font-style"]);
        res.node.string && (res.paper.span.innerHTML = Str(res.node.string)[rp](/</g, "&#60;")[rp](/&/g, "&#38;")[rp](/\n/g, "<br>"));
        res.W = a.w = res.paper.span.offsetWidth;
        res.H = a.h = res.paper.span.offsetHeight;
        res.X = a.x;
        res.Y = a.y + round(res.H / 2); // text-anchor emulationm

        switch (a["text-anchor"]) {
          case "start":
            res.node.style["v-text-align"] = "left";
            res.bbx = round(res.W / 2);
            break;

          case "end":
            res.node.style["v-text-align"] = "right";
            res.bbx = -round(res.W / 2);
            break;

          default:
            res.node.style["v-text-align"] = "center";
            break;
        }
      }
    };

    addGradientFill = function addGradientFill(o, gradient) {
      o.attrs = o.attrs || {};
      o.attrs;
          var fill,
          type = "linear",
          fxfy = ".5 .5";
      o.attrs.gradient = gradient;
      gradient = Str(gradient)[rp](radial_gradient, function (all, fx, fy) {
        type = "radial";

        if (fx && fy) {
          fx = toFloat(fx);
          fy = toFloat(fy);
          pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
          fxfy = fx + S + fy;
        }

        return E;
      });
      gradient = gradient[split](/\s*\-\s*/);

      if (type == "linear") {
        var angle = gradient.shift();
        angle = -toFloat(angle);

        if (isNaN(angle)) {
          return null;
        }
      }

      var dots = parseDots(gradient);

      if (!dots) {
        return null;
      }

      o = o.shape || o.node;
      fill = o.getElementsByTagName(fillString)[0] || createNode(fillString);
      !fill.parentNode && o.appendChild(fill);

      if (dots[length]) {
        fill.on = true;
        fill.method = "none";
        fill.color = dots[0].color;
        fill.color2 = dots[dots[length] - 1].color;
        var clrs = [];

        for (var i = 0, ii = dots[length]; i < ii; i++) {
          dots[i].offset && clrs[push](dots[i].offset + S + dots[i].color);
        }

        fill.colors && (fill.colors.value = clrs[length] ? clrs[join]() : "0% " + fill.color);

        if (type == "radial") {
          fill.type = "gradientradial";
          fill.focus = "100%";
          fill.focussize = fxfy;
          fill.focusposition = fxfy;
        } else {
          fill.type = "gradient";
          fill.angle = (270 - angle) % 360;
        }
      }

      return 1;
    };

    Element = function Element(node, group, vml) {
      this[0] = node;
      this.id = R._oid++;
      this.node = node;
      node.raphael = this;
      this.X = 0;
      this.Y = 0;
      this.attrs = {};
      this.Group = group;
      this.paper = vml;
      this._ = {
        tx: 0,
        ty: 0,
        rt: {
          deg: 0
        },
        sx: 1,
        sy: 1
      };
      !vml.bottom && (vml.bottom = this);
      this.prev = vml.top;
      vml.top && (vml.top.next = this);
      vml.top = this;
      this.next = null;
    };

    elproto = Element[proto];

    elproto.rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }

      if (deg == null) {
        if (this._.rt.cx) {
          return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
        }

        return this._.rt.deg;
      }

      deg = Str(deg)[split](separator);

      if (deg[length] - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }

      deg = toFloat(deg[0]);

      if (cx != null) {
        this._.rt.deg = deg;
      } else {
        this._.rt.deg += deg;
      }

      cy == null && (cx = null);
      this._.rt.cx = cx;
      this._.rt.cy = cy;
      this.setBox(this.attrs, cx, cy);
      this.Group.style.rotation = this._.rt.deg; // gradient fix for rotation. TODO
      // var fill = (this.shape || this.node).getElementsByTagName(fillString);
      // fill = fill[0] || {};
      // var b = ((360 - this._.rt.deg) - 270) % 360;
      // !R.is(fill.angle, "undefined") && (fill.angle = b);

      return this;
    };

    elproto.setBox = function (params, cx, cy) {
      if (this.removed) {
        return this;
      }

      var gs = this.Group.style,
          os = this.shape && this.shape.style || this.node.style;
      params = params || {};

      for (var i in params) {
        if (params[has](i)) {
          this.attrs[i] = params[i];
        }
      }

      cx = cx || this._.rt.cx;
      cy = cy || this._.rt.cy;
      var attr = this.attrs,
          x,
          y,
          w,
          h;

      switch (this.type) {
        case "circle":
          x = attr.cx - attr.r;
          y = attr.cy - attr.r;
          w = h = attr.r * 2;
          break;

        case "ellipse":
          x = attr.cx - attr.rx;
          y = attr.cy - attr.ry;
          w = attr.rx * 2;
          h = attr.ry * 2;
          break;

        case "image":
          x = +attr.x;
          y = +attr.y;
          w = attr.width || 0;
          h = attr.height || 0;
          break;

        case "text":
          this.textpath.v = ["m", round(attr.x), ", ", round(attr.y - 2), "l", round(attr.x) + 1, ", ", round(attr.y - 2)][join](E);
          x = attr.x - round(this.W / 2);
          y = attr.y - this.H / 2;
          w = this.W;
          h = this.H;
          break;

        case "rect":
        case "path":
          if (!this.attrs.path) {
            x = 0;
            y = 0;
            w = this.paper.width;
            h = this.paper.height;
          } else {
            var dim = pathDimensions(this.attrs.path);
            x = dim.x;
            y = dim.y;
            w = dim.width;
            h = dim.height;
          }

          break;

        default:
          x = 0;
          y = 0;
          w = this.paper.width;
          h = this.paper.height;
          break;
      }

      cx = cx == null ? x + w / 2 : cx;
      cy = cy == null ? y + h / 2 : cy;
      var left = cx - this.paper.width / 2,
          top = cy - this.paper.height / 2,
          t;
      gs.left != (t = left + "px") && (gs.left = t);
      gs.top != (t = top + "px") && (gs.top = t);
      this.X = pathlike[has](this.type) ? -left : x;
      this.Y = pathlike[has](this.type) ? -top : y;
      this.W = w;
      this.H = h;

      if (pathlike[has](this.type)) {
        os.left != (t = -left * zoom + "px") && (os.left = t);
        os.top != (t = -top * zoom + "px") && (os.top = t);
      } else if (this.type == "text") {
        os.left != (t = -left + "px") && (os.left = t);
        os.top != (t = -top + "px") && (os.top = t);
      } else {
        gs.width != (t = this.paper.width + "px") && (gs.width = t);
        gs.height != (t = this.paper.height + "px") && (gs.height = t);
        os.left != (t = x - left + "px") && (os.left = t);
        os.top != (t = y - top + "px") && (os.top = t);
        os.width != (t = w + "px") && (os.width = t);
        os.height != (t = h + "px") && (os.height = t);
      }
    };

    elproto.hide = function () {
      !this.removed && (this.Group.style.display = "none");
      return this;
    };

    elproto.show = function () {
      !this.removed && (this.Group.style.display = "block");
      return this;
    };

    elproto.getBBox = function () {
      if (this.removed) {
        return this;
      }

      if (pathlike[has](this.type)) {
        return pathDimensions(this.attrs.path);
      }

      return {
        x: this.X + (this.bbx || 0),
        y: this.Y,
        width: this.W,
        height: this.H
      };
    };

    elproto.remove = function () {
      if (this.removed) {
        return;
      }

      tear(this, this.paper);
      this.node.parentNode.removeChild(this.node);
      this.Group.parentNode.removeChild(this.Group);
      this.shape && this.shape.parentNode.removeChild(this.shape);

      for (var i in this) {
        delete this[i];
      }

      this.removed = true;
    };

    elproto.attr = function (name, value) {
      if (this.removed) {
        return this;
      }

      if (name == null) {
        var res = {};

        for (var i in this.attrs) {
          if (this.attrs[has](i)) {
            res[i] = this.attrs[i];
          }
        }

        this._.rt.deg && (res.rotation = this.rotate());
        (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
        return res;
      }

      if (value == null && R.is(name, "string")) {
        if (name == "translation") {
          return translate.call(this);
        }

        if (name == "rotation") {
          return this.rotate();
        }

        if (name == "scale") {
          return this.scale();
        }

        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
          return this.attrs.gradient;
        }

        return this.attrs[name];
      }

      if (this.attrs && value == null && R.is(name, array)) {
        var ii,
            values = {};

        for (i = 0, ii = name[length]; i < ii; i++) {
          values[name[i]] = this.attr(name[i]);
        }

        return values;
      }

      var params;

      if (value != null) {
        params = {};
        params[name] = value;
      }

      value == null && R.is(name, "object") && (params = name);

      if (params) {
        for (var key in this.paper.customAttributes) {
          if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
            var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
            this.attrs[key] = params[key];

            for (var subkey in par) {
              if (par[has](subkey)) {
                params[subkey] = par[subkey];
              }
            }
          }
        }

        if (params.text && this.type == "text") {
          this.node.string = params.text;
        }

        setFillAndStroke(this, params);

        if (params.gradient && ({
          circle: 1,
          ellipse: 1
        }[has](this.type) || Str(params.gradient).charAt() != "r")) {
          addGradientFill(this, params.gradient);
        }

        (!pathlike[has](this.type) || this._.rt.deg) && this.setBox(this.attrs);
      }

      return this;
    };

    elproto.toFront = function () {
      !this.removed && this.Group.parentNode[appendChild](this.Group);
      this.paper.top != this && tofront(this, this.paper);
      return this;
    };

    elproto.toBack = function () {
      if (this.removed) {
        return this;
      }

      if (this.Group.parentNode.firstChild != this.Group) {
        this.Group.parentNode.insertBefore(this.Group, this.Group.parentNode.firstChild);
        toback(this, this.paper);
      }

      return this;
    };

    elproto.insertAfter = function (element) {
      if (this.removed) {
        return this;
      }

      if (element.constructor == Set) {
        element = element[element.length - 1];
      }

      if (element.Group.nextSibling) {
        element.Group.parentNode.insertBefore(this.Group, element.Group.nextSibling);
      } else {
        element.Group.parentNode[appendChild](this.Group);
      }

      insertafter(this, element, this.paper);
      return this;
    };

    elproto.insertBefore = function (element) {
      if (this.removed) {
        return this;
      }

      if (element.constructor == Set) {
        element = element[0];
      }

      element.Group.parentNode.insertBefore(this.Group, element.Group);
      insertbefore(this, element, this.paper);
      return this;
    };

    elproto.blur = function (size) {
      var s = this.node.runtimeStyle,
          f = s.filter;
      f = f.replace(blurregexp, E);

      if (+size !== 0) {
        this.attrs.blur = size;
        s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
        s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
      } else {
        s.filter = f;
        s.margin = 0;
        delete this.attrs.blur;
      }
    };

    theCircle = function theCircle(vml, x, y, r) {
      var g = createNode("group"),
          o = createNode("oval");
          o.style;
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "circle";
      setFillAndStroke(res, {
        stroke: "#000",
        fill: "none"
      });
      res.attrs.cx = x;
      res.attrs.cy = y;
      res.attrs.r = r;
      res.setBox({
        x: x - r,
        y: y - r,
        width: r * 2,
        height: r * 2
      });
      vml.canvas[appendChild](g);
      return res;
    };

    function rectPath(x, y, w, h, r) {
      if (r) {
        return R.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", x + r, y, w - r * 2, r, -r, h - r * 2, r * 2 - w, r * 2 - h);
      } else {
        return R.format("M{0},{1}l{2},0,0,{3},{4},0z", x, y, w, h, -w);
      }
    }

    theRect = function theRect(vml, x, y, w, h, r) {
      var path = rectPath(x, y, w, h, r),
          res = vml.path(path),
          a = res.attrs;
      res.X = a.x = x;
      res.Y = a.y = y;
      res.W = a.width = w;
      res.H = a.height = h;
      a.r = r;
      a.path = path;
      res.type = "rect";
      return res;
    };

    theEllipse = function theEllipse(vml, x, y, rx, ry) {
      var g = createNode("group"),
          o = createNode("oval");
          o.style;
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "ellipse";
      setFillAndStroke(res, {
        stroke: "#000"
      });
      res.attrs.cx = x;
      res.attrs.cy = y;
      res.attrs.rx = rx;
      res.attrs.ry = ry;
      res.setBox({
        x: x - rx,
        y: y - ry,
        width: rx * 2,
        height: ry * 2
      });
      vml.canvas[appendChild](g);
      return res;
    };

    theImage = function theImage(vml, src, x, y, w, h) {
      var g = createNode("group"),
          o = createNode("image");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      o.src = src;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "image";
      res.attrs.src = src;
      res.attrs.x = x;
      res.attrs.y = y;
      res.attrs.w = w;
      res.attrs.h = h;
      res.setBox({
        x: x,
        y: y,
        width: w,
        height: h
      });
      vml.canvas[appendChild](g);
      return res;
    };

    theText = function theText(vml, x, y, text) {
      var g = createNode("group"),
          el = createNode("shape"),
          ol = el.style,
          path = createNode("path");
          path.style;
          var o = createNode("textpath");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      path.v = R.format("m{0},{1}l{2},{1}", round(x * 10), round(y * 10), round(x * 10) + 1);
      path.textpathok = true;
      ol.width = vml.width;
      ol.height = vml.height;
      o.string = Str(text);
      o.on = true;
      el[appendChild](o);
      el[appendChild](path);
      g[appendChild](el);
      var res = new Element(o, g, vml);
      res.shape = el;
      res.textpath = path;
      res.type = "text";
      res.attrs.text = text;
      res.attrs.x = x;
      res.attrs.y = y;
      res.attrs.w = 1;
      res.attrs.h = 1;
      setFillAndStroke(res, {
        font: availableAttrs.font,
        stroke: "none",
        fill: "#000"
      });
      res.setBox();
      vml.canvas[appendChild](g);
      return res;
    };

    setSize = function setSize(width, height) {
      var cs = this.canvas.style;
      width == +width && (width += "px");
      height == +height && (height += "px");
      cs.width = width;
      cs.height = height;
      cs.clip = "rect(0 " + width + " " + height + " 0)";
      return this;
    };

    var createNode;
    doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");

    try {
      !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");

      createNode = function createNode(tagName) {
        return doc.createElement('<rvml:' + tagName + ' class="rvml">');
      };
    } catch (e) {
      createNode = function createNode(tagName) {
        return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
      };
    }

    create = function create() {
      var con = getContainer[apply](0, arguments),
          container = con.container,
          height = con.height,
          width = con.width,
          x = con.x,
          y = con.y;

      if (!container) {
        throw new Error("VML container not found.");
      }

      var res = new Paper(),
          c = res.canvas = doc.createElement("div"),
          cs = c.style;
      x = x || 0;
      y = y || 0;
      width = width || 512;
      height = height || 342;
      width == +width && (width += "px");
      height == +height && (height += "px");
      res.width = 1e3;
      res.height = 1e3;
      res.coordsize = zoom * 1e3 + S + zoom * 1e3;
      res.coordorigin = "0 0";
      res.span = doc.createElement("span");
      res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
      c[appendChild](res.span);
      cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);

      if (container == 1) {
        doc.body[appendChild](c);
        cs.left = x + "px";
        cs.top = y + "px";
        cs.position = "absolute";
      } else {
        if (container.firstChild) {
          container.insertBefore(c, container.firstChild);
        } else {
          container[appendChild](c);
        }
      }

      plugins.call(res, res, R.fn);
      return res;
    };

    paperproto.clear = function () {
      this.canvas.innerHTML = E;
      this.span = doc.createElement("span");
      this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
      this.canvas[appendChild](this.span);
      this.bottom = this.top = null;
    };

    paperproto.remove = function () {
      this.canvas.parentNode.removeChild(this.canvas);

      for (var i in this) {
        this[i] = removed(i);
      }

      return true;
    };
  } // rest
  // WebKit rendering bug workaround method


  var version = navigator.userAgent.match(/Version\/(.*?)\s/);

  if (navigator.vendor == "Apple Computer, Inc." && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP")) {
    paperproto.safari = function () {
      var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
        stroke: "none"
      });
      win.setTimeout(function () {
        rect.remove();
      });
    };
  } else {
    paperproto.safari = function () {};
  } // Events


  var preventDefault = function preventDefault() {
    this.returnValue = false;
  },
      preventTouch = function preventTouch() {
    return this.originalEvent.preventDefault();
  },
      stopPropagation = function stopPropagation() {
    this.cancelBubble = true;
  },
      stopTouch = function stopTouch() {
    return this.originalEvent.stopPropagation();
  },
      addEvent = function () {
    if (doc.addEventListener) {
      return function (obj, type, fn, element) {
        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type;

        var f = function f(e) {
          if (supportsTouch && touchMap[has](type)) {
            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
              if (e.targetTouches[i].target == obj) {
                var olde = e;
                e = e.targetTouches[i];
                e.originalEvent = olde;
                e.preventDefault = preventTouch;
                e.stopPropagation = stopTouch;
                break;
              }
            }
          }

          return fn.call(element, e);
        };

        obj.addEventListener(realName, f, false);
        return function () {
          obj.removeEventListener(realName, f, false);
          return true;
        };
      };
    } else if (doc.attachEvent) {
      return function (obj, type, fn, element) {
        var f = function f(e) {
          e = e || win.event;
          e.preventDefault = e.preventDefault || preventDefault;
          e.stopPropagation = e.stopPropagation || stopPropagation;
          return fn.call(element, e);
        };

        obj.attachEvent("on" + type, f);

        var detacher = function detacher() {
          obj.detachEvent("on" + type, f);
          return true;
        };

        return detacher;
      };
    }
  }(),
      drag = [],
      dragMove = function dragMove(e) {
    var x = e.clientX,
        y = e.clientY,
        scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
        scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft,
        dragi,
        j = drag.length;

    while (j--) {
      dragi = drag[j];

      if (supportsTouch) {
        var i = e.touches.length,
            touch;

        while (i--) {
          touch = e.touches[i];

          if (touch.identifier == dragi.el._drag.id) {
            x = touch.clientX;
            y = touch.clientY;
            (e.originalEvent ? e.originalEvent : e).preventDefault();
            break;
          }
        }
      } else {
        e.preventDefault();
      }

      x += scrollX;
      y += scrollY;
      dragi.move && dragi.move.call(dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
    }
  },
      dragUp = function dragUp(e) {
    R.unmousemove(dragMove).unmouseup(dragUp);
    var i = drag.length,
        dragi;

    while (i--) {
      dragi = drag[i];
      dragi.el._drag = {};
      dragi.end && dragi.end.call(dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
    }

    drag = [];
  };

  for (var i = events[length]; i--;) {
    (function (eventName) {
      R[eventName] = Element[proto][eventName] = function (fn, scope) {
        if (R.is(fn, "function")) {
          this.events = this.events || [];
          this.events.push({
            name: eventName,
            f: fn,
            unbind: addEvent(this.shape || this.node || doc, eventName, fn, scope || this)
          });
        }

        return this;
      };

      R["un" + eventName] = Element[proto]["un" + eventName] = function (fn) {
        var events = this.events,
            l = events[length];

        while (l--) {
          if (events[l].name == eventName && events[l].f == fn) {
            events[l].unbind();
            events.splice(l, 1);
            !events.length && delete this.events;
            return this;
          }
        }

        return this;
      };
    })(events[i]);
  }

  elproto.hover = function (f_in, f_out, scope_in, scope_out) {
    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
  };

  elproto.unhover = function (f_in, f_out) {
    return this.unmouseover(f_in).unmouseout(f_out);
  };

  elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
    this._drag = {};
    this.mousedown(function (e) {
      (e.originalEvent || e).preventDefault();
      var scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
          scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft;
      this._drag.x = e.clientX + scrollX;
      this._drag.y = e.clientY + scrollY;
      this._drag.id = e.identifier;
      onstart && onstart.call(start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
      !drag.length && R.mousemove(dragMove).mouseup(dragUp);
      drag.push({
        el: this,
        move: onmove,
        end: onend,
        move_scope: move_scope,
        start_scope: start_scope,
        end_scope: end_scope
      });
    });
    return this;
  };

  elproto.undrag = function (onmove, onstart, onend) {
    var i = drag.length;

    while (i--) {
      drag[i].el == this && drag[i].move == onmove && drag[i].end == onend && drag.splice(i++, 1);
    }

    !drag.length && R.unmousemove(dragMove).unmouseup(dragUp);
  };

  paperproto.circle = function (x, y, r) {
    return theCircle(this, x || 0, y || 0, r || 0);
  };

  paperproto.rect = function (x, y, w, h, r) {
    return theRect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
  };

  paperproto.ellipse = function (x, y, rx, ry) {
    return theEllipse(this, x || 0, y || 0, rx || 0, ry || 0);
  };

  paperproto.path = function (pathString) {
    pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
    return thePath(R.format[apply](R, arguments), this);
  };

  paperproto.image = function (src, x, y, w, h) {
    return theImage(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
  };

  paperproto.text = function (x, y, text) {
    return theText(this, x || 0, y || 0, Str(text));
  };

  paperproto.set = function (itemsArray) {
    arguments[length] > 1 && (itemsArray = Array[proto].splice.call(arguments, 0, arguments[length]));
    return new Set(itemsArray);
  };

  paperproto.setSize = setSize;
  paperproto.top = paperproto.bottom = null;
  paperproto.raphael = R;

  function x_y() {
    return this.x + S + this.y;
  }

  elproto.resetScale = function () {
    if (this.removed) {
      return this;
    }

    this._.sx = 1;
    this._.sy = 1;
    this.attrs.scale = "1 1";
  };

  elproto.scale = function (x, y, cx, cy) {
    if (this.removed) {
      return this;
    }

    if (x == null && y == null) {
      return {
        x: this._.sx,
        y: this._.sy,
        toString: x_y
      };
    }

    y = y || x;
    !+y && (y = x);
    var dx,
        dy,
        a = this.attrs;

    if (x != 0) {
      var bb = this.getBBox(),
          rcx = bb.x + bb.width / 2,
          rcy = bb.y + bb.height / 2,
          kx = abs(x / this._.sx),
          ky = abs(y / this._.sy);
      cx = +cx || cx == 0 ? cx : rcx;
      cy = +cy || cy == 0 ? cy : rcy;
      var posx = this._.sx > 0,
          posy = this._.sy > 0,
          dirx = ~~(x / abs(x)),
          diry = ~~(y / abs(y)),
          dkx = kx * dirx,
          dky = ky * diry,
          s = this.node.style,
          ncx = cx + abs(rcx - cx) * dkx * (rcx > cx == posx ? 1 : -1),
          ncy = cy + abs(rcy - cy) * dky * (rcy > cy == posy ? 1 : -1),
          fr = x * dirx > y * diry ? ky : kx;

      switch (this.type) {
        case "rect":
        case "image":
          var neww = a.width * kx,
              newh = a.height * ky;
          this.attr({
            height: newh,
            r: a.r * fr,
            width: neww,
            x: ncx - neww / 2,
            y: ncy - newh / 2
          });
          break;

        case "circle":
        case "ellipse":
          this.attr({
            rx: a.rx * kx,
            ry: a.ry * ky,
            r: a.r * fr,
            cx: ncx,
            cy: ncy
          });
          break;

        case "text":
          this.attr({
            x: ncx,
            y: ncy
          });
          break;

        case "path":
          var path = pathToRelative(a.path),
              skip = true,
              fx = posx ? dkx : kx,
              fy = posy ? dky : ky;

          for (var i = 0, ii = path[length]; i < ii; i++) {
            var p = path[i],
                P0 = upperCase.call(p[0]);

            if (P0 == "M" && skip) {
              continue;
            } else {
              skip = false;
            }

            if (P0 == "A") {
              p[path[i][length] - 2] *= fx;
              p[path[i][length] - 1] *= fy;
              p[1] *= kx;
              p[2] *= ky;
              p[5] = +(dirx + diry ? !!+p[5] : !+p[5]);
            } else if (P0 == "H") {
              for (var j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= fx;
              }
            } else if (P0 == "V") {
              for (j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= fy;
              }
            } else {
              for (j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= j % 2 ? fx : fy;
              }
            }
          }

          var dim2 = pathDimensions(path);
          dx = ncx - dim2.x - dim2.width / 2;
          dy = ncy - dim2.y - dim2.height / 2;
          path[0][1] += dx;
          path[0][2] += dy;
          this.attr({
            path: path
          });
          break;
      }

      if (this.type in {
        text: 1,
        image: 1
      } && (dirx != 1 || diry != 1)) {
        if (this.transformations) {
          this.transformations[2] = "scale("[concat](dirx, ",", diry, ")");
          setAttr(this.node, "transform", this.transformations[join](S));
          dx = dirx == -1 ? -a.x - (neww || 0) : a.x;
          dy = diry == -1 ? -a.y - (newh || 0) : a.y;
          this.attr({
            x: dx,
            y: dy
          });
          a.fx = dirx - 1;
          a.fy = diry - 1;
        } else {
          this.node.filterMatrix = ms + ".Matrix(M11="[concat](dirx, ", M12=0, M21=0, M22=", diry, ", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");
          s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
        }
      } else {
        if (this.transformations) {
          this.transformations[2] = E;
          setAttr(this.node, "transform", this.transformations[join](S));
          a.fx = 0;
          a.fy = 0;
        } else {
          this.node.filterMatrix = E;
          s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
        }
      }

      a.scale = [x, y, cx, cy][join](S);
      this._.sx = x;
      this._.sy = y;
    }

    return this;
  };

  elproto.clone = function () {
    if (this.removed) {
      return null;
    }

    var attr = this.attr();
    delete attr.scale;
    delete attr.translation;
    return this.paper[this.type]().attr(attr);
  };

  var curveslengths = {},
      getPointAtSegmentLength = function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
    // Is this a straight line?
    // Added for huge speed improvements
    if (p1x === c1x && p1y === c1y && c2x === p2x && c2y == p2y) {
      var dx = p2x - p1x,
          dy = p2y - p1y;
      var totalLength = Math.sqrt(dx * dx + dy * dy);

      if (length == null) {
        return totalLength;
      } else {
        var fract = length / totalLength;
        return {
          start: {
            x: p1x,
            y: p1y
          },
          m: {
            x: p1x,
            y: p1y
          },
          n: {
            x: p2x,
            y: p2y
          },
          end: {
            x: p2x,
            y: p2y
          },
          x: p1x + fract * dx,
          y: p1y + fract * dy,
          alpha: 90 - math.atan(dx / dy) * 180 / PI
        };
      }
    }

    var len = 0,
        precision = 100,
        name = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y].join(),
        cache = curveslengths[name],
        old,
        dot;
    !cache && (curveslengths[name] = cache = {
      data: []
    });
    cache.timer && clearTimeout(cache.timer);
    cache.timer = setTimeout(function () {
      delete curveslengths[name];
    }, 2000);

    if (length != null) {
      var total = getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
      precision = ~~total * 10;
    }

    for (var i = 0; i < precision + 1; i++) {
      if (cache.data[length] > i) {
        dot = cache.data[i * precision];
      } else {
        dot = R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, i / precision);
        cache.data[i] = dot;
      }

      i && (len += pow(pow(old.x - dot.x, 2) + pow(old.y - dot.y, 2), .5));

      if (length != null && len >= length) {
        return dot;
      }

      old = dot;
    }

    if (length == null) {
      return len;
    }
  },
      getLengthFactory = function getLengthFactory(istotal, subpath) {
    return function (path, length, onlystart) {
      path = path2curve(path);
      var x,
          y,
          p,
          l,
          sp = "",
          subpaths = {},
          point,
          len = 0;

      for (var i = 0, ii = path.length; i < ii; i++) {
        p = path[i];

        if (p[0] == "M") {
          x = +p[1];
          y = +p[2];
        } else {
          l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);

          if (len + l > length) {
            if (subpath && !subpaths.start) {
              point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
              sp += ["C", point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];

              if (onlystart) {
                return sp;
              }

              subpaths.start = sp;
              sp = ["M", point.x, point.y + "C", point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]][join]();
              len += l;
              x = +p[5];
              y = +p[6];
              continue;
            }

            if (!istotal && !subpath) {
              point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
              return {
                x: point.x,
                y: point.y,
                alpha: point.alpha
              };
            }
          }

          len += l;
          x = +p[5];
          y = +p[6];
        }

        sp += p;
      }

      subpaths.end = sp;
      point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[1], p[2], p[3], p[4], p[5], p[6], 1);
      point.alpha && (point = {
        x: point.x,
        y: point.y,
        alpha: point.alpha
      });
      return point;
    };
  };

  var getTotalLength = getLengthFactory(1),
      getPointAtLength = getLengthFactory(),
      getSubpathsAtLength = getLengthFactory(0, 1);

  elproto.getTotalLength = function () {
    if (this.type != "path") {
      return;
    }

    if (this.node.getTotalLength) {
      return this.node.getTotalLength();
    }

    return getTotalLength(this.attrs.path);
  };

  elproto.getPointAtLength = function (length) {
    if (this.type != "path") {
      return;
    }

    return getPointAtLength(this.attrs.path, length);
  };

  elproto.getSubpath = function (from, to) {
    if (this.type != "path") {
      return;
    }

    if (abs(this.getTotalLength() - to) < "1e-6") {
      return getSubpathsAtLength(this.attrs.path, from).end;
    }

    var a = getSubpathsAtLength(this.attrs.path, to, 1);
    return from ? getSubpathsAtLength(a, from).end : a;
  }; // animation easing formulas


  R.easing_formulas = {
    linear: function linear(n) {
      return n;
    },
    "<": function _(n) {
      return pow(n, 3);
    },
    ">": function _(n) {
      return pow(n - 1, 3) + 1;
    },
    "<>": function _(n) {
      n = n * 2;

      if (n < 1) {
        return pow(n, 3) / 2;
      }

      n -= 2;
      return (pow(n, 3) + 2) / 2;
    },
    backIn: function backIn(n) {
      var s = 1.70158;
      return n * n * ((s + 1) * n - s);
    },
    backOut: function backOut(n) {
      n = n - 1;
      var s = 1.70158;
      return n * n * ((s + 1) * n + s) + 1;
    },
    elastic: function elastic(n) {
      if (n == 0 || n == 1) {
        return n;
      }

      var p = .3,
          s = p / 4;
      return pow(2, -10 * n) * math.sin((n - s) * (2 * PI) / p) + 1;
    },
    bounce: function bounce(n) {
      var s = 7.5625,
          p = 2.75,
          l;

      if (n < 1 / p) {
        l = s * n * n;
      } else {
        if (n < 2 / p) {
          n -= 1.5 / p;
          l = s * n * n + .75;
        } else {
          if (n < 2.5 / p) {
            n -= 2.25 / p;
            l = s * n * n + .9375;
          } else {
            n -= 2.625 / p;
            l = s * n * n + .984375;
          }
        }
      }

      return l;
    }
  };

  var animationElements = [],
      animation = function animation() {
    var Now = +new Date();

    for (var l = 0; l < animationElements[length]; l++) {
      var e = animationElements[l];

      if (e.stop || e.el.removed) {
        continue;
      }

      var time = Now - e.start,
          ms = e.ms,
          easing = e.easing,
          from = e.from,
          diff = e.diff,
          to = e.to,
          t = e.t,
          that = e.el,
          set = {},
          now;

      if (time < ms) {
        var pos = easing(time / ms);

        for (var attr in from) {
          if (from[has](attr)) {
            switch (availableAnimAttrs[attr]) {
              case "along":
                now = pos * ms * diff[attr];
                to.back && (now = to.len - now);
                var point = getPointAtLength(to[attr], now);
                that.translate(diff.sx - diff.x || 0, diff.sy - diff.y || 0);
                diff.x = point.x;
                diff.y = point.y;
                that.translate(point.x - diff.sx, point.y - diff.sy);
                to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
                break;

              case nu:
                now = +from[attr] + pos * ms * diff[attr];
                break;

              case "colour":
                now = "rgb(" + [upto255(round(from[attr].r + pos * ms * diff[attr].r)), upto255(round(from[attr].g + pos * ms * diff[attr].g)), upto255(round(from[attr].b + pos * ms * diff[attr].b))][join](",") + ")";
                break;

              case "path":
                now = [];

                for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                  now[i] = [from[attr][i][0]];

                  for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                    now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                  }

                  now[i] = now[i][join](S);
                }

                now = now[join](S);
                break;

              case "csv":
                switch (attr) {
                  case "translation":
                    var x = pos * ms * diff[attr][0] - t.x,
                        y = pos * ms * diff[attr][1] - t.y;
                    t.x += x;
                    t.y += y;
                    now = x + S + y;
                    break;

                  case "rotation":
                    now = +from[attr][0] + pos * ms * diff[attr][0];
                    from[attr][1] && (now += "," + from[attr][1] + "," + from[attr][2]);
                    break;

                  case "scale":
                    now = [+from[attr][0] + pos * ms * diff[attr][0], +from[attr][1] + pos * ms * diff[attr][1], 2 in to[attr] ? to[attr][2] : E, 3 in to[attr] ? to[attr][3] : E][join](S);
                    break;

                  case "clip-rect":
                    now = [];
                    i = 4;

                    while (i--) {
                      now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                    }

                    break;
                }

                break;

              default:
                var from2 = [].concat(from[attr]);
                now = [];
                i = that.paper.customAttributes[attr].length;

                while (i--) {
                  now[i] = +from2[i] + pos * ms * diff[attr][i];
                }

                break;
            }

            set[attr] = now;
          }
        }

        that.attr(set);
        that._run && that._run.call(that);
      } else {
        if (to.along) {
          point = getPointAtLength(to.along, to.len * !to.back);
          that.translate(diff.sx - (diff.x || 0) + point.x - diff.sx, diff.sy - (diff.y || 0) + point.y - diff.sy);
          to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
        }

        (t.x || t.y) && that.translate(-t.x, -t.y);
        to.scale && (to.scale += E);
        that.attr(to);
        animationElements.splice(l--, 1);
      }
    }

    R.svg && that && that.paper && that.paper.safari();
    animationElements[length] && setTimeout(animation);
  },
      keyframesRun = function keyframesRun(attr, element, time, prev, prevcallback) {
    var dif = time - prev;
    element.timeouts.push(setTimeout(function () {
      R.is(prevcallback, "function") && prevcallback.call(element);
      element.animate(attr, dif, attr.easing);
    }, prev));
  },
      upto255 = function upto255(color) {
    return mmax(mmin(color, 255), 0);
  },
      translate = function translate(x, y) {
    if (x == null) {
      return {
        x: this._.tx,
        y: this._.ty,
        toString: x_y
      };
    }

    this._.tx += +x;
    this._.ty += +y;

    switch (this.type) {
      case "circle":
      case "ellipse":
        this.attr({
          cx: +x + this.attrs.cx,
          cy: +y + this.attrs.cy
        });
        break;

      case "rect":
      case "image":
      case "text":
        this.attr({
          x: +x + this.attrs.x,
          y: +y + this.attrs.y
        });
        break;

      case "path":
        var path = pathToRelative(this.attrs.path);
        path[0][1] += +x;
        path[0][2] += +y;
        this.attr({
          path: path
        });
        break;
    }

    return this;
  };

  elproto.animateWith = function (element, params, ms, easing, callback) {
    for (var i = 0, ii = animationElements.length; i < ii; i++) {
      if (animationElements[i].el.id == element.id) {
        params.start = animationElements[i].start;
      }
    }

    return this.animate(params, ms, easing, callback);
  };

  elproto.animateAlong = along();
  elproto.animateAlongBack = along(1);

  function along(isBack) {
    return function (path, ms, rotate, callback) {
      var params = {
        back: isBack
      };
      R.is(rotate, "function") ? callback = rotate : params.rot = rotate;
      path && path.constructor == Element && (path = path.attrs.path);
      path && (params.along = path);
      return this.animate(params, ms, callback);
    };
  }

  function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
    var cx = 3 * p1x,
        bx = 3 * (p2x - p1x) - cx,
        ax = 1 - cx - bx,
        cy = 3 * p1y,
        by = 3 * (p2y - p1y) - cy,
        ay = 1 - cy - by;

    function sampleCurveX(t) {
      return ((ax * t + bx) * t + cx) * t;
    }

    function solve(x, epsilon) {
      var t = solveCurveX(x, epsilon);
      return ((ay * t + by) * t + cy) * t;
    }

    function solveCurveX(x, epsilon) {
      var t0, t1, t2, x2, d2, i;

      for (t2 = x, i = 0; i < 8; i++) {
        x2 = sampleCurveX(t2) - x;

        if (abs(x2) < epsilon) {
          return t2;
        }

        d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;

        if (abs(d2) < 1e-6) {
          break;
        }

        t2 = t2 - x2 / d2;
      }

      t0 = 0;
      t1 = 1;
      t2 = x;

      if (t2 < t0) {
        return t0;
      }

      if (t2 > t1) {
        return t1;
      }

      while (t0 < t1) {
        x2 = sampleCurveX(t2);

        if (abs(x2 - x) < epsilon) {
          return t2;
        }

        if (x > x2) {
          t0 = t2;
        } else {
          t1 = t2;
        }

        t2 = (t1 - t0) / 2 + t0;
      }

      return t2;
    }

    return solve(t, 1 / (200 * duration));
  }

  elproto.onAnimation = function (f) {
    this._run = f || 0;
    return this;
  };

  elproto.animate = function (params, ms, easing, callback) {
    var element = this;
    element.timeouts = element.timeouts || [];

    if (R.is(easing, "function") || !easing) {
      callback = easing || null;
    }

    if (element.removed) {
      callback && callback.call(element);
      return element;
    }

    var from = {},
        to = {},
        animateable = false,
        diff = {};

    for (var attr in params) {
      if (params[has](attr)) {
        if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
          animateable = true;
          from[attr] = element.attr(attr);
          from[attr] == null && (from[attr] = availableAttrs[attr]);
          to[attr] = params[attr];

          switch (availableAnimAttrs[attr]) {
            case "along":
              var len = getTotalLength(params[attr]);
              var point = getPointAtLength(params[attr], len * !!params.back);
              var bb = element.getBBox();
              diff[attr] = len / ms;
              diff.tx = bb.x;
              diff.ty = bb.y;
              diff.sx = point.x;
              diff.sy = point.y;
              to.rot = params.rot;
              to.back = params.back;
              to.len = len;
              params.rot && (diff.r = toFloat(element.rotate()) || 0);
              break;

            case nu:
              diff[attr] = (to[attr] - from[attr]) / ms;
              break;

            case "colour":
              from[attr] = R.getRGB(from[attr]);
              var toColour = R.getRGB(to[attr]);
              diff[attr] = {
                r: (toColour.r - from[attr].r) / ms,
                g: (toColour.g - from[attr].g) / ms,
                b: (toColour.b - from[attr].b) / ms
              };
              break;

            case "path":
              var pathes = path2curve(from[attr], to[attr]);
              from[attr] = pathes[0];
              var toPath = pathes[1];
              diff[attr] = [];

              for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                diff[attr][i] = [0];

                for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                  diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                }
              }

              break;

            case "csv":
              var values = Str(params[attr])[split](separator),
                  from2 = Str(from[attr])[split](separator);

              switch (attr) {
                case "translation":
                  from[attr] = [0, 0];
                  diff[attr] = [values[0] / ms, values[1] / ms];
                  break;

                case "rotation":
                  from[attr] = from2[1] == values[1] && from2[2] == values[2] ? from2 : [0, values[1], values[2]];
                  diff[attr] = [(values[0] - from[attr][0]) / ms, 0, 0];
                  break;

                case "scale":
                  params[attr] = values;
                  from[attr] = Str(from[attr])[split](separator);
                  diff[attr] = [(values[0] - from[attr][0]) / ms, (values[1] - from[attr][1]) / ms, 0, 0];
                  break;

                case "clip-rect":
                  from[attr] = Str(from[attr])[split](separator);
                  diff[attr] = [];
                  i = 4;

                  while (i--) {
                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                  }

                  break;
              }

              to[attr] = values;
              break;

            default:
              values = [].concat(params[attr]);
              from2 = [].concat(from[attr]);
              diff[attr] = [];
              i = element.paper.customAttributes[attr][length];

              while (i--) {
                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
              }

              break;
          }
        }
      }
    }

    if (!animateable) {
      var attrs = [],
          lastcall;

      for (var key in params) {
        if (params[has](key) && animKeyFrames.test(key)) {
          attr = {
            value: params[key]
          };
          key == "from" && (key = 0);
          key == "to" && (key = 100);
          attr.key = toInt(key, 10);
          attrs.push(attr);
        }
      }

      attrs.sort(sortByKey);

      if (attrs[0].key) {
        attrs.unshift({
          key: 0,
          value: element.attrs
        });
      }

      for (i = 0, ii = attrs[length]; i < ii; i++) {
        keyframesRun(attrs[i].value, element, ms / 100 * attrs[i].key, ms / 100 * (attrs[i - 1] && attrs[i - 1].key || 0), attrs[i - 1] && attrs[i - 1].value.callback);
      }

      lastcall = attrs[attrs[length] - 1].value.callback;

      if (lastcall) {
        element.timeouts.push(setTimeout(function () {
          lastcall.call(element);
        }, ms));
      }
    } else {
      var easyeasy = R.easing_formulas[easing];

      if (!easyeasy) {
        easyeasy = Str(easing).match(bezierrg);

        if (easyeasy && easyeasy[length] == 5) {
          var curve = easyeasy;

          easyeasy = function easyeasy(t) {
            return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
          };
        } else {
          easyeasy = function easyeasy(t) {
            return t;
          };
        }
      }

      animationElements.push({
        start: params.start || +new Date(),
        ms: ms,
        easing: easyeasy,
        from: from,
        diff: diff,
        to: to,
        el: element,
        t: {
          x: 0,
          y: 0
        }
      });
      R.is(callback, "function") && (element._ac = setTimeout(function () {
        callback.call(element);
      }, ms));
      animationElements[length] == 1 && setTimeout(animation);
    }

    return this;
  };

  elproto.stop = function () {
    for (var i = 0; i < animationElements.length; i++) {
      animationElements[i].el.id == this.id && animationElements.splice(i--, 1);
    }

    for (i = 0, ii = this.timeouts && this.timeouts.length; i < ii; i++) {
      clearTimeout(this.timeouts[i]);
    }

    this.timeouts = [];
    clearTimeout(this._ac);
    delete this._ac;
    return this;
  };

  elproto.translate = function (x, y) {
    return this.attr({
      translation: x + " " + y
    });
  };

  elproto[toString] = function () {
    return "Rapha\xebl\u2019s object";
  };

  R.ae = animationElements; // Set

  var Set = function Set(items) {
    this.items = [];
    this[length] = 0;
    this.type = "set";

    if (items) {
      for (var i = 0, ii = items[length]; i < ii; i++) {
        if (items[i] && (items[i].constructor == Element || items[i].constructor == Set)) {
          this[this.items[length]] = this.items[this.items[length]] = items[i];
          this[length]++;
        }
      }
    }
  };

  Set[proto][push] = function () {
    var item, len;

    for (var i = 0, ii = arguments[length]; i < ii; i++) {
      item = arguments[i];

      if (item && (item.constructor == Element || item.constructor == Set)) {
        len = this.items[length];
        this[len] = this.items[len] = item;
        this[length]++;
      }
    }

    return this;
  };

  Set[proto].pop = function () {
    delete this[this[length]--];
    return this.items.pop();
  };

  for (var method in elproto) {
    if (elproto[has](method)) {
      Set[proto][method] = function (methodname) {
        return function () {
          for (var i = 0, ii = this.items[length]; i < ii; i++) {
            this.items[i][methodname][apply](this.items[i], arguments);
          }

          return this;
        };
      }(method);
    }
  }

  Set[proto].attr = function (name, value) {
    if (name && R.is(name, array) && R.is(name[0], "object")) {
      for (var j = 0, jj = name[length]; j < jj; j++) {
        this.items[j].attr(name[j]);
      }
    } else {
      for (var i = 0, ii = this.items[length]; i < ii; i++) {
        this.items[i].attr(name, value);
      }
    }

    return this;
  };

  Set[proto].animate = function (params, ms, easing, callback) {
    (R.is(easing, "function") || !easing) && (callback = easing || null);
    var len = this.items[length],
        i = len,
        item,
        set = this,
        collector;
    callback && (collector = function collector() {
      ! --len && callback.call(set);
    });
    easing = R.is(easing, string) ? easing : collector;
    item = this.items[--i].animate(params, ms, easing, collector);

    while (i--) {
      this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, params, ms, easing, collector);
    }

    return this;
  };

  Set[proto].insertAfter = function (el) {
    var i = this.items[length];

    while (i--) {
      this.items[i].insertAfter(el);
    }

    return this;
  };

  Set[proto].getBBox = function () {
    var x = [],
        y = [],
        w = [],
        h = [];

    for (var i = this.items[length]; i--;) {
      var box = this.items[i].getBBox();
      x[push](box.x);
      y[push](box.y);
      w[push](box.x + box.width);
      h[push](box.y + box.height);
    }

    x = mmin[apply](0, x);
    y = mmin[apply](0, y);
    return {
      x: x,
      y: y,
      width: mmax[apply](0, w) - x,
      height: mmax[apply](0, h) - y
    };
  };

  Set[proto].clone = function (s) {
    s = new Set();

    for (var i = 0, ii = this.items[length]; i < ii; i++) {
      s[push](this.items[i].clone());
    }

    return s;
  };

  R.registerFont = function (font) {
    if (!font.face) {
      return font;
    }

    this.fonts = this.fonts || {};
    var fontcopy = {
      w: font.w,
      face: {},
      glyphs: {}
    },
        family = font.face["font-family"];

    for (var prop in font.face) {
      if (font.face[has](prop)) {
        fontcopy.face[prop] = font.face[prop];
      }
    }

    if (this.fonts[family]) {
      this.fonts[family][push](fontcopy);
    } else {
      this.fonts[family] = [fontcopy];
    }

    if (!font.svg) {
      fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);

      for (var glyph in font.glyphs) {
        if (font.glyphs[has](glyph)) {
          var path = font.glyphs[glyph];
          fontcopy.glyphs[glyph] = {
            w: path.w,
            k: {},
            d: path.d && "M" + path.d[rp](/[mlcxtrv]/g, function (command) {
              return {
                l: "L",
                c: "C",
                x: "z",
                t: "m",
                r: "l",
                v: "c"
              }[command] || "M";
            }) + "z"
          };

          if (path.k) {
            for (var k in path.k) {
              if (path[has](k)) {
                fontcopy.glyphs[glyph].k[k] = path.k[k];
              }
            }
          }
        }
      }
    }

    return font;
  };

  paperproto.getFont = function (family, weight, style, stretch) {
    stretch = stretch || "normal";
    style = style || "normal";
    weight = +weight || {
      normal: 400,
      bold: 700,
      lighter: 300,
      bolder: 800
    }[weight] || 400;

    if (!R.fonts) {
      return;
    }

    var font = R.fonts[family];

    if (!font) {
      var name = new RegExp("(^|\\s)" + family[rp](/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");

      for (var fontName in R.fonts) {
        if (R.fonts[has](fontName)) {
          if (name.test(fontName)) {
            font = R.fonts[fontName];
            break;
          }
        }
      }
    }

    var thefont;

    if (font) {
      for (var i = 0, ii = font[length]; i < ii; i++) {
        thefont = font[i];

        if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
          break;
        }
      }
    }

    return thefont;
  };

  paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
    origin = origin || "middle"; // baseline|middle

    letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
    var out = this.set(),
        letters = Str(string)[split](E),
        shift = 0,
        scale;
    R.is(font, string) && (font = this.getFont(font));

    if (font) {
      scale = (size || 16) / font.face["units-per-em"];
      var bb = font.face.bbox.split(separator),
          top = +bb[0],
          height = +bb[1] + (origin == "baseline" ? bb[3] - bb[1] + +font.face.descent : (bb[3] - bb[1]) / 2);

      for (var i = 0, ii = letters[length]; i < ii; i++) {
        var prev = i && font.glyphs[letters[i - 1]] || {},
            curr = font.glyphs[letters[i]];
        shift += i ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
        curr && curr.d && out[push](this.path(curr.d).attr({
          fill: "#000",
          stroke: "none",
          translation: [shift, 0]
        }));
      }

      out.scale(scale, scale, top, height).translate(x - top, y - height);
    }

    return out;
  };

  R.format = function (token, params) {
    var args = R.is(params, array) ? [0][concat](params) : arguments;
    token && R.is(token, string) && args[length] - 1 && (token = token[rp](formatrg, function (str, i) {
      return args[++i] == null ? E : args[i];
    }));
    return token || E;
  };

  R.ninja = function () {
    oldRaphael.was ? win.Raphael = oldRaphael.is : delete win.Raphael;
    return R;
  };

  R.el = elproto;
  R.st = Set[proto];
  oldRaphael.was ? win.Raphael = R : Raphael = R;
})();

var _module_$2j = {
  exports: {}
};
/* eslint-disable brace-style, max-lines, object-curly-spacing */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var kpoint$c = _kmath3.point;
var kvector$a = _kmath3.vector;
var _$1x = _underscore__default["default"]; // Minify Raphael ourselves because IE8 has a problem with the 1.5.2 minified
// release
// http://groups.google.com/group/raphaeljs/browse_thread/thread/c34c75ad8d431544

/* globals Raphael:false */

var KhanMath$9 = _utilMathJs;
var processMath$1 = _utilTexJs.processMath;
var KhanColors$f = _utilColorsJs;
/* Convert cartesian coordinates [x, y] to polar coordinates [r,
 * theta], with theta in degrees, or in radians if angleInRadians is
 * specified.
 */

function cartToPolar(coord, angleInRadians) {
  var r = Math.sqrt(Math.pow(coord[0], 2) + Math.pow(coord[1], 2));
  var theta = Math.atan2(coord[1], coord[0]); // convert angle range from [-pi, pi] to [0, 2pi]

  if (theta < 0) {
    theta += 2 * Math.PI;
  }

  if (!angleInRadians) {
    theta = theta * 180 / Math.PI;
  }

  return [r, theta];
}

function polar(r, th) {
  if (typeof r === "number") {
    r = [r, r];
  }

  th = th * Math.PI / 180;
  return [r[0] * Math.cos(th), r[1] * Math.sin(th)];
}

var GraphUtils$8 = {
  unscaledSvgPath: function unscaledSvgPath(points) {
    // If this is an empty closed path, return "" instead of "z", which
    // would give an error
    if (points[0] === true) {
      return "";
    }

    return $__default["default"].map(points, function (point, i) {
      if (point === true) {
        return "z";
      }

      return (i === 0 ? "M" : "L") + point[0] + " " + point[1];
    }).join("");
  },
  getDistance: function getDistance(point1, point2) {
    return kpoint$c.distanceToPoint(point1, point2);
  },

  /**
  * Return the difference between two sets of coordinates
  */
  coordDiff: function coordDiff(startCoord, endCoord) {
    return _$1x.map(endCoord, function (val, i) {
      return endCoord[i] - startCoord[i];
    });
  },

  /**
  * Round the given coordinates to a given snap value
  * (e.g., nearest 0.2 increment)
  */
  snapCoord: function snapCoord(coord, snap) {
    return _$1x.map(coord, function (val, i) {
      return KhanMath$9.roundToNearest(snap[i], val);
    });
  },
  // Find the angle in degrees between two or three points
  findAngle: function findAngle(point1, point2, vertex) {
    if (vertex === undefined) {
      var x = point1[0] - point2[0];
      var y = point1[1] - point2[1];

      if (!x && !y) {
        return 0;
      }

      return (180 + Math.atan2(-y, -x) * 180 / Math.PI + 360) % 360;
    } else {
      return GraphUtils$8.findAngle(point1, vertex) - GraphUtils$8.findAngle(point2, vertex);
    }
  },
  graphs: {}
};

var Graphie$8 = GraphUtils$8.Graphie = function () {};

_$1x.extend(Graphie$8.prototype, {
  cartToPolar: cartToPolar,
  polar: polar
});

var labelDirections = {
  center: [-0.5, -0.5],
  above: [-0.5, -1.0],
  "above right": [0.0, -1.0],
  right: [0.0, -0.5],
  "below right": [0.0, 0.0],
  below: [-0.5, 0.0],
  "below left": [-1.0, 0.0],
  left: [-1.0, -0.5],
  "above left": [-1.0, -1.0]
};
/**
 * Safari applies some SVG-specific styles to things that are not SVGs, so we
 * need to exclude those styles from things that are not SVGs.
 *
 * To see this behavior in action, open https://codepen.io/anon/pen/zENEoa in
 * Safari.
 *
 * Usage `$.extend({}, someStyles, SVG_SPECIFIC_STYLE_MASK)`
 */

var SVG_SPECIFIC_STYLE_MASK = {
  "stroke-width": null
};

GraphUtils$8.createGraphie = function (el) {
  var xScale = 40;
  var yScale = 40;
  var xRange;
  var yRange;
  $__default["default"](el).css("position", "relative");
  var raphael = Raphael(el); // For a sometimes-reproducible IE8 bug; doesn't affect SVG browsers at all

  $__default["default"](el).children("div").css("position", "absolute"); // Set up some reasonable defaults

  var currentStyle = {
    "stroke-width": 2,
    fill: "none"
  };

  var scaleVector = function scaleVector(point) {
    if (typeof point === "number") {
      return scaleVector([point, point]);
    }

    var x = point[0];
    var y = point[1];
    return [x * xScale, y * yScale];
  };

  var scalePoint = function scalePoint(point) {
    if (typeof point === "number") {
      return scalePoint([point, point]);
    }

    var x = point[0];
    var y = point[1];
    return [(x - xRange[0]) * xScale, (yRange[1] - y) * yScale];
  };

  var unscalePoint = function unscalePoint(point) {
    if (typeof point === "number") {
      return unscalePoint([point, point]);
    }

    var x = point[0];
    var y = point[1];
    return [x / xScale + xRange[0], yRange[1] - y / yScale];
  };

  var unscaleVector = function unscaleVector(point) {
    if (typeof point === "number") {
      return unscaleVector([point, point]);
    }

    return [point[0] / xScale, point[1] / yScale];
  };

  var setLabelMargins = function setLabelMargins(span, size) {
    var $span = $__default["default"](span);
    var direction = $span.data("labelDirection");
    $span.css("visibility", "");

    if (typeof direction === "number") {
      var x = Math.cos(direction);
      var y = Math.sin(direction);
      var scale = Math.min(size[0] / 2 / Math.abs(x), size[1] / 2 / Math.abs(y));
      $span.css({
        marginLeft: -size[0] / 2 + x * scale,
        marginTop: -size[1] / 2 - y * scale
      });
    } else {
      var multipliers = labelDirections[direction || "center"];
      $span.css({
        marginLeft: Math.round(size[0] * multipliers[0]),
        marginTop: Math.round(size[1] * multipliers[1])
      });
    }
  };

  var svgPath = function svgPath(points, alreadyScaled) {
    return $__default["default"].map(points, function (point, i) {
      if (point === true) {
        return "z";
      } else {
        var scaled = alreadyScaled ? point : scalePoint(point);
        return (i === 0 ? "M" : "L") + KhanMath$9.bound(scaled[0]) + " " + KhanMath$9.bound(scaled[1]);
      }
    }).join("");
  };

  var svgParabolaPath = function svgParabolaPath(a, b, c) {
    var computeParabola = function computeParabola(x) {
      return (a * x + b) * x + c;
    }; // If points are collinear, plot a line instead


    if (a === 0) {
      var _points = _$1x.map(xRange, function (x) {
        return [x, computeParabola(x)];
      });

      return svgPath(_points);
    } // Calculate x coordinates of points on parabola


    var xVertex = -b / (2 * a);
    var distToEdge = Math.max(Math.abs(xVertex - xRange[0]), Math.abs(xVertex - xRange[1])); // To guarantee that drawn parabola to spans the viewport, use a point
    // on the edge of the graph furtherest from the vertex

    var xPoint = xVertex + distToEdge; // Compute parabola and other point on the curve

    var vertex = [xVertex, computeParabola(xVertex)];
    var point = [xPoint, computeParabola(xPoint)]; // Calculate SVG 'control' point, defined by spec

    var control = [vertex[0], vertex[1] - (point[1] - vertex[1])]; // Calculate mirror points across parabola's axis of symmetry

    var dx = Math.abs(vertex[0] - point[0]);
    var left = [vertex[0] - dx, point[1]];
    var right = [vertex[0] + dx, point[1]]; // Scale and bound

    var points = _$1x.map([left, control, right], scalePoint);

    var values = _$1x.map(_$1x.flatten(points), KhanMath$9.bound);

    return "M" + values[0] + "," + values[1] + " Q" + values[2] + "," + values[3] + " " + values[4] + "," + values[5];
  };

  var svgSinusoidPath = function svgSinusoidPath(a, b, c, d) {
    // Plot a sinusoid of the form: f(x) = a * sin(b * x - c) + d
    var quarterPeriod = Math.abs(Math.PI / (2 * b));

    var computeSine = function computeSine(x) {
      return a * Math.sin(b * x - c) + d;
    };

    var computeDerivative = function computeDerivative(x) {
      return a * b * Math.cos(c - b * x);
    };

    var coordsForOffset = function coordsForOffset(initial, i) {
      // Return the cubic coordinates (including the two anchor and two
      // control points) for the ith portion of the sinusoid.
      var x0 = initial + quarterPeriod * i;
      var x1 = x0 + quarterPeriod; // Interpolate using derivative technique
      // See: http://stackoverflow.com/questions/13932704/how-to-draw-sine-waves-with-svg-js

      var xCoords = [x0, x0 * 2 / 3 + x1 * 1 / 3, x0 * 1 / 3 + x1 * 2 / 3, x1];
      var yCoords = [computeSine(x0), computeSine(x0) + computeDerivative(x0) * (x1 - x0) / 3, computeSine(x1) - computeDerivative(x1) * (x1 - x0) / 3, computeSine(x1)]; // Zip and scale

      return _$1x.map(_$1x.zip(xCoords, yCoords), scalePoint);
    }; // How many quarter-periods do we need to span the graph?


    var extent = xRange[1] - xRange[0];
    var numQuarterPeriods = Math.ceil(extent / quarterPeriod) + 1; // Find starting coordinate: first anchor point curve left of xRange[0]

    var initial = c / b;
    var distToEdge = initial - xRange[0];
    initial -= quarterPeriod * Math.ceil(distToEdge / quarterPeriod); // First portion of path is special-case, requiring move-to ('M')

    var coords = coordsForOffset(initial, 0);
    var path = "M" + coords[0][0] + "," + coords[0][1] + " C" + coords[1][0] + "," + coords[1][1] + " " + coords[2][0] + "," + coords[2][1] + " " + coords[3][0] + "," + coords[3][1];

    for (var i = 1; i < numQuarterPeriods; i++) {
      coords = coordsForOffset(initial, i);
      path += " C" + coords[1][0] + "," + coords[1][1] + " " + coords[2][0] + "," + coords[2][1] + " " + coords[3][0] + "," + coords[3][1];
    }

    return path;
  }; // `svgPath` is independent of graphie range, so we export it independently


  GraphUtils$8.svgPath = svgPath;

  var processAttributes = function processAttributes(attrs) {
    var transformers = {
      scale: function scale(_scale) {
        if (typeof _scale === "number") {
          _scale = [_scale, _scale];
        }

        xScale = _scale[0];
        yScale = _scale[1]; // Update the canvas size

        raphael.setSize((xRange[1] - xRange[0]) * xScale, (yRange[1] - yRange[0]) * yScale);
      },
      clipRect: function clipRect(pair) {
        var point = pair[0];
        var size = pair[1];
        point[1] += size[1]; // because our coordinates are flipped

        return {
          "clip-rect": scalePoint(point).concat(scaleVector(size)).join(" ")
        };
      },
      strokeWidth: function strokeWidth(val) {
        return {
          "stroke-width": parseFloat(val)
        };
      },
      rx: function rx(val) {
        return {
          rx: scaleVector([val, 0])[0]
        };
      },
      ry: function ry(val) {
        return {
          ry: scaleVector([0, val])[1]
        };
      },
      r: function r(val) {
        var scaled = scaleVector([val, val]);
        return {
          rx: scaled[0],
          ry: scaled[1]
        };
      }
    };
    var processed = {};
    $__default["default"].each(attrs || {}, function (key, value) {
      var transformer = transformers[key];

      if (typeof transformer === "function") {
        $__default["default"].extend(processed, transformer(value));
      } else {
        var dasherized = key.replace(/([A-Z]+)([A-Z][a-z])/g, "$1-$2").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
        processed[dasherized] = value;
      }
    });
    return processed;
  };

  var addArrowheads = function arrows(path) {
    var type = path.constructor.prototype;

    if (type === Raphael.el) {
      if (path.type === "path" && typeof path.arrowheadsDrawn === "undefined") {
        var w = path.attr("stroke-width");
        var s = 0.6 + 0.4 * w;
        var l = path.getTotalLength();
        var set = raphael.set();
        var head = raphael.path(graphie.isMobile ? "M-4,4 C-4,4 -0.25,0 -0.25,0 C-0.25,0 -4,-4 -4,-4" : "M-3 4 C-2.75 2.5 0 0.25 0.75 0C0 -0.25 -2.75 -2.5 -3 -4" // eslint-disable-line max-len
        );
        var end = path.getPointAtLength(l - 0.4);
        var almostTheEnd = path.getPointAtLength(l - 0.75 * s);
        var angle = Math.atan2(end.y - almostTheEnd.y, end.x - almostTheEnd.x) * 180 / Math.PI;
        var attrs = path.attr();
        delete attrs.path;
        var subpath = path.getSubpath(0, l - 0.75 * s);
        subpath = raphael.path(subpath).attr(attrs);
        subpath.arrowheadsDrawn = true;
        path.remove(); // For some unknown reason 0 doesn't work for the rotation
        // origin so we use a tiny number.

        head.rotate(angle, graphie.isMobile ? 1e-5 : 0.75, 0).scale(s, s, 0.75, 0).translate(almostTheEnd.x, almostTheEnd.y).attr(attrs).attr({
          "stroke-linejoin": "round",
          "stroke-linecap": "round"
        });
        head.arrowheadsDrawn = true;
        set.push(subpath);
        set.push(head);
        return set;
      }
    } else if (type === Raphael.st) {
      for (var i = 0, _l = path.items.length; i < _l; i++) {
        arrows(path.items[i]);
      }
    }

    return path;
  };

  var drawingTools = {
    circle: function circle(center, radius) {
      return raphael.ellipse(...scalePoint(center).concat(scaleVector([radius, radius])));
    },
    // (x, y) is coordinate of bottom left corner
    rect: function rect(x, y, width, height) {
      // Raphael needs (x, y) to be coordinate of upper left corner
      var corner = scalePoint([x, y + height]);
      var dims = scaleVector([width, height]);
      var elem = raphael.rect(...corner.concat(dims));

      if (graphie.isMobile) {
        elem.node.style.shapeRendering = "crispEdges";
      }

      return elem;
    },
    ellipse: function ellipse(center, radii) {
      return raphael.ellipse(...scalePoint(center).concat(scaleVector(radii)));
    },
    fixedEllipse: function fixedEllipse(center, radii, maxScale, padding) {
      // Scale point and radius
      var scaledPoint = scalePoint(center);
      var scaledRadii = scaleVector(radii);
      var width = 2 * scaledRadii[0] * maxScale + padding;
      var height = 2 * scaledRadii[1] * maxScale + padding; // Calculate absolute left, top

      var left = scaledPoint[0] - width / 2;
      var top = scaledPoint[1] - height / 2; // Wrap in <div>

      var wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px"
      }); // Create Raphael canvas

      var localRaphael = Raphael(wrapper, width, height);
      var visibleShape = localRaphael.ellipse(width / 2, height / 2, scaledRadii[0], scaledRadii[1]);
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    arc: function arc(center, radius, startAngle, endAngle, sector) {
      startAngle = (startAngle % 360 + 360) % 360;
      endAngle = (endAngle % 360 + 360) % 360;
      var cent = scalePoint(center);
      var radii = scaleVector(radius);
      var startVector = polar(radius, startAngle);
      var endVector = polar(radius, endAngle);
      var startPoint = scalePoint([center[0] + startVector[0], center[1] + startVector[1]]);
      var endPoint = scalePoint([center[0] + endVector[0], center[1] + endVector[1]]);
      var largeAngle = ((endAngle - startAngle) % 360 + 360) % 360 > 180;
      return raphael.path("M" + startPoint.join(" ") + "A" + radii.join(" ") + " 0 " + ( // ellipse rotation
      largeAngle ? 1 : 0) + " 0 " + // sweep flag
      endPoint.join(" ") + (sector ? "L" + cent.join(" ") + "z" : ""));
    },
    path: function path(points) {
      var p = raphael.path(svgPath(points));
      p.graphiePath = points;
      return p;
    },
    fixedPath: function fixedPath(points, center, createPath) {
      points = _$1x.map(points, scalePoint);
      center = center ? scalePoint(center) : null;
      createPath = createPath || svgPath;

      var pathLeft = _$1x.min(_$1x.pluck(points, 0));

      var pathRight = _$1x.max(_$1x.pluck(points, 0));

      var pathTop = _$1x.min(_$1x.pluck(points, 1));

      var pathBottom = _$1x.max(_$1x.pluck(points, 1)); // Apply padding to line


      var padding = [4, 4]; // Calculate and apply additional offset

      var extraOffset = [pathLeft, pathTop]; // Apply padding and offset to points

      points = _$1x.map(points, function (point) {
        return kvector$a.add(kvector$a.subtract(point, extraOffset), kvector$a.scale(padding, 0.5));
      }); // Calculate <div> dimensions

      var width = pathRight - pathLeft + padding[0];
      var height = pathBottom - pathTop + padding[1];
      var left = extraOffset[0] - padding[0] / 2;
      var top = extraOffset[1] - padding[1] / 2; // Create <div>

      var wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px",
        // If user specified a center, set it
        transformOrigin: center ? width / 2 + center[0] + "px " + (height / 2 + center[1]) + "px" : null
      }); // Create Raphael canvas

      var localRaphael = Raphael(wrapper, width, height); // Calculate path

      var visibleShape = localRaphael.path(createPath(points));
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    scaledPath: function scaledPath(points) {
      var p = raphael.path(svgPath(points,
      /* alreadyScaled */
      true));
      p.graphiePath = points;
      return p;
    },
    line: function line(start, end) {
      var l = this.path([start, end]);

      if (graphie.isMobile) {
        l.node.style.shapeRendering = "crispEdges";
      }

      return l;
    },
    parabola: function parabola(a, b, c) {
      // Plot a parabola of the form: f(x) = (a * x + b) * x + c
      return raphael.path(svgParabolaPath(a, b, c));
    },
    fixedLine: function fixedLine(start, end, thickness) {
      // Apply padding to line
      var padding = [thickness, thickness]; // Scale points to get values in pixels

      start = scalePoint(start);
      end = scalePoint(end); // Calculate and apply additional offset

      var extraOffset = [Math.min(start[0], end[0]), Math.min(start[1], end[1])]; // Apply padding and offset to start, end points

      start = kvector$a.add(kvector$a.subtract(start, extraOffset), kvector$a.scale(padding, 0.5));
      end = kvector$a.add(kvector$a.subtract(end, extraOffset), kvector$a.scale(padding, 0.5)); // Calculate <div> dimensions

      var left = extraOffset[0] - padding[0] / 2;
      var top = extraOffset[1] - padding[1] / 2;
      var width = Math.abs(start[0] - end[0]) + padding[0];
      var height = Math.abs(start[1] - end[1]) + padding[1]; // Create <div>

      var wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px",
        // Outsiders should feel like the line's 'origin' (i.e., for
        // rotation) is the starting point
        transformOrigin: start[0] + "px " + start[1] + "px"
      }); // Create Raphael canvas

      var localRaphael = Raphael(wrapper, width, height); // Calculate path

      var path = "M" + start[0] + " " + start[1] + " " + "L" + end[0] + " " + end[1];
      var visibleShape = localRaphael.path(path);
      visibleShape.graphiePath = [start, end];
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    sinusoid: function sinusoid(a, b, c, d) {
      // Plot a sinusoid of the form: f(x) = a * sin(b * x - c) + d
      return raphael.path(svgSinusoidPath(a, b, c, d));
    },
    grid: function grid(xr, yr) {
      var step = currentStyle.step || [1, 1];
      var set = raphael.set();
      var x = step[0] * Math.ceil(xr[0] / step[0]);

      for (; x <= xr[1]; x += step[0]) {
        set.push(this.line([x, yr[0]], [x, yr[1]]));
      }

      var y = step[1] * Math.ceil(yr[0] / step[1]);

      for (; y <= yr[1]; y += step[1]) {
        set.push(this.line([xr[0], y], [xr[1], y]));
      }

      return set;
    },
    label: function label(point, text, direction, latex) {
      latex = typeof latex === "undefined" || latex;
      var $span = $__default["default"]("<span>").addClass("graphie-label");
      var pad = currentStyle["label-distance"];
      $span.css($__default["default"].extend({}, {
        position: "absolute",
        padding: (pad != null ? pad : 7) + "px"
      })).data("labelDirection", direction).appendTo(el);

      $span.setPosition = function (point) {
        var scaledPoint = scalePoint(point);
        $span.css({
          left: scaledPoint[0],
          top: scaledPoint[1]
        });
      };

      $span.setPosition(point);
      var span = $span[0];

      $span.processMath = function (math, force) {
        processMath$1(span, math, force, function () {
          var width = span.scrollWidth;
          var height = span.scrollHeight;
          setLabelMargins(span, [width, height]);
        });
      };

      $span.processText = function (text) {
        $span.html(text);
        var width = span.scrollWidth;
        var height = span.scrollHeight;
        setLabelMargins(span, [width, height]);
      };

      if (latex) {
        $span.processMath(text,
        /* force */
        false);
      } else {
        $span.processText(text);
      }

      return $span;
    },
    plotParametric: function plotParametric(fn, range, shade, fn2) {
      // Note: fn2 should only be set if 'shade' is true, as it denotes
      // the function between which fn should have its area shaded.
      // In general, plotParametric shouldn't be used to shade the area
      // between two arbitrary parametrics functions over an interval,
      // as the method assumes that fn and fn2 are both of the form
      // fn(t) = (t, fn'(t)) for some initial fn'.
      fn2 = fn2 || function (t) {
        return [t, 0];
      }; // We truncate to 500,000, since anything bigger causes
      // overflow in the firefox svg renderer.  This is safe
      // since 500,000 is outside the viewport anyway.  We
      // write these functions the way we do to handle undefined.


      var clipper = xy => {
        if (Math.abs(xy[1]) > 500000) {
          return [xy[0], Math.min(Math.max(xy[1], -500000), 500000)];
        }

        return xy;
      };

      var clippedFn = x => clipper(fn(x));

      var clippedFn2 = x => clipper(fn2(x));

      if (!currentStyle.strokeLinejoin) {
        currentStyle.strokeLinejoin = "round";
      }

      if (!currentStyle.strokeLinecap) {
        currentStyle.strokeLinecap = "round";
      }

      var min = range[0];
      var max = range[1];
      var step = (max - min) / (currentStyle["plot-points"] || 800);

      if (step === 0) {
        step = 1;
      }

      var paths = raphael.set();
      var points = [];
      var lastDiff = GraphUtils$8.coordDiff(clippedFn(min), clippedFn2(min));
      var lastFlip = min;

      for (var t = min; t <= max; t += step) {
        var top = clippedFn(t);
        var bottom = clippedFn2(t);
        var diff = GraphUtils$8.coordDiff(top, bottom); // Find points where it flips
        // Create path that sketches area between the two functions

        if ( // if there is an asymptote here, meaning that the graph
        // switches signs and has a large difference
        diff[1] < 0 !== lastDiff[1] < 0 && Math.abs(diff[1] - lastDiff[1]) > 2 * yScale || // or the function is undefined
        isNaN(diff[1])) {
          // split the path at this point, and draw it
          if (shade) {
            points.push(top); // backtrack to draw paired function

            for (var u = t - step; u >= lastFlip; u -= step) {
              points.push(clippedFn2(u));
            }

            lastFlip = t;
          }

          paths.push(this.path(points)); // restart the path, excluding this point

          points = [];

          if (shade) {
            points.push(top);
          }
        } else {
          // otherwise, just add the point to the path
          points.push(top);
        }

        lastDiff = diff;
      }

      if (shade) {
        // backtrack to draw paired function
        for (var _u = max - step; _u >= lastFlip; _u -= step) {
          points.push(clippedFn2(_u));
        }
      }

      paths.push(this.path(points));
      return paths;
    },
    plotPolar: function plotPolar(fn, range) {
      var min = range[0];
      var max = range[1]; // There is probably a better heuristic for this

      if (!currentStyle["plot-points"]) {
        currentStyle["plot-points"] = 2 * (max - min) * xScale;
      }

      return this.plotParametric(function (th) {
        return polar(fn(th), th * 180 / Math.PI);
      }, range);
    },
    plot: function plot(fn, range, swapAxes, shade, fn2) {
      var min = range[0];
      var max = range[1];

      if (!currentStyle["plot-points"]) {
        currentStyle["plot-points"] = 2 * (max - min) * xScale;
      }

      if (swapAxes) {
        if (fn2) {
          // TODO(charlie): support swapped axis area shading
          throw new Error("Can't shade area between functions with swapped axes.");
        }

        return this.plotParametric(function (y) {
          return [fn(y), y];
        }, range, shade);
      } else {
        if (fn2) {
          if (shade) {
            return this.plotParametric(function (x) {
              return [x, fn(x)];
            }, range, shade, function (x) {
              return [x, fn2(x)];
            });
          } else {
            throw new Error("fn2 should only be set when 'shade' is True.");
          }
        }

        return this.plotParametric(function (x) {
          return [x, fn(x)];
        }, range, shade);
      }
    },

    /**
     * Given a piecewise function, return a Raphael set of paths that
     * can be used to draw the function, e.g. using style().
     * Calls plotParametric.
     *
     * @param  {[]} fnArray    array of functions which when called
     *                         with a parameter i return the value of
     *                         the function at i
     * @param  {[]} rangeArray array of ranges over which the
     *                         corresponding functions are defined
     * @return {Raphael set}
     */
    plotPiecewise: function plotPiecewise(fnArray, rangeArray) {
      var paths = raphael.set();
      var self = this;

      _$1x.times(fnArray.length, function (i) {
        var fn = fnArray[i];
        var range = rangeArray[i];
        var fnPaths = self.plotParametric(function (x) {
          return [x, fn(x)];
        }, range);

        _$1x.each(fnPaths, function (fnPath) {
          paths.push(fnPath);
        });
      });

      return paths;
    },

    /**
     * Given an array of coordinates of the form [x, y], create and
     * return a Raphael set of Raphael circle objects at those
     * coordinates
     *
     * @param  {Array of arrays} endpointArray
     * @return {Raphael set}
     */
    plotEndpointCircles: function plotEndpointCircles(endpointArray) {
      var circles = raphael.set();
      var self = this;

      _$1x.each(endpointArray, function (coord, i) {
        circles.push(self.circle(coord, 0.15));
      });

      return circles;
    },
    plotAsymptotes: function plotAsymptotes(fn, range) {
      var min = range[0];
      var max = range[1];
      var step = (max - min) / (currentStyle["plot-points"] || 800);
      var asymptotes = raphael.set();
      var lastVal = fn(min);

      for (var t = min; t <= max; t += step) {
        var funcVal = fn(t);

        if (funcVal < 0 !== lastVal < 0 && Math.abs(funcVal - lastVal) > 2 * yScale) {
          asymptotes.push(this.line([t, yScale], [t, -yScale]));
        }

        lastVal = funcVal;
      }

      return asymptotes;
    }
  };
  var graphie = new Graphie$8();

  _$1x.extend(graphie, {
    raphael: raphael,
    init: function init(options) {
      var scale = options.scale || [40, 40];
      scale = typeof scale === "number" ? [scale, scale] : scale;
      xScale = scale[0];
      yScale = scale[1];

      if (options.range == null) {
        return Khan.error("range should be specified in graph init");
      }

      xRange = options.range[0];
      yRange = options.range[1];
      var w = (xRange[1] - xRange[0]) * xScale;
      var h = (yRange[1] - yRange[0]) * yScale;
      raphael.setSize(w, h);
      $__default["default"](el).css({
        width: w,
        height: h
      });
      this.range = options.range;
      this.scale = scale;
      this.dimensions = [w, h];
      this.xpixels = w;
      this.ypixels = h;
      this.isMobile = options.isMobile;
      return this;
    },
    style: function style(attrs, fn) {
      var processed = processAttributes(attrs);

      if (typeof fn === "function") {
        var oldStyle = currentStyle;
        currentStyle = $__default["default"].extend({}, currentStyle, processed);
        var result = fn.call(graphie);
        currentStyle = oldStyle;
        return result;
      } else {
        $__default["default"].extend(currentStyle, processed);
      }
    },
    scalePoint: scalePoint,
    scaleVector: scaleVector,
    unscalePoint: unscalePoint,
    unscaleVector: unscaleVector,
    // Custom SVG path functions that are dependent on graphie range
    // `svgPath`, while independent of range, is exported for consistency
    svgPath: svgPath,
    svgParabolaPath: svgParabolaPath,
    svgSinusoidPath: svgSinusoidPath
  });

  $__default["default"].each(drawingTools, function (name) {
    graphie[name] = function () {
      var last = arguments[arguments.length - 1];
      var oldStyle = currentStyle;
      var result; // The last argument is probably trying to change the style

      if (typeof last === "object" && !_$1x.isArray(last)) {
        currentStyle = _objectSpread2(_objectSpread2({}, currentStyle), processAttributes(last));
        var rest = [].slice.call(arguments, 0, arguments.length - 1);
        result = drawingTools[name](...rest);
      } else {
        currentStyle = $__default["default"].extend({}, currentStyle);
        result = drawingTools[name](...arguments);
      } // Bad heuristic for recognizing Raphael elements and sets


      var type = result.constructor.prototype;

      if (type === Raphael.el || type === Raphael.st) {
        result.attr(currentStyle);

        if (currentStyle.arrows) {
          result = addArrowheads(result);
        }
      } else if (result instanceof $__default["default"]) {
        // We assume that if it's not a Raphael element/set, it
        // does not contain SVG.
        result.css(_objectSpread2(_objectSpread2({}, currentStyle), SVG_SPECIFIC_STYLE_MASK));
      }

      currentStyle = oldStyle;
      return result;
    };
  }); // Initializes graphie settings for a graph and draws the basic graph
  // features (axes, grid, tick marks, and axis labels)
  // Options expected are:
  // - range: [[a, b], [c, d]] or [a, b]
  // - scale: [a, b] or number
  // - gridOpacity: number (0 - 1)
  // - gridStep: [a, b] or number (relative to units)
  // - tickStep: [a, b] or number (relative to grid steps)
  // - tickLen: [a, b] or number (in pixels)
  // - labelStep: [a, b] or number (relative to tick steps)
  // - yLabelFormat: fn to format label string for y-axis
  // - xLabelFormat: fn to format label string for x-axis
  // - smartLabelPositioning: true or false to ignore minus sign

  graphie.graphInit = function (options) {
    options = options || {};
    $__default["default"].each(options, function (prop, val) {
      // allow options to be specified by a single number for shorthand if
      // the horizontal and vertical components are the same
      if (!prop.match(/.*Opacity$/) && prop !== "range" && typeof val === "number") {
        options[prop] = [val, val];
      } // allow symmetric ranges to be specified by the absolute values


      if (prop === "range" || prop === "gridRange") {
        if (val.constructor === Array) {
          // but don't mandate symmetric ranges
          if (val[0].constructor !== Array) {
            options[prop] = [[-val[0], val[0]], [-val[1], val[1]]];
          }
        } else if (typeof val === "number") {
          options[prop] = [[-val, val], [-val, val]];
        }
      }
    });
    var range = options.range || [[-10, 10], [-10, 10]];
    var gridRange = options.gridRange || options.range;
    var scale = options.scale || [20, 20];
    var grid = options.grid != null ? options.grid : true;
    var gridOpacity = options.gridOpacity || 0.1;
    var gridStep = options.gridStep || [1, 1];
    var axes = options.axes != null ? options.axes : true;
    var axisArrows = options.axisArrows || "";
    var axisOpacity = options.axisOpacity || 1.0;
    var axisCenter = options.axisCenter || [Math.min(Math.max(range[0][0], 0), range[0][1]), Math.min(Math.max(range[1][0], 0), range[1][1])];
    var axisLabels = options.axisLabels != null ? options.axisLabels : false;
    var ticks = options.ticks != null ? options.ticks : true;
    var tickStep = options.tickStep || [2, 2];
    var tickLen = options.tickLen || [5, 5];
    var tickOpacity = options.tickOpacity || 1.0;
    var labels = options.labels || options.labelStep || false;
    var labelStep = options.labelStep || [1, 1];
    var labelOpacity = options.labelOpacity || 1.0;
    var unityLabels = options.unityLabels || false;

    var labelFormat = options.labelFormat || function (a) {
      return a;
    };

    var xLabelFormat = options.xLabelFormat || labelFormat;
    var yLabelFormat = options.yLabelFormat || labelFormat;
    var smartLabelPositioning = options.smartLabelPositioning != null ? options.smartLabelPositioning : true;
    var realRange = [[range[0][0] - (range[0][0] > 0 ? 1 : 0), range[0][1] + (range[0][1] < 0 ? 1 : 0)], [range[1][0] - (range[1][0] > 0 ? 1 : 0), range[1][1] + (range[1][1] < 0 ? 1 : 0)]];

    if (!_$1x.isArray(unityLabels)) {
      unityLabels = [unityLabels, unityLabels];
    }

    if (smartLabelPositioning) {
      var minusIgnorer = function minusIgnorer(lf) {
        return function (a) {
          return (lf(a) + "").replace(/-(\d)/g, "\\llap{-}$1");
        };
      };

      xLabelFormat = minusIgnorer(xLabelFormat);
      yLabelFormat = minusIgnorer(yLabelFormat);
    }

    this.init({
      range: realRange,
      scale: scale,
      isMobile: options.isMobile
    }); // draw grid

    if (grid) {
      this.grid(gridRange[0], gridRange[1], {
        stroke: options.isMobile ? KhanColors$f.GRAY_C : "#000000",
        opacity: options.isMobile ? 1 : gridOpacity,
        step: gridStep,
        strokeWidth: options.isMobile ? 1 : 2
      });
    } // draw axes


    if (axes) {
      // this is a slight hack until <-> arrowheads work
      if (axisArrows === "<->" || axisArrows === true) {
        this.style({
          stroke: options.isMobile ? KhanColors$f.GRAY_G : "#000000",
          opacity: options.isMobile ? 1 : axisOpacity,
          strokeWidth: options.isMobile ? 1 : 2,
          arrows: "->"
        }, function () {
          if (range[1][0] < 0 && range[1][1] > 0) {
            this.path([axisCenter, [gridRange[0][0], axisCenter[1]]]);
            this.path([axisCenter, [gridRange[0][1], axisCenter[1]]]);
          }

          if (range[0][0] < 0 && range[0][1] > 0) {
            this.path([axisCenter, [axisCenter[0], gridRange[1][0]]]);
            this.path([axisCenter, [axisCenter[0], gridRange[1][1]]]);
          }
        }); // also, we don't support "<-" arrows yet, but why you
        // would want that on your graph is beyond me.
      } else if (axisArrows === "->" || axisArrows === "") {
        this.style({
          stroke: "#000000",
          opacity: axisOpacity,
          strokeWidth: 2,
          arrows: axisArrows
        }, function () {
          this.path([[gridRange[0][0], axisCenter[1]], [gridRange[0][1], axisCenter[1]]]);
          this.path([[axisCenter[0], gridRange[1][0]], [axisCenter[0], gridRange[1][1]]]);
        });
      }

      if (axisLabels && axisLabels.length === 2) {
        this.label([gridRange[0][1], axisCenter[1]], axisLabels[0], "right");
        this.label([axisCenter[0], gridRange[1][1]], axisLabels[1], "above");
      }
    } // draw tick marks


    if (ticks) {
      var halfWidthTicks = options.isMobile;
      this.style({
        stroke: options.isMobile ? KhanColors$f.GRAY_G : "#000000",
        opacity: options.isMobile ? 1 : tickOpacity,
        strokeWidth: 1
      }, function () {
        // horizontal axis
        var step = gridStep[0] * tickStep[0];
        var len = tickLen[0] / scale[1];
        var start = gridRange[0][0];
        var stop = gridRange[0][1];

        if (range[1][0] < 0 && range[1][1] > 0) {
          for (var x = step + axisCenter[0]; x <= stop; x += step) {
            if (x < stop || !axisArrows) {
              this.line([x, -len + axisCenter[1]], [x, halfWidthTicks ? 0 : len + axisCenter[1]]);
            }
          }

          for (var _x = -step + axisCenter[0]; _x >= start; _x -= step) {
            if (_x > start || !axisArrows) {
              this.line([_x, -len + axisCenter[1]], [_x, halfWidthTicks ? 0 : len + axisCenter[1]]);
            }
          }
        } // vertical axis


        step = gridStep[1] * tickStep[1];
        len = tickLen[1] / scale[0];
        start = gridRange[1][0];
        stop = gridRange[1][1];

        if (range[0][0] < 0 && range[0][1] > 0) {
          for (var y = step + axisCenter[1]; y <= stop; y += step) {
            if (y < stop || !axisArrows) {
              this.line([-len + axisCenter[0], y], [halfWidthTicks ? 0 : len + axisCenter[0], y]);
            }
          }

          for (var _y = -step + axisCenter[1]; _y >= start; _y -= step) {
            if (_y > start || !axisArrows) {
              this.line([-len + axisCenter[0], _y], [halfWidthTicks ? 0 : len + axisCenter[0], _y]);
            }
          }
        }
      });
    } // draw axis labels


    if (labels) {
      this.style({
        stroke: options.isMobile ? KhanColors$f.GRAY_G : "#000000",
        opacity: options.isMobile ? 1 : labelOpacity
      }, function () {
        // horizontal axis
        var step = gridStep[0] * tickStep[0] * labelStep[0];
        var start = gridRange[0][0];
        var stop = gridRange[0][1];
        var xAxisPosition = axisCenter[0] < 0 ? "above" : "below";
        var yAxisPosition = axisCenter[0] < 0 ? "right" : "left";
        var xShowZero = axisCenter[0] === 0 && axisCenter[1] !== 0;
        var yShowZero = axisCenter[0] !== 0 && axisCenter[1] === 0;
        var axisOffCenter = axisCenter[0] !== 0 || axisCenter[1] !== 0;
        var showUnityX = unityLabels[0] || axisOffCenter;
        var showUnityY = unityLabels[1] || axisOffCenter; // positive x-axis

        for (var x = (xShowZero ? 0 : step) + axisCenter[0]; x <= stop; x += step) {
          if (x < stop || !axisArrows) {
            this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
          }
        } // negative x-axis


        for (var _x2 = -step * (showUnityX ? 1 : 2) + axisCenter[0]; _x2 >= start; _x2 -= step) {
          if (_x2 > start || !axisArrows) {
            this.label([_x2, axisCenter[1]], xLabelFormat(_x2), xAxisPosition);
          }
        }

        step = gridStep[1] * tickStep[1] * labelStep[1];
        start = gridRange[1][0];
        stop = gridRange[1][1]; // positive y-axis

        for (var y = (yShowZero ? 0 : step) + axisCenter[1]; y <= stop; y += step) {
          if (y < stop || !axisArrows) {
            this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
          }
        } // negative y-axis


        for (var _y2 = -step * (showUnityY ? 1 : 2) + axisCenter[1]; _y2 >= start; _y2 -= step) {
          if (_y2 > start || !axisArrows) {
            this.label([axisCenter[0], _y2], yLabelFormat(_y2), yAxisPosition);
          }
        }
      });
    }
  };

  return graphie;
};

_module_$2j.exports = GraphUtils$8;
var _graphieJs = _module_$2j.exports;

/*
* jQuery Mobile Framework : "mouse" plugin
* Copyright (c) jQuery Project
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*/
// This plugin is an experiment for abstracting away the touch and mouse
// events so that developers don't have to worry about which method of input
// the device their document is loaded on supports.
//
// The idea here is to allow the developer to register listeners for the
// basic mouse events, such as mousedown, mousemove, mouseup, and click,
// and the plugin will take care of registering the correct listeners
// behind the scenes to invoke the listener at the fastest possible time
// for that device, while still retaining the order of event firing in
// the traditional mouse environment, should multiple handlers be registered
// on the same element for different events.
//
// The current version exposes the following virtual events to jQuery bind methods:
// "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"
(function ($, window, document, undefined$1) {
  var dataPropertyName = "virtualMouseBindings",
      touchTargetPropertyName = "virtualTouchID",
      virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split(" "),
      touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "),
      mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
      mouseEventProps = $.event.props.concat(mouseHookProps),
      activeDocHandlers = {},
      resetTimerID = 0,
      startX = 0,
      startY = 0,
      didScroll = false,
      clickBlockList = [],
      blockMouseTriggers = false,
      blockTouchTriggers = false,
      eventCaptureSupported = ("addEventListener" in document),
      $document = $(document),
      nextTouchID = 1,
      lastTouchID = 0;
  $.vmouse = {
    moveDistanceThreshold: 10,
    clickDistanceThreshold: 10,
    resetTimerDuration: 1500
  };

  function getNativeEvent(event) {
    while (event && typeof event.originalEvent !== "undefined") {
      event = event.originalEvent;
    }

    return event;
  }

  function createVirtualEvent(event, eventType) {
    var t = event.type,
        oe,
        props,
        ne,
        prop,
        ct,
        touch,
        i,
        j;
    event = $.Event(event);
    event.type = eventType;
    oe = event.originalEvent;
    props = $.event.props; // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
    // https://github.com/jquery/jquery-mobile/issues/3280

    if (t.search(/mouse/) > -1) {
      props = mouseEventProps;
    } // copy original event properties over to the new event
    // this would happen if we could call $.event.fix instead of $.Event
    // but we don't have a way to force an event to be fixed multiple times


    if (oe) {
      for (i = props.length, prop; i;) {
        prop = props[--i];
        event[prop] = oe[prop];
      }
    } // make sure that if the mouse and click virtual events are generated
    // without a .which one is defined


    if (t.search(/mouse(down|up)|click/) > -1 && !event.which) {
      event.which = 1;
    }

    if (t.search(/^touch/) !== -1) {
      ne = getNativeEvent(oe);
      t = ne.touches;
      ct = ne.changedTouches;
      touch = t && t.length ? t[0] : ct && ct.length ? ct[0] : undefined$1;

      if (touch) {
        for (j = 0, len = touchEventProps.length; j < len; j++) {
          prop = touchEventProps[j];
          event[prop] = touch[prop];
        }
      }
    }

    return event;
  }

  function getVirtualBindingFlags(element) {
    var flags = {},
        b,
        k;

    while (element) {
      b = $.data(element, dataPropertyName);

      for (k in b) {
        if (b[k]) {
          flags[k] = flags.hasVirtualBinding = true;
        }
      }

      element = element.parentNode;
    }

    return flags;
  }

  function getClosestElementWithVirtualBinding(element, eventType) {
    var b;

    while (element) {
      b = $.data(element, dataPropertyName);

      if (b && (!eventType || b[eventType])) {
        return element;
      }

      element = element.parentNode;
    }

    return null;
  }

  function enableTouchBindings() {
    blockTouchTriggers = false;
  }

  function disableTouchBindings() {
    blockTouchTriggers = true;
  }

  function enableMouseBindings() {
    lastTouchID = 0;
    clickBlockList.length = 0;
    blockMouseTriggers = false; // When mouse bindings are enabled, our
    // touch bindings are disabled.

    disableTouchBindings();
  }

  function disableMouseBindings() {
    // When mouse bindings are disabled, our
    // touch bindings are enabled.
    enableTouchBindings();
  }

  function startResetTimer() {
    clearResetTimer();
    resetTimerID = setTimeout(function () {
      resetTimerID = 0;
      enableMouseBindings();
    }, $.vmouse.resetTimerDuration);
  }

  function clearResetTimer() {
    if (resetTimerID) {
      clearTimeout(resetTimerID);
      resetTimerID = 0;
    }
  }

  function triggerVirtualEvent(eventType, event, flags) {
    var ve;

    if (flags && flags[eventType] || !flags && getClosestElementWithVirtualBinding(event.target, eventType)) {
      ve = createVirtualEvent(event, eventType);
      $(event.target).trigger(ve);
    }

    return ve;
  }

  function mouseEventCallback(event) {
    var touchID = $.data(event.target, touchTargetPropertyName);

    if (!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
      var ve = triggerVirtualEvent("v" + event.type, event);

      if (ve) {
        if (ve.isDefaultPrevented()) {
          event.preventDefault();
        }

        if (ve.isPropagationStopped()) {
          event.stopPropagation();
        }

        if (ve.isImmediatePropagationStopped()) {
          event.stopImmediatePropagation();
        }
      }
    }
  }

  function handleTouchStart(event) {
    var touches = getNativeEvent(event).touches,
        target,
        flags;

    if (touches && touches.length === 1) {
      target = event.target;
      flags = getVirtualBindingFlags(target);

      if (flags.hasVirtualBinding) {
        lastTouchID = nextTouchID++;
        $.data(target, touchTargetPropertyName, lastTouchID);
        clearResetTimer();
        disableMouseBindings();
        didScroll = false;
        var t = getNativeEvent(event).touches[0];
        startX = t.pageX;
        startY = t.pageY;
        triggerVirtualEvent("vmouseover", event, flags);
        triggerVirtualEvent("vmousedown", event, flags);
      }
    }
  }

  function handleScroll(event) {
    if (blockTouchTriggers) {
      return;
    }

    if (!didScroll) {
      triggerVirtualEvent("vmousecancel", event, getVirtualBindingFlags(event.target));
    }

    didScroll = true;
    startResetTimer();
  }

  function handleTouchMove(event) {
    if (blockTouchTriggers) {
      return;
    }

    var t = getNativeEvent(event).touches[0],
        didCancel = didScroll,
        moveThreshold = $.vmouse.moveDistanceThreshold;
    didScroll = didScroll || Math.abs(t.pageX - startX) > moveThreshold || Math.abs(t.pageY - startY) > moveThreshold, flags = getVirtualBindingFlags(event.target);

    if (didScroll && !didCancel) {
      triggerVirtualEvent("vmousecancel", event, flags);
    }

    triggerVirtualEvent("vmousemove", event, flags);
    startResetTimer();
  }

  function handleTouchEnd(event) {
    if (blockTouchTriggers) {
      return;
    }

    disableTouchBindings();
    var flags = getVirtualBindingFlags(event.target),
        t;
    triggerVirtualEvent("vmouseup", event, flags);

    if (!didScroll) {
      var ve = triggerVirtualEvent("vclick", event, flags);

      if (ve && ve.isDefaultPrevented()) {
        // The target of the mouse events that follow the touchend
        // event don't necessarily match the target used during the
        // touch. This means we need to rely on coordinates for blocking
        // any click that is generated.
        t = getNativeEvent(event).changedTouches[0];
        clickBlockList.push({
          touchID: lastTouchID,
          x: t.clientX,
          y: t.clientY
        }); // Prevent any mouse events that follow from triggering
        // virtual event notifications.

        blockMouseTriggers = true;
      }
    }

    triggerVirtualEvent("vmouseout", event, flags);
    didScroll = false;
    startResetTimer();
  }

  function hasVirtualBindings(ele) {
    var bindings = $.data(ele, dataPropertyName),
        k;

    if (bindings) {
      for (k in bindings) {
        if (bindings[k]) {
          return true;
        }
      }
    }

    return false;
  }

  function dummyMouseHandler() {}

  function getSpecialEventObject(eventType) {
    var realType = eventType.substr(1);
    return {
      setup: function setup(data, namespace) {
        // If this is the first virtual mouse binding for this element,
        // add a bindings object to its data.
        if (!hasVirtualBindings(this)) {
          $.data(this, dataPropertyName, {});
        } // If setup is called, we know it is the first binding for this
        // eventType, so initialize the count for the eventType to zero.


        var bindings = $.data(this, dataPropertyName);
        bindings[eventType] = true; // If this is the first virtual mouse event for this type,
        // register a global handler on the document.

        activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;

        if (activeDocHandlers[eventType] === 1) {
          $document.bind(realType, mouseEventCallback);
        } // Some browsers, like Opera Mini, won't dispatch mouse/click events
        // for elements unless they actually have handlers registered on them.
        // To get around this, we register dummy handlers on the elements.


        $(this).bind(realType, dummyMouseHandler); // For now, if event capture is not supported, we rely on mouse handlers.

        if (eventCaptureSupported) {
          // If this is the first virtual mouse binding for the document,
          // register our touchstart handler on the document.
          activeDocHandlers["touchstart"] = (activeDocHandlers["touchstart"] || 0) + 1;

          if (activeDocHandlers["touchstart"] === 1) {
            $document.bind("touchstart", handleTouchStart).bind("touchend", handleTouchEnd) // On touch platforms, touching the screen and then dragging your finger
            // causes the window content to scroll after some distance threshold is
            // exceeded. On these platforms, a scroll prevents a click event from being
            // dispatched, and on some platforms, even the touchend is suppressed. To
            // mimic the suppression of the click event, we need to watch for a scroll
            // event. Unfortunately, some platforms like iOS don't dispatch scroll
            // events until *AFTER* the user lifts their finger (touchend). This means
            // we need to watch both scroll and touchmove events to figure out whether
            // or not a scroll happenens before the touchend event is fired.
            .bind("touchmove", handleTouchMove).bind("scroll", handleScroll);
          }
        }
      },
      teardown: function teardown(data, namespace) {
        // If this is the last virtual binding for this eventType,
        // remove its global handler from the document.
        --activeDocHandlers[eventType];

        if (!activeDocHandlers[eventType]) {
          $document.unbind(realType, mouseEventCallback);
        }

        if (eventCaptureSupported) {
          // If this is the last virtual mouse binding in existence,
          // remove our document touchstart listener.
          --activeDocHandlers["touchstart"];

          if (!activeDocHandlers["touchstart"]) {
            $document.unbind("touchstart", handleTouchStart).unbind("touchmove", handleTouchMove).unbind("touchend", handleTouchEnd).unbind("scroll", handleScroll);
          }
        }

        var $this = $(this),
            bindings = $.data(this, dataPropertyName); // teardown may be called when an element was
        // removed from the DOM. If this is the case,
        // jQuery core may have already stripped the element
        // of any data bindings so we need to check it before
        // using it.

        if (bindings) {
          bindings[eventType] = false;
        } // Unregister the dummy event handler.


        $this.unbind(realType, dummyMouseHandler); // If this is the last virtual mouse binding on the
        // element, remove the binding data from the element.

        if (!hasVirtualBindings(this)) {
          $this.removeData(dataPropertyName);
        }
      }
    };
  } // Expose our custom events to the jQuery bind/unbind mechanism.


  for (var i = 0; i < virtualEventNames.length; i++) {
    $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
  } // Add a capture click handler to block clicks.
  // Note that we require event capture support for this so if the device
  // doesn't support it, we punt for now and rely solely on mouse events.


  if (eventCaptureSupported) {
    document.addEventListener("click", function (e) {
      var cnt = clickBlockList.length,
          target = e.target,
          x,
          y,
          ele,
          i,
          o;

      if (cnt) {
        x = e.clientX;
        y = e.clientY;
        threshold = $.vmouse.clickDistanceThreshold; // The idea here is to run through the clickBlockList to see if
        // the current click event is in the proximity of one of our
        // vclick events that had preventDefault() called on it. If we find
        // one, then we block the click.
        //
        // Why do we have to rely on proximity?
        //
        // Because the target of the touch event that triggered the vclick
        // can be different from the target of the click event synthesized
        // by the browser. The target of a mouse/click event that is syntehsized
        // from a touch event seems to be implementation specific. For example,
        // some browsers will fire mouse/click events for a link that is near
        // a touch event, even though the target of the touchstart/touchend event
        // says the user touched outside the link. Also, it seems that with most
        // browsers, the target of the mouse/click event is not calculated until the
        // time it is dispatched, so if you replace an element that you touched
        // with another element, the target of the mouse/click will be the new
        // element underneath that point.
        //
        // Aside from proximity, we also check to see if the target and any
        // of its ancestors were the ones that blocked a click. This is necessary
        // because of the strange mouse/click target calculation done in the
        // Android 2.1 browser, where if you click on an element, and there is a
        // mouse/click handler on one of its ancestors, the target will be the
        // innermost child of the touched element, even if that child is no where
        // near the point of touch.

        ele = target;

        while (ele) {
          for (i = 0; i < cnt; i++) {
            o = clickBlockList[i];

            if (ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold || $.data(ele, touchTargetPropertyName) === o.touchID) {
              // XXX: We may want to consider removing matches from the block list
              //      instead of waiting for the reset timer to fire.
              e.preventDefault();
              e.stopPropagation();
              return;
            }
          }

          ele = ele.parentNode;
        }
      }
    }, true);
  }
})(jQuery, window, document);

/* eslint-disable max-lines */

/**
 * Interactive graphie utilities.
 *
 * This file exposes a couple functions, but mostly it adds functions to the
 * `Graphie` prototype for dealing with interactive graphie elements.
 */
// TODO(emily): This file breaks our line length limits like nobody's business.
// Figure out how to fix that.

var _$1w = _underscore__default["default"];
/* global Raphael:false */

var GraphUtils$7 = _graphieJs;
var kvector$9 = _kmath3.vector;
var kpoint$b = _kmath3.point;
var kline$2 = _kmath3.line;
var WrappedEllipse$2 = _wrappedEllipseJs;
var WrappedLine$5 = _interactive2WrappedLineJs;
var WrappedPath$1 = _wrappedPathJs;
var KhanMath$8 = _utilMathJs;
var KhanColors$e = _utilColorsJs;

function sum$1(array) {
  return _$1w.reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}

function clockwise$1(points) {
  var segments = _$1w.zip(points, points.slice(1).concat(points.slice(0, 1)));

  var areas = _$1w.map(segments, function (segment) {
    var p1 = segment[0];
    var p2 = segment[1];
    return (p2[0] - p1[0]) * (p2[1] + p1[1]);
  });

  return sum$1(areas) > 0;
}
/* vector-add multiple [x, y] coords/vectors */


function addPoints() {
  var points = _$1w.toArray(arguments);

  var zipped = _$1w.zip(...points);

  return _$1w.map(zipped, sum$1);
}

function reverseVector(vector) {
  return _$1w.map(vector, function (coord) {
    return coord * -1;
  });
}

function scaledDistanceFromAngle(angle) {
  var a = 3.51470560176242 * 20;
  var b = 0.5687298702748785 * 20;
  var c = -0.037587715462826674;
  return (a - b) * Math.exp(c * angle) + b;
}

function scaledPolarRad(radius, radians) {
  return [radius * Math.cos(radians), radius * Math.sin(radians) * -1 // SVG flips y axis
  ];
}

function scaledPolarDeg(radius, degrees) {
  var radians = degrees * Math.PI / 180;
  return scaledPolarRad(radius, radians);
} // Global dragging state


var dragging = false;
var InteractiveUtils = {
  // Useful for shapes that are only sometimes drawn. If a shape isn't
  // needed, it can be replaced with bogusShape which just has stub methods
  // that successfully do nothing.
  // The alternative would be 'if..typeof' checks all over the place.
  bogusShape: {
    animate: function animate() {},
    attr: function attr() {},
    remove: function remove() {}
  }
};

_$1w.extend(GraphUtils$7.Graphie.prototype, {
  // graphie puts text spans on top of the SVG, which looks good, but gets
  // in the way of mouse events. This adds another SVG element on top
  // of everything else where we can add invisible shapes with mouse
  // handlers wherever we want.
  addMouseLayer: function addMouseLayer(options) {
    var graph = this;
    options = _$1w.extend({
      allowScratchpad: false,
      setDrawingAreaAvailable: function setDrawingAreaAvailable() {}
    }, options);
    var mouselayerZIndex = 2;
    graph.mouselayer = Raphael(graph.raphael.canvas.parentNode, graph.xpixels, graph.ypixels);
    $__default["default"](graph.mouselayer.canvas).css("z-index", mouselayerZIndex);

    if (options.onClick || options.onMouseDown || options.onMouseMove || options.onMouseOver || options.onMouseOut) {
      var canvasClickTarget = graph.mouselayer.rect(0, 0, graph.xpixels, graph.ypixels).attr({
        fill: "#000",
        opacity: 0
      });
      var isClickingCanvas = false;
      $__default["default"](graph.mouselayer.canvas).on("vmousedown", function (e) {
        if (e.target === canvasClickTarget[0]) {
          if (options.onMouseDown) {
            options.onMouseDown(graph.getMouseCoord(e));
          }

          isClickingCanvas = true;

          if (options.onMouseMove) {
            $__default["default"](document).bind("vmousemove.mouseLayer", function (e) {
              if (isClickingCanvas) {
                e.preventDefault();
                options.onMouseMove(graph.getMouseCoord(e));
              }
            });
          }

          $__default["default"](document).bind("vmouseup.mouseLayer", function (e) {
            $__default["default"](document).unbind(".mouseLayer"); // Only register clicks that started on the canvas,
            // and not on another mouseLayer target

            if (isClickingCanvas && options.onClick) {
              options.onClick(graph.getMouseCoord(e));
            }

            isClickingCanvas = false;
          });
        }
      });

      if (options.onMouseOver) {
        $__default["default"](graph.mouselayer.canvas).on("vmouseover", function (e) {
          options.onMouseOver(graph.getMouseCoord(e));
        });
      }

      if (options.onMouseOut) {
        $__default["default"](graph.mouselayer.canvas).on("vmouseout", function (e) {
          options.onMouseOut(graph.getMouseCoord(e));
        });
      }
    }

    if (!options.allowScratchpad) {
      options.setDrawingAreaAvailable(false);
    } // Add mouse and visible wrapper layers for DOM-node-wrapped movables


    graph._mouselayerWrapper = document.createElement("div");
    $__default["default"](graph._mouselayerWrapper).css({
      position: "absolute",
      left: 0,
      top: 0,
      zIndex: mouselayerZIndex
    });
    graph._visiblelayerWrapper = document.createElement("div");
    $__default["default"](graph._visiblelayerWrapper).css({
      position: "absolute",
      left: 0,
      top: 0
    });
    var el = graph.raphael.canvas.parentNode;
    el.appendChild(graph._visiblelayerWrapper);
    el.appendChild(graph._mouselayerWrapper); // Add functions for adding to wrappers

    graph.addToMouseLayerWrapper = function (el) {
      this._mouselayerWrapper.appendChild(el);
    };

    graph.addToVisibleLayerWrapper = function (el) {
      this._visiblelayerWrapper.appendChild(el);
    };
  },

  /**
   * Get mouse coordinates in pixels
   */
  getMousePx: function getMousePx(event) {
    var graphie = this;
    var mouseX = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
    var mouseY = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top;
    return [mouseX, mouseY];
  },

  /**
   * Get mouse coordinates in graph coordinates
   */
  getMouseCoord: function getMouseCoord(event) {
    return this.unscalePoint(this.getMousePx(event));
  },

  /**
   * Unlike all other Graphie-related code, the following three functions use
   * a lot of scaled coordinates (so that labels appear the same size
   * regardless of current shape/figure scale). These are prefixed with 's'.
   */
  labelAngle: function labelAngle(options) {
    var graphie = this;

    _$1w.defaults(options, {
      point1: [0, 0],
      vertex: [0, 0],
      point3: [0, 0],
      label: null,
      numArcs: 1,
      showRightAngleMarker: true,
      pushOut: 0,
      clockwise: false,
      style: {}
    });

    var text = options.text === undefined ? "" : options.text;
    var vertex = options.vertex;
    var sVertex = graphie.scalePoint(vertex);
    var p1;
    var p3;

    if (options.clockwise) {
      p1 = options.point1;
      p3 = options.point3;
    } else {
      p1 = options.point3;
      p3 = options.point1;
    }

    var startAngle = GraphUtils$7.findAngle(p1, vertex);
    var endAngle = GraphUtils$7.findAngle(p3, vertex);
    var angle = (endAngle + 360 - startAngle) % 360;
    var halfAngle = (startAngle + angle / 2) % 360;
    var sPadding = 5 * options.pushOut;
    var sRadius = sPadding + scaledDistanceFromAngle(angle);
    var temp = [];

    if (Math.abs(angle - 90) < 1e-9 && options.showRightAngleMarker) {
      var v1 = addPoints(sVertex, scaledPolarDeg(sRadius, startAngle));
      var v2 = addPoints(sVertex, scaledPolarDeg(sRadius, endAngle));
      sRadius *= Math.SQRT2;
      var v3 = addPoints(sVertex, scaledPolarDeg(sRadius, halfAngle));

      _$1w.each([v1, v2], function (v) {
        temp.push(graphie.scaledPath([v, v3], options.style));
      });
    } else {
      // Draw arcs
      _$1w.times(options.numArcs, function (i) {
        temp.push(graphie.arc(vertex, graphie.unscaleVector(sRadius), startAngle, endAngle, options.style));
        sRadius += 3;
      });
    }

    if (text) {
      var match = text.match(/\$deg(\d)?/);

      if (match) {
        var precision = match[1] || 1;
        text = text.replace(match[0], KhanMath$8.toFixedApprox(angle, precision) + "^{\\circ}");
      }

      var sOffset = scaledPolarDeg(sRadius + 15, halfAngle);
      var sPosition = addPoints(sVertex, sOffset);
      var position = graphie.unscalePoint(sPosition); // Reuse label if possible

      if (options.label) {
        options.label.setPosition(position);
        options.label.processMath(text,
        /* force */
        true);
      } else {
        graphie.label(position, text, "center", options.style);
      }
    }

    return temp;
  },
  labelSide: function labelSide(options) {
    var graphie = this;

    _$1w.defaults(options, {
      point1: [0, 0],
      point2: [0, 0],
      label: null,
      text: "",
      numTicks: 0,
      numArrows: 0,
      clockwise: false,
      style: {}
    });

    var p1;
    var p2;

    if (options.clockwise) {
      p1 = options.point1;
      p2 = options.point2;
    } else {
      p1 = options.point2;
      p2 = options.point1;
    }

    var midpoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
    var sMidpoint = graphie.scalePoint(midpoint);
    var parallelAngle = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
    var perpendicularAngle = parallelAngle + Math.PI / 2;
    var temp = [];
    var sCumulativeOffset = 0;

    if (options.numTicks) {
      var n = options.numTicks;
      var sSpacing = 5;
      var sHeight = 5;

      var style = _$1w.extend({}, options.style, {
        strokeWidth: 2
      });

      _$1w.times(n, function (i) {
        var sOffset = sSpacing * (i - (n - 1) / 2);
        var sOffsetVector = scaledPolarRad(sOffset, parallelAngle);
        var sHeightVector = scaledPolarRad(sHeight, perpendicularAngle);
        var sPath = [addPoints(sMidpoint, sOffsetVector, sHeightVector), addPoints(sMidpoint, sOffsetVector, reverseVector(sHeightVector))];
        temp.push(graphie.scaledPath(sPath, style));
      });

      sCumulativeOffset += sSpacing * (n - 1) + 15;
    }

    if (options.numArrows) {
      var _n = options.numArrows;
      var start = [p1, p2].sort(function (a, b) {
        if (a[1] === b[1]) {
          return a[0] - b[0];
        } else {
          return a[1] - b[1];
        }
      })[0];
      var sStart = graphie.scalePoint(start);

      var _style = _$1w.extend({}, options.style, {
        arrows: "->",
        strokeWidth: 2
      });

      var _sSpacing = 5;

      _$1w.times(_n, function (i) {
        var sOffset = sCumulativeOffset + _sSpacing * i;
        var sOffsetVector = scaledPolarRad(sOffset, parallelAngle);

        if (start !== p1) {
          sOffsetVector = reverseVector(sOffsetVector);
        }

        var sEnd = addPoints(sMidpoint, sOffsetVector);
        temp.push(graphie.scaledPath([sStart, sEnd], _style));
      });
    }

    var text = options.text;

    if (text) {
      var match = text.match(/\$len(\d)?/);

      if (match) {
        var distance = GraphUtils$7.getDistance(p1, p2);
        var precision = match[1] || 1;
        text = text.replace(match[0], KhanMath$8.toFixedApprox(distance, precision));
      }

      var sOffset = 20;
      var sOffsetVector = scaledPolarRad(sOffset, perpendicularAngle);
      var sPosition = addPoints(sMidpoint, sOffsetVector);
      var position = graphie.unscalePoint(sPosition); // Reuse label if possible

      if (options.label) {
        options.label.setPosition(position);
        options.label.processMath(text,
        /* force */
        true);
      } else {
        graphie.label(position, text, "center", options.style);
      }
    }

    return temp;
  },

  /* Can also be used to label points that aren't vertices */
  labelVertex: function labelVertex(options) {
    var graphie = this;

    _$1w.defaults(options, {
      point1: null,
      vertex: [0, 0],
      point3: null,
      label: null,
      text: "",
      clockwise: false,
      style: {}
    });

    if (!options.text) {
      return;
    }

    var vertex = options.vertex;
    var sVertex = graphie.scalePoint(vertex);
    var p1;
    var p3;

    if (options.clockwise) {
      p1 = options.point1;
      p3 = options.point3;
    } else {
      p1 = options.point3;
      p3 = options.point1;
    }

    var angle = 135;
    var halfAngle;

    if (p1 && p3) {
      var startAngle = GraphUtils$7.findAngle(p1, vertex);
      var endAngle = GraphUtils$7.findAngle(p3, vertex);
      angle = (endAngle + 360 - startAngle) % 360;
      halfAngle = (startAngle + angle / 2 + 180) % 360;
    } else if (p1) {
      var parallelAngle = GraphUtils$7.findAngle(vertex, p1);
      halfAngle = parallelAngle + 90;
    } else if (p3) {
      var _parallelAngle = GraphUtils$7.findAngle(p3, vertex);

      halfAngle = _parallelAngle + 90;
    } else {
      // Standalone point
      halfAngle = 135;
    }

    var sRadius = 10 + scaledDistanceFromAngle(360 - angle);
    var sOffsetVector = scaledPolarDeg(sRadius, halfAngle);
    var sPosition = addPoints(sVertex, sOffsetVector);
    var position = graphie.unscalePoint(sPosition); // Reuse label if possible

    if (options.label) {
      options.label.setPosition(position);
      options.label.processMath(options.text,
      /* force */
      true);
    } else {
      graphie.label(position, options.text, "center", options.style);
    }
  },
  // Add a point to the graph that can be dragged around.
  // It allows automatic constraints on its movement as well as automatically
  // managing line segments that terminate at the point.
  //
  // Options can be set to control how the point behaves:
  //   coord[]:
  //     The initial position of the point
  //   snapX, snapY:
  //     The minimum increment the point can be moved
  //
  // The return value is an object that can be used to manipulate the point:
  //   The coordX and coordY properties tell you the current position
  //
  //   By adding an onMove() method to the returned object, you can install an
  //   event handler that gets called every time the user moves the point.
  //
  //   The returned object also provides a moveTo(x,y) method that will move
  //   the point to a specific coordinate
  //
  // Constraints can be set on the on the returned object:
  //
  //  - Set point to be immovable:
  //        movablePoint.constraints.fixed = true
  //
  //  - Constrain point to a fixed distance from another point. The resulting
  //    point will move in a circle:
  //        movablePoint.fixedDistance = {
  //           dist: 2,
  //           point: point1
  //        }
  //
  //  - Constrain point to a line defined by a fixed angle between it and
  //    two other points:
  //        movablePoint.fixedAngle = {
  //           angle: 45,
  //           vertex: point1,
  //           ref: point2
  //        }
  //
  //  - Confined the point to traveling in a vertical or horizontal line,
  //    respectively
  //        movablePoint.constrainX = true;
  //        movablePoint.constrainY = true;
  //
  //  - Connect a movableLineSegment to a movablePoint. The point is attached
  //    to a specific end of the line segment by adding the segment either to
  //    the list of lines that start at the point or the list of lines that
  //    end at the point (movableLineSegment can do this for you):
  //        movablePoint.lineStarts.push(movableLineSegment);
  //          - or -
  //        movablePoint.lineEnds.push(movableLineSegment);
  //
  //  - Connect a movablePolygon to a movablePoint in exacty the same way:
  //        movablePoint.polygonVertices.push(movablePolygon);
  //
  addMovablePoint: function addMovablePoint(options) {
    var movablePoint = $__default["default"].extend(true, {
      graph: this,
      coord: [0, 0],
      snapX: 0,
      snapY: 0,
      pointSize: 4,
      highlight: false,
      dragging: false,
      visible: true,
      bounded: true,
      constraints: {
        fixed: false,
        constrainX: false,
        constrainY: false,
        fixedAngle: {},
        fixedDistance: {}
      },
      lineStarts: [],
      lineEnds: [],
      polygonVertices: [],
      normalStyle: {},
      highlightStyle: {
        fill: KhanColors$e.INTERACTING,
        stroke: KhanColors$e.INTERACTING
      },
      labelStyle: {
        color: KhanColors$e.INTERACTIVE
      },
      vertexLabel: "",
      mouseTarget: null
    }, options);
    var normalColor = movablePoint.constraints.fixed ? KhanColors$e.DYNAMIC : KhanColors$e.INTERACTIVE;
    movablePoint.normalStyle = _$1w.extend({}, {
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle); // deprecated: don't use coordX/coordY; use coord[]

    if (options.coordX !== undefined) {
      movablePoint.coord[0] = options.coordX;
    }

    if (options.coordY !== undefined) {
      movablePoint.coord[1] = options.coordY;
    }

    var graph = movablePoint.graph;

    var applySnapAndConstraints = function applySnapAndConstraints(coord) {
      // coord should be the scaled coordinate
      // move point away from edge of graph unless it's invisible or fixed
      if (movablePoint.visible && movablePoint.bounded && !movablePoint.constraints.fixed) {
        // can't go beyond 10 pixels from the edge
        coord = graph.constrainToBounds(coord, 10);
      }

      var coordX = coord[0];
      var coordY = coord[1]; // snap coordinates to grid

      if (movablePoint.snapX !== 0) {
        coordX = Math.round(coordX / movablePoint.snapX) * movablePoint.snapX;
      }

      if (movablePoint.snapY !== 0) {
        coordY = Math.round(coordY / movablePoint.snapY) * movablePoint.snapY;
      } // snap to points around circle


      if (movablePoint.constraints.fixedDistance.snapPoints) {
        var mouse = graph.scalePoint(coord);
        var mouseX = mouse[0];
        var mouseY = mouse[1];
        var snapRadians = 2 * Math.PI / movablePoint.constraints.fixedDistance.snapPoints;
        var radius = movablePoint.constraints.fixedDistance.dist;
        var centerCoord = movablePoint.constraints.fixedDistance.point;
        var centerX = (centerCoord[0] - graph.range[0][0]) * graph.scale[0];
        var centerY = (-centerCoord[1] + graph.range[1][1]) * graph.scale[1];
        var mouseXrel = mouseX - centerX;
        var mouseYrel = -mouseY + centerY;
        var radians = Math.atan(mouseYrel / mouseXrel);
        var outsideArcTanRange = mouseXrel < 0; // adjust so that angles increase from 0 to 2 pi as you go
        // around the circle

        if (outsideArcTanRange) {
          radians += Math.PI;
        } // perform the snap


        radians = Math.round(radians / snapRadians) * snapRadians; // convert from radians back to pixels

        mouseXrel = radius * Math.cos(radians);
        mouseYrel = radius * Math.sin(radians); // convert back to coordinates relative to graphie canvas

        mouseX = mouseXrel + centerX;
        mouseY = -mouseYrel + centerY;
        coordX = KhanMath$8.roundTo(5, mouseX / graph.scale[0] + graph.range[0][0]);
        coordY = KhanMath$8.roundTo(5, graph.range[1][1] - mouseY / graph.scale[1]);
      }

      var result = movablePoint.applyConstraint([coordX, coordY]);
      return result;
    }; // Using the passed coordinates, apply any constraints and return
    // the closest coordinates that match the constraints.


    movablePoint.applyConstraint = function (coord, extraConstraints, override) {
      var newCoord = coord.slice();
      var constraints = {};

      if (override) {
        $__default["default"].extend(constraints, {
          fixed: false,
          constrainX: false,
          constrainY: false,
          fixedAngle: {},
          fixedDistance: {}
        }, extraConstraints);
      } else {
        $__default["default"].extend(constraints, this.constraints, extraConstraints);
      } // constrain to vertical movement


      if (constraints.constrainX) {
        newCoord = [this.coord[0], coord[1]]; // constrain to horizontal movement
      } else if (constraints.constrainY) {
        newCoord = [coord[0], this.coord[1]]; // both distance and angle are constrained
      } else if (typeof constraints.fixedAngle.angle === "number" && typeof constraints.fixedDistance.dist === "number") {
        var vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
        var ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;
        var distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;
        var constrainedAngle = (constraints.fixedAngle.angle + GraphUtils$7.findAngle(ref, vertex)) * Math.PI / 180;
        var length = constraints.fixedDistance.dist;
        newCoord[0] = length * Math.cos(constrainedAngle) + distPoint[0];
        newCoord[1] = length * Math.sin(constrainedAngle) + distPoint[1]; // angle is constrained
      } else if (typeof constraints.fixedAngle.angle === "number") {
        var _vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;

        var _ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;

        var _constrainedAngle = (constraints.fixedAngle.angle + GraphUtils$7.findAngle(_ref, _vertex)) * Math.PI / 180;

        var angle = GraphUtils$7.findAngle(coord, _vertex) * Math.PI / 180;
        var distance = GraphUtils$7.getDistance(coord, _vertex);

        var _length = distance * Math.cos(_constrainedAngle - angle);

        _length = _length < 1.0 ? 1.0 : _length;
        newCoord[0] = _length * Math.cos(_constrainedAngle) + _vertex[0];
        newCoord[1] = _length * Math.sin(_constrainedAngle) + _vertex[1]; // distance is constrained
      } else if (typeof constraints.fixedDistance.dist === "number") {
        var _distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;

        var _angle = GraphUtils$7.findAngle(coord, _distPoint);

        var _length2 = constraints.fixedDistance.dist;
        _angle = _angle * Math.PI / 180;
        newCoord[0] = _length2 * Math.cos(_angle) + _distPoint[0];
        newCoord[1] = _length2 * Math.sin(_angle) + _distPoint[1]; // point is fixed
      } else if (constraints.fixed) {
        newCoord = movablePoint.coord;
      }

      return newCoord;
    };

    movablePoint.coord = applySnapAndConstraints(movablePoint.coord);
    var highlightScale = 2;

    if (movablePoint.visible) {
      graph.style(movablePoint.normalStyle, function () {
        var radii = [movablePoint.pointSize / graph.scale[0], movablePoint.pointSize / graph.scale[1]];
        var options = {
          maxScale: highlightScale,
          // Add in 2px of padding to avoid clipping at the edges.
          padding: 2
        };
        movablePoint.visibleShape = new WrappedEllipse$2(graph, movablePoint.coord, radii, options);
        movablePoint.visibleShape.attr(_$1w.omit(movablePoint.normalStyle, "scale"));
        movablePoint.visibleShape.toFront();
      });
    }

    movablePoint.normalStyle.scale = 1;
    movablePoint.highlightStyle.scale = highlightScale;

    if (movablePoint.vertexLabel) {
      movablePoint.labeledVertex = this.label([0, 0], "", "center", movablePoint.labelStyle);
    }

    movablePoint.drawLabel = function () {
      if (movablePoint.vertexLabel) {
        movablePoint.graph.labelVertex({
          vertex: movablePoint.coord,
          label: movablePoint.labeledVertex,
          text: movablePoint.vertexLabel,
          style: movablePoint.labelStyle
        });
      }
    };

    movablePoint.drawLabel();

    movablePoint.grab = function (offset) {
      // The offset for the gesture. When provided, the movable point will
      // track the mouse's position, plus this offset. This is typically
      // used to lock the distance between a user's finger and the movable
      // point, when dragging.
      offset = offset || [0, 0];
      $__default["default"](document).bind("vmousemove.point vmouseup.point", function (event) {
        event.preventDefault();
        movablePoint.dragging = true;
        dragging = true; // Adjust the target coordinate by accounting for the gesture's
        // offset.

        var coord = kvector$9.add(graph.getMouseCoord(event), offset);
        coord = applySnapAndConstraints(coord);
        var coordX = coord[0];
        var coordY = coord[1];
        var mouseX;
        var mouseY;

        if (event.type === "vmousemove") {
          var doMove = true; // The caller has the option of adding an onMove() method
          // to the movablePoint object we return as a sort of event
          // handler. By returning false from onMove(), the move
          // can be vetoed, providing custom constraints on where
          // the point can be moved. By returning array [x, y], the
          // move can be overridden

          if (_$1w.isFunction(movablePoint.onMove)) {
            var result = movablePoint.onMove(coordX, coordY);

            if (result === false) {
              doMove = false;
            }

            if (_$1w.isArray(result)) {
              coordX = result[0];
              coordY = result[1];
            }
          } // coord{X|Y} may have been modified by constraints or
          // onMove handler; adjust mouse{X|Y} to match


          mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
          mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];

          if (doMove) {
            var point = graph.unscalePoint([mouseX, mouseY]);
            movablePoint.visibleShape.moveTo(point);
            movablePoint.mouseTarget.moveTo(point);
            movablePoint.coord = [coordX, coordY];
            movablePoint.updateLineEnds();
            $__default["default"](movablePoint).trigger("move");
          }

          movablePoint.drawLabel();
        } else if (event.type === "vmouseup") {
          $__default["default"](document).unbind(".point");
          movablePoint.dragging = false;
          dragging = false;

          if (_$1w.isFunction(movablePoint.onMoveEnd)) {
            var _result = movablePoint.onMoveEnd(coordX, coordY);

            if (_$1w.isArray(_result)) {
              coordX = _result[0];
              coordY = _result[1];
              mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
              mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];

              var _point = graph.unscalePoint([mouseX, mouseY]);

              movablePoint.visibleShape.moveTo(_point);
              movablePoint.mouseTarget.moveTo(_point);
              movablePoint.coord = [coordX, coordY];
            }
          }

          if (!movablePoint.highlight) {
            movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);

            if (movablePoint.onUnhighlight) {
              movablePoint.onUnhighlight();
            }
          }
        }
      });
    };

    if (movablePoint.visible && !movablePoint.constraints.fixed) {
      // the invisible shape in front of the point that gets mouse events
      if (!movablePoint.mouseTarget) {
        var radii = graph.unscaleVector(16);
        var _options = {
          mouselayer: true,
          padding: 0,
          disableMouseEventsOnWrapper: true
        };
        movablePoint.mouseTarget = new WrappedEllipse$2(graph, movablePoint.coord, radii, _options);
        movablePoint.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }

      var $mouseTarget = $__default["default"](movablePoint.mouseTarget.getMouseTarget());
      $mouseTarget.css("cursor", "move");
      $mouseTarget.bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          movablePoint.highlight = true;

          if (!dragging) {
            movablePoint.visibleShape.animate(movablePoint.highlightStyle, 50);

            if (movablePoint.onHighlight) {
              movablePoint.onHighlight();
            }
          }
        } else if (event.type === "vmouseout") {
          movablePoint.highlight = false;

          if (!movablePoint.dragging && !dragging) {
            movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);

            if (movablePoint.onUnhighlight) {
              movablePoint.onUnhighlight();
            }
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault(); // The offset between the cursor or finger and the initial
          // coordinates of the point. This is tracked so as to avoid
          // locking the moving point to the user's finger on touch
          // devices, which would obscure it, no matter how large we
          // made the touch target. Instead, we respect the offset at
          // which the point was grabbed for the entirety of the
          // gesture, if it's a touch-based interaction.

          var startCoord = movablePoint.coord;
          var startMouseCoord = graph.getMouseCoord(event);
          var isMouse = !("ontouchstart" in window);
          var touchOffset = isMouse ? [0, 0] : kvector$9.subtract(startCoord, startMouseCoord);
          movablePoint.grab(touchOffset);
        }
      });
    } // Method to let the caller animate the point to a new position.
    // Useful as part of a hint to show the user the correct place
    // to put the point.


    movablePoint.moveTo = function (coordX, coordY, updateLines) {
      var distance = GraphUtils$7.getDistance(this.graph.scalePoint([coordX, coordY]), this.graph.scalePoint(this.coord));
      var time = distance * 5;

      var cb = updateLines && function (coord) {
        movablePoint.coord = coord;
        movablePoint.updateLineEnds();
      };

      this.visibleShape.animateTo([coordX, coordY], time, cb);
      this.mouseTarget.animateTo([coordX, coordY], time, cb);
      this.coord = [coordX, coordY];

      if (_$1w.isFunction(this.onMove)) {
        this.onMove(coordX, coordY);
      }
    }; // After moving the point, call this to update all line segments
    // terminating at the point


    movablePoint.updateLineEnds = function () {
      $__default["default"](this.lineStarts).each(function () {
        this.coordA = movablePoint.coord;
        this.transform();
      });
      $__default["default"](this.lineEnds).each(function () {
        this.coordZ = movablePoint.coord;
        this.transform();
      });
      $__default["default"](this.polygonVertices).each(function () {
        this.transform();
      });
    }; // Put the point at a new position without any checks, animation,
    // or callbacks


    movablePoint.setCoord = function (coord) {
      if (this.visible) {
        this.visibleShape.moveTo(coord);

        if (this.mouseTarget != null) {
          this.mouseTarget.moveTo(coord);
        }
      }

      this.coord = coord.slice();
    }; // Put the point at the new position, checking that it is
    // within the graph's bounds


    movablePoint.setCoordConstrained = function (coord) {
      this.setCoord(applySnapAndConstraints(coord));
    }; // Change z-order to back


    movablePoint.toBack = function () {
      if (this.visible) {
        if (this.mouseTarget != null) {
          this.mouseTarget.toBack();
        }

        this.visibleShape.toBack();
      }
    }; // Change z-order to front


    movablePoint.toFront = function () {
      if (this.visible) {
        if (this.mouseTarget != null) {
          this.mouseTarget.toFront();
        }

        this.visibleShape.toFront();
      }
    };

    movablePoint.remove = function () {
      if (this.visibleShape) {
        this.visibleShape.remove();
      }

      if (this.mouseTarget) {
        this.mouseTarget.remove();
      }

      if (this.labeledVertex) {
        this.labeledVertex.remove();
      }
    };

    return movablePoint;
  },
  // MovableLineSegment is a line segment that can be dragged around the
  // screen. By attaching a smartPoint to each (or one) end, the ends can be
  // manipulated individually.
  //
  // To use with smartPoints, add the smartPoints first, then:
  //   addMovableLineSegment({ pointA: smartPoint1, pointZ: smartPoint2 });
  // Or just one end:
  //   addMovableLineSegment({ pointA: smartPoint, coordZ: [0, 0] });
  //
  // Include "fixed: true" in the options if you don't want the entire line
  // to be draggable (you can still use points to make the endpoints
  // draggable)
  //
  // The returned object includes the following properties/methods:
  //
  //   - lineSegment.coordA / lineSegment.coordZ
  //         The coordinates of each end of the line segment
  //
  //   - lineSegment.transform(syncToPoints)
  //         Repositions the line segment. Call after changing coordA
  //         and/or coordZ, or pass syncToPoints = true to use the current
  //         position of the corresponding smartPoints, if the segment was
  //         defined using smartPoints
  //
  addMovableLineSegment: function addMovableLineSegment(options) {
    var lineSegment = $__default["default"].extend({
      graph: this,
      coordA: [0, 0],
      coordZ: [1, 1],
      snapX: 0,
      snapY: 0,
      fixed: false,
      ticks: 0,
      normalStyle: {},
      highlightStyle: {
        stroke: KhanColors$e.INTERACTING,
        "stroke-width": 6
      },
      labelStyle: {
        stroke: KhanColors$e.INTERACTIVE,
        color: KhanColors$e.INTERACTIVE
      },
      highlight: false,
      dragging: false,
      tick: [],
      extendLine: false,
      extendRay: false,
      constraints: {
        fixed: false,
        constrainX: false,
        constrainY: false
      },
      sideLabel: "",
      vertexLabels: [],
      numArrows: 0,
      numTicks: 0,
      movePointsWithLine: false
    }, options);
    var normalColor = lineSegment.fixed ? KhanColors$e.DYNAMIC : KhanColors$e.INTERACTIVE;
    lineSegment.normalStyle = _$1w.extend({}, {
      "stroke-width": 2,
      stroke: normalColor
    }, options.normalStyle); // arrowStyle should be kept in sync with styling of the line

    lineSegment.arrowStyle = _$1w.extend({}, lineSegment.normalStyle, {
      color: lineSegment.normalStyle.stroke
    }); // If the line segment is defined by movablePoints, coordA/coordZ are
    // owned by the points, otherwise they're owned by us

    if (options.pointA !== undefined) {
      lineSegment.coordA = options.pointA.coord;
      lineSegment.pointA.lineStarts.push(lineSegment);
    } else if (options.coordA !== undefined) {
      lineSegment.coordA = options.coordA.slice();
    }

    if (options.pointZ !== undefined) {
      lineSegment.coordZ = options.pointZ.coord;
      lineSegment.pointZ.lineEnds.push(lineSegment);
    } else if (options.coordA !== undefined) {
      lineSegment.coordA = lineSegment.coordA.slice();
    }

    var graph = lineSegment.graph;
    graph.style(lineSegment.normalStyle);

    for (var i = 0; i < lineSegment.ticks; ++i) {
      lineSegment.tick[i] = InteractiveUtils.bogusShape;
    } // TODO(kevinb) figure out why path isn't being used

    /* eslint-disable */


    var path = GraphUtils$7.unscaledSvgPath([[0, 0], [1, 0]]);

    for (var _i = 0; _i < lineSegment.ticks; ++_i) {
      var tickoffset = 0.5 - (lineSegment.ticks - 1 + _i * 2) / graph.scale[0];
      path += GraphUtils$7.unscaledSvgPath([[tickoffset, -7], [tickoffset, 7]]);
    }
    /* eslint-enable */


    options = {
      thickness: Math.max(lineSegment.normalStyle["stroke-width"], lineSegment.highlightStyle["stroke-width"])
    };
    lineSegment.visibleLine = new WrappedLine$5(graph, [0, 0], [1, 0], options);
    lineSegment.visibleLine.attr(lineSegment.normalStyle); // Add mouse target

    if (!lineSegment.fixed) {
      var _options2 = {
        thickness: 30,
        mouselayer: true
      };
      lineSegment.mouseTarget = new WrappedLine$5(graph, [0, 0], [1, 0], _options2);
      lineSegment.mouseTarget.attr({
        fill: "#000",
        opacity: 0.0
      });
    } // Reposition the line segment. Call after changing coordA and/or
    // coordZ, or pass syncToPoints = true to use the current position of
    // the corresponding movablePoints, if the segment was defined using
    // movablePoints


    lineSegment.transform = function (syncToPoints) {
      if (syncToPoints) {
        if (typeof this.pointA === "object") {
          this.coordA = this.pointA.coord;
        }

        if (typeof this.pointZ === "object") {
          this.coordZ = this.pointZ.coord;
        }
      }

      var getScaledAngle = function getScaledAngle(line) {
        var scaledA = line.graph.scalePoint(line.coordA);
        var scaledZ = line.graph.scalePoint(line.coordZ);
        return kvector$9.polarDegFromCart(kvector$9.subtract(scaledZ, scaledA))[1];
      };

      var getClipPoint = function getClipPoint(graph, coord, angle) {
        graph = lineSegment.graph;
        var xExtent = graph.range[0][1] - graph.range[0][0];
        var yExtent = graph.range[1][1] - graph.range[1][0];
        var distance = xExtent + yExtent;
        var angleVec = graph.unscaleVector(kvector$9.cartFromPolarDeg([1, angle]));
        var distVec = kvector$9.scale(kvector$9.normalize(angleVec), distance);
        var farCoord = kvector$9.add(coord, distVec);
        var scaledAngle = kvector$9.polarDegFromCart(angleVec)[1];
        var clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4, scaledAngle * Math.PI / 180);
        return clipPoint;
      };

      var angle = getScaledAngle(this);
      var start = this.coordA;
      var end = this.coordZ; // Extend start, end if necessary (i.e., if not a line segment)

      if (this.extendLine) {
        start = getClipPoint(graph, start, 360 - angle);
        end = getClipPoint(graph, end, (540 - angle) % 360);
      } else if (this.extendRay) {
        end = getClipPoint(graph, start, 360 - angle);
      }

      var elements = [this.visibleLine];

      if (!this.fixed) {
        elements.push(this.mouseTarget);
      }

      _$1w.each(elements, function (element) {
        element.moveTo(start, end);
      });

      var createArrow = function createArrow(graph, style) {
        var center = [0.75, 0];
        var points = [[-3, 4], [-2.75, 2.5], [0, 0.25], center, [0, -0.25], [-2.75, -2.5], [-3, -4]];
        var scale = 1.4;
        points = _$1w.map(points, function (point) {
          var pv = kvector$9.subtract(point, center);
          var pvScaled = kvector$9.scale(pv, scale);
          return kvector$9.add(center, pvScaled);
        });

        var createCubicPath = function createCubicPath(points) {
          var path = "M" + points[0][0] + " " + points[0][1];

          for (var _i2 = 1; _i2 < points.length; _i2 += 3) {
            path += "C" + points[_i2][0] + " " + points[_i2][1] + " " + points[_i2 + 1][0] + " " + points[_i2 + 1][1] + " " + points[_i2 + 2][0] + " " + points[_i2 + 2][1];
          }

          return path;
        };

        var unscaledPoints = _$1w.map(points, graph.unscalePoint);

        var options = {
          center: graph.unscalePoint(center),
          createPath: createCubicPath
        };
        var arrowHead = new WrappedPath$1(graph, unscaledPoints, options);
        arrowHead.attr(_$1w.extend({
          "stroke-linejoin": "round",
          "stroke-linecap": "round",
          "stroke-dasharray": ""
        }, style)); // Add custom function for transforming arrowheads that
        // accounts for center, scaling, etc.

        arrowHead.toCoordAtAngle = function (coord, angle) {
          var clipPoint = graph.scalePoint(getClipPoint(graph, coord, angle));
          var do3dTransform = getCanUse3dTransform();
          arrowHead.transform("translateX(" + (clipPoint[0] + scale * center[0]) + "px) " + "translateY(" + (clipPoint[1] + scale * center[1]) + "px) " + (do3dTransform ? "translateZ(0) " : "") + "rotate(" + (360 - KhanMath$8.bound(angle)) + "deg)");
        };

        return arrowHead;
      }; // Add arrows


      if (this._arrows == null) {
        this._arrows = [];

        if (this.extendLine) {
          this._arrows.push(createArrow(graph, this.normalStyle));

          this._arrows.push(createArrow(graph, this.normalStyle));
        } else if (this.extendRay) {
          this._arrows.push(createArrow(graph, this.normalStyle));
        }
      }

      var coordForArrow = [this.coordA, this.coordZ];
      var angleForArrow = [360 - angle, (540 - angle) % 360];

      _$1w.each(this._arrows, function (arrow, i) {
        arrow.toCoordAtAngle(coordForArrow[i], angleForArrow[i]);
      }); // Temporary objects: array of SVG nodes that get recreated on drag


      _$1w.invoke(this.temp, "remove");

      this.temp = [];
      var isClockwise = this.coordA[0] < this.coordZ[0] || this.coordA[0] === this.coordZ[0] && this.coordA[1] > this.coordZ[1]; // Update side label

      if (this.sideLabel) {
        this.temp.push(this.graph.labelSide({
          point1: this.coordA,
          point2: this.coordZ,
          label: this.labeledSide,
          text: this.sideLabel,
          numArrows: this.numArrows,
          numTicks: this.numTicks,
          clockwise: isClockwise,
          style: this.labelStyle
        }));
      } // Update vertex labels


      if (this.vertexLabels.length) {
        this.graph.labelVertex({
          vertex: this.coordA,
          point3: this.coordZ,
          label: this.labeledVertices[0],
          text: this.vertexLabels[0],
          clockwise: isClockwise,
          style: this.labelStyle
        });
        this.graph.labelVertex({
          point1: this.coordA,
          vertex: this.coordZ,
          label: this.labeledVertices[1],
          text: this.vertexLabels[1],
          clockwise: isClockwise,
          style: this.labelStyle
        });
      }

      this.temp = _$1w.flatten(this.temp);
    }; // Change z-order to back;


    lineSegment.toBack = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.toBack();
      }

      lineSegment.visibleLine.toBack();
    }; // Change z-order to front


    lineSegment.toFront = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.toFront();
      }

      lineSegment.visibleLine.toFront();
    };

    lineSegment.remove = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.remove();
      }

      lineSegment.visibleLine.remove();

      if (lineSegment.labeledSide) {
        lineSegment.labeledSide.remove();
      }

      if (lineSegment.labeledVertices) {
        _$1w.invoke(lineSegment.labeledVertices, "remove");
      }

      if (lineSegment._arrows) {
        _$1w.invoke(lineSegment._arrows, "remove");
      }

      if (lineSegment.temp.length) {
        _$1w.invoke(lineSegment.temp, "remove");
      }
    };

    lineSegment.hide = function () {
      lineSegment.visibleLine.hide();

      if (lineSegment.temp.length) {
        _$1w.invoke(lineSegment.temp, "hide");
      }

      if (lineSegment._arrows) {
        _$1w.invoke(lineSegment._arrows, "hide");
      }
    };

    lineSegment.show = function () {
      lineSegment.visibleLine.show();

      if (lineSegment.temp.length) {
        _$1w.invoke(lineSegment.temp, "show");
      }

      if (lineSegment._arrows) {
        _$1w.invoke(lineSegment._arrows, "show");
      }
    };

    if (lineSegment.sideLabel) {
      lineSegment.labeledSide = this.label([0, 0], "", "center", lineSegment.labelStyle);
    }

    if (lineSegment.vertexLabels.length) {
      lineSegment.labeledVertices = _$1w.map(lineSegment.vertexLabels, function (label) {
        return this.label([0, 0], "", "center", lineSegment.labelStyle);
      }, this);
    }

    if (!lineSegment.fixed && !lineSegment.constraints.fixed) {
      var $mouseTarget = $__default["default"](lineSegment.mouseTarget.getMouseTarget());
      $mouseTarget.css("cursor", "move");
      $mouseTarget.bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          if (!dragging) {
            lineSegment.highlight = true;
            lineSegment.visibleLine.animate(lineSegment.highlightStyle, 50);
            lineSegment.arrowStyle = _$1w.extend({}, lineSegment.arrowStyle, {
              color: lineSegment.highlightStyle.stroke,
              stroke: lineSegment.highlightStyle.stroke
            });
            lineSegment.transform();
          }
        } else if (event.type === "vmouseout") {
          lineSegment.highlight = false;

          if (!lineSegment.dragging) {
            lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
            lineSegment.arrowStyle = _$1w.extend({}, lineSegment.arrowStyle, {
              color: lineSegment.normalStyle.stroke,
              stroke: lineSegment.normalStyle.stroke
            });
            lineSegment.transform();
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault();
          var coordX = (event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left) / graph.scale[0] + graph.range[0][0];
          var coordY = graph.range[1][1] - (event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top) / graph.scale[1];

          if (lineSegment.snapX > 0) {
            coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
          }

          if (lineSegment.snapY > 0) {
            coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
          }

          var mouseOffsetA = [lineSegment.coordA[0] - coordX, lineSegment.coordA[1] - coordY];
          var mouseOffsetZ = [lineSegment.coordZ[0] - coordX, lineSegment.coordZ[1] - coordY];
          var offsetLeft = -Math.min(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
          var offsetRight = Math.max(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
          var offsetTop = Math.max(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
          var offsetBottom = -Math.min(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
          $__default["default"](document).bind("vmousemove.lineSegment vmouseup.lineSegment", function (event) {
            event.preventDefault();
            lineSegment.dragging = true;
            dragging = true;
            var mouseX = event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left;
            var mouseY = event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top; // no part of the line segment can go beyond 10
            // pixels from the edge

            mouseX = Math.max(offsetLeft + 10, Math.min(graph.xpixels - 10 - offsetRight, mouseX));
            mouseY = Math.max(offsetTop + 10, Math.min(graph.ypixels - 10 - offsetBottom, mouseY));
            var coordX = mouseX / graph.scale[0] + graph.range[0][0];
            var coordY = graph.range[1][1] - mouseY / graph.scale[1];

            if (lineSegment.snapX > 0) {
              coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
            }

            if (lineSegment.snapY > 0) {
              coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
            }

            if (event.type === "vmousemove") {
              if (lineSegment.constraints.constrainX) {
                coordX = lineSegment.coordA[0] - mouseOffsetA[0];
              }

              if (lineSegment.constraints.constrainY) {
                coordY = lineSegment.coordA[1] - mouseOffsetA[1];
              }

              var dX = coordX + mouseOffsetA[0] - lineSegment.coordA[0];
              var dY = coordY + mouseOffsetA[1] - lineSegment.coordA[1];
              lineSegment.coordA = [coordX + mouseOffsetA[0], coordY + mouseOffsetA[1]];
              lineSegment.coordZ = [coordX + mouseOffsetZ[0], coordY + mouseOffsetZ[1]];
              lineSegment.transform();

              if (lineSegment.movePointsWithLine) {
                // If the points are movablePoints, adjust
                // their coordinates when the line itself is
                // dragged
                if (typeof lineSegment.pointA === "object") {
                  lineSegment.pointA.setCoord([lineSegment.pointA.coord[0] + dX, lineSegment.pointA.coord[1] + dY]);
                }

                if (typeof lineSegment.pointZ === "object") {
                  lineSegment.pointZ.setCoord([lineSegment.pointZ.coord[0] + dX, lineSegment.pointZ.coord[1] + dY]);
                }
              }

              if (_$1w.isFunction(lineSegment.onMove)) {
                lineSegment.onMove(dX, dY);
              }
            } else if (event.type === "vmouseup") {
              $__default["default"](document).unbind(".lineSegment");
              lineSegment.dragging = false;
              dragging = false;

              if (!lineSegment.highlight) {
                lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
                lineSegment.arrowStyle = _$1w.extend({}, lineSegment.arrowStyle, {
                  color: lineSegment.normalStyle.stroke,
                  stroke: lineSegment.normalStyle.stroke
                });
                lineSegment.transform();
              }

              if (_$1w.isFunction(lineSegment.onMoveEnd)) {
                lineSegment.onMoveEnd();
              }
            }

            $__default["default"](lineSegment).trigger("move");
          });
        }
      });
    }

    if (lineSegment.pointA !== undefined) {
      lineSegment.pointA.toFront();
    }

    if (lineSegment.pointZ !== undefined) {
      lineSegment.pointZ.toFront();
    }

    lineSegment.transform();
    return lineSegment;
  },
  // MovablePolygon is a polygon that can be dragged around the screen.
  // By attaching a smartPoint to each vertex, the points can be
  // manipulated individually.
  //
  // To use with smartPoints, add the smartPoints first, then:
  //   addMovablePolygon({points: [...]});
  //
  // Include "fixed: true" in the options if you don't want the entire
  // polygon to be draggable (you can still use points to make the
  // vertices draggable)
  //
  // The returned object includes the following properties/methods:
  //
  //   - polygon.points
  //         The polygon's dynamic smartPoints and static coordinates, mixed.
  //
  //   - polygon.coords
  //         The polygon's current coordinates (generated, don't edit).
  //
  //   - polygon.transform()
  //         Repositions the polygon. Call after changing any points.
  //
  addMovablePolygon: function addMovablePolygon(options) {
    var graphie = this;
    var polygon = $__default["default"].extend({
      snapX: 0,
      snapY: 0,
      fixed: false,
      constrainToGraph: true,
      normalStyle: {},
      highlightStyle: {
        stroke: KhanColors$e.INTERACTING,
        "stroke-width": 2,
        fill: KhanColors$e.INTERACTING,
        "fill-opacity": 0.05
      },
      pointHighlightStyle: {
        fill: KhanColors$e.INTERACTING,
        stroke: KhanColors$e.INTERACTING
      },
      labelStyle: {
        stroke: KhanColors$e.DYNAMIC,
        "stroke-width": 1,
        color: KhanColors$e.DYNAMIC
      },
      angleLabels: [],
      showRightAngleMarkers: [],
      sideLabels: [],
      vertexLabels: [],
      numArcs: [],
      numArrows: [],
      numTicks: [],
      updateOnPointMove: true,
      closed: true
    }, _$1w.omit(options, "points"));
    var normalColor = polygon.fixed ? KhanColors$e.DYNAMIC : KhanColors$e.INTERACTIVE;
    polygon.normalStyle = _$1w.extend({
      "stroke-width": 2,
      "fill-opacity": 0,
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle); // don't deep copy the points array with $.extend;
    // we may want to append to it later for click-to-add-points

    polygon.points = options.points;

    var isPoint = function isPoint(coordOrPoint) {
      return !_$1w.isArray(coordOrPoint);
    };

    polygon.update = function () {
      var n = polygon.points.length; // Update coords

      polygon.coords = _$1w.map(polygon.points, function (coordOrPoint, i) {
        if (isPoint(coordOrPoint)) {
          return coordOrPoint.coord;
        } else {
          return coordOrPoint;
        }
      }); // Calculate bounding box

      polygon.left = _$1w.min(_$1w.pluck(polygon.coords, 0));
      polygon.right = _$1w.max(_$1w.pluck(polygon.coords, 0));
      polygon.top = _$1w.max(_$1w.pluck(polygon.coords, 1));
      polygon.bottom = _$1w.min(_$1w.pluck(polygon.coords, 1));

      var scaledCoords = _$1w.map(polygon.coords, function (coord) {
        return graphie.scalePoint(coord);
      }); // Create path


      if (polygon.closed) {
        scaledCoords.push(true);
      } else {
        // For open polygons, concatenate a reverse of the path,
        // to remove the inside area of the path, which would
        // otherwise be clickable (even if the closing line segment
        // wasn't drawn
        scaledCoords = scaledCoords.concat(_$1w.clone(scaledCoords).reverse());
      }

      polygon.path = GraphUtils$7.unscaledSvgPath(scaledCoords); // Temporary objects

      _$1w.invoke(polygon.temp, "remove");

      polygon.temp = [];
      var isClockwise = clockwise$1(polygon.coords); // Update angle labels

      if (polygon.angleLabels.length || polygon.showRightAngleMarkers.length) {
        _$1w.each(polygon.labeledAngles, function (label, i) {
          polygon.temp.push(graphie.labelAngle({
            point1: polygon.coords[(i - 1 + n) % n],
            vertex: polygon.coords[i],
            point3: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.angleLabels[i],
            showRightAngleMarker: polygon.showRightAngleMarkers[i],
            numArcs: polygon.numArcs[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          }));
        });
      } // Update side labels


      if (polygon.sideLabels.length) {
        _$1w.each(polygon.labeledSides, function (label, i) {
          polygon.temp.push(graphie.labelSide({
            point1: polygon.coords[i],
            point2: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.sideLabels[i],
            numArrows: polygon.numArrows[i],
            numTicks: polygon.numTicks[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          }));
        });
      } // Update vertex labels


      if (polygon.vertexLabels.length) {
        _$1w.each(polygon.labeledVertices, function (label, i) {
          graphie.labelVertex({
            point1: polygon.coords[(i - 1 + n) % n],
            vertex: polygon.coords[i],
            point3: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.vertexLabels[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          });
        });
      }

      polygon.temp = _$1w.flatten(polygon.temp);
    };

    polygon.transform = function () {
      polygon.update();
      polygon.visibleShape.attr({
        path: polygon.path
      });

      if (!polygon.fixed) {
        polygon.mouseTarget.attr({
          path: polygon.path
        });
      }
    };

    polygon.remove = function () {
      polygon.visibleShape.remove();

      if (!polygon.fixed) {
        polygon.mouseTarget.remove();
      }

      if (polygon.labeledAngles) {
        _$1w.invoke(polygon.labeledAngles, "remove");
      }

      if (polygon.labeledSides) {
        _$1w.invoke(polygon.labeledSides, "remove");
      }

      if (polygon.labeledVertices) {
        _$1w.invoke(polygon.labeledVertices, "remove");
      }

      if (polygon.temp.length) {
        _$1w.invoke(polygon.temp, "remove");
      }
    };

    polygon.toBack = function () {
      if (!polygon.fixed) {
        polygon.mouseTarget.toBack();
      }

      polygon.visibleShape.toBack();
    };

    polygon.toFront = function () {
      if (!polygon.fixed) {
        polygon.mouseTarget.toFront();
      }

      polygon.visibleShape.toFront();
    }; // Setup


    if (polygon.updateOnPointMove) {
      _$1w.each(_$1w.filter(polygon.points, isPoint), function (coordOrPoint) {
        coordOrPoint.polygonVertices.push(polygon);
      });
    }

    polygon.coords = new Array(polygon.points.length);

    if (polygon.angleLabels.length) {
      var numLabels = Math.max(polygon.angleLabels.length, polygon.showRightAngleMarkers.length);
      polygon.labeledAngles = _$1w.times(numLabels, function () {
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }

    if (polygon.sideLabels.length) {
      polygon.labeledSides = _$1w.map(polygon.sideLabels, function (label) {
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }

    if (polygon.vertexLabels.length) {
      polygon.labeledVertices = _$1w.map(polygon.vertexLabels, function (label) {
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }

    polygon.update();
    polygon.visibleShape = graphie.raphael.path(polygon.path);
    polygon.visibleShape.attr(polygon.normalStyle);

    if (!polygon.fixed) {
      polygon.mouseTarget = graphie.mouselayer.path(polygon.path);
      polygon.mouseTarget.attr({
        fill: "#000",
        opacity: 0,
        cursor: "move"
      });
      $__default["default"](polygon.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          if (!dragging || polygon.dragging) {
            polygon.highlight = true;
            polygon.visibleShape.animate(polygon.highlightStyle, 50);

            _$1w.each(_$1w.filter(polygon.points, isPoint), function (point) {
              point.visibleShape.animate(polygon.pointHighlightStyle, 50);
            });
          }
        } else if (event.type === "vmouseout") {
          polygon.highlight = false;

          if (!polygon.dragging) {
            polygon.visibleShape.animate(polygon.normalStyle, 50);

            var points = _$1w.filter(polygon.points, isPoint);

            if (!_$1w.any(_$1w.pluck(points, "dragging"))) {
              _$1w.each(points, function (point) {
                point.visibleShape.animate(point.normalStyle, 50);
              });
            }
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault();

          _$1w.each(_$1w.filter(polygon.points, isPoint), function (point) {
            point.dragging = true;
          });

          var startX = (event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left) / graphie.scale[0] + graphie.range[0][0];
          var startY = graphie.range[1][1] - (event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top) / graphie.scale[1];

          if (polygon.snapX > 0) {
            startX = Math.round(startX / polygon.snapX) * polygon.snapX;
          }

          if (polygon.snapY > 0) {
            startY = Math.round(startY / polygon.snapY) * polygon.snapY;
          }

          var lastX = startX;
          var lastY = startY;
          var polygonCoords = polygon.coords.slice();
          var offsetLeft = (startX - polygon.left) * graphie.scale[0];
          var offsetRight = (polygon.right - startX) * graphie.scale[0];
          var offsetTop = (polygon.top - startY) * graphie.scale[1];
          var offsetBottom = (startY - polygon.bottom) * graphie.scale[1];
          $__default["default"](document).bind("vmousemove.polygon vmouseup.polygon", function (event) {
            event.preventDefault();
            polygon.dragging = true;
            dragging = true;
            var mouseX = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
            var mouseY = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top; // no part of the polygon can go beyond 10 pixels from
            // the edge

            if (polygon.constrainToGraph) {
              mouseX = Math.max(offsetLeft + 10, Math.min(graphie.xpixels - 10 - offsetRight, mouseX));
              mouseY = Math.max(offsetTop + 10, Math.min(graphie.ypixels - 10 - offsetBottom, mouseY));
            }

            var currentX = mouseX / graphie.scale[0] + graphie.range[0][0];
            var currentY = graphie.range[1][1] - mouseY / graphie.scale[1];

            if (polygon.snapX > 0) {
              currentX = Math.round(currentX / polygon.snapX) * polygon.snapX;
            }

            if (polygon.snapY > 0) {
              currentY = Math.round(currentY / polygon.snapY) * polygon.snapY;
            }

            if (event.type === "vmousemove") {
              var dX = currentX - startX;
              var dY = currentY - startY;
              var doMove = true;

              if (_$1w.isFunction(polygon.onMove)) {
                var onMoveResult = polygon.onMove(dX, dY);

                if (onMoveResult === false) {
                  doMove = false;
                } else if (_$1w.isArray(onMoveResult)) {
                  dX = onMoveResult[0];
                  dY = onMoveResult[1];
                  currentX = startX + dX;
                  currentY = startY + dY;
                }
              }

              var increment = function increment(i) {
                return [polygonCoords[i][0] + dX, polygonCoords[i][1] + dY];
              };

              if (doMove) {
                _$1w.each(polygon.points, function (coordOrPoint, i) {
                  if (isPoint(coordOrPoint)) {
                    coordOrPoint.setCoord(increment(i));
                  } else {
                    polygon.points[i] = increment(i);
                  }
                });

                polygon.transform();
                $__default["default"](polygon).trigger("move");
                lastX = currentX;
                lastY = currentY;
              }
            } else if (event.type === "vmouseup") {
              $__default["default"](document).unbind(".polygon");

              var _points = _$1w.filter(polygon.points, isPoint);

              _$1w.each(_points, function (point) {
                point.dragging = false;
              });

              polygon.dragging = false;
              dragging = false;

              if (!polygon.highlight) {
                polygon.visibleShape.animate(polygon.normalStyle, 50);

                _$1w.each(_points, function (point) {
                  point.visibleShape.animate(point.normalStyle, 50);
                });
              }

              if (_$1w.isFunction(polygon.onMoveEnd)) {
                polygon.onMoveEnd(lastX - startX, lastY - startY);
              }
            }
          });
        }
      });
    } // Bring any movable points to the front


    _$1w.invoke(_$1w.filter(polygon.points, isPoint), "toFront");

    return polygon;
  },

  /**
   * Constrain a point to be within the graph (including padding).
   * If outside graph, point's x and y coordinates are clamped within
   * the graph.
   */
  constrainToBounds: function constrainToBounds(point, padding) {
    var lower = this.unscalePoint([padding, this.ypixels - padding]);
    var upper = this.unscalePoint([this.xpixels - padding, padding]);
    var coordX = Math.max(lower[0], Math.min(upper[0], point[0]));
    var coordY = Math.max(lower[1], Math.min(upper[1], point[1]));
    return [coordX, coordY];
  },

  /**
   * Constrain a point to be within the graph (including padding).
   * If outside graph, point is moved along the ray specified by angle
   * until inside graph.
   */
  constrainToBoundsOnAngle: function constrainToBoundsOnAngle(point, padding, angle) {
    var lower = this.unscalePoint([padding, this.ypixels - padding]);
    var upper = this.unscalePoint([this.xpixels - padding, padding]);
    var result = point.slice();

    if (result[0] < lower[0]) {
      result = [lower[0], result[1] + (lower[0] - result[0]) * Math.tan(angle)];
    } else if (result[0] > upper[0]) {
      result = [upper[0], result[1] - (result[0] - upper[0]) * Math.tan(angle)];
    }

    if (result[1] < lower[1]) {
      result = [result[0] + (lower[1] - result[1]) / Math.tan(angle), lower[1]];
    } else if (result[1] > upper[1]) {
      result = [result[0] - (result[1] - upper[1]) / Math.tan(angle), upper[1]];
    }

    return result;
  },
  // MovableAngle is an angle that can be dragged around the screen.
  // By attaching a smartPoint to the vertex and ray control points, the
  // rays can be manipulated individually.
  //
  // Use only with smartPoints; add the smartPoints first, then:
  //   addMovableAngle({points: [...]});
  //
  // The rays can be controlled to snap on degrees (more useful than snapping
  // on coordinates) by setting snapDegrees to a positive integer.
  //
  // The returned object includes the following properties/methods:
  //
  //   - movableAngle.points
  //         The movableAngle's dynamic smartPoints.
  //
  //   - movableAngle.coords
  //         The movableAngle's current coordinates (generated, don't edit).
  //
  addMovableAngle: function addMovableAngle(options) {
    return new MovableAngle(this, options);
  },
  // center: movable point
  // radius: int
  // circ: graphie circle
  // perim: invisible mouse target for dragging/changing radius
  addCircleGraph: function addCircleGraph(options) {
    var graphie = this;
    var circle = $__default["default"].extend({
      center: [0, 0],
      radius: 2,
      snapX: 0.5,
      snapY: 0.5,
      snapRadius: 0.5,
      minRadius: 1,
      centerConstraints: {},
      centerNormalStyle: {},
      centerHighlightStyle: {
        stroke: KhanColors$e.INTERACTING,
        fill: KhanColors$e.INTERACTING
      },
      circleNormalStyle: {
        stroke: KhanColors$e.INTERACTIVE,
        "fill-opacity": 0
      },
      circleHighlightStyle: {
        stroke: KhanColors$e.INTERACTING,
        fill: KhanColors$e.INTERACTING,
        "fill-opacity": 0.05
      }
    }, options);
    var normalColor = circle.centerConstraints.fixed ? KhanColors$e.DYNAMIC : KhanColors$e.INTERACTIVE;
    var centerNormalStyle = options ? options.centerNormalStyle : null;
    circle.centerNormalStyle = _$1w.extend({}, {
      fill: normalColor,
      stroke: normalColor
    }, centerNormalStyle);
    circle.centerPoint = graphie.addMovablePoint({
      graph: graphie,
      coord: circle.center,
      normalStyle: circle.centerNormalStyle,
      snapX: circle.snapX,
      snapY: circle.snapY,
      constraints: circle.centerConstraints
    });
    circle.circ = graphie.circle(circle.center, circle.radius, circle.circleNormalStyle);
    circle.perim = graphie.mouselayer.circle(graphie.scalePoint(circle.center)[0], graphie.scalePoint(circle.center)[1], graphie.scaleVector(circle.radius)[0]).attr({
      "stroke-width": 20,
      opacity: 0.002 // This is as close to 0 as MSIE will allow

    }); // Highlight circle circumference on center point hover

    if (!circle.centerConstraints.fixed) {
      $__default["default"](circle.centerPoint.mouseTarget.getMouseTarget()).on("vmouseover vmouseout", function (event) {
        if (circle.centerPoint.highlight || circle.centerPoint.dragging) {
          circle.circ.animate(circle.circleHighlightStyle, 50);
        } else {
          circle.circ.animate(circle.circleNormalStyle, 50);
        }
      });
    }

    circle.toFront = function () {
      circle.circ.toFront();
      circle.perim.toFront();
      circle.centerPoint.visibleShape.toFront();

      if (!circle.centerConstraints.fixed) {
        circle.centerPoint.mouseTarget.toFront();
      }
    };

    circle.centerPoint.onMove = function (x, y) {
      circle.toFront();
      circle.circ.attr({
        cx: graphie.scalePoint(x)[0],
        cy: graphie.scalePoint(y)[1]
      });
      circle.perim.attr({
        cx: graphie.scalePoint(x)[0],
        cy: graphie.scalePoint(y)[1]
      });

      if (circle.onMove) {
        circle.onMove(x, y);
      }
    };

    $__default["default"](circle.centerPoint).on("move", function () {
      circle.center = this.coord;
      $__default["default"](circle).trigger("move");
    }); // circle.setCenter(x, y) moves the circle to the specified
    // x, y coordinate as if the user had dragged it there.

    circle.setCenter = function (x, y) {
      circle.centerPoint.setCoord([x, y]);
      circle.centerPoint.onMove(x, y);
      circle.center = [x, y];
    }; // circle.setRadius(r) sets the circle's radius to the specified
    // value as if the user had dragged it there.


    circle.setRadius = function (r) {
      circle.radius = r;
      circle.perim.attr({
        r: graphie.scaleVector(r)[0]
      });
      circle.circ.attr({
        rx: graphie.scaleVector(r)[0],
        ry: graphie.scaleVector(r)[1]
      });
    };

    circle.remove = function () {
      circle.centerPoint.remove();
      circle.circ.remove();
      circle.perim.remove();
    }; // Define a set of axes using polar coordinates to specify
    // which resizing cursor we want to show based on where the
    // mouse position lies in relation to the circle's center.
    // The first two columns in cursorAxes refer to the minimum
    // and maximum angle values bounding a circle sector, and
    // the third column refers to the cursor name that will be
    // applied if the mouse position falls inside the given sector.


    var cursorAxes = [[Math.PI * -1.0, Math.PI * -0.875, "ew-resize"], [Math.PI * -0.875, Math.PI * -0.625, "nesw-resize"], [Math.PI * -0.625, Math.PI * -0.375, "ns-resize"], [Math.PI * -0.375, Math.PI * -0.125, "nwse-resize"], [Math.PI * -0.125, Math.PI * 0.125, "ew-resize"], [Math.PI * 0.125, Math.PI * 0.375, "nesw-resize"], [Math.PI * 0.375, Math.PI * 0.625, "ns-resize"], [Math.PI * 0.625, Math.PI * 0.875, "nwse-resize"], [Math.PI * 0.875, Math.PI * 1.0, "ew-resize"]]; // When the mouse moves along the circle's perimeter, we
    // dynamically set a CSS rule to show the correct
    // bidirectional cursor so a student knows they can resize
    // our circle. To do this, we convert the x and y coordinates
    // of the mouse position into polar coordinates and use the
    // defined cursorAxes above to set our rule.

    $__default["default"](circle.perim.node).on("vmousemove", event => {
      var [x, y] = this.getMouseCoord(event);
      x -= circle.center[0];
      y -= circle.center[1];
      var theta = Math.atan2(y, x);
      cursorAxes.forEach(function (axes) {
        var [min, max, cursorName] = axes;

        if (theta >= min && theta < max) {
          $__default["default"](circle.perim.node).css("cursor", cursorName);
        }
      });
    }); // Set a default resizing-friendly cursor to be safe.

    $__default["default"](circle.perim.node).css("cursor", "nesw-resize"); // Prevent the page from scrolling when we grab and drag the circle on
    // a mobile device.

    circle.perim.node.addEventListener("touchstart", function (event) {
      event.preventDefault();
    }, {
      passive: false
    });
    $__default["default"](circle.perim.node).on("vmouseover vmouseout vmousedown", function (event) {
      if (event.type === "vmouseover") {
        circle.highlight = true;

        if (!dragging) {
          // TODO(jack): Figure out why this doesn't work
          // for circleHighlightStyle's that change
          // stroke-dasharray
          circle.circ.animate(circle.circleHighlightStyle, 50);
          circle.centerPoint.visibleShape.animate(circle.centerHighlightStyle, 50);
        }
      } else if (event.type === "vmouseout") {
        circle.highlight = false;

        if (!circle.dragging && !circle.centerPoint.dragging) {
          circle.circ.animate(circle.circleNormalStyle, 50);
          circle.centerPoint.visibleShape.animate(circle.centerNormalStyle, 50);
        }
      } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
        event.preventDefault();
        circle.toFront();
        var startRadius = circle.radius;
        $__default["default"](document).on("vmousemove vmouseup", function (event) {
          event.preventDefault();
          circle.dragging = true;
          dragging = true;

          if (event.type === "vmousemove") {
            var coord = graphie.constrainToBounds(graphie.getMouseCoord(event), 10);
            var radius = GraphUtils$7.getDistance(circle.centerPoint.coord, coord);
            radius = Math.max(circle.minRadius, Math.round(radius / circle.snapRadius) * circle.snapRadius);
            var oldRadius = circle.radius;
            var doResize = true;

            if (circle.onResize) {
              var onResizeResult = circle.onResize(radius, oldRadius);

              if (_$1w.isNumber(onResizeResult)) {
                radius = onResizeResult;
              } else if (onResizeResult === false) {
                doResize = false;
              }
            }

            if (doResize) {
              circle.setRadius(radius);
              $__default["default"](circle).trigger("move");
            }
          } else if (event.type === "vmouseup") {
            $__default["default"](document).off("vmousemove vmouseup");
            circle.dragging = false;
            dragging = false;

            if (circle.onResizeEnd) {
              circle.onResizeEnd(circle.radius, startRadius);
            }
          }
        });
      }
    });
    return circle;
  },
  addRotateHandle: function () {
    var drawRotateHandle = function drawRotateHandle(graphie, center, radius, halfWidth, lengthAngle, angle, interacting) {
      var getRotateHandlePoint = function getRotateHandlePoint(offset, distanceFromArrowMidline) {
        var distFromRotationCenter = radius + distanceFromArrowMidline;
        var vec = kvector$9.cartFromPolarDeg([distFromRotationCenter, angle + offset]);
        var absolute = kvector$9.add(center, vec);
        var pixels = graphie.scalePoint(absolute);
        return pixels[0] + "," + pixels[1];
      };

      var innerR = graphie.scaleVector(radius - halfWidth);
      var outerR = graphie.scaleVector(radius + halfWidth); // Draw the double-headed arrow thing that shows users where to
      // click and drag to rotate

      return graphie.raphael.path( // upper arrowhead
      " M" + getRotateHandlePoint(lengthAngle, -halfWidth) + " L" + getRotateHandlePoint(lengthAngle, -3 * halfWidth) + " L" + getRotateHandlePoint(2 * lengthAngle, 0) + " L" + getRotateHandlePoint(lengthAngle, 3 * halfWidth) + " L" + getRotateHandlePoint(lengthAngle, halfWidth) + // outer arc
      " A" + outerR[0] + "," + outerR[1] + ",0,0,1," + getRotateHandlePoint(-lengthAngle, halfWidth) + // lower arrowhead
      " L" + getRotateHandlePoint(-lengthAngle, 3 * halfWidth) + " L" + getRotateHandlePoint(-2 * lengthAngle, 0) + " L" + getRotateHandlePoint(-lengthAngle, -3 * halfWidth) + " L" + getRotateHandlePoint(-lengthAngle, -halfWidth) + // inner arc
      " A" + innerR[0] + "," + innerR[1] + ",0,0,0," + getRotateHandlePoint(lengthAngle, -halfWidth) + " Z").attr({
        stroke: null,
        fill: interacting ? KhanColors$e.INTERACTING : KhanColors$e.INTERACTIVE
      });
    };

    return function (options) {
      var graph = this;
      var rotatePoint = options.center;
      var radius = options.radius;
      var lengthAngle = options.lengthAngle || 30;
      var hideArrow = options.hideArrow || false;
      var mouseTarget = options.mouseTarget;

      var id = _$1w.uniqueId("rotateHandle"); // Normalize rotatePoint into something that always looks
      // like a movablePoint


      if (_$1w.isArray(rotatePoint)) {
        rotatePoint = {
          coord: rotatePoint
        };
      }

      var rotateHandle = graph.addMovablePoint({
        coord: kpoint$b.addVector(rotatePoint.coord, kvector$9.cartFromPolarDeg(radius, options.angleDeg || 0)),
        constraints: {
          fixedDistance: {
            dist: radius,
            point: rotatePoint
          }
        },
        mouseTarget: mouseTarget
      }); // move the rotatePoint in front of the rotateHandle to avoid
      // confusing clicking/scaling of the rotateHandle when the user
      // intends to click on the rotatePoint

      rotatePoint.toFront();
      var rotatePointPrevCoord = rotatePoint.coord;
      var rotateHandlePrevCoord = rotateHandle.coord;
      var rotateHandleStartCoord = rotateHandlePrevCoord;
      var isRotating = false;
      var isHovering = false;
      var drawnRotateHandle;

      var redrawRotateHandle = function redrawRotateHandle(handleCoord) {
        if (hideArrow) {
          return; // Don't draw anything!
        }

        var handleVec = kvector$9.subtract(handleCoord, rotatePoint.coord);
        var handlePolar = kvector$9.polarDegFromCart(handleVec);
        var angle = handlePolar[1];

        if (drawnRotateHandle) {
          drawnRotateHandle.remove();
        }

        drawnRotateHandle = drawRotateHandle(graph, rotatePoint.coord, options.radius, isRotating || isHovering ? options.hoverWidth / 2 : options.width / 2, lengthAngle, angle, isRotating || isHovering);
      }; // when the rotation center moves, we need to move
      // the rotationHandle as well, or it will end up out
      // of sync


      $__default["default"](rotatePoint).on("move." + id, function () {
        var delta = kvector$9.subtract(rotatePoint.coord, rotatePointPrevCoord);
        rotateHandle.setCoord(kvector$9.add(rotateHandle.coord, delta));
        redrawRotateHandle(rotateHandle.coord);
        rotatePointPrevCoord = rotatePoint.coord;
        rotateHandle.constraints.fixedDistance.point = rotatePoint;
        rotateHandlePrevCoord = rotateHandle.coord;
      }); // Rotate polygon with rotateHandle

      rotateHandle.onMove = function (x, y) {
        if (!isRotating) {
          rotateHandleStartCoord = rotateHandlePrevCoord;
          isRotating = true;
        }

        var coord = [x, y];

        if (options.onMove) {
          var oldPolar = kvector$9.polarDegFromCart(kvector$9.subtract(rotateHandlePrevCoord, rotatePoint.coord));
          var newPolar = kvector$9.polarDegFromCart(kvector$9.subtract(coord, rotatePoint.coord));
          var oldAngle = oldPolar[1];
          var newAngle = newPolar[1];
          var result = options.onMove(newAngle, oldAngle);

          if (result != null && result !== true) {
            if (result === false) {
              result = oldAngle;
            }

            coord = kvector$9.add(rotatePoint.coord, kvector$9.cartFromPolarDeg([oldPolar[0], result]));
          }
        }

        redrawRotateHandle(coord);
        rotateHandlePrevCoord = coord;
        return coord;
      };

      rotateHandle.onMoveEnd = function () {
        isRotating = false;
        redrawRotateHandle(rotateHandle.coord);

        if (options.onMoveEnd) {
          var oldPolar = kvector$9.polarDegFromCart(kvector$9.subtract(rotateHandleStartCoord, rotatePoint.coord));
          var newPolar = kvector$9.polarDegFromCart(kvector$9.subtract(rotateHandle.coord, rotatePoint.coord));
          options.onMoveEnd(newPolar[1], oldPolar[1]);
        }
      }; // Remove the default dot added by the movablePoint since we have
      // our double-arrow thing


      rotateHandle.visibleShape.remove();

      if (!mouseTarget) {
        // Make the default mouse target bigger to encompass the whole
        // area around the double-arrow thing
        rotateHandle.mouseTarget.attr({
          scale: 2
        });
      }

      var $mouseTarget = $__default["default"](rotateHandle.mouseTarget.getMouseTarget());
      $mouseTarget.bind("vmouseover", function (e) {
        isHovering = true;
        redrawRotateHandle(rotateHandle.coord);
      });
      $mouseTarget.bind("vmouseout", function (e) {
        isHovering = false;
        redrawRotateHandle(rotateHandle.coord);
      });
      redrawRotateHandle(rotateHandle.coord);
      var oldRemove = rotateHandle.remove;

      rotateHandle.remove = function () {
        oldRemove.call(rotateHandle);

        if (drawnRotateHandle) {
          drawnRotateHandle.remove();
        }

        $__default["default"](rotatePoint).off("move." + id);
      };

      rotateHandle.update = function () {
        redrawRotateHandle(rotateHandle.coord);
      };

      return rotateHandle;
    };
  }(),
  addReflectButton: function () {
    var drawButton = function drawButton(graphie, buttonCoord, lineCoords, size, distanceFromCenter, leftStyle, rightStyle) {
      // Avoid invalid lines
      if (kpoint$b.equal(lineCoords[0], lineCoords[1])) {
        lineCoords = [lineCoords[0], kpoint$b.addVector(lineCoords[0], [1, 1])];
      }

      var lineDirection = kvector$9.normalize(kvector$9.subtract(lineCoords[1], lineCoords[0]));
      var lineVec = kvector$9.scale(lineDirection, size / 2);
      var centerVec = kvector$9.scale(lineDirection, distanceFromCenter);
      var leftCenterVec = kvector$9.rotateDeg(centerVec, 90);
      var rightCenterVec = kvector$9.rotateDeg(centerVec, -90);
      var negLineVec = kvector$9.negate(lineVec);
      var leftVec = kvector$9.rotateDeg(lineVec, 90);
      var rightVec = kvector$9.rotateDeg(lineVec, -90);
      var leftCenter = kpoint$b.addVectors(buttonCoord, leftCenterVec);
      var rightCenter = kpoint$b.addVectors(buttonCoord, rightCenterVec);
      var leftCoord1 = kpoint$b.addVectors(buttonCoord, leftCenterVec, lineVec, leftVec);
      var leftCoord2 = kpoint$b.addVectors(buttonCoord, leftCenterVec, negLineVec, leftVec);
      var rightCoord1 = kpoint$b.addVectors(buttonCoord, rightCenterVec, lineVec, rightVec);
      var rightCoord2 = kpoint$b.addVectors(buttonCoord, rightCenterVec, negLineVec, rightVec);
      var leftButton = graphie.path([leftCenter, leftCoord1, leftCoord2, true], leftStyle);
      var rightButton = graphie.path([rightCenter, rightCoord1, rightCoord2, true], rightStyle);
      return {
        remove: function remove() {
          leftButton.remove();
          rightButton.remove();
        }
      };
    };

    return function (options) {
      var graphie = this;
      var line = options.line;
      var button = graphie.addMovablePoint({
        constraints: options.constraints,
        coord: kline$2.midpoint([line.pointA.coord, line.pointZ.coord]),
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        onMove: function onMove(x, y) {
          // Don't allow the button to actually move. This is a hack
          // around the inability to both set a point as fixed AND
          // allow it to be clicked.
          return false;
        },
        onMoveEnd: function onMoveEnd(x, y) {
          if (options.onMoveEnd) {
            options.onMoveEnd.call(this, x, y);
          }
        }
      });
      var isHovering = false;
      var isFlipped = false;
      var currentlyDrawnButton;

      var isHighlight = function isHighlight() {
        return isHovering;
      };

      var styles = _$1w.map([0, 1], function (isHighlight) {
        var baseStyle = isHighlight ? options.highlightStyle : options.normalStyle;
        return _$1w.map([0, 1], function (opacity) {
          return _$1w.defaults({
            "fill-opacity": opacity
          }, baseStyle);
        });
      });

      var getStyle = function getStyle(isRight) {
        if (isFlipped) {
          isRight = !isRight;
        }

        return styles[+isHighlight()][+isRight];
      };

      var redraw = function redraw(coord, lineCoords) {
        if (currentlyDrawnButton) {
          currentlyDrawnButton.remove();
        }

        currentlyDrawnButton = drawButton(graphie, coord, lineCoords, isHighlight() ? options.size * 1.5 : options.size, isHighlight() ? options.size * 0.125 : 0.25, getStyle(0), getStyle(1));
      };

      var update = function update(coordA, coordZ) {
        coordA = coordA || line.pointA.coord;
        coordZ = coordZ || line.pointZ.coord;
        var buttonCoord = kline$2.midpoint([coordA, coordZ]);
        button.setCoord(buttonCoord);
        redraw(buttonCoord, [coordA, coordZ]);
      };

      $__default["default"](line).on("move", _$1w.bind(update, button, null, null));
      var $mouseTarget = $__default["default"](button.mouseTarget.getMouseTarget());
      $mouseTarget.on("vclick", function () {
        var result = options.onClick();

        if (result !== false) {
          isFlipped = !isFlipped;
          redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
        }
      }); // Bring the reflection line handles in front of the button, so
      // that if we drag the reflectPoints really close together, we can
      // still move the handles away from each other, rather than only
      // being able to apply the reflection.

      line.pointA.toFront();
      line.pointZ.toFront(); // Replace the visual point with the double triangle thing

      button.visibleShape.remove();
      var pointScale = graphie.scaleVector(options.size)[0] / 20;
      button.mouseTarget.attr({
        scale: 1.5 * pointScale
      });
      $mouseTarget.css("cursor", "pointer"); // Make the arrow-thing grow and shrink with mouseover/out

      $mouseTarget.bind("vmouseover", function (e) {
        isHovering = true;
        redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
      });
      $mouseTarget.bind("vmouseout", function (e) {
        isHovering = false;
        redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
      });
      var oldButtonRemove = button.remove;

      button.remove = function () {
        currentlyDrawnButton.remove();
        oldButtonRemove.call(button);
      };

      button.update = update;

      button.isFlipped = function () {
        return isFlipped;
      };

      update();
      return button;
    };
  }(),
  protractor: function protractor(center) {
    return new Protractor(this, center);
  },
  ruler: function ruler(options) {
    return new Ruler(this, options || {});
  },
  addPoints: addPoints
});

function Protractor(graph, center) {
  this.set = graph.raphael.set();
  this.cx = center[0];
  this.cy = center[1];
  var pro = this;
  var r = graph.unscaleVector(180.5)[0];
  var imgPos = graph.scalePoint([this.cx - r, this.cy + r - graph.unscaleVector(10.5)[1]]);
  var image = graph.mouselayer.image("https://ka-perseus-graphie.s3.amazonaws.com/e9d032f2ab8b95979f674fbfa67056442ba1ff6a.png", imgPos[0], imgPos[1], 360, 180);
  this.set.push(image); // Prevent the page from scrolling when we grab and drag the image on a
  // mobile device.

  image.node.addEventListener("touchstart", function (event) {
    event.preventDefault();
  }, {
    passive: false
  });

  var arrowHelper = function arrowHelper(angle, pixelsFromEdge) {
    var scaledRadius = graph.scaleVector(r);
    scaledRadius[0] -= 16;
    scaledRadius[1] -= 16;
    var scaledCenter = graph.scalePoint(center);
    var x = Math.sin((angle + 90) * Math.PI / 180) * (scaledRadius[0] + pixelsFromEdge) + scaledCenter[0];
    var y = Math.cos((angle + 90) * Math.PI / 180) * (scaledRadius[1] + pixelsFromEdge) + scaledCenter[1];
    return x + "," + y;
  };

  var arrow = graph.raphael.path(" M" + arrowHelper(180, 6) + " L" + arrowHelper(180, 2) + " L" + arrowHelper(183, 10) + " L" + arrowHelper(180, 18) + " L" + arrowHelper(180, 14) + " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,1," + arrowHelper(170, 14) + " L" + arrowHelper(170, 18) + " L" + arrowHelper(167, 10) + " L" + arrowHelper(170, 2) + " L" + arrowHelper(170, 6) + " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,0," + arrowHelper(180, 6) + " Z").attr({
    stroke: null,
    fill: KhanColors$e.INTERACTIVE
  }); // add it to the set so it translates with everything else

  this.set.push(arrow);
  this.centerPoint = graph.addMovablePoint({
    coord: center,
    visible: false
  }); // Use a movablePoint for rotation

  this.rotateHandle = graph.addMovablePoint({
    bounded: false,
    coord: [Math.sin(275 * Math.PI / 180) * r + this.cx, Math.cos(275 * Math.PI / 180) * r + this.cy],
    onMove: function onMove(x, y) {
      var angle = Math.atan2(pro.centerPoint.coord[1] - y, pro.centerPoint.coord[0] - x) * 180 / Math.PI;
      pro.rotate(-angle - 5, true);
    }
  }); // Add a constraint so the point moves in a circle

  this.rotateHandle.constraints.fixedDistance.dist = r;
  this.rotateHandle.constraints.fixedDistance.point = this.centerPoint; // Remove the default dot added by the movablePoint since we have our
  // double-arrow thing

  this.rotateHandle.visibleShape.remove(); // Make the mouse target bigger to encompass the whole area around the
  // double-arrow thing

  this.rotateHandle.mouseTarget.attr({
    scale: 2.0
  });
  var isDragging = false;
  var isHovering = false;

  var isHighlight = function isHighlight() {
    return isHovering || isDragging;
  };

  var self = this;
  var $mouseTarget = $__default["default"](self.rotateHandle.mouseTarget.getMouseTarget());
  $mouseTarget.bind("vmousedown", function (event) {
    isDragging = true;
    $mouseTarget.css("cursor", "-webkit-grabbing");
    $mouseTarget.css("cursor", "grabbing");
    arrow.animate({
      scale: 1.5,
      fill: KhanColors$e.INTERACTING
    }, 50);
    $__default["default"](document).bind("vmouseup.rotateHandle", function (event) {
      isDragging = false;
      $mouseTarget.css("cursor", "-webkit-grab");
      $mouseTarget.css("cursor", "grab");

      if (!isHighlight()) {
        arrow.animate({
          scale: 1.0,
          fill: KhanColors$e.INTERACTIVE
        }, 50);
      }

      $__default["default"](document).unbind("vmouseup.rotateHandle");
    });
  });
  $mouseTarget.bind("vmouseover", function (event) {
    isHovering = true;
    arrow.animate({
      scale: 1.5,
      fill: KhanColors$e.INTERACTING
    }, 50);
  });
  $mouseTarget.bind("vmouseout", function (event) {
    isHovering = false;

    if (!isHighlight()) {
      arrow.animate({
        scale: 1.0,
        fill: KhanColors$e.INTERACTIVE
      }, 50);
    }
  });
  var setNodes = $__default["default"].map(this.set, function (el) {
    return el.node;
  });

  this.makeTranslatable = function makeTranslatable() {
    $__default["default"](setNodes).css("cursor", "move");
    $mouseTarget.css("cursor", "-webkit-grab");
    $mouseTarget.css("cursor", "grab");
    $__default["default"](setNodes).bind("vmousedown", function (event) {
      event.preventDefault();
      var startx = event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left;
      var starty = event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top;
      $__default["default"](document).bind("vmousemove.protractor", function (event) {
        var mouseX = event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left;
        var mouseY = event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top; // can't go beyond 10 pixels from the edge

        mouseX = Math.max(10, Math.min(graph.xpixels - 10, mouseX));
        mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));
        var dx = mouseX - startx;
        var dy = mouseY - starty;
        $__default["default"].each(pro.set.items, function () {
          this.translate(dx, dy);
        });
        pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
        pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
        startx = mouseX;
        starty = mouseY;
      });
      $__default["default"](document).one("vmouseup", function (event) {
        $__default["default"](document).unbind("vmousemove.protractor");
      });
    });
  };

  this.rotation = 0;

  this.rotate = function (offset, absolute) {
    var center = graph.scalePoint(this.centerPoint.coord);

    if (absolute) {
      this.rotation = 0;
    }

    this.set.rotate(this.rotation + offset, center[0], center[1]);
    this.rotation = this.rotation + offset;
    return this;
  };

  this.moveTo = function moveTo(x, y) {
    var start = graph.scalePoint(pro.centerPoint.coord);
    var end = graph.scalePoint([x, y]);
    var time = GraphUtils$7.getDistance(start, end) * 2;
    $__default["default"]({
      x: start[0],
      y: start[1]
    }).animate({
      x: end[0],
      y: end[1]
    }, {
      duration: time,
      step: function step(now, fx) {
        var dx = 0;
        var dy = 0;

        if (fx.prop === "x") {
          dx = now - graph.scalePoint(pro.centerPoint.coord)[0];
        } else if (fx.prop === "y") {
          dy = now - graph.scalePoint(pro.centerPoint.coord)[1];
        }

        $__default["default"].each(pro.set.items, function () {
          this.translate(dx, dy);
        });
        pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
        pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
      }
    });
  };

  this.rotateTo = function rotateTo(angle) {
    if (Math.abs(this.rotation - angle) > 180) {
      this.rotation += 360;
    }

    var time = Math.abs(this.rotation - angle) * 5;
    $__default["default"]({
      0: this.rotation
    }).animate({
      0: angle
    }, {
      duration: time,
      step: function step(now, fx) {
        pro.rotate(now, true);
        pro.rotateHandle.setCoord([Math.sin((now + 275) * Math.PI / 180) * r + pro.centerPoint.coord[0], Math.cos((now + 275) * Math.PI / 180) * r + pro.centerPoint.coord[1]]);
      }
    });
  };

  this.remove = function () {
    this.set.remove();
  };

  this.makeTranslatable();
  return this;
}

function Ruler(graphie, options) {
  _$1w.defaults(options, {
    center: [0, 0],
    pixelsPerUnit: 40,
    ticksPerUnit: 10,
    // 10 or power of 2
    units: 10,
    // the length the ruler can measure
    label: "",
    // e.g "cm" (the shorter, the better)
    style: {
      fill: null,
      stroke: KhanColors$e.GRAY
    }
  });

  var light = _$1w.extend({}, options.style, {
    strokeWidth: 1
  });

  var bold = _$1w.extend({}, options.style, {
    strokeWidth: 2
  });

  var width = options.units * options.pixelsPerUnit;
  var height = 50;
  var leftBottom = graphie.unscalePoint(kvector$9.subtract(graphie.scalePoint(options.center), kvector$9.scale([width, -height], 0.5)));
  var graphieUnitsPerUnit = options.pixelsPerUnit / graphie.scale[0];
  var graphieUnitsHeight = height / graphie.scale[0];
  var rightTop = kvector$9.add(leftBottom, [options.units * graphieUnitsPerUnit, graphieUnitsHeight]);
  var tickHeight = 1.0;
  var tickHeightMap;

  if (options.ticksPerUnit === 10) {
    // decimal, as on a centimeter ruler
    tickHeightMap = {
      10: tickHeight,
      5: tickHeight * 0.55,
      1: tickHeight * 0.35
    };
  } else {
    var sizes = [1, 0.6, 0.45, 0.3];
    tickHeightMap = {};

    for (var i = options.ticksPerUnit; i >= 1; i /= 2) {
      tickHeightMap[i] = tickHeight * (sizes.shift() || 0.2);
    }
  }

  var tickFrequencies = _$1w.keys(tickHeightMap).sort(function (a, b) {
    return b - a;
  });

  function getTickHeight(i) {
    for (var k = 0; k < tickFrequencies.length; k++) {
      var key = tickFrequencies[k];

      if (i % key === 0) {
        return tickHeightMap[key];
      }
    }
  }

  var left = leftBottom[0];
  var bottom = leftBottom[1];
  var right = rightTop[0];
  var top = rightTop[1];
  var numTicks = options.units * options.ticksPerUnit + 1;
  var set = graphie.raphael.set();
  var px = 1 / graphie.scale[0];
  set.push(graphie.line([left - px, bottom], [right + px, bottom], bold));
  set.push(graphie.line([left - px, top], [right + px, top], bold));

  _$1w.times(numTicks, function (i) {
    var n = i / options.ticksPerUnit;
    var x = left + n * graphieUnitsPerUnit;
    var height = getTickHeight(i) * graphieUnitsHeight;
    var style = i === 0 || i === numTicks - 1 ? bold : light;
    set.push(graphie.line([x, bottom], [x, bottom + height], style));

    if (n % 1 === 0) {
      var coord = graphie.scalePoint([x, top]);
      var text;
      var offset;

      if (n === 0) {
        // Unit label
        text = options.label;
        offset = {
          mm: 13,
          cm: 11,
          m: 8,
          km: 11,
          in: 8,
          ft: 8,
          yd: 10,
          mi: 10
        }[text] || 3 * text.toString().length;
      } else {
        // Tick label
        text = n;
        offset = -3 * (n.toString().length + 1);
      }

      var label = graphie.raphael.text(coord[0] + offset, coord[1] + 10, text);
      label.attr({
        "font-family": "KaTeX_Main",
        "font-size": "12px",
        color: "#444"
      });
      set.push(label);
    }
  });

  var mouseTarget = graphie.mouselayer.path(GraphUtils$7.svgPath([leftBottom, [left, top], rightTop, [right, bottom],
  /* closed */
  true]));
  mouseTarget.attr({
    fill: "#000",
    opacity: 0,
    stroke: "#000",
    "stroke-width": 2
  });
  set.push(mouseTarget); // Prevent the page from scrolling when we grab and drag the ruler on a
  // mobile device.

  mouseTarget.node.addEventListener("touchstart", function (event) {
    event.preventDefault();
  }, {
    passive: false
  });
  var setNodes = $__default["default"].map(set, function (el) {
    return el.node;
  });
  $__default["default"](setNodes).css("cursor", "move");
  $__default["default"](setNodes).bind("vmousedown", function (event) {
    event.preventDefault();
    var startx = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
    var starty = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top;
    $__default["default"](document).bind("vmousemove.ruler", function (event) {
      var mouseX = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
      var mouseY = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top; // can't go beyond 10 pixels from the edge

      mouseX = Math.max(10, Math.min(graphie.xpixels - 10, mouseX));
      mouseY = Math.max(10, Math.min(graphie.ypixels - 10, mouseY));
      var dx = mouseX - startx;
      var dy = mouseY - starty;
      set.translate(dx, dy);
      leftBottomHandle.setCoord([leftBottomHandle.coord[0] + dx / graphie.scale[0], leftBottomHandle.coord[1] - dy / graphie.scale[1]]);
      rightBottomHandle.setCoord([rightBottomHandle.coord[0] + dx / graphie.scale[0], rightBottomHandle.coord[1] - dy / graphie.scale[1]]);
      startx = mouseX;
      starty = mouseY;
    });
    $__default["default"](document).one("vmouseup", function (event) {
      $__default["default"](document).unbind("vmousemove.ruler");
    });
  });
  var leftBottomHandle = graphie.addMovablePoint({
    coord: leftBottom,
    normalStyle: {
      fill: KhanColors$e.INTERACTIVE,
      "fill-opacity": 0,
      stroke: KhanColors$e.INTERACTIVE
    },
    highlightStyle: {
      fill: KhanColors$e.INTERACTING,
      "fill-opacity": 0.1,
      stroke: KhanColors$e.INTERACTING
    },
    pointSize: 6,
    // or 8 maybe?
    onMove: function onMove(x, y) {
      var dy = rightBottomHandle.coord[1] - y;
      var dx = rightBottomHandle.coord[0] - x;
      var angle = Math.atan2(dy, dx) * 180 / Math.PI;
      var center = kvector$9.scale(kvector$9.add([x, y], rightBottomHandle.coord), 0.5);
      var scaledCenter = graphie.scalePoint(center);
      var oldCenter = kvector$9.scale(kvector$9.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
      var scaledOldCenter = graphie.scalePoint(oldCenter);
      var diff = kvector$9.subtract(scaledCenter, scaledOldCenter);
      set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
      set.translate(diff[0], diff[1]);
    }
  });
  var rightBottomHandle = graphie.addMovablePoint({
    coord: [right, bottom],
    normalStyle: {
      fill: KhanColors$e.INTERACTIVE,
      "fill-opacity": 0,
      stroke: KhanColors$e.INTERACTIVE
    },
    highlightStyle: {
      fill: KhanColors$e.INTERACTING,
      "fill-opacity": 0.1,
      stroke: KhanColors$e.INTERACTING
    },
    pointSize: 6,
    // or 8 maybe?
    onMove: function onMove(x, y) {
      var dy = y - leftBottomHandle.coord[1];
      var dx = x - leftBottomHandle.coord[0];
      var angle = Math.atan2(dy, dx) * 180 / Math.PI;
      var center = kvector$9.scale(kvector$9.add([x, y], leftBottomHandle.coord), 0.5);
      var scaledCenter = graphie.scalePoint(center);
      var oldCenter = kvector$9.scale(kvector$9.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
      var scaledOldCenter = graphie.scalePoint(oldCenter);
      var diff = kvector$9.subtract(scaledCenter, scaledOldCenter);
      set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
      set.translate(diff[0], diff[1]);
    }
  }); // Make each handle rotate the ruler about the other one

  leftBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
  leftBottomHandle.constraints.fixedDistance.point = rightBottomHandle;
  rightBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
  rightBottomHandle.constraints.fixedDistance.point = leftBottomHandle;

  this.remove = function () {
    set.remove();
    leftBottomHandle.remove();
    rightBottomHandle.remove();
  };

  return this;
}

function MovableAngle(graphie, options) {
  this.graphie = graphie; // TODO(alex): Move standard colors from math.js to somewhere else
  // so that they are available when this file is first parsed

  _$1w.extend(this, options);

  _$1w.defaults(this, {
    normalStyle: {
      stroke: KhanColors$e.INTERACTIVE,
      "stroke-width": 2,
      fill: KhanColors$e.INTERACTIVE
    },
    highlightStyle: {
      stroke: KhanColors$e.INTERACTING,
      "stroke-width": 2,
      fill: KhanColors$e.INTERACTING
    },
    labelStyle: {
      stroke: KhanColors$e.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors$e.DYNAMIC
    },
    angleStyle: {
      stroke: KhanColors$e.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors$e.DYNAMIC
    },
    allowReflex: true // not on MovableAngle.prototype so that
    // it is not overridden by undefined

  });

  if (!this.points || this.points.length !== 3) {
    throw new Error("MovableAngle requires 3 points");
  } // Handle coordinates that are not MovablePoints (i.e. [2, 4])


  this.points = _$1w.map(options.points, function (point) {
    if (_$1w.isArray(point)) {
      return graphie.addMovablePoint({
        coord: point,
        visible: false,
        constraints: {
          fixed: true
        },
        normalStyle: this.normalStyle
      });
    } else {
      return point;
    }
  }, this);
  this.coords = _$1w.pluck(this.points, "coord");

  if (this.reflex == null) {
    if (this.allowReflex) {
      this.reflex = this._getClockwiseAngle(this.coords) > 180;
    } else {
      this.reflex = false;
    }
  }

  this.rays = _$1w.map([0, 2], function (i) {
    return graphie.addMovableLineSegment({
      pointA: this.points[1],
      pointZ: this.points[i],
      fixed: true,
      extendRay: true
    });
  }, this);
  this.temp = [];
  this.labeledAngle = graphie.label([0, 0], "", "center", this.labelStyle);

  if (!this.fixed) {
    this.addMoveHandlers();
    this.addHighlightHandlers();
  }

  this.update();
}

_$1w.extend(MovableAngle.prototype, {
  points: [],
  snapDegrees: 0,
  snapOffsetDeg: 0,
  angleLabel: "",
  numArcs: 1,
  pushOut: 0,
  fixed: false,
  addMoveHandlers: function addMoveHandlers() {
    var graphie = this.graphie;

    function tooClose(point1, point2) {
      var safeDistance = 30;
      var distance = GraphUtils$7.getDistance(graphie.scalePoint(point1), graphie.scalePoint(point2));
      return distance < safeDistance;
    }

    var points = this.points; // Drag the vertex to move the entire angle

    points[1].onMove = function (x, y) {
      var oldVertex = points[1].coord;
      var newVertex = [x, y];
      var delta = addPoints(newVertex, reverseVector(oldVertex));
      var valid = true;
      var newPoints = {};

      _$1w.each([0, 2], function (i) {
        var oldPoint = points[i].coord;
        var newPoint = addPoints(oldPoint, delta);
        var angle = GraphUtils$7.findAngle(newVertex, newPoint);
        angle *= Math.PI / 180;
        newPoint = graphie.constrainToBoundsOnAngle(newPoint, 10, angle);
        newPoints[i] = newPoint;

        if (tooClose(newVertex, newPoint)) {
          valid = false;
        }
      }); // Only move points if all new positions are valid


      if (valid) {
        _$1w.each(newPoints, function (newPoint, i) {
          points[i].setCoord(newPoint);
        });
      }

      return valid;
    };

    var snap = this.snapDegrees;
    var snapOffset = this.snapOffsetDeg; // Drag ray control points to move each ray individually

    _$1w.each([0, 2], function (i) {
      points[i].onMove = function (x, y) {
        var newPoint = [x, y];
        var vertex = points[1].coord;

        if (tooClose(vertex, newPoint)) {
          return false;
        } else if (snap) {
          var angle = GraphUtils$7.findAngle(newPoint, vertex);
          angle = Math.round((angle - snapOffset) / snap) * snap + snapOffset;
          var distance = GraphUtils$7.getDistance(newPoint, vertex);
          return addPoints(vertex, graphie.polar(distance, angle));
        } else {
          return true;
        }
      };
    }); // Expose only a single move event


    $__default["default"](points).on("move", function () {
      this.update();
      $__default["default"](this).trigger("move");
    }.bind(this));
  },
  addHighlightHandlers: function addHighlightHandlers() {
    var vertex = this.points[1];

    vertex.onHighlight = function () {
      _$1w.each(this.points, function (point) {
        point.visibleShape.animate(this.highlightStyle, 50);
      }, this);

      _$1w.each(this.rays, function (ray) {
        ray.visibleLine.animate(this.highlightStyle, 50);
        ray.arrowStyle = _$1w.extend({}, ray.arrowStyle, {
          color: this.highlightStyle.stroke,
          stroke: this.highlightStyle.stroke
        });
      }, this);

      this.angleStyle = _$1w.extend({}, this.angleStyle, {
        color: this.highlightStyle.stroke,
        stroke: this.highlightStyle.stroke
      });
      this.update();
    }.bind(this);

    vertex.onUnhighlight = function () {
      _$1w.each(this.points, function (point) {
        point.visibleShape.animate(this.normalStyle, 50);
      }, this);

      _$1w.each(this.rays, function (ray) {
        ray.visibleLine.animate(ray.normalStyle, 50);
        ray.arrowStyle = _$1w.extend({}, ray.arrowStyle, {
          color: ray.normalStyle.stroke,
          stroke: ray.normalStyle.stroke
        });
      }, this);

      this.angleStyle = _$1w.extend({}, this.angleStyle, {
        color: KhanColors$e.DYNAMIC,
        stroke: KhanColors$e.DYNAMIC
      });
      this.update();
    }.bind(this);
  },

  /**
   * Returns the angle in [0, 360) degrees created by the
   * coords when interpreted in a clockwise direction.
   */
  _getClockwiseAngle: function _getClockwiseAngle(coords) {
    var rawAngle = GraphUtils$7.findAngle( // The order of these is "weird" to match what a clockwise
    // order is in graphie.labelAngle
    coords[2], // from the second point
    coords[0], // clockwise to the first point
    coords[1] // the vertex parameter is last
    );
    var clockwiseAngle = rawAngle + 360 % 360;
    return clockwiseAngle;
  },
  isReflex: function isReflex() {
    return this.reflex;
  },
  isClockwise: function isClockwise() {
    var clockwiseReflexive = this._getClockwiseAngle(this.coords) > 180;
    return clockwiseReflexive === this.reflex;
  },
  getClockwiseCoords: function getClockwiseCoords() {
    if (this.isClockwise()) {
      return _$1w.clone(this.coords);
    } else {
      return _$1w.clone(this.coords).reverse();
    }
  },
  update: function update(shouldChangeReflexivity) {
    var prevCoords = this.coords;
    this.coords = _$1w.pluck(this.points, "coord"); // Update lines

    _$1w.invoke(this.points, "updateLineEnds");

    var prevAngle = this._getClockwiseAngle(prevCoords);

    var angle = this._getClockwiseAngle(this.coords);

    var prevClockwiseReflexive = prevAngle > 180;
    var clockwiseReflexive = angle > 180;

    if (this.allowReflex) {
      if (shouldChangeReflexivity == null) {
        shouldChangeReflexivity = prevClockwiseReflexive !== clockwiseReflexive && Math.abs(angle - prevAngle) < 180;
      }

      if (shouldChangeReflexivity) {
        this.reflex = !this.reflex;
      }
    }

    _$1w.invoke(this.temp, "remove");

    this.temp = this.graphie.labelAngle({
      point1: this.coords[0],
      vertex: this.coords[1],
      point3: this.coords[2],
      label: this.labeledAngle,
      text: this.angleLabel,
      numArcs: this.numArcs,
      pushOut: this.pushOut,
      clockwise: this.reflex === clockwiseReflexive,
      style: this.angleStyle
    });
  },
  remove: function remove() {
    _$1w.invoke(this.rays, "remove");

    _$1w.invoke(this.temp, "remove");

    this.labeledAngle.remove();
  }
});

var _module_$2i = {
  exports: {}
};
/**
 * A wrapper around graphie.js and interactive.js to make sure interactive.js
 * is always required at the same time as graphie.js. This is because
 * interactive.js has side effects that are hard to see (it adds things to
 * `Graphie.prototype`), so someone might forget to require interactive.js.
 *
 * To use the utilities exported from interactive.js, require that file
 * itself.
 */

var GraphUtils$6 = _graphieJs;
_module_$2i.exports = GraphUtils$6;
var _utilGraphUtilsJs = _module_$2i.exports;

var _module_$2h = {
  exports: {}
};
/**
 * A library of options to pass to add/draw/remove/constraints
 */

var _$1v = _underscore__default["default"];
var kpoint$a = _kmath3.point;
var kvector$8 = _kmath3.vector;

function sum(array) {
  return _$1v.reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}

function clockwise(points) {
  var segments = _$1v.zip(points, points.slice(1).concat(points.slice(0, 1)));

  var areas = _$1v.map(segments, function (segment) {
    var p1 = segment[0];
    var p2 = segment[1];
    return (p2[0] - p1[0]) * (p2[1] + p1[1]);
  });

  return sum(areas) > 0;
}

var add$2 = {
  constrain: function constrain() {
    this.constrain();
  },
  pointsToFront: function pointsToFront(state) {
    _$1v.invoke(state.points, "toFront");
  }
};
add$2.standard = [add$2.constrain, add$2.pointsToFront];
var modify$2 = {
  draw: function draw() {
    this.draw();
  }
};
modify$2.standard = [modify$2.draw];
var draw$4 = {
  basic: function basic(state, prevState) {
    var graphie = this.graphie;
    var path = this.path(state);

    if (!this.state.visibleShape) {
      this.state.visibleShape = graphie.raphael.path(path);
      this.state.visibleShape.attr(this.normalStyle());
    }

    if (state.normalStyle !== prevState.normalStyle && !_$1v.isEqual(state.normalStyle, prevState.normalStyle)) {
      this.state.visibleShape.attr(this.normalStyle());
    }

    this.state.visibleShape.attr({
      path: path
    });

    if (this.mouseTarget()) {
      this.mouseTarget().attr({
        path: path
      });
    }
  },

  /* Labels are handled primarily by label objects, but sometimes require
   * extra movables, e.g., for the arcs drawn at labeled angles. These extra
   * movables are stored in the label cache. */
  labels: function labels(state, prevState) {
    var graphie = this.graphie;
    var self = this;

    var coords = _$1v.invoke(state.points, "coord");

    var isClockwise = clockwise(coords);
    var n = coords.length; // graphie.labelAngle and similar methods attempt to re-use the label
    // provided, which will have been stored on state._labeledAngles.
    // If they cannot re-use the label, they make a new one, which will
    // get stored on state._labelCache. These will all be cleared out when
    // we remove the polygon.
    // (This logic is borrowed from graphie:addMovablePolygon.)

    if (self.state._labelCache != null) {
      _$1v.invoke(self.state._labelCache, "remove");
    }

    self.state._labelCache = []; // Update angle labels

    if (state.angleLabels.length || state.showRightAngleMarkers.length) {
      // Generate labels
      if (self.state._labeledAngles == null) {
        self.state._labeledAngles = _$1v.times(Math.max(state.angleLabels.length, state.showRightAngleMarkers.length), function () {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      _$1v.each(self.state._labeledAngles, function (label, i) {
        self.state._labelCache.push(graphie.labelAngle({
          point1: coords[(i - 1 + n) % n],
          vertex: coords[i],
          point3: coords[(i + 1) % n],
          label: label,
          text: state.angleLabels[i],
          showRightAngleMarker: state.showRightAngleMarkers[i],
          numArcs: state.numArcs[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    } // Update side labels


    if (state.sideLabels.length) {
      // Generate labels
      if (self.state._labeledSides == null) {
        self.state._labeledSides = _$1v.map(state.sideLabels, function (label) {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      _$1v.each(self.state._labeledSides, function (label, i) {
        self.state._labelCache.push(graphie.labelSide({
          point1: coords[i],
          point2: coords[(i + 1) % n],
          label: label,
          text: state.sideLabels[i],
          numArrows: state.numArrows[i],
          numTicks: state.numTicks[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    } // Update vertex labels


    if (state.vertexLabels.length) {
      // Generate labels
      if (self.state._labeledVertices == null) {
        self.state._labeledVertices = _$1v.map(state.vertexLabels, function (label) {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      _$1v.each(self.state._labeledVertices, function (label, i) {
        self.state._labelCache.push(graphie.labelVertex({
          point1: coords[(i - 1 + n) % n],
          vertex: coords[i],
          point3: coords[(i + 1) % n],
          label: label,
          text: state.vertexLabels[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    } // graphie.labelVertex and its peer methods return an array of movables


    self.state._labelCache = _$1v.flatten(self.state._labelCache);
  },
  highlight: function highlight(state, prevState) {
    if (state.isHovering && !prevState.isHovering) {
      state.visibleShape.animate(this.highlightStyle(), 50);
    } else if (!state.isHovering && prevState.isHovering) {
      state.visibleShape.animate(this.normalStyle(), 50);
    }
  }
};
draw$4.standard = [draw$4.basic, draw$4.labels, draw$4.highlight];
var remove$2 = {
  basic: function basic() {
    if (this.state.visibleShape) {
      this.state.visibleShape.remove();
    }
  },
  labels: function labels() {
    var labels = [this.state._labeledSides, this.state._labeledVertices, this.state._labeledAngles, this.state._labelCache];

    _$1v.each(labels, function (labelType) {
      if (labelType != null && labelType.length) {
        _$1v.invoke(labelType, "remove");
      }
    });
  }
};
remove$2.standard = [remove$2.basic, remove$2.labels];
var constraints$2 = {
  fixed: function fixed() {
    return function () {
      return false;
    };
  },
  snap: function snap(_snap) {
    return function (coord) {
      if (_snap === null) {
        return true;
      }

      _snap = _snap || this.graphie.snap;
      return kpoint$a.roundTo(coord, _snap);
    };
  },
  bound: function bound(range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }

    return function (coord, prevCoord) {
      var graphie = this.graphie;
      var delta = kvector$8.subtract(coord, prevCoord);
      var range = range || graphie.range; // A null snap means no snap; an undefined snap means
      // default to graphie's

      if (snap === undefined) {
        snap = graphie.snap;
      } // Calculate the bounds for both points


      var absoluteLower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      var absoluteUpper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);

      if (snap) {
        absoluteLower = kpoint$a.ceilTo(absoluteLower, snap);
        absoluteUpper = kpoint$a.floorTo(absoluteUpper, snap);
      } // Calculate the bounds for the delta.


      var deltaBounds = _$1v.map(this.coords(), function (coord, i) {
        var max = kvector$8.subtract(absoluteUpper, coord);
        var min = kvector$8.subtract(absoluteLower, coord);
        return [min, max];
      }); // bound the delta by the calculated bounds


      var boundedDelta = _$1v.reduce(deltaBounds, function (delta, bound) {
        var lower = bound[0];
        var upper = bound[1];
        var deltaX = Math.max(lower[0], Math.min(upper[0], delta[0]));
        var deltaY = Math.max(lower[1], Math.min(upper[1], delta[1]));
        return [deltaX, deltaY];
      }, delta);

      return kvector$8.add(prevCoord, boundedDelta);
    };
  }
};
constraints$2.standard = null;
var onMove$1 = {
  updatePoints: function updatePoints(coord, prevCoord) {
    var actualDelta = kvector$8.subtract(coord, prevCoord);

    _$1v.each(this.state.points, function (point) {
      point.setCoord(kvector$8.add(point.coord(), actualDelta));
    });
  }
};
onMove$1.standard = null;
_module_$2h.exports = {
  add: add$2,
  modify: modify$2,
  draw: draw$4,
  remove: remove$2,
  onMoveStart: {
    standard: null
  },
  constraints: constraints$2,
  onMove: onMove$1,
  onMoveEnd: {
    standard: null
  },
  onClick: {
    standard: null
  }
};
var _movablePolygonOptionsJs = _module_$2h.exports;

var _module_$2g = {
  exports: {}
};
/**
 * Creates and adds a polygon to the graph that can be dragged around.
 * It allows constraints on its movement and draws when moves happen.
 */

var kvector$7 = _kmath3.vector;
var _$1u = _underscore__default["default"];
var MovablePolygonOptions = _movablePolygonOptionsJs;
var InteractiveUtil$3 = InteractiveUtil$7;
var objective_$2 = _objective_Js;
var assert$9 = InteractiveUtil$3.assert;
var normalizeOptions$3 = InteractiveUtil$3.normalizeOptions;
var KhanColors$d = _utilColorsJs;
var GraphUtils$5 = _utilGraphUtilsJs; // State parameters that should be converted into an array of
// functions

var FUNCTION_ARRAY_OPTIONS$3 = _$1u.keys(MovablePolygonOptions); // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.points() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".


var DEFAULT_PROPS$3 = {
  points: null,
  angleLabels: [],
  showRightAngleMarkers: [],
  sideLabels: [],
  vertexLabels: [],
  numArcs: [],
  numArrows: [],
  numTicks: [],
  closed: true,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  labelStyle: null // likewise

};
var DEFAULT_STATE$3 = {
  added: false,
  hasMoved: false,
  visibleShape: null,
  mouseTarget: null
};

var MovablePolygon$1 = function MovablePolygon(graphie, movable, options) {
  assert$9(graphie != null);
  assert$9(options != null);

  _$1u.extend(this, {
    graphie: graphie,
    movable: movable,
    state: {
      // Set here because this must be unique for each instance
      id: _$1u.uniqueId("movablePolygon")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(_$1u.extend({}, DEFAULT_STATE$3, options));
};

_$1u.extend(MovablePolygon$1, MovablePolygonOptions);

InteractiveUtil$3.createGettersFor(MovablePolygon$1, _$1u.extend({}, DEFAULT_PROPS$3, DEFAULT_STATE$3));
InteractiveUtil$3.addMovableHelperMethodsTo(MovablePolygon$1);

_$1u.extend(MovablePolygon$1.prototype, {
  cloneState: function cloneState() {
    return _$1u.extend(this.movable.cloneState(), this.state);
  },
  _createDefaultState: function _createDefaultState() {
    return _$1u.extend({
      id: this.state.id
    }, normalizeOptions$3(FUNCTION_ARRAY_OPTIONS$3, // Defaults are copied from MovablePolygonOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_$2.pluck(MovablePolygonOptions, "standard") // We only update props here, because we want things on state to
    // be persistent, and updated appropriately in modify()
    ), DEFAULT_PROPS$3);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function modify(options) {
    this.update(_$1u.extend(this._createDefaultState(), options));
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function update(options) {
    var self = this;
    var graphie = self.graphie;

    var state = _$1u.extend(self.state, normalizeOptions$3(FUNCTION_ARRAY_OPTIONS$3, options)); // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPS/STATE!)


    var normalColor = state.static ? KhanColors$d.DYNAMIC : KhanColors$d.INTERACTIVE;
    state.normalStyle = _$1u.extend({}, state.normalStyle, {
      "stroke-width": 2,
      "fill-opacity": 0,
      "fill": normalColor,
      "stroke": normalColor
    }, options.normalStyle);
    state.highlightStyle = _$1u.extend({}, {
      "stroke": KhanColors$d.INTERACTING,
      "stroke-width": 2,
      "fill": KhanColors$d.INTERACTING,
      "fill-opacity": 0.05
    }, state.highlightStyle);
    state.labelStyle = _$1u.extend({}, {
      "stroke": KhanColors$d.DYNAMIC,
      "stroke-width": 1,
      "color": KhanColors$d.DYNAMIC
    }, state.labelStyle);

    if (!state.static) {
      // the invisible shape in front of the point that gets mouse events
      if (!state.mouseTarget) {
        state.mouseTarget = graphie.mouselayer.path(this.path());
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0,
          cursor: "move"
        });
      }
    } // The Movable representing this MovablePolygon's representation
    // This handles mouse events for us, which we propagate in
    // onMove. The onMoveStart-onMove-onMoveEnd logic is borrowed from
    // movable-line.js.


    self.movable.modify(_$1u.extend({}, state, {
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: function onMoveStart() {
        self._initialRefCoord = self.coord(0);
        self._prevRefCoord = self._initialRefCoord;
        self._totalDelta = [0, 0];

        self._fireEvent(self.state.onMoveStart, self.coord(0), self.coord(0));
      },
      onMove: function onMove(mouseCoord, prevMouseCoord) {
        var delta = kvector$7.subtract(mouseCoord, prevMouseCoord);
        self._totalDelta = kvector$7.add(self._totalDelta, delta);
        var refCoord = kvector$7.add(self._initialRefCoord, self._totalDelta);
        refCoord = self._applyConstraints(refCoord, self._prevRefCoord);

        if (refCoord === false) {
          return;
        }

        self._fireEvent(self.state.onMove, refCoord, self._prevRefCoord);

        self._prevRefCoord = refCoord;
      },
      onMoveEnd: function onMoveEnd() {
        self._fireEvent(self.state.onMoveEnd, self._prevRefCoord, self._initialRefCoord);
      }
    })); // Update the polygon with the points' movement

    _$1u.invoke(state.points, "listen", "onMove", state.id, self.draw.bind(self)); // Trigger an add event if this hasn't been added before


    if (!state.added) {
      self.prevState = {};

      self._fireEvent(state.add, self.cloneState(), self.prevState);

      state.added = true; // Update the state for `added` and in case the add event
      // changed it

      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  path: function path(state) {
    var graphie = this.graphie;
    state = state || this.state;

    var coords = _$1u.map(state.points, function (point) {
      return graphie.scalePoint(point.coord());
    }); // Create path


    if (state.closed) {
      coords.push(true);
    } else {
      // For open polygons, concatenate a reverse of the path,
      // to remove the inside area of the path, which would
      // otherwise be clickable (even if the closing line segment
      // wasn't drawn
      coords = coords.concat(_$1u.clone(coords).reverse());
    }

    return GraphUtils$5.unscaledSvgPath(coords);
  },
  coords: function coords() {
    return _$1u.invoke(this.state.points, "coord");
  },
  point: function point(index) {
    return this.state.points[index];
  },
  coord: function coord(index) {
    return this.point(index).coord();
  },
  remove: function remove() {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.state.points) {
      _$1u.invoke(this.state.points, "unlisten", "onMove", this.state.id);
    }

    if (this.movable) {
      // We need this to be guarded because it is called on the initial
      // constructor/modify call, before this.movable is created
      this.movable.remove();
    } // TODO(jack): This should really be moved off of
    // movablePolygon.state and only kept on movable.state


    this.state.mouseTarget = null;
  },
  constrain: function constrain() {
    if (this.points == null || this.points.length === 0) {
      return;
    }

    var prevRefCoord = this.coord(0);

    var refCoord = this._applyConstraints(prevRefCoord, prevRefCoord);

    if (refCoord !== false) {
      this._fireEvent(this.state.onMove, refCoord, prevRefCoord);
    }
  },
  // Clone these for use with raphael, which modifies the input
  // style parameters
  normalStyle: function normalStyle() {
    return _$1u.clone(this.state.normalStyle);
  },
  highlightStyle: function highlightStyle() {
    return _$1u.clone(this.state.highlightStyle);
  },
  // Change z-order to back
  toBack: function toBack() {
    this.movable.toBack();

    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function toFront() {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }

    this.movable.toFront();
  },

  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function isHovering() {
    return this.movable.isHovering();
  },
  isDragging: function isDragging() {
    return this.movable.isDragging();
  },
  mouseTarget: function mouseTarget() {
    return this.movable.mouseTarget();
  }
});

_module_$2g.exports = MovablePolygon$1;
var _interactive2MovablePolygonJs = _module_$2g.exports;

var _module_$2f = {
  exports: {}
};
/**
 * A library of options to pass to add/draw/remove/constraints
 */

var _$1t = _underscore__default["default"];
var WrappedLine$4 = _interactive2WrappedLineJs;
var WrappedPath = _wrappedPathJs;
var kvector$6 = _kmath3.vector;
var kpoint$9 = _kmath3.point;
var KhanMath$7 = _utilMathJs;
/**
 * Helper functions
 */

var getScaledAngle = function getScaledAngle(line) {
  var scaledA = line.graphie.scalePoint(line.coord(0));
  var scaledZ = line.graphie.scalePoint(line.coord(1));
  return kvector$6.polarDegFromCart(kvector$6.subtract(scaledZ, scaledA))[1];
}; // Given `coord` and `angle`, find the point where a line extended
// from `coord` in the direction of `angle` would be clipped by the
// edge of the graphie canvas. Then draw an arrowhead at that point
// pointing in the direction of `angle`.


var getClipPoint = function getClipPoint(graph, coord, angle) {
  // Actually put the arrowheads 4px from the edge so they have
  // a bit of room
  var xExtent = graph.range[0][1] - graph.range[0][0];
  var yExtent = graph.range[1][1] - graph.range[1][0]; // shoot a point off into the distance ...

  var distance = xExtent + yExtent; // we need to scale the point according to the scale of the axes

  var angleVec = graph.unscaleVector(kvector$6.cartFromPolarDeg([1, angle]));
  var distVec = kvector$6.scale(kvector$6.normalize(angleVec), distance);
  var farCoord = kvector$6.add(coord, distVec);
  var scaledAngle = kvector$6.polarDegFromCart(angleVec)[1]; // ... and then bring it back

  var clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4, scaledAngle * Math.PI / 180);
  return clipPoint;
}; // Given `coord` and `angle`, find the point where a line extended
// from `coord` in the direction of `angle` would be clipped by the
// edge of the graphie canvas. Then draw an arrowhead at that point
// pointing in the direction of `angle`.


var createArrow = function createArrow(graph, style) {
  // Points that define the arrowhead
  var center = [0.75, 0];
  var points = [[-3, 4], [-2.75, 2.5], [0, 0.25], center, [0, -0.25], [-2.75, -2.5], [-3, -4]]; // Scale points by 1.4 around (0.75, 0)

  var scale = 1.4;
  points = _$1t.map(points, function (point) {
    var pv = kvector$6.subtract(point, center);
    var pvScaled = kvector$6.scale(pv, scale);
    return kvector$6.add(center, pvScaled);
  }); // We can't just pass in a path to `graph.fixedPath` as we need to modify
  // the points in some way, so instead we provide a function for creating
  // the path once the points have been transformed

  var createCubicPath = function createCubicPath(points) {
    var path = "M" + points[0][0] + " " + points[0][1];

    for (var i = 1; i < points.length; i += 3) {
      path += "C" + points[i][0] + " " + points[i][1] + " " + points[i + 1][0] + " " + points[i + 1][1] + " " + points[i + 2][0] + " " + points[i + 2][1];
    }

    return path;
  }; // Create arrowhead


  var unscaledPoints = _$1t.map(points, graph.unscalePoint);

  var options = {
    center: graph.unscalePoint(center),
    createPath: createCubicPath
  };
  var arrowHead = new WrappedPath(graph, unscaledPoints, options);
  arrowHead.attr(_$1t.extend({
    "stroke-linejoin": "round",
    "stroke-linecap": "round",
    "stroke-dasharray": ""
  }, style)); // Add custom function for transforming arrowheads that accounts for
  // center, scaling, etc.

  arrowHead.toCoordAtAngle = function (coord, angle) {
    var clipPoint = graph.scalePoint(getClipPoint(graph, coord, angle));
    arrowHead.transform("translateX(" + (clipPoint[0] + scale * center[0]) + "px) " + "translateY(" + (clipPoint[1] + scale * center[1]) + "px) " + "translateZ(0) " + "rotate(" + (360 - KhanMath$7.bound(angle)) + "deg)");
  };

  return arrowHead;
};
/**
 * MovableLine option functions
 */


var add$1 = {
  // We do this in add as well as in standard so that we can call
  // pointsToFront after the first draw (which adds `this.visibleShape`)
  draw: function draw() {
    this.draw();
  },
  pointsToFront: function pointsToFront(state) {
    _$1t.invoke(state.points, "toFront");
  }
};
add$1.standard = [add$1.draw, add$1.pointsToFront];
var modify$1 = {
  draw: function draw() {
    this.draw();
  }
};
modify$1.standard = [modify$1.draw];
var draw$3 = {
  basic: function basic(state) {
    var graphie = this.graphie;
    var start = this.coord(0);
    var end = this.coord(1);

    if (!this.state.visibleShape) {
      var options = {
        thickness: 10
      };
      this.state.visibleShape = new WrappedLine$4(graphie, start, end, options);
      this.state.visibleShape.attr(this.normalStyle());
      this.state.visibleShape.toFront();

      if (this.mouseTarget()) {
        this.mouseTarget().toFront();
      }
    } // Compute angle


    var angle = getScaledAngle(this); // Extend start, end if necessary (i.e., if not a line segment)

    if (state.extendLine) {
      start = getClipPoint(graphie, start, 360 - angle);
      end = getClipPoint(graphie, end, (540 - angle) % 360);
    } else if (state.extendRay) {
      end = getClipPoint(graphie, end, 360 - angle);
    } // Move elements


    var elements = [this.state.visibleShape];

    if (this.mouseTarget()) {
      elements.push(this.mouseTarget());
    }

    _$1t.each(elements, function (element) {
      element.moveTo(start, end);
    });
  },
  arrows: function arrows(state) {
    // Create arrows, if not yet created
    if (this._arrows == null) {
      this._arrows = [];

      if (state.extendLine) {
        this._arrows.push(createArrow(this.graphie, this.normalStyle()));

        this._arrows.push(createArrow(this.graphie, this.normalStyle()));
      } else if (state.extendRay) {
        this._arrows.push(createArrow(this.graphie, this.normalStyle()));
      }
    } // Transform arrows


    var angle = getScaledAngle(this);
    var angleForArrow = [360 - angle, (540 - angle) % 360];

    _$1t.each(this._arrows, function (arrow, i) {
      arrow.toCoordAtAngle(this.coord(i), angleForArrow[i]);
    }, this);
  },
  highlight: function highlight(state, prevState) {
    // TODO(jack): Figure out a way to highlight the points attached to
    // the line. Maybe this means an additional isHovering: []
    // function to state of movable/movablepoint to define [additional?]
    // times it should be highlighted
    if (state.isHovering && !prevState.isHovering) {
      state.visibleShape.animate(state.highlightStyle, 50);
    } else if (!state.isHovering && prevState.isHovering) {
      state.visibleShape.animate(state.normalStyle, 50);
    }
  }
};
draw$3.standard = [draw$3.basic, draw$3.arrows, draw$3.highlight];
var remove$1 = {
  basic: function basic() {
    if (this.state.visibleShape) {
      this.state.visibleShape.remove();
    }
  },
  arrows: function arrows() {
    if (this._arrows != null) {
      _$1t.invoke(this._arrows, "remove");
    }

    this._arrows = null;
  }
};
remove$1.standard = [remove$1.basic, remove$1.arrows];
var constraints$1 = {
  fixed: function fixed() {
    return function () {
      return false;
    };
  },
  snap: function snap(_snap) {
    return function (coord, prevCoord) {
      if (_snap === null) {
        return true;
      }

      var delta = kvector$6.subtract(coord, prevCoord);
      _snap = _snap || this.graphie.snap;
      delta = kpoint$9.roundTo(delta, _snap);
      return kvector$6.add(prevCoord, delta);
    };
  },
  bound: function bound(range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }

    return function (coord, prevCoord) {
      var graphie = this.graphie;
      var delta = kvector$6.subtract(coord, prevCoord);
      var range = range || graphie.range; // A null snap means no snap; an undefined snap means
      // default to graphie's

      if (snap === undefined) {
        snap = graphie.snap;
      } // Calculate the bounds for both points


      var absoluteLower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      var absoluteUpper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);

      if (snap) {
        absoluteLower = kpoint$9.ceilTo(absoluteLower, snap);
        absoluteUpper = kpoint$9.floorTo(absoluteUpper, snap);
      } // Calculate the bounds for the delta.


      var deltaBounds = _$1t.map(this.coords(), function (coord, i) {
        var max = kvector$6.subtract(absoluteUpper, coord);
        var min = kvector$6.subtract(absoluteLower, coord);
        return [min, max];
      }); // bound the delta by the calculated bounds


      var boundedDelta = _$1t.reduce(deltaBounds, function (delta, bound) {
        var lower = bound[0];
        var upper = bound[1];
        var deltaX = Math.max(lower[0], Math.min(upper[0], delta[0]));
        var deltaY = Math.max(lower[1], Math.min(upper[1], delta[1]));
        return [deltaX, deltaY];
      }, delta);

      return kvector$6.add(prevCoord, boundedDelta);
    };
  }
};
constraints$1.standard = null;
var onMove = {
  updatePoints: function updatePoints(coord, prevCoord) {
    var actualDelta = kvector$6.subtract(coord, prevCoord);

    _$1t.each(this.state.points, function (point) {
      point.setCoord(kvector$6.add(point.coord(), actualDelta));
    });
  }
};
onMove.standard = null;
_module_$2f.exports = {
  add: add$1,
  modify: modify$1,
  draw: draw$3,
  remove: remove$1,
  onMoveStart: {
    standard: null
  },
  constraints: constraints$1,
  onMove: onMove,
  onMoveEnd: {
    standard: null
  }
};
var _movableLineOptionsJs = _module_$2f.exports;

var _module_$2e = {
  exports: {}
};
/**
 * MovableLine
 */

var _$1s = _underscore__default["default"];
var MovableLineOptions = _movableLineOptionsJs;
var WrappedLine$3 = _interactive2WrappedLineJs;
var InteractiveUtil$2 = InteractiveUtil$7;
var objective_$1 = _objective_Js;
var assert$8 = InteractiveUtil$2.assert;
var normalizeOptions$2 = InteractiveUtil$2.normalizeOptions;
var kvector$5 = _kmath3.vector;
var KhanColors$c = _utilColorsJs;
var FUNCTION_ARRAY_OPTIONS$2 = ["add", "draw", "remove", "onMoveStart", "constraints", "onMove", "onMoveEnd"]; // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.cursor() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".

var DEFAULT_PROPS$2 = {
  points: null,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  extendLine: false,
  extendRay: false
};
var DEFAULT_STATE$2 = {
  visibleShape: null,
  mouseTarget: null
};

var MovableLine$5 = function MovableLine(graphie, movable, options) {
  assert$8(graphie != null);
  assert$8(options != null);

  _$1s.extend(this, {
    graphie: graphie,
    movable: movable,
    state: {
      // Set here because this must be unique for each instance
      id: _$1s.uniqueId("movableLine")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(_$1s.extend({}, DEFAULT_STATE$2, options));
};

_$1s.extend(MovableLine$5, MovableLineOptions);

InteractiveUtil$2.createGettersFor(MovableLine$5, _$1s.extend({}, DEFAULT_PROPS$2, DEFAULT_STATE$2));
InteractiveUtil$2.addMovableHelperMethodsTo(MovableLine$5);

_$1s.extend(MovableLine$5.prototype, {
  cloneState: function cloneState() {
    return _$1s.extend(this.movable.cloneState(), {
      coords: this.coords()
    }, this.state);
  },
  _createDefaultState: function _createDefaultState() {
    return _$1s.extend({
      id: this.state.id
    }, normalizeOptions$2(FUNCTION_ARRAY_OPTIONS$2, // Defaults are copied from MovableLineOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_$1.pluck(MovableLineOptions, "standard")), DEFAULT_PROPS$2);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function modify(options) {
    this.update(_$1s.extend(this._createDefaultState(), options));
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function update(options) {
    var self = this;
    var graphie = this.graphie;

    var state = self.state = _$1s.extend(self.state, normalizeOptions$2(FUNCTION_ARRAY_OPTIONS$2, options)); // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPERTIES!)


    var normalColor = state.static ? KhanColors$c.DYNAMIC : KhanColors$c.INTERACTIVE;
    state.normalStyle = _$1s.extend({
      stroke: normalColor,
      "stroke-width": 2
    }, state.normalStyle);
    state.highlightStyle = _$1s.extend({
      stroke: KhanColors$c.INTERACTING,
      "stroke-width": 3
    }, state.highlightStyle);

    if (!state.static) {
      // the invisible shape in front of the line that gets mouse events
      if (!state.mouseTarget) {
        var _options = {
          thickness: 30,
          mouselayer: true
        };
        state.mouseTarget = new WrappedLine$3(graphie, this.coord(0), this.coord(1), _options);
        state.mouseTarget.attr({
          fill: "#000",
          "opacity": 0.0
        });
      }
    }

    if (state.static && state.mouseTarget) {
      // state.static was specified, remove any previously
      // existing mousetarget (from a previous modify)
      state.mouseTarget.remove();
      state.mouseTarget = null;
    } // The movable that handles mouse events for us


    self.movable.modify(_$1s.extend({}, state, {
      mouseTarget: state.mouseTarget,
      // We null out the add/modify/remove to avoid propagating our
      // state.add... to the movable, so that we can fire those
      // events ourselves, rather than letting the movable handle
      // them
      add: null,
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: function onMoveStart() {
        self._initialRefCoord = self.coord(0);
        self._prevRefCoord = self._initialRefCoord;
        self._totalDelta = [0, 0];

        self._fireEvent(self.state.onMoveStart, self.coord(0), self.coord(0));
      },
      onMove: function onMove(mouseCoord, prevMouseCoord) {
        var delta = kvector$5.subtract(mouseCoord, prevMouseCoord);
        self._totalDelta = kvector$5.add(self._totalDelta, delta);
        var refCoord = kvector$5.add(self._initialRefCoord, self._totalDelta);
        refCoord = self._applyConstraints(refCoord, self._prevRefCoord);

        if (refCoord === false) {
          return;
        }

        self._fireEvent(self.state.onMove, refCoord, self._prevRefCoord);

        self._prevRefCoord = refCoord;
      },
      onMoveEnd: function onMoveEnd() {
        self._fireEvent(self.state.onMoveEnd, self._prevRefCoord, self._initialRefCoord);
      }
    })); // Trigger an add event if this hasn't been added before

    if (!state.added) {
      self.prevState = {};

      self._fireEvent(state.add, self.cloneState(), self.prevState);

      state.added = true; // Update the line with the points' movement

      _$1s.invoke(state.points, "listen", "onMove", state.id, self.draw.bind(self)); // Update the state for `added` and in case the add event
      // changed it


      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  coords: function coords() {
    return _$1s.invoke(this.state.points, "coord");
  },
  point: function point(index) {
    return this.state.points[index];
  },
  coord: function coord(index) {
    return this.point(index).coord();
  },
  remove: function remove() {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.points) {
      _$1s.invoke(this.points, "unlisten", "onMove", this.state.id);
    }

    if (this.movable) {
      // We need this to be guarded because it is called on the initial
      // constructor/modify call, before this.movable is created
      this.movable.remove();
    }
  },
  // Change z-order to back
  toBack: function toBack() {
    this.movable.toBack();

    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function toFront() {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }

    this.movable.toFront();
  },

  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function isHovering() {
    return this.movable.isHovering();
  },
  isDragging: function isDragging() {
    return this.movable.isDragging();
  },
  mouseTarget: function mouseTarget() {
    return this.movable.mouseTarget();
  }
});

_module_$2e.exports = MovableLine$5;
var _interactive2MovableLineJs = _module_$2e.exports;

/**
 * Icon paths to be used with `inline-icon.jsx`.
 *
 * These paths are taken directly from webapp's `icon-paths.js`. Unlike the
 * webapp equivalent, these can be directly required within Perseus files since
 * this is all bundled together anyway.
 */

/* eslint-disable max-len */
var iconCheck = {
  path: "M8.70710678,12.2928932 C8.31658249,11.9023689 7.68341751,11.9023689 7.29289322,12.2928932 C6.90236893,12.6834175 6.90236893,13.3165825 7.29289322,13.7071068 L9.82842712,16.2426407 C10.2207367,16.6349502 10.8574274,16.6328935 11.2471942,16.2380576 L16.7116603,10.7025237 C17.0996535,10.3094846 17.0955629,9.67633279 16.7025237,9.28833966 C16.3094846,8.90034653 15.6763328,8.90443714 15.2883397,9.29747629 L10.5309507,14.1167372 L8.70710678,12.2928932 Z",
  width: 24,
  height: 24
};
var iconChevronDown = {
  path: "M99.669 13.048q0 3.36-2.352 5.712l-41.664 41.664q-2.408 2.408-5.88 2.408t-5.712-2.408l-41.664-41.664q-2.408-2.24-2.408-5.712t2.408-5.88l4.76-4.816q2.52-2.352 5.88-2.352t5.656 2.352l31.136 31.136 31.08-31.136q2.352-2.352 5.712-2.352t5.88 2.352l4.816 4.816q2.352 2.52 2.352 5.88z",
  width: 100,
  height: 63.034
};
var iconChevronRight = {
  path: "M62.808 49.728q0 3.36-2.352 5.88l-41.72 41.664q-2.352 2.408-5.768 2.408t-5.768-2.408l-4.872-4.76q-2.352-2.52-2.352-5.88t2.352-5.712l31.08-31.136-31.08-31.024q-2.352-2.52-2.352-5.88t2.352-5.712l4.872-4.76q2.296-2.408 5.768-2.408t5.768 2.408l41.72 41.664q2.352 2.296 2.352 5.656z",
  width: 63.034,
  height: 100
};
var iconCircle = {
  path: "M100.035 50.046q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
var iconCircleArrowDown = {
  path: "M50.046 83.676q1.767 0 2.907-1.14l29.526-29.526q1.197-1.197 1.197-2.907t-1.197-2.964l-5.928-5.928q-1.197-1.14-2.964-1.14t-2.907 1.14l-12.312 12.312l0-32.661q0-1.71-1.254-2.964t-2.907-1.254l-8.322 0q-1.71 0-2.964 1.254t-1.254 2.964l0 32.661l-12.312-12.312q-1.197-1.254-2.907-1.254t-2.907 1.254l-5.928 5.928q-1.197 1.197-1.197 2.964t1.197 2.907l29.469 29.526q1.197 1.14 2.964 1.14zm49.989-33.63q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
var iconCircleArrowUp = {
  path: "M54.207 83.391q1.653 0 2.907-1.254t1.254-2.907l0-32.718l12.312 12.312q1.254 1.254 2.964 1.254t2.907-1.254l5.928-5.928q1.197-1.197 1.14-2.964 0-1.767-1.14-2.907l-29.526-29.526q-1.197-1.14-2.907-1.14t-2.964 1.14l-29.469 29.526q-1.197 1.254-1.197 2.964t1.197 2.907l5.928 5.928q1.197 1.197 2.907 1.197t2.907-1.197l12.312-12.312l0 32.718q0 1.653 1.254 2.907t2.964 1.254l8.322 0zm45.828-33.345q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
var iconCircleThin = {
  path: "M50.046 8.322q-8.493 0-16.188 3.306-15.561 6.669-22.173 22.23-3.363 7.695-3.363 16.188t3.306 16.188 8.949 13.281q5.586 5.586 13.281 8.892t16.188 3.306 16.188-3.306 13.281-8.892 8.892-13.281 3.306-16.188-3.306-16.188-8.892-13.281-13.281-8.949q-7.695-3.306-16.188-3.306zm0 91.713q-13.623 0-25.137-6.726t-18.183-18.183q-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.726 25.137-6.726 25.137-18.24 18.126q-11.514 6.726-25.08 6.726z",
  width: 100,
  height: 99.944
};
var iconDropdownArrow = {
  path: "M9 9.8c0 .5.7 1.7 1.5 2.8 1.5 1.9 1.5 1.9 3 0C15.7 9.7 15.4 9 12 9c-1.6 0-3 .4-3 .8z",
  width: 24,
  height: 24
};
var iconExclamationSign = {
  path: "M58.368 81.225l0-12.369q0-.912-.57-1.539t-1.425-.627l-12.54 0q-.855-.057-1.482.627t-.684 1.539l0 12.369q-.057.855.627 1.482t1.539.684l12.54 0q.855 0 1.425-.627t.57-1.539zm1.026-62.871q0-1.596-2.223-1.71l-14.307 0q-2.109 0-2.223 1.71l1.14 40.47q0 .627.627 1.14t1.539.456l12.084 0q.912-.057 1.539-.513t.684-1.083zm-9.348-18.354q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.726 25.137-6.726 25.137-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669z",
  width: 100,
  height: 99.944
}; // Grabbed from https://github.com/encharm/Font-Awesome-SVG-PNG

var iconGear = {
  path: "M1152 896q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm512-109v222q0 12-8 23t-20 13l-185 28q-19 54-39 91 35 50 107 138 10 12 10 25t-9 23q-27 37-99 108t-94 71q-12 0-26-9l-138-108q-44 23-91 38-16 136-29 186-7 28-36 28h-222q-14 0-24.5-8.5t-11.5-21.5l-28-184q-49-16-90-37l-141 107q-10 9-25 9-14 0-25-11-126-114-165-168-7-10-7-23 0-12 8-23 15-21 51-66.5t54-70.5q-27-50-41-99l-183-27q-13-2-21-12.5t-8-23.5v-222q0-12 8-23t19-13l186-28q14-46 39-92-40-57-107-138-10-12-10-24 0-10 9-23 26-36 98.5-107.5t94.5-71.5q13 0 26 10l138 107q44-23 91-38 16-136 29-186 7-28 36-28h222q14 0 24.5 8.5t11.5 21.5l28 184q49 16 90 37l142-107q9-9 24-9 13 0 25 10 129 119 165 170 7 8 7 22 0 12-8 23-15 21-51 66.5t-54 70.5q26 50 41 98l183 28q13 2 21 12.5t8 23.5z",
  width: 1792,
  height: 1792
};
var iconOk = {
  path: "M37.964 76.048q-2.576 0-4.368-1.792l-31.864-31.864q-1.792-1.792-1.792-4.368t1.792-4.368l8.736-8.68q1.792-1.792 4.368-1.792t4.312 1.792l18.816 18.872 42-42.056q1.792-1.792 4.368-1.792t4.312 1.792l8.736 8.736q1.792 1.792 1.792 4.368t-1.792 4.312l-55.048 55.048q-1.792 1.792-4.368 1.792z",
  width: 100,
  height: 76.637
};
var iconPlus = {
  path: "M99.758 43.09l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-29.45 0l0 29.45q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-29.45l-29.45 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l29.45 0l0-29.45q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836l0 29.45l29.45 0q2.852 0 4.836 1.984t1.984 4.836z",
  width: 100,
  height: 100
};
var iconRemove = {
  path: "M100.464 80.808q0 3.404-2.368 5.772l-11.47 11.544q-2.368 2.368-5.772 2.368t-5.698-2.368l-24.864-24.864-24.864 24.864q-2.368 2.368-5.772 2.368t-5.772-2.368l-11.47-11.544q-2.368-2.368-2.368-5.772t2.368-5.698l24.864-24.864-24.864-24.864q-2.368-2.368-2.368-5.772t2.368-5.772l11.47-11.47q2.368-2.368 5.772-2.368t5.772 2.368l24.864 24.864 24.864-24.864q2.294-2.368 5.698-2.368t5.772 2.368l11.47 11.47q2.368 2.368 2.368 5.772t-2.368 5.772l-24.864 24.864 24.864 24.864q2.368 2.294 2.368 5.698z",
  width: 100,
  height: 100
};
var iconStar = {
  path: "M15.1052249,9.55978547 L22.0028147,9.55978545 C23.6568673,9.55978545 23.9349557,10.3753626 22.6181351,11.3858845 L16.9943688,15.7015366 L19.2518801,22.8294455 C19.7526645,24.4106317 19.0984455,24.8825885 17.769353,23.8673293 L12.0490577,19.4977438 L6.5116497,23.8422153 C5.20921411,24.8640642 4.53299569,24.4067544 5.00266927,22.8160582 L7.10332364,15.7015366 L1.42794544,11.3634306 C0.110226041,10.3562014 0.383967283,9.54239221 2.0409646,9.54574013 L8.9924676,9.55978547 L11.1485117,2.72669438 C11.6458693,1.15043244 12.4548928,1.15900049 12.9494787,2.72669438 L15.1052249,9.55978547 Z",
  width: 24,
  height: 24
};
var iconTryAgain = {
  path: "M3.74890556,17.9799506 C2.19251241,16.1970909 1.10103636,13.4971457 1.13090903,11.1491783 C1.17160478,7.95052637 4.01704076,0.865059407 11.7028044,0.865059407 C19.388568,0.865059407 22.3026521,7.35203035 22.3026521,11.5879453 C22.3026521,15.8238603 19.386629,20.5574509 13.6832464,21.7131548 L13.6757539,17.3722171 C17.0812986,16.2190517 18.331158,14.1944123 18.3311578,11.5879451 C18.3311574,8.16554692 15.6664205,5.03476549 11.7028048,5.20494205 C7.73918903,5.37511861 5.59244567,8.66930079 5.59244567,11.1491783 C5.59244567,12.9090077 6.11128139,14.1753512 6.93640437,15.3053215 L8.14052356,14.2949456 C8.98559348,13.5858477 9.6994861,13.9070448 9.73489556,15.0076413 L9.91284941,20.5388014 C9.94832683,21.6415103 9.09967118,22.3514475 8.02194403,22.1254594 L2.60571602,20.9897332 C1.5259204,20.7633114 1.34338662,19.9984207 2.18070755,19.295825 L3.74890556,17.9799506 Z",
  width: 23,
  height: 23
};
var iconTrash = {
  path: "M31.293 37.506q2.052 0 2.052 2.109l0 37.506q0 1.995-2.052 2.109l-4.218 0q-.912-.057-1.482-.627t-.57-1.482l0-37.506q0-2.109 2.052-2.109l4.218 0zm18.753 2.109l0 37.506q0 .912-.57 1.482t-1.539.627l-4.161 0q-1.995 0-2.109-2.109l0-37.506q.057-.912.627-1.482t1.482-.627l4.161 0q.969.057 1.539.627t.57 1.482zm14.592-2.109q2.052 0 2.052 2.109l0 37.506q0 1.995-2.052 2.109l-4.161 0q-.969-.057-1.539-.627t-.57-1.482l0-37.506q0-2.109 2.109-2.109l4.161 0zm10.431 49.248l0-61.731l-58.368 0l0 61.731q.057 2.679.969 3.819t1.083 1.14l54.207 0q.171 0 1.14-1.083t.969-3.876zm-43.776-70.11l29.184 0l-3.135-7.581q-.456-.57-1.14-.741l-20.634 0q-.627.114-1.083.741zm-31.293 2.109q0-1.995 2.109-2.109l20.121 0l4.56-10.83q.969-2.394 3.477-4.104 2.565-1.71 5.187-1.71l20.805 0q2.622 0 5.187 1.71t3.477 4.104l4.56 10.83l20.178 0q.912.057 1.482.627t.57 1.482l0 4.161q0 1.995-2.052 2.109l-6.27 0l0 61.731q0 5.415-3.078 9.348t-7.353 3.933l-54.207 0q-4.275 0-7.353-3.819t-3.078-9.177l0-62.016l-6.213 0q-.969 0-1.539-.57t-.57-1.539l0-4.161z",
  width: 91.681,
  height: 100
};
var iconUndo = {
  path: "M10,6.6C10,7.2,9.8,8,9.3,9.1c0,0,0,0.1-0.1,0.1S9.2,9.3,9.2,9.4c0,0,0,0.1-0.1,0.1C9,9.6,9,9.6,8.9,9.6 c-0.1,0-0.1,0-0.1-0.1c0,0,0-0.1,0-0.1c0,0,0-0.1,0-0.1s0-0.1,0-0.1c0-0.3,0-0.5,0-0.7c0-0.4,0-0.7-0.1-1C8.6,7.1,8.5,6.9,8.4,6.7S8.2,6.3,8,6.1C7.8,5.9,7.6,5.8,7.4,5.7S6.9,5.5,6.7,5.5S6.1,5.4,5.8,5.4c-0.3,0-0.6,0-1,0H3.6v1.4c0,0.1,0,0.2-0.1,0.3C3.4,7.1,3.3,7.1,3.2,7.1C3.1,7.1,3,7.1,3,7L0.1,4.1C0,4.1,0,4,0,3.9s0-0.2,0.1-0.3L3,0.8C3,0.7,3.1,0.7,3.2,0.7c0.1,0,0.2,0,0.3,0.1C3.5,0.9,3.6,0.9,3.6,1v1.4h1.2c2.6,0,4.3,0.7,4.9,2.2C9.9,5.2,10,5.8,10,6.6z",
  width: 10,
  height: 10
};
var iconMinus = {
  path: "M8,13 L16,13 C16.5522847,13 17,12.5522847 17,12 C17,11.4477153 16.5522847,11 16,11 L8,11 C7.44771525,11 7,11.4477153 7,12 C7,12.5522847 7.44771525,13 8,13 Z",
  width: 24,
  height: 24
};

var _module_$2d = {
  exports: {}
};
/**
 * A library of options to pass to add/draw/remove/constraints
 */

var _$1r = _underscore__default["default"];
var WrappedEllipse$1 = _wrappedEllipseJs;
var kpoint$8 = _kmath3.point;
var add = {
  constrain: function constrain() {
    this.constrain();
  }
};
add.standard = [add.constrain];
var modify = {
  draw: function draw() {
    this.draw();
  }
};
modify.standard = [modify.draw];
var draw$2 = {
  basic: function basic(state, prevState) {
    var graphie = this.graphie;

    if (!this.state.visibleShape) {
      var radii = [this.pointSize() / graphie.scale[0], this.pointSize() / graphie.scale[1]];
      var options = {
        maxScale: Math.max(this.highlightStyle().scale, this.normalStyle().scale),
        // Add in 10px of padding to avoid clipping at the edges.
        padding: 10,
        shadow: state.shadow
      };
      this.state.visibleShape = new WrappedEllipse$1(graphie, this.coord(), radii, options);
      this.state.visibleShape.attr(_$1r.omit(this.normalStyle(), "scale"));
      this.state.visibleShape.toFront(); // Keep mouseTarget in front of visible shape

      if (this.mouseTarget()) {
        this.mouseTarget().toFront();
      }
    }

    if (state.normalStyle !== prevState.normalStyle && !_$1r.isEqual(state.normalStyle, prevState.normalStyle)) {
      this.state.visibleShape.attr(this.normalStyle());
    }

    this.state.visibleShape.moveTo(this.coord());

    if (this.mouseTarget()) {
      this.mouseTarget().moveTo(this.coord());
    }
  },
  highlight: function highlight(state, prevState) {
    if (state.isHovering && !prevState.isHovering) {
      state.visibleShape.animate(this.highlightStyle(), 50);
    } else if (!state.isHovering && prevState.isHovering) {
      state.visibleShape.animate(this.normalStyle(), 50);
    }
  }
};
draw$2.standard = [draw$2.basic, draw$2.highlight];
var remove = {
  basic: function basic() {
    if (this.state.visibleShape) {
      this.state.visibleShape.remove();
      this.state.visibleShape = null;
    }
  }
};
remove.standard = remove.basic;
var constraints = {
  fixed: function fixed() {
    return function () {
      return false;
    };
  },
  snap: function snap(_snap) {
    return function (coord) {
      if (_snap === null) {
        return true;
      }

      _snap = _snap || this.graphie.snap;
      return kpoint$8.roundTo(coord, _snap);
    };
  },
  bound: function bound(range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }

    return function (coord, prev, options) {
      var graphie = this.graphie;
      range = range || graphie.range;

      if (snap === undefined) {
        snap = graphie.snap;
      }

      var lower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      var upper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);

      if (snap) {
        lower = kpoint$8.ceilTo(lower, snap);
        upper = kpoint$8.floorTo(upper, snap);
      }

      if (!!options && !!options.onOutOfBounds) {
        if (coord[0] > upper[0] || coord[0] < lower[0] || coord[1] > upper[1] || coord[1] < lower[1]) {
          options.onSkipRemaining();
          options.onOutOfBounds();
        }

        return coord;
      }

      var coordX = Math.max(lower[0], Math.min(upper[0], coord[0]));
      var coordY = Math.max(lower[1], Math.min(upper[1], coord[1]));
      return [coordX, coordY];
    };
  }
};
constraints.standard = null;
_module_$2d.exports = {
  add: add,
  modify: modify,
  draw: draw$2,
  remove: remove,
  onMoveStart: {
    standard: null
  },
  constraints: constraints,
  onMove: {
    standard: null
  },
  onMoveEnd: {
    standard: null
  },
  onClick: {
    standard: null
  }
};
var _movablePointOptionsJs = _module_$2d.exports;

var _module_$2c = {
  exports: {}
};
/**
 * Creates and adds a point to the graph that can be dragged around.
 * It allows constraints on its movement and draws when moves happen.
 *
 * Options can be passed to the constructor to control how the point behaves:
 *   coord: [x, y]
 *     The initial position of the point
 *   pointSize:
 *     changes the size of the point. defaults to 4
 *   static: boolean
 *     draw the point, but don't let it be interactable
 *   cursor: "move", "pointer"
 *     css cursor for this point
 *   add: [function(state)]
 *     called immediately when this movablePoint is added
 *     default: apply any constraints and draw
 *   draw: [function(prevState, currentState)]
 *     drawing functions. default to [basic, highlight]
 *   remove: [function(state)]
 *     called when this movablePoint is removed
 *   onMoveStart: [function(coord)]
 *     called when this point is clicked on
 *   constraints: [function(coord)]
 *     called when this point is dragged
 *     return true or nothing to accept the move
 *     return false to cancel the move
 *     return an [x, y] coordinate to override the move
 *   onMove: [function(coord)]
 *     called after all constraints functions pass and the point
 *     is moved to a new location
 *   onMoveEnd: [function(coord)]
 *     called when the mouse is released from a click or move
 *   onClick: [function(coord)]
 *     called when someone mouses down, doesn't move the point,
 *     and mouses up.
 *   normalStyle:
 *     the raphael/graphie style of the point when not hovering
 *   highlightStyle:
 *     the raphael/graphie style of the point when hovering, if
 *     MovablePoint.draw.highlight is used
 *
 * This creates a MovablePoint object with the following methods:
 *   setCoord: [x, y]
 *     changes the point's coordinate
 *   draw:
 *     redraws the coord
 *   modify: {options}
 *     modifies the original options passed to the point
 *   remove:
 *     removes the point from graphie
 */

var _$1q = _underscore__default["default"];
var MovablePointOptions = _movablePointOptionsJs;
var WrappedEllipse = _wrappedEllipseJs;
var InteractiveUtil$1 = InteractiveUtil$7;
var objective_ = _objective_Js;
var assert$7 = InteractiveUtil$1.assert;
var normalizeOptions$1 = InteractiveUtil$1.normalizeOptions;
var kpoint$7 = _kmath3.point;
var kvector$4 = _kmath3.vector;
var KhanColors$b = _utilColorsJs;
var processMath = _utilTexJs.processMath;
var React$26 = _react__default["default"];
var ReactDOM$z = _reactDom__default["default"];
var InlineIcon$i = _componentsInlineIconJsx; // State parameters that should be converted into an array of
// functions

var FUNCTION_ARRAY_OPTIONS$1 = _$1q.keys(MovablePointOptions); // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.coord() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".


var DEFAULT_PROPS$1 = {
  coord: [0, 0],
  pointSize: 4,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  shadow: false,
  tooltip: false
};
var DEFAULT_STATE$1 = {
  added: false,
  hasMoved: false,
  visibleShape: null,
  outOfBounds: false,
  mouseTarget: null,
  touchOffset: null
};
var tooltipResetFunctions = [];

var MovablePoint$7 = function MovablePoint(graphie, movable, options) {
  _$1q.extend(this, {
    graphie: graphie,
    movable: movable,
    state: {
      // Set here because this must be unique for each instance
      id: _$1q.uniqueId("movablePoint")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(_$1q.extend({}, DEFAULT_STATE$1, options));
};

_$1q.extend(MovablePoint$7, MovablePointOptions);

InteractiveUtil$1.createGettersFor(MovablePoint$7, _$1q.extend({}, DEFAULT_PROPS$1, DEFAULT_STATE$1));
InteractiveUtil$1.addMovableHelperMethodsTo(MovablePoint$7);

_$1q.extend(MovablePoint$7.prototype, {
  cloneState: function cloneState() {
    return _$1q.extend(this.movable.cloneState(), this.state);
  },
  _createDefaultState: function _createDefaultState() {
    return _$1q.extend({
      id: this.state.id
    }, normalizeOptions$1(FUNCTION_ARRAY_OPTIONS$1, // Defaults are copied from MovablePointOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_.pluck(MovablePointOptions, "standard") // We only update props here, because we want things on state to
    // be persistent, and updated appropriately in modify()
    ), DEFAULT_PROPS$1);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function modify(options) {
    this.update(_$1q.extend(this._createDefaultState(), options));
  },

  /**
   * Displays a tooltip above the point, replacing any previous contents. If
   * there is no tooltip initialized, adds the tooltip.
   *
   * If the type of contents is string, the contents will be rendered with
   * KaTeX. Otherwise, the content will be assumed to be a DOM node and will
   * be appended inside the tooltip.
   */
  _showTooltip: function _showTooltip(contents) {
    if (!this._tooltip) {
      this._tooltip = document.createElement("div");
      this._tooltip.className = "tooltip-content";
      this.state.visibleShape.wrapper.className = "tooltip";
      this.state.visibleShape.wrapper.appendChild(this._tooltip); // Only one tooltip should be displayed at a time, so store a list
      // of all the tooltips initialized.

      tooltipResetFunctions.push(() => {
        if (this.state.added) {
          this._hideTooltip();
        }
      });
    }

    if (this._tooltip.firstChild) {
      this._tooltip.removeChild(this._tooltip.firstChild);
    }

    this.state.visibleShape.wrapper.className = "tooltip visible";

    this._tooltip.appendChild(document.createElement("span"));

    if (typeof contents === "string") {
      processMath(this._tooltip.firstChild, contents, false);
    } else if (typeof contents === "function") {
      contents(this._tooltip.firstChild);
    } else {
      this._tooltip.firstChild.appendChild(contents);
    }
  },
  _hideTooltip: function _hideTooltip() {
    if (this._tooltip) {
      // Without the visible class, tooltips have display: none set
      this.state.visibleShape.wrapper.className = "tooltip";
    }
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function update(options) {
    var self = this;
    var graphie = self.graphie;

    var state = _$1q.extend(self.state, normalizeOptions$1(FUNCTION_ARRAY_OPTIONS$1, options));

    assert$7(kpoint$7.is(state.coord)); // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPS/STATE!)

    var normalColor = state.static ? KhanColors$b.DYNAMIC : KhanColors$b.INTERACTIVE;
    state.normalStyle = _$1q.extend({
      fill: normalColor,
      stroke: normalColor,
      scale: 1
    }, state.normalStyle);
    state.highlightStyle = _$1q.extend({
      fill: KhanColors$b.INTERACTING,
      stroke: KhanColors$b.INTERACTING,
      scale: 2
    }, state.highlightStyle);

    if (!state.static) {
      // the invisible shape in front of the point that gets mouse events
      if (!state.mouseTarget) {
        var center = self.state.coord;
        var radii = graphie.unscaleVector(24);
        var _options = {
          mouselayer: true,
          padding: 0
        };
        state.mouseTarget = new WrappedEllipse(graphie, center, radii, _options);
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }
    }

    var showTrashTooltip = () => {
      this._showTooltip(container => {
        ReactDOM$z.render( /*#__PURE__*/React$26.createElement("span", {
          style: {
            fontSize: "2em"
          }
        }, /*#__PURE__*/React$26.createElement(InlineIcon$i, _extends({}, iconTrash, {
          style: {
            position: "static",
            color: KhanColors$b.INTERACTIVE,
            marginLeft: 9,
            marginRight: 9
          }
        }))), container);
      });
    }; // The starting coord of any move, sent to onMoveEnd as the previous
    // value


    var startCoord = state.coord; // The Movable representing this movablePoint's representation
    // This handles mouse events for us, which we propagate in
    // onMove

    self.movable.modify(_$1q.extend({}, state, {
      add: null,
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: startMouseCoord => {
        state.hasMoved = false;
        startCoord = state.coord; // Save the offset between the cursor and the initial coordinate
        // of the point. This is tracked so as to avoid locking the
        // moving point to the user's finger on touch devices, which
        // would obscure it, no matter how large we made the touch
        // target. Instead, we respect the offset at which the point was
        // grabbed for the entirety of the gesture, if it's a
        // touch-based interaction.

        if (state.touchOffset == null) {
          var isMouse = !('ontouchstart' in window);
          state.touchOffset = isMouse ? [0, 0] : kvector$4.subtract(startCoord, startMouseCoord);
        }

        var svgElem = state.visibleShape.wrapper;

        if (state.shadow) {
          var filter = "none";
          svgElem.style.webkitFilter = filter;
          svgElem.style.filter = filter;
        }

        if (state.showHairlines) {
          state.showHairlines(state.coord);
        }

        tooltipResetFunctions.forEach(f => f());

        if (state.tooltip) {
          if (state.xOnlyTooltip) {
            this._showTooltip("".concat(state.coord[0]));
          } else {
            this._showTooltip("(".concat(state.coord[0], ", ").concat(state.coord[1], ")"));
          }

          if (state.shadow) {
            var content = svgElem.getElementsByClassName("tooltip-content")[0];
            var _filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
            content.style.webkitFilter = _filter;
            content.style.filter = _filter;
          }
        }

        self._fireEvent(state.onMoveStart, startCoord, startCoord);

        self.draw();
      },
      onMove: (mouseCoord, prevMouseCoord) => {
        var transformedCoord = kvector$4.add(mouseCoord, state.touchOffset);
        self.moveTo(transformedCoord);

        if (state.showHairlines) {
          if (!this.state.outOfBounds) {
            state.showHairlines(state.coord);
          } else {
            state.hideHairlines();
          }
        }

        if (state.tooltip) {
          if (!this.state.outOfBounds) {
            if (state.xOnlyTooltip) {
              this._showTooltip("".concat(state.coord[0]));
            } else {
              this._showTooltip("(".concat(state.coord[0], ", ").concat(state.coord[1], ")"));
            }
          }
        }

        if (state.onRemove && this.state.outOfBounds) {
          showTrashTooltip();
        }
      },
      onMoveEnd: () => {
        if (self.isHovering() && !state.hasMoved) {
          self._fireEvent(state.onClick, state.coord, startCoord);
        }

        var svgElem = state.visibleShape.wrapper;

        if (state.shadow) {
          var filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
          svgElem.style.webkitFilter = filter;
          svgElem.style.filter = filter;
        }

        if (state.hideHairlines) {
          state.hideHairlines();
        }

        if (state.hasMoved) {
          this._hideTooltip();
        } else if (state.onRemove) {
          // If we haven't moved and we should be displaying trash
          // tooltips.
          showTrashTooltip();
          var content = svgElem.getElementsByClassName("tooltip-content")[0];
          content.style.webkitFilter = "none";
          content.style.filter = "none";

          this._tooltip.firstChild.addEventListener("touchstart", e => {
            // Prevent creation of a new point when the event is
            // propagated up the DOM.
            e.stopPropagation();
          }, true);

          this._tooltip.firstChild.addEventListener("touchend", e => {
            // Remove the point and prevent creation of a
            // new point.
            state.onRemove();
            e.stopPropagation();
          }, true);
        } else if (state.tooltip) {
          this._hideTooltip();
        }

        if (state.outOfBounds) {
          state.onRemove();
        }

        self._fireEvent(state.onMoveEnd, state.coord, startCoord);

        state.hasMoved = false;
        state.touchOffset = null;
        self.draw();
      }
    })); // Trigger an add event if this hasn't been added before

    if (!state.added) {
      self.prevState = {};

      self._fireEvent(state.add, self.cloneState(), self.prevState);

      state.added = true; // Update the state for `added` and in case the add event
      // changed it

      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  remove: function remove() {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.movable) {
      this.movable.remove();
    } // TODO(jack): This should really be moved off of
    // movablePoint.state and only kept on movable.state


    this.state.mouseTarget = null;
  },
  constrain: function constrain() {
    var result = this._applyConstraints(this.coord(), this.coord());

    if (kpoint$7.is(result)) {
      this.setCoord(result);
    }

    return result !== false;
  },
  setCoord: function setCoord(coord) {
    assert$7(kpoint$7.is(coord, 2));
    this.state.coord = _$1q.clone(coord);
    this.draw();
  },
  setCoordConstrained: function setCoordConstrained(coord) {
    assert$7(kpoint$7.is(coord, 2));

    var result = this._applyConstraints(coord, this.coord());

    if (result !== false) {
      this.state.coord = _$1q.clone(result);
      this.draw();
    }
  },
  moveTo: function moveTo(coord) {
    // The caller has the option of adding an onMove() method to the
    // movablePoint object we return as a sort of event handler
    // By returning false from onMove(), the move can be vetoed,
    // providing custom constraints on where the point can be moved.
    // By returning array [x, y], the move can be overridden
    var state = this.state;
    this.state.outOfBounds = false;

    var result = this._applyConstraints(coord, state.coord, state.onRemove ? {
      onOutOfBounds: () => {
        this.state.outOfBounds = true;
      }
    } : {});

    if (result === false) {
      return;
    } else if (kpoint$7.is(result)) {
      coord = result;
    }

    if (!kpoint$7.equal(coord, state.coord)) {
      var prevCoord = state.coord;
      state.coord = coord;
      state.hasMoved = true;

      this._fireEvent(state.onMove, state.coord, prevCoord);

      this.draw();
    }
  },
  // Clone these for use with raphael, which modifies the input
  // style parameters
  normalStyle: function normalStyle() {
    return _$1q.clone(this.state.normalStyle);
  },
  highlightStyle: function highlightStyle() {
    return _$1q.clone(this.state.highlightStyle);
  },
  // Change z-order to back
  toBack: function toBack() {
    this.movable.toBack();

    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function toFront() {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }

    this.movable.toFront();
  },

  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function isHovering() {
    return this.movable.isHovering();
  },
  isDragging: function isDragging() {
    return this.movable.isDragging();
  },
  mouseTarget: function mouseTarget() {
    return this.movable.mouseTarget();
  },
  grab: function grab(coord) {
    // Provide an explicit touchOffset override, so that we track the user's
    // finger when a point has been grabbed.
    this.state.touchOffset = [0, 0];
    this.movable.grab(coord);
    this.moveTo(coord);
  }
});

_module_$2c.exports = MovablePoint$7;
var _interactive2MovablePointJsx = _module_$2c.exports;

var _module_$2b = {
  exports: {}
};
/**
 * Movable
 *
 * A Movable Something, that sends onMove events based on the
 * mouse coordinate (graphie unscaled, non-pixel-value) of the
 * move.
 *
 * Other MovableThings should generally have a Movable field, and
 * let this class handle all of the virtual mouse events, and then
 * take appropriate action in onMoveStart, onMove, onMoveEnd
 */

var _$1p = _underscore__default["default"];
var InteractiveUtil = InteractiveUtil$7;
var normalizeOptions = InteractiveUtil.normalizeOptions;
var assert$6 = InteractiveUtil.assert;
var kpoint$6 = _kmath3.point; // state parameters that should be converted into an array of
// functions

var FUNCTION_ARRAY_OPTIONS = ["add", "modify", "draw", "remove", "onMoveStart", "onMove", "onMoveEnd", "onClick"]; // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.isHovering() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the movable should be on "state".

var DEFAULT_PROPS = {
  cursor: null
};
var DEFAULT_STATE = {
  added: false,
  isHovering: false,
  isMouseOver: false,
  isDragging: false,
  mouseTarget: null
};

var Movable$1 = function Movable(graphie, options) {
  _$1p.extend(this, {
    graphie: graphie,
    state: {
      // Set here because this must be unique for each instance
      id: _$1p.uniqueId("movable")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(_$1p.extend({}, DEFAULT_STATE, options));
};

InteractiveUtil.createGettersFor(Movable$1, _$1p.extend({}, DEFAULT_PROPS, DEFAULT_STATE));
InteractiveUtil.addMovableHelperMethodsTo(Movable$1);

_$1p.extend(Movable$1.prototype, {
  cloneState: function cloneState() {
    return _$1p.clone(this.state);
  },
  _createDefaultState: function _createDefaultState() {
    return _$1p.extend({
      id: this.state.id,
      add: [],
      modify: [],
      draw: [],
      remove: [],
      onMoveStart: [],
      onMove: [],
      onMoveEnd: [],
      onClick: [] // We only update props here, because we want things on state to
      // be persistent, and updated appropriately in modify()

    }, DEFAULT_PROPS);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. The only state maintained is `state.id`
   *
   * Analogous to React.js's replaceProps
   */
  modify: function modify(options) {
    this.update(_$1p.extend({}, this._createDefaultState(), options));
  },

  /**
   * Simulates a mouse grab event on the movable object.
   */
  grab: function grab(coord) {
    assert$6(kpoint$6.is(coord));
    var self = this;
    var graphie = self.graphie;
    var state = self.state;
    state.isHovering = true;
    state.isDragging = true;
    graphie.isDragging = true;
    var startMouseCoord = coord;
    var prevMouseCoord = startMouseCoord;

    self._fireEvent(state.onMoveStart, startMouseCoord, startMouseCoord);

    var moveHandler = function moveHandler(e) {
      e.preventDefault();
      var mouseCoord = graphie.getMouseCoord(e);

      self._fireEvent(state.onMove, mouseCoord, prevMouseCoord);

      self.draw();
      prevMouseCoord = mouseCoord;
    };

    var upHandler = function upHandler(e) {
      $__default["default"](document).unbind("vmousemove", moveHandler);
      $__default["default"](document).unbind("vmouseup", upHandler);

      if (state.isHovering) {
        self._fireEvent(state.onClick, prevMouseCoord, startMouseCoord);
      }

      state.isHovering = self.state.isMouseOver;
      state.isDragging = false;
      graphie.isDragging = false;

      self._fireEvent(state.onMoveEnd, prevMouseCoord, startMouseCoord);

      self.draw();
    };

    $__default["default"](document).bind("vmousemove", moveHandler);
    $__default["default"](document).bind("vmouseup", upHandler);
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function update(options) {
    var self = this;
    var graphie = self.graphie;
    var prevState = self.cloneState();

    var state = _$1p.extend(self.state, normalizeOptions(FUNCTION_ARRAY_OPTIONS, options)); // the invisible shape in front of the point that gets mouse events


    if (state.mouseTarget && !prevState.mouseTarget) {
      var $mouseTarget;

      if (state.mouseTarget.getMouseTarget) {
        $mouseTarget = $__default["default"](state.mouseTarget.getMouseTarget());
      } else {
        $mouseTarget = $__default["default"](state.mouseTarget[0]);
      }

      var isMouse = !('ontouchstart' in window);

      if (isMouse) {
        $mouseTarget.on("vmouseover", function () {
          state.isMouseOver = true;

          if (!graphie.isDragging) {
            state.isHovering = true;
          }

          if (self.state.added) {
            // Avoid drawing if the point has been removed
            self.draw();
          }
        });
        $mouseTarget.on("vmouseout", function () {
          state.isMouseOver = false;

          if (!state.isDragging) {
            state.isHovering = false;
          }

          if (self.state.added) {
            // Avoid drawing if the point has been removed
            self.draw();
          }
        });
      } // Prevent the page from scrolling when we grab and drag the
      // movable object on a mobile device.


      $mouseTarget[0].addEventListener("touchstart", function (event) {
        event.preventDefault();
      }, {
        passive: false
      });
      $mouseTarget.on("vmousedown", function (e) {
        if (e.which !== 0 && e.which !== 1) {
          return;
        }

        e.preventDefault();
        var mouseCoord = graphie.getMouseCoord(e);
        self.grab(mouseCoord);
      });
    }

    if (state.mouseTarget && state.cursor !== undefined) {
      var _$mouseTarget;

      if (state.mouseTarget.getMouseTarget) {
        _$mouseTarget = $__default["default"](state.mouseTarget.getMouseTarget());
      } else {
        _$mouseTarget = $__default["default"](state.mouseTarget[0]);
      } // "" removes the css cursor if state.cursor is null


      _$mouseTarget.css("cursor", state.cursor || "");
    } // Trigger an add event if this hasn't been added before


    if (!state.added) {
      self._fireEvent(state.modify, self.cloneState(), {});

      state.added = true; // Update the state for `added` and in case the add event
      // changed it

      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  remove: function remove() {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.state.mouseTarget) {
      $__default["default"](this.state.mouseTarget).off();
      this.state.mouseTarget.remove();
      this.state.mouseTarget = null;
    }
  },
  // Change z-order to back
  toBack: function toBack() {
    if (this.state.mouseTarget) {
      this.state.mouseTarget.toBack();
    }
  },
  // Change z-order to front
  toFront: function toFront() {
    if (this.state.mouseTarget) {
      this.state.mouseTarget.toFront();
    }
  }
});

_module_$2b.exports = Movable$1;
var _interactive2MovableJs = _module_$2b.exports;

var _module_$2a = {
  exports: {}
};
var Movable = _interactive2MovableJs;
var MovablePoint$6 = _interactive2MovablePointJsx;
var MovableLine$4 = _interactive2MovableLineJs;
var MovablePolygon = _interactive2MovablePolygonJs;
var KhanColors$a = _utilColorsJs;
var Interactive2$4 = {
  MovablePoint: MovablePoint$6,
  addMovablePoint: function addMovablePoint(graphie, options) {
    var movable = new Movable(graphie, {});
    return new MovablePoint$6(graphie, movable, options);
  },
  MovableLine: MovableLine$4,
  addMovableLine: function addMovableLine(graphie, options) {
    var movable = new Movable(graphie, {});
    return new MovableLine$4(graphie, movable, options);
  },
  MovablePolygon: MovablePolygon,
  addMovablePolygon: function addMovablePolygon(graphie, options) {
    var movable = new Movable(graphie, {});
    return new MovablePolygon(graphie, movable, options);
  },
  addMaybeMobileMovablePoint: function addMaybeMobileMovablePoint(widget, extraProps) {
    var isMobile = widget.props.apiOptions.isMobile;
    var commonStyle = isMobile ? {
      stroke: "#ffffff",
      "stroke-width": 3,
      fill: KhanColors$a.INTERACTIVE
    } : {
      stroke: KhanColors$a.INTERACTIVE,
      fill: KhanColors$a.INTERACTIVE
    };
    var normalStyle = Object.assign(commonStyle, extraProps.normalStyle);
    var highlightStyle = Object.assign(isMobile ? _objectSpread2(_objectSpread2({}, commonStyle), {}, {
      "stroke-width": 0,
      scale: 0.75
    }) : {}, extraProps.highlightStyle);
    var props = Object.assign({
      normalStyle: normalStyle,
      highlightStyle: highlightStyle,
      shadow: isMobile,
      tooltip: isMobile && widget.props.showTooltips,
      showHairlines: widget.showHairlines,
      hideHairlines: widget.hideHairlines
    }, isMobile ? {
      pointSize: 7
    } : {});
    return Interactive2$4.addMovablePoint(widget.graphie, Object.assign(extraProps, props));
  }
};
_module_$2a.exports = Interactive2$4;
var _interactive2Js = _module_$2a.exports;

var _module_$29 = {
  exports: {}
};
var Util$o = Util$q;
var nestedMap$1 = Util$o.nestedMap;
var deepEq$5 = Util$o.deepEq;
var _$1o = _underscore__default["default"];
/**
 * A base class for all Graphie Movables
 *
 * Used for checking that all Graphie children are, in fact,
 * GraphieMovables
 */

function GraphieMovable$1(descriptor) {
  _$1o.extend(this, descriptor);
}

var abstractMethod = function abstractMethod() {
  throw new Error("Abstract method! Must be implemented by Graphie Movable" + this.constructor.displayName);
};

_$1o.extend(GraphieMovable$1.prototype, {
  movableProps: [],
  add: abstractMethod,
  modify: abstractMethod,
  remove: abstractMethod,
  toFront: function toFront() {
    /* no op */
  }
});
/**
 * returns cloned props modified with `children: childrenArray`
 */


var rewriteProps = function rewriteProps(props, childrenArray) {
  // Clone the props and add `children:`
  // childrenArray is always an array here because this is only called
  // from createClass, which initializes childrenArray as _.rest(arguments)
  return _$1o.extend({}, props, {
    children: _$1o.filter(_$1o.flatten(childrenArray), _$1o.identity)
  });
};
/**
 * Create a custom GraphieMovable class
 */


var createClass = function createClass(spec) {
  var GraphieClass = function GraphieClass(props) {
    if (!(this instanceof GraphieClass)) {
      throw new Error("Use createElement or JSX with graphie movables");
    }

    this.props = rewriteProps(props, props.children || []);
    return this;
  };

  spec.displayName = spec.displayName || _$1o.uniqueId("GraphieClass"); // Add the displayName to the constructor for compatibility with
  // React's myDescriptor.constructor.displayName

  GraphieClass.displayName = spec.displayName;
  GraphieClass.prototype = new GraphieMovable$1(spec);
  GraphieClass.prototype.constructor = GraphieClass;
  return GraphieClass;
};
/**
 * Create a GraphieMovable class from a function that describes
 * how to add said class to a graphie, and returns an array of
 * `.remove()`able elements to be used when a remove() or
 * modify() is called.
 *
 * This convenience method creates an inefficient class, although
 * it does check for a difference in this.props and prevProps before
 * removing and re-adding itself.
 *
 * The primary benefit of this is being able to very easily create
 * a wrapper for old graphie code to make it interface with <Graphie>
 *
 * Commonly used elements should use the fully-fledged createClass
 * and implement an efficient modify() operation.
 */


var createSimpleClass = function createSimpleClass(addFunction) {
  return createClass({
    displayName: addFunction.name || _$1o.uniqueId("GraphieSimpleClass"),
    movableProps: ["children"],
    add: function add(graphie) {
      this._elements = addFunction(graphie, this.props);
      this._prevProps = this.props;
    },
    modify: function modify(graphie) {
      if (!deepEq$5(this.props, this._prevProps)) {
        this.remove();
        this.add(graphie);
        this._prevProps = this.props;
        return "reordered";
      }
    },
    remove: function remove() {
      nestedMap$1(this._elements, elem => {
        if (elem) {
          elem.remove();
        }
      });
      this._elements = null;
      this._prevProps = null;
    },
    toFront: function toFront() {
      nestedMap$1(this._elements, elem => {
        if (_$1o.isFunction(elem.toFront)) {
          elem.toFront();
        }
      });
    }
  });
};

_module_$29.exports = {
  GraphieMovable: GraphieMovable$1,
  createClass: createClass,
  createSimpleClass: createSimpleClass
};
var _graphieClassesJsx = _module_$29.exports;

var _module_$28 = {
  exports: {}
};
var _$1n = _underscore__default["default"];
var GraphieClasses$1 = _graphieClassesJsx;
var Interactive2$3 = _interactive2Js;
var KhanColors$9 = _utilColorsJs;
var MovablePoint$5 = GraphieClasses$1.createClass({
  displayName: "MovablePoint",
  movableProps: ["children"],
  _getProps: function _getProps() {
    if (this.props.isMobile) {
      var isMobile = this.props.isMobile; // TODO(kevinb) precompute commonStyle and commonMobileStyle

      /* eslint-disable indent */

      var commonStyle = isMobile ? {
        stroke: "#ffffff",
        "stroke-width": 3,
        fill: KhanColors$9.INTERACTIVE
      } : {
        stroke: KhanColors$9.INTERACTIVE,
        fill: KhanColors$9.INTERACTIVE
      }; // TODO(kevinb) precompute normalStyle and normalMobileStyle

      var normalStyle = isMobile ? Object.assign(commonStyle, this.props.mobileStyleOverride || {}) : Object.assign(commonStyle, this.props.normalStyle); // TODO(kevinb) precompute highlightStyle and highlightMobileStyle

      var highlightStyle = isMobile ? _objectSpread2(_objectSpread2({}, commonStyle), {}, {
        "stroke-width": 0,
        scale: 0.75
      }) : this.props.highlightStyle;
      /* eslint-enable indent */

      var addedProps = Object.assign({
        normalStyle: normalStyle,
        highlightStyle: highlightStyle,
        shadow: isMobile,
        tooltip: isMobile && this.props.showTooltips
      }, isMobile ? {
        pointSize: 7
      } : {});
      return Object.assign(this.props, addedProps);
    } else {
      return this.props;
    }
  },
  add: function add(graphie) {
    this.point = Interactive2$3.addMovablePoint(graphie, this._getProps());
  },
  modify: function modify() {
    this.point.modify(this._getProps());
  },
  remove: function remove() {
    this.point.remove();
  },
  toFront: function toFront() {
    this.point.toFront();
  },
  grab: function grab(coord) {
    this.point.grab(coord);
  }
}); // Include helper methods, such as MovablePoint.constrain.snap()

_$1n.extend(MovablePoint$5, Interactive2$3.MovablePoint);

var MovableLine$3 = GraphieClasses$1.createClass({
  displayName: "MovableLine",
  movableProps: ["children"],
  add: function add(graphie) {
    // Add MovablePoint children
    var points = _$1n.pluck(this.props.children, "point");

    var props = _$1n.extend({}, this.props, {
      points: points
    });

    this.line = Interactive2$3.addMovableLine(graphie, props);
  },
  modify: function modify() {
    // Add MovablePoint children
    var points = _$1n.pluck(this.props.children, "point");

    var props = _$1n.extend({}, this.props, {
      points: points
    });

    this.line.modify(props);
  },
  remove: function remove() {
    this.line.remove();
  },
  toFront: function toFront() {
    this.line.toFront();
  }
}); // Include helper methods, such as MovableLine.constrain.snap()

_$1n.extend(MovableLine$3, Interactive2$3.MovableLine);

var Label$2 = GraphieClasses$1.createSimpleClass((graphie, props) => {
  var coord = props.coord;

  if (props.unscaled) {
    coord = graphie.unscalePoint(coord);
  }

  return graphie.label(coord, props.text, props.direction, props.tex, props.style);
});
var Line$3 = GraphieClasses$1.createClass({
  displayName: "Line",
  movableProps: ["children"],
  add: function add(graphie) {
    var props = this.props;
    this.graphie = graphie;
    this.line = this.graphie.line(props.start, props.end, props.style);
  },
  modify: function modify() {
    var props = this.props;
    var path = this.graphie.svgPath([props.start, props.end]);
    this.line.attr(_$1n.extend({}, props.style, {
      path: path
    }));
  },
  remove: function remove() {
    this.line.remove();
  },
  toFront: function toFront() {
    this.line.toFront();
  }
});
var Parabola = GraphieClasses$1.createClass({
  displayName: "Parabola",
  movableProps: ["children"],
  add: function add(graphie) {
    var props = this.props;
    this.graphie = graphie;
    this.parabola = this.graphie.parabola(props.a, props.b, props.c, props.style);
  },
  modify: function modify() {
    var props = this.props;
    var path = this.graphie.svgParabolaPath(props.a, props.b, props.c);
    this.parabola.attr(_$1n.extend({}, props.style, {
      path: path
    }));
  },
  remove: function remove() {
    this.parabola.remove();
  },
  toFront: function toFront() {
    this.parabola.toFront();
  }
});
var Sinusoid$1 = GraphieClasses$1.createClass({
  displayName: "Sinusoid",
  movableProps: ["children"],
  add: function add(graphie) {
    var props = this.props;
    this.graphie = graphie;
    this.sinusoid = this.graphie.sinusoid(props.a, props.b, props.c, props.d, props.style);
  },
  modify: function modify() {
    var props = this.props;
    var path = this.graphie.svgSinusoidPath(props.a, props.b, props.c, props.d);
    this.sinusoid.attr(_$1n.extend({}, props.style, {
      path: path
    }));
  },
  remove: function remove() {
    this.sinusoid.remove();
  },
  toFront: function toFront() {
    this.sinusoid.toFront();
  }
});
var Plot$2 = GraphieClasses$1.createSimpleClass((graphie, props) => {
  return graphie.plot(props.fn, props.range, props.style);
});
var PlotParametric$1 = GraphieClasses$1.createSimpleClass((graphie, props) => {
  return graphie.plotParametric(props.fn, props.range, props.style);
});
var Point$1 = GraphieClasses$1.createSimpleClass((graphie, props) => {
  return graphie.ellipse(props.coord, graphie.unscaleVector([4, 4]), {
    fill: props.color || KhanColors$9.BLACK,
    stroke: props.color || KhanColors$9.BLACK
  });
});
var Path$1 = GraphieClasses$1.createClass({
  displayName: "Path",
  movableProps: ["children"],
  add: function add(graphie) {
    var props = this.props;
    this.graphie = graphie;
    this.path = this.graphie.path(props.coords, props.style);
  },
  modify: function modify() {
    var props = this.props;
    var path = this.graphie.svgPath(props.coords);
    this.path.attr({
      path: path
    });
  },
  remove: function remove() {
    this.path.remove();
  },
  toFront: function toFront() {
    this.path.toFront();
  }
});
var Arc$1 = GraphieClasses$1.createSimpleClass((graphie, props) => {
  var center = props.center;
  var radius = props.radius;

  if (props.unscaled) {
    center = graphie.unscalePoint(center);
    radius = graphie.unscaleVector(radius);
  }

  return graphie.arc(center, radius, props.startAngle, props.endAngle, props.sector, props.style);
});
var Circle$1 = GraphieClasses$1.createSimpleClass((graphie, props) => {
  return graphie.circle(props.center, props.radius, props.style);
});
var Rect$1 = GraphieClasses$1.createSimpleClass((graphie, props) => {
  return graphie.rect(props.x, props.y, props.width, props.height, props.style);
});
_module_$28.exports = {
  Arc: Arc$1,
  Circle: Circle$1,
  Label: Label$2,
  Line: Line$3,
  MovableLine: MovableLine$3,
  MovablePoint: MovablePoint$5,
  Parabola: Parabola,
  Path: Path$1,
  Plot: Plot$2,
  PlotParametric: PlotParametric$1,
  Point: Point$1,
  Sinusoid: Sinusoid$1,
  Rect: Rect$1
};
var _graphieMovablesJsx = _module_$28.exports;

var _module_$27 = {
  exports: {}
};
var React$25 = _react__default["default"];
var ReactDOM$y = _reactDom__default["default"];
var _$1m = _underscore__default["default"];
var GraphieClasses = _graphieClassesJsx;
var Movables = _graphieMovablesJsx;
var GraphieMovable = GraphieClasses.GraphieMovable;
var deepEq$4 = Util$q.deepEq;
var nestedMap = Util$q.nestedMap;
var assert$5 = InteractiveUtil$7.assert;
var GraphUtils$4 = _utilGraphUtilsJs;
var createGraphie = GraphUtils$4.createGraphie;
var Graphie$7 = createReactClass({
  displayName: "Graphie",
  propTypes: {
    addMouseLayer: PropTypes.bool,
    box: PropTypes.arrayOf(PropTypes.number).isRequired,
    children: PropTypes.node,
    isMobile: PropTypes.bool,
    onClick: PropTypes.func,
    onMouseDown: PropTypes.func,
    onMouseMove: PropTypes.func,
    onMouseUp: PropTypes.func,
    options: PropTypes.shape({
      snapStep: PropTypes.arrayOf(PropTypes.number)
    }),
    range: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),
    responsive: PropTypes.bool,
    setDrawingAreaAvailable: PropTypes.func,
    setup: PropTypes.func.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return {
      range: [[-10, 10], [-10, 10]],
      options: {},
      responsive: false,
      addMouseLayer: true
    };
  },
  componentDidMount: function componentDidMount() {
    this._setupGraphie();

    this._updateMovables();
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
    return !deepEq$4(this.props, nextProps);
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    // If someone changes the setup function passed in, we should
    // technically setup graphie again. But that's definitely an
    // anti-pattern, since it is most-likely caused by passing in an
    // anonymous function rather than a "real" change, and re-rendering
    // in that case would cause us to constantly re-setup graphie, which
    // would have horrible performance implications. In order to avoid
    // those, we just warn here.
    if (this.props.setup !== prevProps.setup && window.console && window.console.warn) {
      window.console.warn("<Graphie> was given a new setup function. " + "This is a bad idea; please refactor your code to give " + "the same setup function reference to <Graphie> on " + "every render.");
    }

    if (!deepEq$4(this.props.options, prevProps.options) || !deepEq$4(this.props.box, prevProps.box) || !deepEq$4(this.props.range, prevProps.range)) {
      this._setupGraphie();
    }

    this._updateMovables();
  },

  /**
   * Allow parents of the <Graphie> component to grab a reference to the
   * underlying graphie object using
   * `this.refs.graphieComponent.getGraphie()`
   *
   * This shouldn't be necessary for 90% of cases, but the power is there.
   * Use it for good and not evil.
   */
  getGraphie: function getGraphie() {
    return this._graphie;
  },
  // bounds-checked range
  _range: function _range() {
    return _$1m.map(this.props.range, dimRange => {
      if (dimRange[0] >= dimRange[1]) {
        return [-10, 10];
      } else {
        return dimRange;
      }
    });
  },
  _box: function _box() {
    return _$1m.map(this.props.box, pixelDim => {
      // 340 = default size in the editor. exact value
      // is arbitrary; this is just a safety check.
      return pixelDim > 0 ? pixelDim : 340;
    });
  },
  _scale: function _scale() {
    var box = this._box();

    var range = this._range();

    return _$1m.map(box, (pixelDim, i) => {
      var unitDim = range[i][1] - range[i][0];
      return pixelDim / unitDim;
    });
  },
  _setupGraphie: function _setupGraphie() {
    this._removeMovables();

    var graphieDiv = ReactDOM$y.findDOMNode(this.refs.graphieDiv);
    $__default["default"](graphieDiv).empty();
    var graphie = this._graphie = createGraphie(graphieDiv); // This has to be called before addMouseLayer. You can re-init
    // with graphInit later if you prefer

    graphie.init({
      range: this._range(),
      scale: this._scale(),
      isMobile: this.props.isMobile
    }); // Only add the mouselayer if we actually want one.

    if (this.props.addMouseLayer) {
      graphie.addMouseLayer({
        onClick: this.props.onClick,
        onMouseDown: this.props.onMouseDown,
        onMouseUp: this.props.onMouseUp,
        onMouseMove: this.props.onMouseMove,
        setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
      });
    }

    graphie.snap = this.props.options.snapStep || [1, 1];

    if (this.props.responsive) {
      // Overwrite fixed styles set in init()
      // TODO(alex): Either make this component always responsive by
      // itself, or always wrap it in other components so that it is.
      $__default["default"](graphieDiv).css({
        width: "100%",
        height: "100%"
      });
      graphie.raphael.setSize("100%", "100%");
    }

    this.props.setup(graphie, _$1m.extend({
      range: this._range(),
      scale: this._scale()
    }, this.props.options));
  },
  _removeMovables: function _removeMovables() {
    // _.invoke works even when this._movables is undefined
    _$1m.invoke(this._movables, "remove");

    this._movables = {};
  },
  _renderMovables: function _renderMovables(children, options) {
    // Each leaf of `children` is a movable descriptor created by a call to
    // some `GraphieMovable`, such as `MovablePoint`.
    //
    // This function takes these descriptors and renders them into
    // on-screen movables, or updates on-screen movables for
    // descriptors when possible.
    //
    // If there is no movable with that key already, this descriptor is
    // stored in this._movables and promoted to an on-screen movable by
    // calling `child.add(graphie)`.
    //
    // If a movable of the same type with the same key exists already,
    // we take `child.props` and give them to the already-existing
    // on-screen movable, and call `movable.modify()`
    var graphie = options.graphie;
    var oldMovables = options.oldMovables;
    var newMovables = options.newMovables;
    /* output parameter */

    var renderChildren = elem => {
      _$1m.each(elem.movableProps, prop => {
        // Render the children, and save the results of that
        // render to the appropriate props
        elem.props[prop] = this._renderMovables(elem.props[prop], options);
      });
    }; // Add/modify movables
    // We want to keep track of whether we have added a new svg element,
    // because if we have, then we need to call .toFront() on any svg
    // elements occurring afterwards. If this happens, we set
    // `areMovablesOutOfOrder` to true:


    var areMovablesOutOfOrder = false;
    return nestedMap(children, childDescriptor => {
      if (!childDescriptor) {
        // Still increment the key to avoid cascading key changes
        // on hiding/unhiding children, i.e. by using
        // {someBoolean && <MovablePoint />}
        options.nextKey++; // preserve the null/undefined in the resulting array

        return childDescriptor;
      } // Instantiate the descriptor to turn it into a real Movable


      var child = new childDescriptor.type(childDescriptor.props);
      assert$5(child instanceof GraphieMovable, "All children of a Graphie component must be Graphie " + "movables"); // Give each child a key

      var keyProp = childDescriptor.key;
      var key = keyProp == null ? "_no_id_" + options.nextKey : keyProp;
      options.nextKey++;
      var ref = childDescriptor.ref; // We render our children first. This allows us to replace any
      // `movableProps` on our child with the on-screen movables
      // corresponding with those descriptors.

      renderChildren(child);
      var prevMovable = oldMovables[key];

      if (!prevMovable) {
        // We're creating a new child
        child.add(graphie);
        areMovablesOutOfOrder = true;
        newMovables[key] = child;
      } else if (child.constructor === prevMovable.constructor) {
        // We're updating an old child
        prevMovable.props = child.props;
        var modifyResult = prevMovable.modify(graphie);

        if (modifyResult === "reordered") {
          areMovablesOutOfOrder = true;
        }

        newMovables[key] = prevMovable;
      } else {
        // We're destroying an old child and replacing it
        // with a new child of a different type
        // This generally is a bad idea, so warn about it if this
        // is being caused by implicit keys
        if (keyProp == null) {
          /* eslint-disable no-console */
          if (typeof console !== "undefined" && console.warn) {
            console.warn("Replacing a <Graphie> child with a " + "child of a different type. Please add keys " + "to your <Graphie> children");
          }
          /* eslint-enable no-console */

        }

        prevMovable.remove();
        child.add(graphie);
        areMovablesOutOfOrder = true;
        newMovables[key] = child;
      }

      if (areMovablesOutOfOrder) {
        newMovables[key].toFront();
      }

      if (ref) {
        this.movables[ref] = newMovables[key];
      }

      return newMovables[key];
    });
  },
  // Sort of like react diffing, but for movables
  _updateMovables: function _updateMovables() {
    var graphie = this._graphie;
    var oldMovables = this._movables;
    var newMovables = {};
    this._movables = newMovables;
    this.movables = {};

    this._renderMovables(this.props.children, {
      nextKey: 1,
      graphie: graphie,
      oldMovables: oldMovables,
      newMovables: newMovables
    }); // Remove any movables that no longer exist in the child array


    _$1m.each(oldMovables, (oldMovable, key) => {
      if (!newMovables[key]) {
        oldMovable.remove();
      }
    });
  },
  render: function render() {
    return /*#__PURE__*/React$25.createElement("div", {
      className: "graphie-container"
    }, /*#__PURE__*/React$25.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  }
}); // Attach Graphie.createClass and Graphie.createSimpleClass

_$1m.extend(Graphie$7, GraphieClasses); // Attach the Movable react components for easy reference


_$1m.extend(Graphie$7, Movables);

_module_$27.exports = Graphie$7;
var _componentsGraphieJsx = _module_$27.exports;

var _module_$26 = {
  exports: {}
};
/* eslint-disable react/prop-types */

/**
 * A wrapper for a component that would otherwise have a fixed width and
 * height, that magically makes it reponsive while preserving its aspect ratio.
 * Specifically, the component will shrink dynamically when it needs to but
 * won't ever grow past its original dimensions.
 *
 * Can wrap multiple components with the same dimensions at the same time;
 * these will be overlaid on top of each other.
 *
 * Usage:
 * <FixedToResponsive width={400} height={400}>
 *     <img src="bottom-layer.png" />
 *     <img src="top-layer.png" />
 * </FixedToResponsive>
 */

var classNames$g = _classnames__default["default"];
var React$24 = _react__default["default"];
var MIN_VIEWPORT_HEIGHT = 480;
var FixedToResponsive$2 = createReactClass({
  displayName: "FixedToResponsive",
  propTypes: {
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,
    className: PropTypes.string,
    constrainHeight: PropTypes.bool,
    allowFullBleed: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      className: "",
      constrainHeight: false,
      allowFullBleed: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      viewportHeight: null,
      viewportWidth: null
    };
  },
  componentDidMount: function componentDidMount() {
    // Cache viewport sizes instead of computing on each render.
    // We setState() in componentDidMount(), even though it's a React
    // anti-pattern, because we do actually want to trigger a re-render
    // after the initial render (because initial render may be
    // server-side).
    // TODO(david): Don't do this for each image. Do this once per page.
    if (window.innerHeight < MIN_VIEWPORT_HEIGHT) {
      // There is a weird issue when this gets rendered in an Android
      // webview where window.innerHeight might be initially very small,
      // like 46, but seems to be good after ~400ms.
      setTimeout(this._cacheViewportSize, 800);
    } else {
      this._cacheViewportSize();
    }
  },
  _cacheViewportSize: function _cacheViewportSize() {
    if (this.isMounted()) {
      this.setState({
        viewportHeight: Math.max(MIN_VIEWPORT_HEIGHT, window.innerHeight),
        viewportWidth: window.innerWidth
      });
    }
  },
  render: function render() {
    // The ideal behavior for responsified, fixed size child components is
    // that they shrink when they need to (while preserving aspect ratio)
    // but never grow larger than their original dimensions. We accomplish
    // this by absolutely positioning the children and telling them to fill
    // up all of a space that has the correct aspect ratio.
    var aspectRatio = this.props.width / this.props.height; // This works because padding percentages are interpreted in terms of
    // the width of the containing block, so:
    //     (fixed height / fixed width) * display width = display height
    // Based on http://refills.bourbon.io/components/#video && medium.com

    var spacer = /*#__PURE__*/React$24.createElement("div", {
      style: {
        paddingBottom: (1 / aspectRatio).toFixed(4) * 100 + "%"
      }
    });
    var {
      width,
      height
    } = this.props; // Constrain height to be at most 2/3 viewport height, maintaining
    // aspect ratio.

    if (this.props.constrainHeight && this.state.viewportHeight) {
      var maxHeight = 2 / 3 * this.state.viewportHeight;

      if (this.props.height >= maxHeight) {
        height = maxHeight;
        width = maxHeight * aspectRatio;
      }
    } // Prevent child components from growing (aka "the Peter Pan effect")


    var style = {
      maxWidth: width,
      maxHeight: height
    };
    var className = classNames$g("fixed-to-responsive", this.props.className);
    var container = /*#__PURE__*/React$24.createElement("div", {
      className: className,
      style: style
    }, spacer, this.props.children);
    var shouldFullBleed = this.props.allowFullBleed && this.state.viewportWidth && width >= this.state.viewportWidth;

    if (shouldFullBleed) {
      return /*#__PURE__*/React$24.createElement("div", {
        style: {
          marginLeft: negativePhoneMargin,
          marginRight: negativePhoneMargin
        }
      }, container);
    } else {
      return container;
    }
  }
});
_module_$26.exports = FixedToResponsive$2;
var _componentsFixedToResponsiveJsx = _module_$26.exports;

var _module_$25 = {
  exports: {}
};
/* globals KA */

var classNames$f = _classnames__default["default"];
var React$23 = _react__default["default"];
var $$4 = $__default["default"];
var _$1l = _underscore__default["default"];
var FixedToResponsive$1 = _componentsFixedToResponsiveJsx;
var Graphie$6 = _componentsGraphieJsx;
var ImageLoader = _componentsImageLoaderJsx;
var Util$n = Util$q;
var Zoom = _zoomJs; // Minimum image width to make an image appear as zoomable.

var ZOOMABLE_THRESHOLD = 700; // The global cache of label data. Its format is:
// {
//   hash (e.g. "c21435944d2cf0c8f39d9059cb35836aa701d04a"): {
//     loaded: a boolean of whether the data has been loaded or not
//     dataCallbacks: a list of callbacks to call with the data when the data
//                    is loaded
//     data: the other data for this hash
//   },
//   ...
// }

var labelDataCache = {}; // Write our own JSONP handler because all the other ones don't do things we
// need.

var doJSONP = function doJSONP(url, options) {
  options = _objectSpread2({
    callbackName: "callback",
    success: $$4.noop,
    error: $$4.noop
  }, options); // Create the script

  var script = document.createElement("script");
  script.setAttribute("async", "");
  script.setAttribute("src", url); // A cleanup function to run when we're done.

  function cleanup() {
    document.head.removeChild(script);
    delete window[options.callbackName];
  } // Add the global callback.


  window[options.callbackName] = function () {
    cleanup();
    options.success.apply(null, arguments);
  }; // Add the error handler.


  script.addEventListener("error", function () {
    cleanup();
    options.error.apply(null, arguments);
  }); // Insert the script to start the download.

  document.head.appendChild(script);
};

var hashRegex = /\/([^/]+)$/;

function isImageProbablyPhotograph(imageUrl) {
  // TODO(david): Do an inventory to refine this heuristic. For example, what
  //     % of .png images are illustrations?
  return /\.(jpg|jpeg)$/i.test(imageUrl);
}

function shouldUseLocalizedData() {
  // TODO(emily): Remove this depenency on `KA` and pass it down with
  // Perseus' initialization. (Also used in renderer.jsx)
  return typeof KA !== "undefined" && KA.language !== "en";
}

function shouldRenderJipt() {
  return typeof KA !== "undefined" && KA.language === "en-pt";
}

var jiptLabels = [];

if (shouldRenderJipt()) {
  if (!KA.jipt_dom_insert_checks) {
    KA.jipt_dom_insert_checks = [];
  }

  KA.jipt_dom_insert_checks.push(function (text, node, attribute) {
    var index = $$4(node).data("jipt-label-index");

    if (node && typeof index !== "undefined") {
      var {
        label,
        useMath
      } = jiptLabels[index];
      label.text("");
      text = maybeUnescape(text);

      if (useMath) {
        var mathRegex = /^\$(.*)\$$/;
        var match = text.match(mathRegex);
        var mathText = match ? match[1] : "\\color{red}{\\text{Invalid Math}}";
        label.processMath(mathText, true);
      } else {
        label.processText(text);
      }

      return false;
    }

    return text;
  });
} // Get the hash from the url, which is just the filename


function getUrlHash(url) {
  var match = url.match(hashRegex);
  return match && match[1];
}

function defaultPreloader() {
  return ReactDOMtags.span({
    style: {
      background: "url(/images/spinner.gif) no-repeat",
      backgroundPosition: "center",
      width: "100%",
      height: "100%",
      position: "absolute",
      minWidth: "20px"
    }
  });
}

var SvgImage$6 = createReactClass({
  displayName: "SvgImage",
  propTypes: {
    allowFullBleed: PropTypes.bool,
    alt: PropTypes.string,
    constrainHeight: PropTypes.bool,
    extraGraphie: PropTypes.shape({
      box: PropTypes.array.isRequired,
      range: PropTypes.array.isRequired,
      labels: PropTypes.array.isRequired
    }),
    height: PropTypes.number,
    // When the DOM updates to replace the preloader with the image, or
    // vice-versa, we trigger this callback.
    onUpdate: PropTypes.func,
    preloader: PropTypes.func,
    // By default, this component attempts to be responsive whenever
    // possible (specifically, when width and height are passed in).
    // You can expliclty force unresponsive behavior by *either*
    // not passing in width/height *or* setting this prop to false.
    // The difference is that forcing via this prop will result in
    // explicit width and height styles being set on the rendered
    // component.
    responsive: PropTypes.bool,
    scale: PropTypes.number,
    src: PropTypes.string.isRequired,
    title: PropTypes.string,
    trackInteraction: PropTypes.func,
    width: PropTypes.number,
    // Whether clicking this image will allow it to be fully zoomed in to
    // its original size on click, and allow the user to scroll in that
    // state. This also does some hacky viewport meta tag changing to
    // ensure this works on mobile devices, so I (david@) don't recommend
    // enabling this on desktop yet.
    zoomToFullSizeOnMobile: PropTypes.bool
  },
  statics: {
    // Sometimes other components want to download the actual image e.g. to
    // determine its size. Here, we transform an .svg-labels url into the
    // correct image url, and leave normal image urls alone
    getRealImageUrl: getRealImageUrl
  },
  getDefaultProps: function getDefaultProps() {
    return {
      constrainHeight: false,
      onUpdate: () => {},
      responsive: true,
      src: "",
      scale: 1,
      zoomToFullSizeOnMobile: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      imageLoaded: false,
      imageDimensions: null,
      dataLoaded: false,
      labelDataIsLocalized: false,
      labels: [],
      range: [[0, 0], [0, 0]]
    };
  },
  componentDidMount: function componentDidMount() {
    if (isLabeledSVG(this.props.src)) {
      this.loadResources();
    }
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (this.props.src !== nextProps.src) {
      this.setState({
        imageLoaded: false,
        dataLoaded: false
      });
    }
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    // If the props changed, we definitely need to update
    if (!_$1l.isEqual(this.props, nextProps)) {
      return true;
    }

    if (!isLabeledSVG(nextProps.src)) {
      return false;
    }

    var wasLoaded = this.isLoadedInState(this.state);
    var nextLoaded = this.isLoadedInState(nextState);
    return wasLoaded !== nextLoaded;
  },
  componentDidUpdate: function componentDidUpdate() {
    if (isLabeledSVG(this.props.src) && !this.isLoadedInState(this.state)) {
      this.loadResources();
    }
  },
  // Check if all of the resources are loaded in a given state
  isLoadedInState: function isLoadedInState(state) {
    return state.imageLoaded && state.dataLoaded;
  },
  loadResources: function loadResources() {
    var hash = getUrlHash(this.props.src); // We can't make multiple jsonp calls to the same file because their
    // callbacks will collide with each other. Instead, we cache the data
    // and only make the jsonp calls once.

    if (labelDataCache[hash]) {
      if (labelDataCache[hash].loaded) {
        var {
          data,
          localized
        } = labelDataCache[hash];
        this.onDataLoaded(data, localized);
      } else {
        labelDataCache[hash].dataCallbacks.push(this.onDataLoaded);
      }
    } else {
      var cacheData = {
        loaded: false,
        dataCallbacks: [this.onDataLoaded],
        data: null,
        localized: shouldUseLocalizedData()
      };
      labelDataCache[hash] = cacheData;

      var retrieveData = (url, errorCallback) => {
        doJSONP(url, {
          callbackName: "svgData" + hash,
          success: data => {
            cacheData.data = data;
            cacheData.loaded = true;

            _$1l.each(cacheData.dataCallbacks, callback => {
              callback(cacheData.data, cacheData.localized);
            });
          },
          error: errorCallback
        });
      };

      if (shouldUseLocalizedData()) {
        retrieveData(getLocalizedDataUrl(this.props.src), (x, status, error) => {
          cacheData.localized = false; // If there is isn't any localized data, fall back to
          // the original, unlocalized data

          retrieveData(getDataUrl(this.props.src), (x, status, error) => {
            // eslint-disable-next-line no-console
            console.error("Data load failed:", getDataUrl(this.props.src), error);
          });
        });
      } else {
        retrieveData(getDataUrl(this.props.src), (x, status, error) => {
          // eslint-disable-next-line no-console
          console.error("Data load failed:", getDataUrl(this.props.src), error);
        });
      }
    }
  },
  onDataLoaded: function onDataLoaded(data, localized) {
    if (this.isMounted() && data.labels && data.range) {
      this.setState({
        dataLoaded: true,
        labelDataIsLocalized: localized,
        labels: data.labels,
        range: data.range
      });
    }
  },
  sizeProvided: function sizeProvided() {
    return this.props.width != null && this.props.height != null;
  },
  onImageLoad: function onImageLoad() {
    // Only need to do this if rendering a Graphie
    if (this.sizeProvided()) {
      // If width and height are provided, we don't need to calculate the
      // size ourselves
      this.setState({
        imageLoaded: true
      });
    } else {
      Util$n.getImageSize(this.props.src, (width, height) => {
        if (this.isMounted()) {
          this.setState({
            imageLoaded: true,
            imageDimensions: [width, height]
          });
        }
      });
    }
  },
  setupGraphie: function setupGraphie(graphie, options) {
    _$1l.map(options.labels, labelData => {
      if (shouldRenderJipt() && this.state.labelDataIsLocalized) {
        // If we're using JIPT translation and we got proper JIPT tags,
        // render the labels as plain text (so JIPT can find them) and
        // add some extra properties to the element so we can properly
        // re-render the label once it is replaced with translated
        // text.
        var elem = graphie.label(labelData.coordinates, labelData.content, labelData.alignment, false);
        $$4(elem).data("jipt-label-index", jiptLabels.length);
        jiptLabels.push({
          label: elem,
          useMath: labelData.typesetAsMath
        });
      } else if (labelData.coordinates) {
        // Create labels from the data
        // TODO(charlie): Some erroneous labels are being sent down
        // without coordinates. They don't seem to have any content, so
        // it seems fine to just ignore them (rather than error), but
        // we should figure out why this is happening.
        var label = graphie.label(labelData.coordinates, labelData.content, labelData.alignment, labelData.typesetAsMath, {
          "font-size": 100 * this.props.scale + "%"
        }); // Convert absolute positioning css from pixels to percentages
        // TODO(alex): Dynamically resize font-size as well. This
        // almost certainly means listening to throttled window.resize
        // events.

        var labelStyle = label[0].style;

        var labelTop = this._tryGetPixels(labelStyle.top);

        var labelLeft = this._tryGetPixels(labelStyle.left);

        if (labelTop === null || labelLeft === null) {
          // Graphie labels are supposed to have an explicit position,
          // but to be on the safe side, let's fall back to using
          // jQuery's position(). The reason we're not always using
          // this is that in the presence of CSS transforms, it will
          // give the rendered position, which may be scaled and
          // not equal to the explicitly specified one.
          var labelPosition = label.position();
          labelTop = labelPosition.top;
          labelLeft = labelPosition.left;
        }

        var svgHeight = this.props.height * this.props.scale;
        var svgWidth = this.props.width * this.props.scale;
        label.css({
          top: labelTop / svgHeight * 100 + "%",
          left: labelLeft / svgWidth * 100 + "%"
        }); // Add back the styles to each of the labels

        _$1l.each(labelData.style, (styleValue, styleName) => {
          label.css(styleName, styleValue);
        });
      }
    });
  },
  // Try to parse a CSS value as pixels. Returns null if the parameter string
  // does not contain a number followed by "px".
  _tryGetPixels: function _tryGetPixels(value) {
    value = value || ""; // While this doesn't check that there are no other alphabetical
    // characters prior to "px", that should be taken care of by the DOM,
    // which won't accept invalid units.

    if (!value.endsWith("px")) {
      return null;
    } // parseFloat() ignores trailing non-numerical characters.


    return parseFloat(value) || null;
  },
  _handleZoomClick: function _handleZoomClick(e) {
    var $image = $$4(e.target); // It's possible that the image is already displayed at its
    // full size, but we don't really know that until we get a chance
    // to measure it (just now, after the user clicks). We only zoom
    // if there's more image to be shown.
    //
    // TODO(kevindangoor) If the window is narrow and the image is
    // already displayed as wide as possible, we may want to do
    // nothing in that case as well. Figuring this out correctly
    // likely required accounting for the image alignment and margins.

    if ($image.width() < this.props.width || this.props.zoomToFullSizeOnMobile) {
      Zoom.ZoomService.handleZoomClick(e, this.props.zoomToFullSizeOnMobile);
    }

    this.props.trackInteraction && this.props.trackInteraction();
  },
  render: function render() {
    var imageSrc = this.props.src; // Props to send to all images

    var imageProps = {
      alt: this.props.alt,
      title: this.props.title
    };
    var width = this.props.width && this.props.width * this.props.scale;
    var height = this.props.height && this.props.height * this.props.scale;
    var dimensions = {
      width: width,
      height: height
    }; // To make an image responsive, we need to know what its width and
    // height are in advance (before inserting it into the DOM) so that we
    // can ensure it doesn't grow past those limits. We don't always have
    // this information, especially in places where <Renderer /> is used
    // to render inline Markdown images within a widget. See Radio, Sorter,
    // Matcher, etc.
    // TODO(alex): Make all of those image rendering locations aware of
    // width+height so that they too can render responsively.

    var responsive = this.props.responsive && !!(width && height); // An additional <Graphie /> may be inserted after the image/graphie
    // pair. Only used by the image widget, for its legacy labels support.
    // Note that since the image widget always provides width and height
    // data, extraGraphie can be ignored for unresponsive images.
    // TODO(alex): Convert all existing uses of that to web+graphie. This
    // is tricky because web+graphie doesn't support labels on non-graphie
    // images.

    var extraGraphie;

    if (this.props.extraGraphie && this.props.extraGraphie.labels.length) {
      extraGraphie = /*#__PURE__*/React$23.createElement(Graphie$6, {
        box: this.props.extraGraphie.box,
        range: this.props.extraGraphie.range,
        options: {
          labels: this.props.extraGraphie.labels
        },
        responsive: true,
        addMouseLayer: false,
        setup: this.setupGraphie
      });
    } // If preloader is undefined, we use the default. If it's
    // null, there will be no preloader in use.


    var preloaderBaseFunc = this.props.preloader === undefined ? defaultPreloader : this.props.preloader;
    var preloader = preloaderBaseFunc ? () => preloaderBaseFunc(dimensions) : null; // Just use a normal image if a normal image is provided

    if (!isLabeledSVG(imageSrc)) {
      if (responsive) {
        var wrapperClasses = classNames$f({
          zoomable: width > ZOOMABLE_THRESHOLD,
          "svg-image": true
        });
        imageProps.onClick = this._handleZoomClick;
        return /*#__PURE__*/React$23.createElement(FixedToResponsive$1, {
          className: wrapperClasses,
          width: width,
          height: height,
          constrainHeight: this.props.constrainHeight,
          allowFullBleed: this.props.allowFullBleed && isImageProbablyPhotograph(imageSrc)
        }, /*#__PURE__*/React$23.createElement(ImageLoader, {
          src: imageSrc,
          imgProps: imageProps,
          preloader: preloader,
          onUpdate: this.props.onUpdate
        }), extraGraphie);
      } else {
        imageProps.style = dimensions;
        return /*#__PURE__*/React$23.createElement(ImageLoader, {
          src: imageSrc,
          preloader: preloader,
          imgProps: imageProps,
          onUpdate: this.props.onUpdate
        });
      }
    }

    var imageUrl = getSvgUrl(imageSrc);
    var graphie; // Since we only want to do the graphie setup once, we only render the
    // graphie once everything is loaded

    if (this.isLoadedInState(this.state)) {
      // Use the provided width and height to size the graphie if
      // possible, otherwise use our own calculated size
      var box;

      if (this.sizeProvided()) {
        box = [width, height];
      } else {
        box = [this.state.imageDimensions[0] * this.props.scale, this.state.imageDimensions[1] * this.props.scale];
      }

      var scale = [40 * this.props.scale, 40 * this.props.scale];
      graphie = /*#__PURE__*/React$23.createElement(Graphie$6, {
        ref: "graphie",
        box: box,
        scale: scale,
        range: this.state.range,
        options: _$1l.pick(this.state, "labels"),
        responsive: responsive,
        addMouseLayer: false,
        setup: this.setupGraphie
      });
    }

    if (responsive) {
      return /*#__PURE__*/React$23.createElement(FixedToResponsive$1, {
        className: "svg-image",
        width: width,
        height: height,
        constrainHeight: this.props.constrainHeight
      }, /*#__PURE__*/React$23.createElement(ImageLoader, {
        src: imageUrl,
        onLoad: this.onImageLoad,
        onUpdate: this.props.onUpdate,
        preloader: preloader,
        imgProps: imageProps
      }), graphie, extraGraphie);
    } else {
      imageProps.style = dimensions;
      return /*#__PURE__*/React$23.createElement("div", {
        className: "unresponsive-svg-image",
        style: dimensions
      }, /*#__PURE__*/React$23.createElement(ImageLoader, {
        src: imageUrl,
        onLoad: this.onImageLoad,
        onUpdate: this.props.onUpdate,
        preloader: preloader,
        imgProps: imageProps
      }), graphie);
    }
  }
});
_module_$25.exports = SvgImage$6;
var _componentsSvgImageJsx = _module_$25.exports;

var _module_$24 = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$22 = _react__default["default"];
var QuestionParagraph$1 = createReactClass({
  displayName: "QuestionParagraph",
  render: function render() {
    var className = this.props.className ? "paragraph " + this.props.className : "paragraph"; // For perseus-article just-in-place-translation (jipt), we need
    // to attach some metadata to top-level QuestionParagraphs:

    return /*#__PURE__*/React$22.createElement("div", {
      className: className,
      "data-perseus-component-index": this.props.translationIndex,
      "data-perseus-paragraph-index": this.props.paragraphIndex
    }, this.props.children);
  }
});
_module_$24.exports = QuestionParagraph$1;
var _questionParagraphJsx = _module_$24.exports;

var _module_$23 = {
  exports: {}
};
/**
 * Paragraph parsing/splitting for article jipt i18n
 */

var SimpleMarkdown$1 = _simpleMarkdown__default["default"];
var arrayRules = {
  fence: {
    match: SimpleMarkdown$1.defaultRules.fence.match,
    order: 1,
    parse: (capture, state, _parse) => capture[3]
  },
  paragraph: {
    match: SimpleMarkdown$1.defaultRules.paragraph.match,
    order: 2,
    parse: (capture, state, _parse2) => capture[1]
  }
};
var builtArrayParser = SimpleMarkdown$1.parserFor(arrayRules); // This should just return an array of strings! magick!

var parseToArray = source => {
  // Remove any leading newlines to avoid splitting weirdness
  // (simple-markdown has the `newline` rule for this, and i have
  // no idea how this will handle leading newlines without that rule),
  // and add \n\n to let it parse at a block/paragraph level
  var paragraphedSource = source.replace(/^\n\s*\n/, "") + "\n\n";
  return builtArrayParser(paragraphedSource, {
    inline: false
  });
};

var joinFromArray = paragraphs => paragraphs.join("\n\n");

_module_$23.exports = {
  parseToArray: parseToArray,
  joinFromArray: joinFromArray
};
var _jiptParagraphsJsx = _module_$23.exports;

// last call. The timer is reset if the lint is called during the wait.

var DEBOUNCE_TIMEOUT = 1000;
class NotGorgon {
  constructor() {
    _defineProperty(this, "previousContent", null);

    _defineProperty(this, "runLinter", _underscore.debounce((perseusStr, onLintErrorsGenerated) => {
      // $FlowFixMe -- TODO(joshuan): use an api flag instead?
      if (typeof KA === "undefined") {
        return;
      }

      if (perseusStr === this.previousContent) {
        return;
      }

      this.previousContent = perseusStr;

      if (perseusStr === "") {
        onLintErrorsGenerated([]);
        return;
      }

      fetch("/api/internal/translate/lint_poentry?preview=1&lang=en", {
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          // The poentry linter verifies that the translation from
          // the original text to the translated text is sane. We
          // want to ensure that the translation from English to
          // English is sane, so msgid === mstr.
          msgid: perseusStr,
          // msgid is the original text
          msgstr: perseusStr,
          // msgstr is the translated text
          format: "perseus_text",
          filename: ""
        }),
        method: "POST"
      }).then(response => {
        if (response.status >= 400) {
          return {
            status: "error",
            message: "Could not run i18n linter."
          };
        }

        return response.json();
      }, rejection => {
        return {
          status: "error",
          message: "Could not run i18n linter."
        };
      }).then(json => {
        if (json.status === "error") {
          onLintErrorsGenerated(["Some part of this text makes it untranslatable. " + "The specific message from the i18n linter was: " + json.message.replace(/\n/g, " ")]);
        } else {
          onLintErrorsGenerated([]);
        }
      });
    }, DEBOUNCE_TIMEOUT));
  }

  /**
   * Applies an array of errors generated by linters without position
   * information (NotGorgon and the legacy getSaveWarnings()) to the top
   * of a Perseus tree.
   */
  applyLintErrors(parsedMarkdown, notGorgonLintErrors) {
    // These lint errors do not have position data associated with
    // them, so we just plop them at the top.
    if (notGorgonLintErrors.length) {
      var errorText = notGorgonLintErrors.join("\n\n");
      parsedMarkdown.unshift({
        content: {
          type: "text",
          content: ""
        },
        insideTable: false,
        message: errorText,
        ruleName: "legacy-error",
        severity: Rule.Severity.ERROR,
        type: "lint"
      });
    }
  }

  destroy() {
    this.runLinter = null;
    this.previousContent = null;
  }

}

/* eslint-disable max-lines, no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals KA */

var $$3 = $__default["default"];
var React$21 = _react__default["default"];
var ReactDOM$x = _reactDom__default["default"];
var _$1k = _underscore__default["default"];
var classNames$e = _classnames__default["default"];
var JiptParagraphs = _jiptParagraphsJsx;
var PerseusMarkdown$3 = _perseusMarkdownJsx;
var QuestionParagraph = _questionParagraphJsx;
var SvgImage$5 = _componentsSvgImageJsx;
var TeX$7 = _reactComponentsTexJsx;
var WidgetContainer = _widgetContainerJsx;
var Widgets$2 = Widgets$5;
var Util$m = Util$q;
var ApiOptionsProps$1 = _mixinsApiOptionsPropsJs;
var ApiClassNames$d = _perseusApiJsx.ClassNames;
var Zoomable = _componentsZoomableJsx;
var Deferred = _deferredJs;
var preprocessTex$1 = _utilKatexPreprocessJs;
var Gorgon$6 = _gorgonGorgonJs; // The linter engine

var _module_$22 = {
  exports: {}
};
var {
  keypadElementPropType: keypadElementPropType$8
} = _mathInput__default["default"].propTypes;
var rContainsNonWhitespace = /\S/;
var rImageURL = /(web\+graphie|https):\/\/[^\s]*/;

var noopOnRender = () => {};

if (typeof KA !== "undefined" && KA.language === "en-pt") {
  // When using crowdin's jipt (Just in place translation), we need to keep a
  // registry of crowdinId's to component so that we can update the
  // component's state as the translator enters their translation.
  window.PerseusTranslationComponents = [];

  if (!KA.jipt_dom_insert_checks) {
    KA.jipt_dom_insert_checks = [];
  } // We add a function that will get called whenever jipt says the dom needs
  // to be updated


  KA.jipt_dom_insert_checks.push(function (text, node, attribute) {
    var $node = $$3(node);
    var index = $node.data("perseus-component-index");
    var paragraphIndex = $node.data("perseus-paragraph-index"); // We only update if we had added an index onto the node's data.

    if (node && typeof index !== "undefined") {
      var component = window.PerseusTranslationComponents[index];

      if (!component) {
        // The component has disappeared, so we tell jipt not to try
        // and insert anything
        return false;
      } // Jipt sometimes sends down the escaped translation, so we need to
      // unescape \\t to \t among other characters here


      text = maybeUnescape(text);
      component.replaceJiptContent(text, paragraphIndex); // Return false to tell jipt not to insert anything into the DOM
      // itself, otherwise it will mess up what React expects there to be

      return false;
    } // The string updated wasn't part of perseus, so we tell jipt to just
    // insert the translation as-is.


    return text;
  });
}

var SHOULD_CLEAR_WIDGETS_PROP_LIST = ["content", "problemNum", "widgets"]; // Check if one focus path / id path is a prefix of another
// The focus path null will never be a prefix of any non-null
// path, since it represents no focus.
// Otherwise, prefix is calculated by whether every array
// element in the prefix is present in the same position in the
// wholeArray path.

var isIdPathPrefix = function isIdPathPrefix(prefixArray, wholeArray) {
  if (prefixArray === null || wholeArray === null) {
    return prefixArray === wholeArray;
  }

  return _$1k.every(prefixArray, (elem, i) => {
    return _$1k.isEqual(elem, wholeArray[i]);
  });
};
/**
 * Wrapper for the trackInteraction apiOption.
 *
 * @param trackApi Original API
 * @param widgetType String name of the widget type
 * @param widgetID String ID of the widget instance
 * @param setting string setting for tracking (either "" for track once or
 *          "all")
 */


var InteractionTracker = function InteractionTracker(trackApi, widgetType, widgetID, setting) {
  if (!trackApi) {
    this.track = this._noop;
  } else {
    this._tracked = false;
    this.trackApi = trackApi;
    this.widgetType = widgetType;
    this.widgetID = widgetID;
    this.setting = setting;
    this.track = this._track.bind(this);
  }
};
/**
 * Function that actually calls the API to mark the interaction. This is
 * private. The public version is just `.track` and is bound to this object
 * for easy use in other context.
 *
 * @param extraData Any extra data to track about the event.
 * @private
 */


InteractionTracker.prototype._track = function (extraData) {
  if (this._tracked && !this.setting) {
    return;
  }

  this._tracked = true;
  this.trackApi(_objectSpread2({
    type: this.widgetType,
    id: this.widgetID
  }, extraData));
};
/**
 * This alternate version of `.track` does nothing as an optimization.
 *
 * @private
 */


InteractionTracker.prototype._noop = function () {};

var Renderer$n = createReactClass({
  displayName: "Renderer",
  propTypes: _objectSpread2(_objectSpread2({}, ApiOptionsProps$1.propTypes), {}, {
    alwaysUpdate: PropTypes.bool,
    findExternalWidgets: PropTypes.func,
    highlightedWidgets: PropTypes.arrayOf(PropTypes.any),
    ignoreMissingWidgets: PropTypes.bool,
    images: PropTypes.any,
    keypadElement: keypadElementPropType$8,
    onInteractWithWidget: PropTypes.func,
    onRender: PropTypes.func,
    problemNum: PropTypes.number,
    questionCompleted: PropTypes.bool,
    reviewMode: PropTypes.bool,
    serializedState: PropTypes.any,
    // Callback which is called when serialized state changes with the new
    // serialized state.
    onSerializedStateUpdated: PropTypes.func,
    // If linterContext.highlightLint is true, then content will be passed
    // to the linter and any warnings will be highlighted in the rendered
    // output.
    linterContext: linterContextProps,
    legacyPerseusLint: PropTypes.arrayOf(PropTypes.string)
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      content: "",
      widgets: {},
      images: {},
      // TODO(aria): Remove this now that it is true everywhere
      // (here and in perseus-i18n)
      ignoreMissingWidgets: true,
      highlightedWidgets: [],
      // onRender may be called multiple times per render, for example
      // if there are multiple images or TeX pieces within `content`.
      // It is a good idea to debounce any functions passed here.
      questionCompleted: false,
      onRender: noopOnRender,
      onInteractWithWidget: function onInteractWithWidget() {},
      findExternalWidgets: () => [],
      alwaysUpdate: false,
      reviewMode: false,
      serializedState: null,
      onSerializedStateUpdated: () => {},
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return _$1k.extend({
      jiptContent: null,
      // The i18n linter.
      // TODO(joshuan): If this becomes an ES6 class, move to a
      // member variable.
      notGorgon: new NotGorgon(),
      // NotGorgon is async and currently does not contain a location.
      // This is a list of error strings NotGorgon detected on its last
      // run.
      notGorgonLintErrors: []
    }, this._getInitialWidgetState());
  },
  componentDidMount: function componentDidMount() {
    this.handleRender({});
    this._currentFocus = null;
    this._rootNode = ReactDOM$x.findDOMNode(this);
    this._isMounted = true; // TODO(emily): actually make the serializedState prop work like a
    // controlled prop, instead of manually calling .restoreSerializedState
    // at the right times.

    if (this.props.serializedState) {
      this.restoreSerializedState(this.props.serializedState);
    }

    if (this.props.linterContext.highlightLint) {
      // Get i18n lint errors asynchronously. If there are lint errors,
      // this component will be rerendered.
      this.state.notGorgon.runLinter(this.props.content, this.handleNotGorgonLintErrors);
    }
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (!_$1k.isEqual(_$1k.pick(this.props, SHOULD_CLEAR_WIDGETS_PROP_LIST), _$1k.pick(nextProps, SHOULD_CLEAR_WIDGETS_PROP_LIST))) {
      this.setState(this._getInitialWidgetState(nextProps));
    }
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    if (this.props.alwaysUpdate) {
      // TOTAL hacks so that findWidgets doesn't break
      // when one widget updates without the other.
      // See passage-refs inside radios, which was why
      // this was introduced.
      // I'm sorry!
      // TODO(aria): cry
      return true;
    }

    var stateChanged = !_$1k.isEqual(this.state, nextState);
    var propsChanged = !_$1k.isEqual(this.props, nextProps);
    return propsChanged || stateChanged;
  },
  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
    var oldJipt = this.shouldRenderJiptPlaceholder(this.props, this.state);
    var newJipt = this.shouldRenderJiptPlaceholder(nextProps, nextState);
    var oldContent = this.getContent(this.props, this.state);
    var newContent = this.getContent(nextProps, nextState);
    var oldHighlightedWidgets = this.props.highlightedWidgets;
    var newHighlightedWidgets = nextProps.highlightedWidgets; // TODO(jared): This seems to be a perfect overlap with
    // "shouldComponentUpdate" -- can we just remove this
    // componentWillUpdate and the reuseMarkdown attr?
    // TODO(aria): The nextState.notGorgonLintErrors`),` seems to be semantically incorrect?

    this.reuseMarkdown = !oldJipt && !newJipt && oldContent === newContent && _$1k.isEqual(this.state.notGorgonLintErrors, // WARN(aria): I changed the , condition here to an &&
    nextState.notGorgonLintErrors) && ( // If we are running the linter then we need to know when
    // widgets have changed because we need for force the linter to
    // run when that happens. Note: don't do identity comparison here:
    // it can cause frequent re-renders that break MathJax somehow
    !this.props.linterContext.highlightLint || _$1k.isEqual(this.props.widgets, nextProps.widgets)) && // If the linter is turned on or off, we have to rerender
    this.props.linterContext.highlightLint === nextProps.linterContext.highlightLint && // yes, this is identity array comparison, but these are passed
    // in from state in the item-renderer, so they should be
    // identity equal unless something changed, and it's expensive
    // to loop through them to look for differences.
    // Technically, we could reuse the markdown when this changes,
    // but to do that we'd have to do more expensive checking of
    // whether a widget should be highlighted in the common case
    // where this array hasn't changed, so we just redo the whole
    // render if this changed
    oldHighlightedWidgets === newHighlightedWidgets;
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    this.handleRender(prevProps); // We even do this if we did reuse the markdown because
    // we might need to update the widget props on this render,
    // even though we have the same widgets.
    // WidgetContainers don't update their widgets' props when
    // they are re-rendered, so even if they've been
    // re-rendered we need to call these methods on them.

    _$1k.each(this.widgetIds, id => {
      var container = this.refs["container:" + id];
      container.replaceWidgetProps(this.getWidgetProps(id));
    });

    if (this.props.serializedState && !_$1k.isEqual(this.props.serializedState, this.getSerializedState())) {
      this.restoreSerializedState(this.props.serializedState);
    }

    if (this.props.linterContext.highlightLint) {
      // Get i18n lint errors asynchronously. If lint errors have changed
      // since the last run, this component will be rerendered.
      this.state.notGorgon.runLinter(this.props.content, this.handleNotGorgonLintErrors);
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    // Clean out the list of widgetIds when unmounting, as this list is
    // meant to be consistent with the refs controlled by the renderer, and
    // refs are also cleared out during unmounting.
    // (This may not be totally necessary, but mobile clients have been
    // seeing JS errors due to an inconsistency between the list of
    // widgetIds and the child refs of the renderer.
    // See: https://phabricator.khanacademy.org/D32420.)
    this.widgetIds = [];

    if (this.translationIndex != null) {
      window.PerseusTranslationComponents[this.translationIndex] = null;
    }

    this.state.notGorgon.destroy();
    this._isMounted = false;
  },

  getApiOptions() {
    return ApiOptionsProps$1.getApiOptions.call(this);
  },

  _getInitialWidgetState: function _getInitialWidgetState(props) {
    props = props || this.props;

    var allWidgetInfo = this._getAllWidgetsInfo(props);

    return {
      widgetInfo: allWidgetInfo,
      widgetProps: this._getAllWidgetsStartProps(allWidgetInfo, props)
    };
  },
  _getAllWidgetsInfo: function _getAllWidgetsInfo(props) {
    props = props || this.props;
    return mapObject(props.widgets, (widgetInfo, widgetId) => {
      if (!widgetInfo.type || !widgetInfo.alignment) {
        var newValues = {};

        if (!widgetInfo.type) {
          newValues.type = widgetId.split(" ")[0];
        }

        if (!widgetInfo.alignment) {
          newValues.alignment = "default";
        }

        widgetInfo = _$1k.extend({}, widgetInfo, newValues);
      }

      return Widgets$2.upgradeWidgetInfoToLatestVersion(widgetInfo);
    });
  },
  _getAllWidgetsStartProps: function _getAllWidgetsStartProps(allWidgetInfo, props) {
    return mapObject(allWidgetInfo, editorProps => {
      return Widgets$2.getRendererPropsForWidgetInfo(editorProps, props.problemNum);
    });
  },
  _getDefaultWidgetInfo: function _getDefaultWidgetInfo(widgetId) {
    var widgetIdParts = Util$m.rTypeFromWidgetId.exec(widgetId);

    if (widgetIdParts == null) {
      return {};
    }

    return {
      type: widgetIdParts[1],
      graded: true,
      options: {}
    };
  },
  _getWidgetInfo: function _getWidgetInfo(widgetId) {
    return this.state.widgetInfo[widgetId] || this._getDefaultWidgetInfo(widgetId);
  },
  renderWidget: function renderWidget(impliedType, id, state) {
    var widgetInfo = this.state.widgetInfo[id];

    if (widgetInfo && widgetInfo.alignment === "full-width") {
      state.foundFullWidth = true;
    }

    if (widgetInfo || this.props.ignoreMissingWidgets) {
      var type = widgetInfo && widgetInfo.type || impliedType;

      var shouldHighlight = _$1k.contains(this.props.highlightedWidgets, id); // By this point we should have no duplicates, which are
      // filtered out in this.render(), so we shouldn't have to
      // worry about using this widget key and ref:


      return /*#__PURE__*/React$21.createElement(WidgetContainer, {
        ref: "container:" + id,
        key: "container:" + id,
        type: type,
        initialProps: this.getWidgetProps(id),
        shouldHighlight: shouldHighlight,
        linterContext: Gorgon$6.pushContextStack(this.props.linterContext, "widget")
      });
    } else {
      return null;
    }
  },
  getWidgetProps: function getWidgetProps(id) {
    var _this = this;

    var apiOptions = this.getApiOptions();
    var widgetProps = this.state.widgetProps[id] || {}; // The widget needs access to its "rubric" at all times when in review
    // mode (which is really just part of its widget info).

    var reviewModeRubric = null;
    var widgetInfo = this.state.widgetInfo[id];

    if (this.props.reviewMode && widgetInfo) {
      reviewModeRubric = widgetInfo.options;
    }

    if (!this._interactionTrackers) {
      this._interactionTrackers = {};
    }

    var interactionTracker = this._interactionTrackers[id];

    if (!interactionTracker) {
      interactionTracker = this._interactionTrackers[id] = new InteractionTracker(apiOptions.trackInteraction, widgetInfo && widgetInfo.type, id, Widgets$2.getTracking(widgetInfo && widgetInfo.type));
    }

    return _objectSpread2(_objectSpread2({}, widgetProps), {}, {
      ref: id,
      widgetId: id,
      alignment: widgetInfo && widgetInfo.alignment,
      static: widgetInfo && widgetInfo.static,
      problemNum: this.props.problemNum,
      apiOptions: this.getApiOptions(this.props),
      keypadElement: this.props.keypadElement,
      questionCompleted: this.props.questionCompleted,
      onFocus: _$1k.partial(this._onWidgetFocus, id),
      onBlur: _$1k.partial(this._onWidgetBlur, id),
      findWidgets: this.findWidgets,
      reviewModeRubric: reviewModeRubric,
      onChange: function onChange(newProps, cb) {
        var silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _this._setWidgetProps(id, newProps, cb, silent);
      },
      trackInteraction: interactionTracker.track
    });
  },

  /**
  * Serializes the questions state so it can be recovered.
  *
  * The return value of this function can be sent to the
  * `restoreSerializedState` method to restore this state.
  *
  * If an instance of widgetProps is passed in, it generates the serialized
  * state from that instead of the current widget props.
  */
  getSerializedState: function getSerializedState(widgetProps) {
    return mapObject(widgetProps || this.state.widgetProps, (props, widgetId) => {
      var widget = this.getWidgetInstance(widgetId);

      if (widget && widget.getSerializedState) {
        return widget.getSerializedState();
      } else {
        return props;
      }
    });
  },
  restoreSerializedState: function restoreSerializedState(serializedState, callback) {
    // Do some basic validation on the serialized state (just make sure the
    // widget IDs are what we expect).
    var serializedWidgetIds = _$1k.keys(serializedState);

    var widgetPropIds = _$1k.keys(this.state.widgetProps); // If the two lists of IDs match (ignoring order)


    if (serializedWidgetIds.length !== widgetPropIds.length || _$1k.intersection(serializedWidgetIds, widgetPropIds).length !== serializedWidgetIds.length) {
      // eslint-disable-next-line no-console
      console.error("Refusing to restore bad serialized state:", serializedState, "Current props:", this.state.widgetProps);
      return;
    } // We want to wait until any children widgets who have a
    // restoreSerializedState function also call their own callbacks before
    // we declare that the operation is finished.


    var numCallbacks = 1;

    var fireCallback = () => {
      --numCallbacks;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this.setState({
      widgetProps: mapObject(serializedState, (props, widgetId) => {
        var widget = this.getWidgetInstance(widgetId);

        if (widget && widget.restoreSerializedState) {
          // Note that we probably can't call
          // `this.change()/this.props.onChange()` in this
          // function, so we take the return value and use
          // that as props if necessary so that
          // `restoreSerializedState` in a widget can
          // change the props as well as state.
          // If a widget has no props to change, it can
          // safely return null.
          ++numCallbacks;
          var restoreResult = widget.restoreSerializedState(props, fireCallback);
          return _$1k.extend({}, this.state.widgetProps[widgetId], restoreResult);
        } else {
          return props;
        }
      })
    }, fireCallback);
  },

  /**
   * Tell each of the radio widgets to show rationales for each of the
   * currently selected choices inside of them. If the widget is correct, it
   * shows rationales for all of the choices. This also disables interaction
   * with the choices that we show rationales for.
   */
  showRationalesForCurrentlySelectedChoices() {
    Object.keys(this.props.widgets).forEach(widgetId => {
      var widget = this.getWidgetInstance(widgetId);

      if (widget && widget.showRationalesForCurrentlySelectedChoices) {
        widget.showRationalesForCurrentlySelectedChoices(this._getWidgetInfo(widgetId).options);
      }
    });
  },

  /**
   * Tells each of the radio widgets to deselect any of the incorrect choices
   * that are currently selected (leaving correct choices still selected).
   */
  deselectIncorrectSelectedChoices() {
    // TODO(emily): this has the exact same structure as
    // showRationalesForCurrentlySelectedChoices above. Maybe DRY this up.
    Object.keys(this.props.widgets).forEach(widgetId => {
      var widget = this.getWidgetInstance(widgetId);

      if (widget && widget.deselectIncorrectSelectedChoices) {
        widget.deselectIncorrectSelectedChoices();
      }
    });
  },

  /**
   * Allows inter-widget communication.
   *
   * This function yields this Renderer's own internal widgets, and it's used
   * in two places.
   *
   * First, we expose our own internal widgets to each other by giving them
   * a `findWidgets` function that, in turn, calls this function.
   *
   * Second, we expose our own internal widgets to this Renderer's parent,
   * by allowing it to call this function directly. That way, it can hook us
   * up to other Renderers on the page, by writing a `findExternalWidgets`
   * prop that calls each other Renderer's `findInternalWidgets` function.
   *
   * Takes a `filterCriterion` on which widgets to return.
   * `filterCriterion` can be one of:
   *  * A string widget id
   *  * A string widget type
   *  * a function from (id, widgetInfo, widgetComponent) to true or false
   *
   * Returns an array of the matching widget components.
   *
   * If you need to do logic with more than the components, it is possible
   * to do such logic inside the filter, rather than on the result array.
   *
   * See the passage-ref widget for an example.
   *
   * "Remember: abilities are not inherently good or evil, it's how you use
   * them." ~ Kyle Katarn
   * Please use this one with caution.
   */
  findInternalWidgets: function findInternalWidgets(filterCriterion) {
    var filterFunc; // Convenience filters:
    // "interactive-graph 3" will give you [[interactive-graph 3]]
    // "interactive-graph" will give you all interactive-graphs

    if (typeof filterCriterion === "string") {
      if (filterCriterion.indexOf(" ") !== -1) {
        var widgetId = filterCriterion;

        filterFunc = (id, widgetInfo) => id === widgetId;
      } else {
        var widgetType = filterCriterion;

        filterFunc = (id, widgetInfo) => {
          return widgetInfo.type === widgetType;
        };
      }
    } else {
      filterFunc = filterCriterion;
    }

    var results = this.widgetIds.filter(id => {
      var widgetInfo = this._getWidgetInfo(id);

      var widget = this.getWidgetInstance(id);
      return filterFunc(id, widgetInfo, widget);
    }).map(this.getWidgetInstance);
    return results;
  },

  /**
   * Allows inter-widget communication.
   *
   * Includes both widgets internal to this Renderer, and external widgets
   * exposed by the `findExternalWidgets` prop.
   *
   * See `findInteralWidgets` for more information.
   */
  findWidgets: function findWidgets(filterCriterion) {
    return [...this.findInternalWidgets(filterCriterion), ...this.props.findExternalWidgets(filterCriterion)];
  },
  getWidgetInstance: function getWidgetInstance(id) {
    var ref = this.refs["container:" + id];

    if (!ref) {
      return null;
    }

    return ref.getWidget();
  },
  _onWidgetFocus: function _onWidgetFocus(id, focusPath) {
    if (focusPath === undefined) {
      focusPath = [];
    } else {
      if (!_$1k.isArray(focusPath)) {
        throw new Error("widget props.onFocus focusPath must be an Array, " + "but was" + JSON.stringify(focusPath));
      }
    }

    this._setCurrentFocus([id].concat(focusPath));
  },
  _onWidgetBlur: function _onWidgetBlur(id, blurPath) {
    var blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
    // before blur

    var fullPath = [id].concat(blurPath);

    if (!_$1k.isEqual(fullPath, blurringFocusPath)) {
      return;
    } // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused.
    // If a different widget was focused, we'll see an onBlur event
    // now, but then an onFocus event on a different element before
    // this callback is executed


    _$1k.defer(() => {
      if (_$1k.isEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    });
  },
  getContent: function getContent(props, state) {
    return state.jiptContent || props.content;
  },
  shouldRenderJiptPlaceholder: function shouldRenderJiptPlaceholder(props, state) {
    // TODO(aria): Pass this in via webapp as an apiOption
    return typeof KA !== "undefined" && KA.language === "en-pt" && state.jiptContent == null && props.content.indexOf("crwdns") !== -1;
  },
  replaceJiptContent: function replaceJiptContent(content, paragraphIndex) {
    if (paragraphIndex == null) {
      // we're not translating paragraph-wise; replace the whole content
      // (we could also theoretically check for apiOptions.isArticle
      // here, which is what causes paragraphIndex to not be null)
      this.setState({
        jiptContent: content
      });
    } else {
      // This is the same regex we use in perseus/translate.py to find
      // code blocks. We use it to count entire code blocks as
      // paragraphs.
      var codeFenceRegex = /^\s*(`{3,}|~{3,})\s*(\S+)?\s*\n([\s\S]+?)\s*\1\s*$/; // eslint-disable-line max-len

      if (codeFenceRegex.test(content)) ; else if (/\S\n\s*\n\S/.test(content)) {
        // Our "render the exact same QuestionParagraphs each time"
        // strategy will fail if we allow translating a paragraph
        // to more than one paragraph. This hack renders as a single
        // paragraph and lets the translator know to not use \n\n,
        // hopefully. We can't wait for linting because we can't
        // safely render the node.
        // TODO(aria): Check for the max number of backticks or tildes
        // in the content, and just render a red code block of the
        // content here instead?
        content = "$\\large{\\red{\\text{Please translate each " + "paragraph to a single paragraph.}}}$";
      } else if (/^\s*$/.test(content)) {
        // We similarly can't have an all-whitespace paragraph, or
        // we will parse it as the closing of the previous paragraph
        content = "$\\large{\\red{\\text{Translated paragraph is " + "currently empty}}}$";
      } // Split the paragraphs; we have to use getContent() in case
      // nothing has been translated yet (in which case we just have
      // this.props.content)


      var allContent = this.getContent(this.props, this.state);
      var paragraphs = JiptParagraphs.parseToArray(allContent);
      paragraphs[paragraphIndex] = content;
      this.setState({
        jiptContent: JiptParagraphs.joinFromArray(paragraphs)
      });
    }
  },
  // wrap top-level elements in a QuestionParagraph, mostly
  // for appropriate spacing and other css
  outputMarkdown: function outputMarkdown(ast, state) {
    if (_$1k.isArray(ast)) {
      // This is duplicated from simple-markdown
      // TODO(aria): Don't duplicate this logic
      var oldKey = state.key;
      var result = []; // map nestedOutput over the ast, except group any text
      // nodes together into a single string output.
      // NOTE(aria): These are never strings--always QuestionParagraphs
      // TODO(aria): We probably don't need this string logic here.

      var lastWasString = false;

      for (var i = 0; i < ast.length; i++) {
        state.key = i;
        state.paragraphIndex = i;
        var nodeOut = this.outputMarkdown(ast[i], state);
        var isString = typeof nodeOut === "string";

        if (isString && lastWasString) {
          result[result.length - 1] += nodeOut;
        } else {
          result.push(nodeOut);
        }

        lastWasString = isString;
      }

      state.key = oldKey;
      return result;
    } else {
      // !!! WARNING: Mutative hacks! mutates `this._foundTextNodes`:
      // because I wrote a bad interface to simple-markdown.js' `output`
      this._foundTextNodes = false;
      state.foundFullWidth = false;
      var output = this.outputNested(ast, state); // In Jipt-land, we need to render the exact same outer
      // QuestionParagraph nodes always. This means the number of
      // paragraphs needs to stay the same, and we can't modify
      // the classnames on the QuestionParagraphs or we'll destroy
      // the crowdin classnames. So we just only use the
      // 'paragraph' classname from the QuestionParagraph.
      // If this becomes a problem it would be easy to fix by wrapping
      // the nodes in an extra layer (hopefully only for jipt) that
      // handles the jipt classnames, and let this layer handle the
      // dynamic classnames.
      // We can't render the classes the first time and leave them
      // the same because we don't know at the time of the first
      // render whether they are full-bleed or centered, since they
      // only contain crowdin IDs like `crwdns:972384209:0...`

      var className;

      if (this.translationIndex != null) {
        className = null;
      } else {
        className = classNames$e({
          "perseus-paragraph-centered": !this._foundTextNodes,
          // There is only one node being rendered,
          // and it's a full-width widget.
          "perseus-paragraph-full-width": state.foundFullWidth && ast.content.length === 1
        });
      }

      return /*#__PURE__*/React$21.createElement(QuestionParagraph, {
        key: state.key,
        className: className,
        translationIndex: this.translationIndex,
        paragraphIndex: state.paragraphIndex
      }, output);
    }
  },
  // output non-top-level nodes or arrays
  outputNested: function outputNested(ast, state) {
    if (_$1k.isArray(ast)) {
      // This is duplicated from simple-markdown
      // TODO(aria): Don't duplicate this logic
      var oldKey = state.key;
      var result = []; // map nestedOutput over the ast, except group any text
      // nodes together into a single string output.

      var lastWasString = false;

      for (var i = 0; i < ast.length; i++) {
        state.key = i;
        var nodeOut = this.outputNested(ast[i], state);
        var isString = typeof nodeOut === "string";

        if (isString && lastWasString) {
          result[result.length - 1] += nodeOut;
        } else {
          result.push(nodeOut);
        }

        lastWasString = isString;
      }

      state.key = oldKey;
      return result;
    } else {
      return this.outputNode(ast, this.outputNested, state);
    }
  },
  // output individual AST nodes [not arrays]
  outputNode: function outputNode(node, nestedOutput, state) {
    var apiOptions = this.getApiOptions();
    var imagePlaceholder = apiOptions.imagePlaceholder;

    if (node.type === "widget") {
      var widgetPlaceholder = apiOptions.widgetPlaceholder;

      if (widgetPlaceholder) {
        return widgetPlaceholder;
      } // Widgets can contain text nodes, so we don't center them with
      // markdown magic here.
      // Instead, we center them with css magic in articles.less
      // /cry(aria)


      this._foundTextNodes = true;

      if (_$1k.contains(this.widgetIds, node.id)) {
        // We don't want to render a duplicate widget key/ref,
        // as this causes problems with react (for obvious
        // reasons). Instead we just notify the
        // hopefully-content-creator that they need to change the
        // widget id.
        return /*#__PURE__*/React$21.createElement("span", {
          key: state.key,
          className: "renderer-widget-error"
        }, "Widget [[", "\u2603", " ", node.id, "]] already exists.");
      } else {
        this.widgetIds.push(node.id);
        return this.renderWidget(node.widgetType, node.id, state);
      }
    } else if (node.type === "blockMath") {
      // We render math here instead of in perseus-markdown.jsx
      // because we need to pass it our onRender callback.
      var deferred = new Deferred();

      var onRender = node => {
        this.props.onRender && this.props.onRender(node);

        if (apiOptions.isMobile) {
          // `onRender` only returns a node on the initial render.
          if (node) {
            var katex = node.querySelector(".katex"); // Though MathJax's visible elements should have been
            // inserted into the DOM by now (and, thus, we should be
            // able to query for .MathJax instead), we're not seeing
            // that guarantee play out in practice. So we look for
            // either .MathJax or the script tag that is inserted
            // on initial render.
            // TODO(charlie): This works, but feels very brittle.
            // Figure out how we can call `onRender` only after the
            // elements have been inserted into the DOM.

            var mathjax = node.querySelector('script[type="math/tex"]') || node.querySelector(".MathJax");

            if (katex) {
              deferred.resolve();
            } else if (mathjax) {
              deferred.resolve();
            } else {
              throw new Error("No math present in Renderer");
            }
          }
        }
      };

      var content = /*#__PURE__*/React$21.createElement(TeX$7, {
        onRender: onRender,
        onResourceLoaded: onRender
      }, preprocessTex$1(node.content));
      var innerStyle = {
        // HACK(benkomalo): we only want horizontal scrolling, but
        // overflowX: 'auto' causes a vertical scrolling scrollbar
        // as well, despite the parent and child elements having
        // the exact same height. Force it to not scroll by
        // applying overflowY: 'hidden'
        overflowX: "auto",
        overflowY: "hidden",
        // HACK(kevinb): overflowY: 'hidden' inadvertently clips the
        // top and bottom of some fractions.  We add padding to the
        // top and bottom to avoid the clipping and then correct for
        // the padding by adding equal but opposite margins.
        paddingTop: 10,
        paddingBottom: 10,
        marginTop: -10,
        marginBottom: -10
      };

      if (apiOptions.isMobile) {
        // The style for the body of articles and exercises on mobile is
        // to have a 16px margin.  When a user taps to zoom math we'd
        // like the math to extend all the way to the edge of the page/
        // To achieve this affect we nest the Zoomable component in two
        // nested divs. The outer div has a negative margin to
        // counteract the margin on main perseus container.  The inner
        // div adds the margin back as padding so that when the math is
        // scaled out it's inset from the edge of the page.  When the
        // TeX component is full size it will extend to the edge of the
        // page if it's larger than the page.
        //
        // TODO(kevinb) automatically determine the margin size
        var margin = 16;
        var outerStyle = {
          marginLeft: -margin,
          marginRight: -margin
        };
        var horizontalPadding = {
          paddingLeft: margin,
          paddingRight: margin
        };

        var computeMathBounds = (parentNode, parentBounds) => {
          var textElement = parentNode.querySelector(".katex-html") || parentNode.querySelector(".MathJax");
          var textBounds = {
            width: textElement.offsetWidth,
            height: textElement.offsetHeight
          }; // HACK(benkomalo): when measuring math content, note that
          // sometimes it actually peeks outside of the
          // container in some cases. Just be conservative and use
          // the maximum value of the text and the parent. :(

          return {
            width: Math.max(parentBounds.width, textBounds.width),
            height: Math.max(parentBounds.height, textBounds.height)
          };
        };

        return /*#__PURE__*/React$21.createElement("div", {
          key: state.key,
          className: "perseus-block-math",
          style: outerStyle
        }, /*#__PURE__*/React$21.createElement("div", {
          className: "perseus-block-math-inner",
          style: _objectSpread2(_objectSpread2({}, innerStyle), horizontalPadding)
        }, /*#__PURE__*/React$21.createElement(Zoomable, {
          readyToMeasureDeferred: deferred,
          computeChildBounds: computeMathBounds
        }, content)));
      } else {
        return /*#__PURE__*/React$21.createElement("div", {
          key: state.key,
          className: "perseus-block-math"
        }, /*#__PURE__*/React$21.createElement("div", {
          className: "perseus-block-math-inner",
          style: innerStyle
        }, content));
      }
    } else if (node.type === "math") {
      // Replace uses of \begin{align}...\end{align} which KaTeX doesn't
      // support (yet) with \begin{aligned}...\end{aligned} which renders
      // the same is supported by KaTeX.  It does the same for align*.
      // TODO(kevinb) update content to use aligned instead of align.
      var tex = node.content.replace(/\{align[*]?\}/g, "{aligned}"); // We render math here instead of in perseus-markdown.jsx
      // because we need to pass it our onRender callback.

      return /*#__PURE__*/React$21.createElement("span", {
        key: state.key,
        style: {
          // If math is directly next to text, don't let it
          // wrap to the next line
          whiteSpace: "nowrap"
        }
      }, /*#__PURE__*/React$21.createElement("span", null), /*#__PURE__*/React$21.createElement(TeX$7, {
        onRender: this.props.onRender,
        onResourceLoaded: this.props.onRender
      }, tex), /*#__PURE__*/React$21.createElement("span", null));
    } else if (node.type === "image") {
      if (imagePlaceholder) {
        return imagePlaceholder;
      } // We need to add width and height to images from our
      // props.images mapping.
      // We do a _.has check here to avoid weird things like
      // 'toString' or '__proto__' as a url.


      var extraAttrs = _$1k.has(this.props.images, node.target) ? this.props.images[node.target] : null; // The width of a table column is determined by the widest table
      // cell within that column, but responsive images constrain
      // themselves to the width of their parent containers. Thus,
      // responsive images don't do very well within tables. To avoid
      // haphazard sizing, simply make images within tables unresponsive.
      // TODO(alex): Make tables themselves responsive.

      var responsive = !state.inTable;
      return /*#__PURE__*/React$21.createElement(SvgImage$5, _extends({
        key: state.key,
        src: PerseusMarkdown$3.sanitizeUrl(node.target),
        alt: node.alt,
        title: node.title,
        responsive: responsive,
        onUpdate: this.props.onRender,
        zoomToFullSizeOnMobile: apiOptions.isMobile && apiOptions.isArticle
      }, extraAttrs));
    } else if (node.type === "columns") {
      // Note that we have two columns. This is so we can put
      // a className on the outer renderer content for SAT.
      // TODO(aria): See if there is a better way we can do
      // things like this
      this._isTwoColumn = true; // but then render normally:

      return PerseusMarkdown$3.ruleOutput(node, nestedOutput, state);
    } else if (node.type === "text") {
      if (rContainsNonWhitespace.test(node.content)) {
        this._foundTextNodes = true;
      } // Used by the translator portal to replace image URLs with
      // placeholders, see preprocessWidgets in manticore-utils.js
      // for more details.


      if (imagePlaceholder && rImageURL.test(node.content)) {
        return imagePlaceholder;
      } else {
        return node.content;
      }
    } else if (node.type === "table" || node.type === "titledTable") {
      state.inTable = true;
      var output = PerseusMarkdown$3.ruleOutput(node, nestedOutput, state);
      state.inTable = false;

      if (!apiOptions.isMobile) {
        return output;
      }

      var _margin = 16;
      var _outerStyle = {
        marginLeft: -_margin,
        marginRight: -_margin
      };
      var _innerStyle = {
        paddingLeft: 0,
        paddingRight: 0
      };
      var wrappedOutput = /*#__PURE__*/React$21.createElement("div", {
        style: _objectSpread2(_objectSpread2({}, _innerStyle), {}, {
          overflowX: "auto"
        })
      }, /*#__PURE__*/React$21.createElement(Zoomable, {
        animateHeight: true
      }, output)); // TODO(benkomalo): how should we deal with tappable items inside
      // of tables?

      return /*#__PURE__*/React$21.createElement("div", {
        style: _outerStyle
      }, wrappedOutput);
    } else {
      // If it's a "normal" or "simple" markdown node, just
      // output it using its output rule.
      return PerseusMarkdown$3.ruleOutput(node, nestedOutput, state);
    }
  },
  handleRender: function handleRender(prevProps) {
    var onRender = this.props.onRender;
    var oldOnRender = prevProps.onRender; // In the common case of no callback specified, avoid this work.

    if (onRender !== noopOnRender || oldOnRender !== noopOnRender) {
      var $images = $$3(ReactDOM$x.findDOMNode(this)).find("img"); // Fire callback on image load...

      if (oldOnRender !== noopOnRender) {
        $images.off("load", oldOnRender);
      }

      if (onRender !== noopOnRender) {
        $images.on("load", onRender);
      }
    } // ...as well as right now (non-image, non-TeX or image from cache)


    onRender();
  },
  // Sets the current focus path
  // If the new focus path is not a prefix of the old focus path,
  // we send an onChangeFocus event back to our parent.
  _setCurrentFocus: function _setCurrentFocus(path) {
    var apiOptions = this.getApiOptions(); // We don't do this when the new path is a prefix because
    // that prefix is already focused (we're just in a more specific
    // area of it). This makes it safe to call _setCurrentFocus
    // whenever a widget is interacted with--we won't wipe out
    // our focus state if we are already focused on a subpart
    // of that widget (i.e. a transformation NumberInput inside
    // of a transformer widget).

    if (!isIdPathPrefix(path, this._currentFocus)) {
      var prevFocus = this._currentFocus;

      if (prevFocus) {
        this.blurPath(prevFocus);
      }

      this._currentFocus = path;

      if (apiOptions.onFocusChange != null) {
        apiOptions.onFocusChange(this._currentFocus, prevFocus);
      }
    }
  },
  focus: function focus() {
    var id;
    var focusResult;

    for (var i = 0; i < this.widgetIds.length; i++) {
      var widgetId = this.widgetIds[i];
      var widget = this.getWidgetInstance(widgetId);
      var widgetFocusResult = widget && widget.focus && widget.focus();

      if (widgetFocusResult) {
        id = widgetId;
        focusResult = widgetFocusResult;
        break;
      }
    }

    if (id) {
      // reconstruct a {path, element} focus object
      var path;

      if (_$1k.isObject(focusResult)) {
        // The result of focus was a {path, id} object itself
        path = [id].concat(focusResult.path || []);
      } else {
        // The result of focus was true or the like; just
        // construct a root focus object
        path = [id];
      }

      this._setCurrentFocus(path);

      return true;
    }
  },
  getDOMNodeForPath: function getDOMNodeForPath(path) {
    var widgetId = _$1k.first(path);

    var interWidgetPath = _$1k.rest(path); // Widget handles parsing of the interWidgetPath. If the path is empty
    // beyond the widgetID, as a special case we just return the widget's
    // DOM node.


    var widget = this.getWidgetInstance(widgetId);
    var getNode = widget.getDOMNodeForPath;

    if (getNode) {
      return getNode(interWidgetPath);
    } else if (interWidgetPath.length === 0) {
      return ReactDOM$x.findDOMNode(widget);
    }
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(path) {
    var widgetId = _$1k.first(path);

    var interWidgetPath = _$1k.rest(path);

    var widget = this.getWidgetInstance(widgetId);
    return widget.getGrammarTypeForPath(interWidgetPath);
  },
  getInputPaths: function getInputPaths() {
    var inputPaths = [];

    _$1k.each(this.widgetIds, widgetId => {
      var widget = this.getWidgetInstance(widgetId);

      if (widget.getInputPaths) {
        // Grab all input paths and add widgetID to the front
        var widgetInputPaths = widget.getInputPaths(); // Prefix paths with their widgetID and add to collective
        // list of paths.

        _$1k.each(widgetInputPaths, inputPath => {
          var relativeInputPath = [widgetId].concat(inputPath);
          inputPaths.push(relativeInputPath);
        });
      }
    });

    return inputPaths;
  },
  focusPath: function focusPath(path) {
    // No need to focus if it's already focused
    if (_$1k.isEqual(this._currentFocus, path)) {
      return;
    } else if (this._currentFocus) {
      // Unfocus old path, if exists
      this.blurPath(this._currentFocus);
    }

    var widgetId = _$1k.first(path);

    var interWidgetPath = _$1k.rest(path); // Widget handles parsing of the interWidgetPath


    var focusWidget = this.getWidgetInstance(widgetId).focusInputPath;
    focusWidget && focusWidget(interWidgetPath);
  },
  blurPath: function blurPath(path) {
    // No need to blur if it's not focused
    if (!_$1k.isEqual(this._currentFocus, path)) {
      return;
    }

    var widgetId = _$1k.first(path);

    var interWidgetPath = _$1k.rest(path);

    var widget = this.getWidgetInstance(widgetId); // We might be in the editor and blurring a widget that no
    // longer exists, so only blur if we actually found the widget

    if (widget) {
      var blurWidget = this.getWidgetInstance(widgetId).blurInputPath; // Widget handles parsing of the interWidgetPath

      blurWidget && blurWidget(interWidgetPath);
    }
  },
  blur: function blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  },
  serialize: function serialize() {
    var state = {};

    _$1k.each(this.state.widgetInfo, function (info, id) {
      var widget = this.getWidgetInstance(id);
      var s = widget.serialize();

      if (!_$1k.isEmpty(s)) {
        state[id] = s;
      }
    }, this);

    return state;
  },
  emptyWidgets: function emptyWidgets() {
    return _$1k.filter(this.widgetIds, id => {
      var widgetInfo = this._getWidgetInfo(id);

      var score = this.getWidgetInstance(id).simpleValidate(widgetInfo.options, null);
      return Util$m.scoreIsEmpty(score);
    });
  },
  _setWidgetProps: function _setWidgetProps(id, newProps, cb, // Widgets can call `onChange` with `silent` set to `true` to prevent
  // interaction events from being triggered in listeners.
  silent) {
    this.setState(prevState => {
      var widgetProps = _objectSpread2(_objectSpread2({}, prevState.widgetProps), {}, {
        [id]: _objectSpread2(_objectSpread2({}, prevState.widgetProps[id]), newProps)
      });

      if (!silent) {
        this.props.onSerializedStateUpdated(this.getSerializedState(widgetProps));
      }

      return {
        widgetProps
      };
    }, () => {
      var cbResult = cb && cb();

      if (!silent) {
        this.props.onInteractWithWidget(id);
      }

      if (cbResult !== false) {
        // TODO(jack): For some reason, some widgets don't always
        // end up in refs here, which is repro-able if you make an
        // [[ orderer 1 ]] and copy-paste this, then change it to
        // be an [[ orderer 2 ]]. The resulting Renderer ends up
        // with an "orderer 2" ref but not an "orderer 1" ref.
        // @_@??
        // TODO(jack): Figure out why this is happening and fix it
        // As far as I can tell, this is only an issue in the
        // editor-page, so doing this shouldn't break clients
        // hopefully
        this._setCurrentFocus([id]);
      }
    });
  },
  setInputValue: function setInputValue(path, newValue, focus) {
    var widgetId = _$1k.first(path);

    var interWidgetPath = _$1k.rest(path);

    var widget = this.getWidgetInstance(widgetId); // Widget handles parsing of the interWidgetPath.

    widget.setInputValue(interWidgetPath, newValue, focus);
  },

  /**
   * Returns an array of the widget `.getUserInput()` results
   */
  getUserInput: function getUserInput() {
    return _$1k.map(this.widgetIds, id => {
      return this.getWidgetInstance(id).getUserInput();
    });
  },

  /**
   * Returns an array of all widget IDs in the order they occur in
   * the content.
   */
  getWidgetIds: function getWidgetIds() {
    return this.widgetIds;
  },

  /**
   * WARNING: This is an experimental/temporary API and should not be relied
   *     upon in production code. This function may change its behavior or
   *     disappear without notice.
   *
   * Returns a treelike structure containing all widget IDs (this will
   * descend into group widgets as well).
   *
   * An example of what the structure looks like:
   *
   * [
   *    {id: "radio 1", children: []},
   *    {
   *        id: "group 1",
   *        children: [
   *            {id: "radio 1", children: []}
   *            {id: "radio 2", children: []}
   *        ]
   *    }
   * ]
   *
   * Widgets will be listed in the order that they appear in their renderer.
   *
   * Note: If a group hasn't been rendered yet, though, then its children
   * ids will not be returned.
   * TODO(marcia): We should figure out a way to either return the widget ids
   * without needing to render all-the-things, or we should probably have a
   * better pattern for requesting widget ids so we are more likely to get
   * one true answer.
   */
  getAllWidgetIds: function getAllWidgetIds() {
    // Recursively builds our result
    return _$1k.map(this.getWidgetIds(), id => {
      var groupPrefix = "group";

      if (id.substring(0, groupPrefix.length) === groupPrefix && this.getWidgetInstance(id)) {
        return {
          id: id,
          children: this.getWidgetInstance(id).getRenderer().getAllWidgetIds()
        };
      } // This is our base case


      return {
        id: id,
        children: []
      };
    });
  },

  /**
   * Returns the result of `.getUserInput()` for each widget, in
   * a map from widgetId to userInput.
   */
  getUserInputForWidgets: function getUserInputForWidgets() {
    return mapObjectFromArray(this.widgetIds, id => {
      return this.getWidgetInstance(id).getUserInput();
    });
  },

  /**
   * Returns an object mapping from widget ID to perseus-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */
  scoreWidgets: function scoreWidgets() {
    var widgetProps = this.state.widgetInfo;

    var onInputError = this.getApiOptions().onInputError || function () {};

    var gradedWidgetIds = _$1k.filter(this.widgetIds, id => {
      var props = widgetProps[id]; // props.graded is unset or true

      return props.graded == null || props.graded;
    });

    var widgetScores = {};

    _$1k.each(gradedWidgetIds, id => {
      var props = widgetProps[id];
      var widget = this.getWidgetInstance(id);

      if (!widget) {
        // This can occur if the widget has not yet been rendered
        return;
      }

      widgetScores[id] = widget.simpleValidate(props.options, onInputError);
    });

    return widgetScores;
  },

  /**
   * Grades the content.
   *
   * Returns a perseus-style score of {
   *     type: "invalid"|"points",
   *     message: string,
   *     earned: undefined|number,
   *     total: undefined|number
   * }
   */
  score: function score() {
    return _$1k.reduce(this.scoreWidgets(), Util$m.combineScores, Util$m.noScore);
  },
  guessAndScore: function guessAndScore() {
    var totalGuess = this.getUserInput();
    var totalScore = this.score();
    return [totalGuess, totalScore];
  },
  examples: function examples() {
    var widgets = this.widgetIds;

    var examples = _$1k.compact(_$1k.map(widgets, function (widget) {
      return widget.examples ? widget.examples() : null;
    })); // no widgets with examples


    if (!examples.length) {
      return null;
    }

    var allEqual = _$1k.all(examples, function (example) {
      return _$1k.isEqual(examples[0], example);
    }); // some widgets have different examples
    // TODO(alex): handle this better


    if (!allEqual) {
      return null;
    }

    return examples[0];
  },
  // NotGorgon callback
  handleNotGorgonLintErrors: function handleNotGorgonLintErrors(lintErrors) {
    if (!this._isMounted) {
      return;
    }

    this.setState({
      notGorgonLintErrors: lintErrors
    });
  },
  render: function render() {
    var apiOptions = this.getApiOptions();

    if (this.reuseMarkdown) {
      return this.lastRenderedMarkdown;
    }

    var content = this.getContent(this.props, this.state); // `this.widgetIds` is appended to in `this.outputMarkdown`:

    this.widgetIds = [];

    if (this.shouldRenderJiptPlaceholder(this.props, this.state)) {
      // Crowdin's JIPT (Just in place translation) uses a fake language
      // with language tag "en-pt" where the value of the translations
      // look like: {crwdns2657085:0}{crwdne2657085:0} where it keeps the
      // {crowdinId:ngettext variant}. We detect whether the current
      // content matches this, so we can take over rendering of
      // the perseus content as the translators interact with jipt.
      // We search for only part of the tag that crowdin uses to guard
      // against them changing the format on us. The full tag it looks
      // for can be found in https://cdn.crowdin.net/jipt/jipt.js
      // globalPhrase var.
      // If we haven't already added this component to the registry do so
      // now. showHints() may cause this component to be rerendered
      // before jipt has a chance to replace its contents, so this check
      // will keep us from adding the component to the registry a second
      // time.
      if (!this.translationIndex) {
        this.translationIndex = window.PerseusTranslationComponents.push(this) - 1;
      } // For articles, we add jipt data to individual paragraphs. For
      // exercises, we add it to the renderer and let translators
      // translate the entire thing. For the article equivalent of
      // this if block, search this file for where we render a
      // QuestionParagraph, and see the `isJipt:` parameter sent to
      // PerseusMarkdown.parse()


      if (!apiOptions.isArticle) {
        // We now need to output this tag, as jipt looks for it to be
        // able to replace it with a translation that it runs an ajax
        // call to get.  We add a data attribute with the index to the
        // Persues.TranslationComponent registry so that when jipt
        // calls its before_dom_insert we can lookup this component by
        // this attribute and render the text with markdown.
        return /*#__PURE__*/React$21.createElement("div", {
          "data-perseus-component-index": this.translationIndex
        }, content);
      }
    } // Hacks:
    // We use mutable state here to figure out whether the output
    // had two columns.
    // It is updated to true by `this.outputMarkdown` if a
    // column break is found
    // TODO(aria): We now have a state variable threaded through
    // simple-markdown output. We should mutate it instead of
    // state on this component to do this in a less hacky way.


    this._isTwoColumn = false; // Parse the string of markdown to a parse tree

    var parsedMarkdown = PerseusMarkdown$3.parse(content, {
      // Recognize crowdin IDs while translating articles
      // (This should never be hit by exercises, though if you
      // decide you want to add a check that this is an article,
      // go for it.)
      isJipt: this.translationIndex != null
    }); // Optionally apply the linter to the parse tree

    if (this.props.linterContext.highlightLint) {
      // If highlightLint is true and lint is detected, this call
      // will modify the parse tree by adding lint nodes that will
      // serve to highlight the lint when rendered
      var context = _objectSpread2({
        content: this.props.content,
        widgets: this.props.widgets
      }, this.props.linterContext);

      Gorgon$6.runLinter(parsedMarkdown, context, true); // Apply the lint errors from the last NotGorgon run.
      // TODO(joshuan): Support overlapping dots.

      this.state.notGorgon.applyLintErrors(parsedMarkdown, [...this.state.notGorgonLintErrors, ...(this.props.legacyPerseusLint || [])]);
    } // Render the linted markdown parse tree with React components


    var markdownContents = this.outputMarkdown(parsedMarkdown, {
      baseElements: apiOptions.baseElements
    });
    var className = classNames$e({
      [ApiClassNames$d.RENDERER]: true,
      [ApiClassNames$d.RESPONSIVE_RENDERER]: true,
      [ApiClassNames$d.TWO_COLUMN_RENDERER]: this._isTwoColumn
    });
    this.lastRenderedMarkdown = /*#__PURE__*/React$21.createElement("div", {
      className: className
    }, markdownContents);
    return this.lastRenderedMarkdown;
  }
});
_module_$22.exports = Renderer$n;
var _rendererJsx = _module_$22.exports;

var _module_$21 = {
  exports: {}
};
_module_$21.exports = {
  xs: "@media screen and (max-width: ".concat(pureXsMax, ")"),
  sm: "@media screen and (min-width: ".concat(pureSmMin, ") and ") + "(max-width: ".concat(pureSmMax, ")"),
  md: "@media screen and (min-width: ".concat(pureMdMin, ") and ") + "(max-width: ".concat(pureMdMax, ")"),
  lg: "@media screen and (min-width: ".concat(pureLgMin, ") and ") + "(max-width: ".concat(pureLgMax, ")"),
  xl: "@media screen and (min-width: ".concat(pureXlMin, ")"),
  smOrSmaller: "@media screen and (max-width: ".concat(pureSmMax, ")"),
  mdOrSmaller: "@media screen and (max-width: ".concat(pureMdMax, ")"),
  lgOrSmaller: "@media screen and (max-width: ".concat(pureLgMax, ")"),
  smOrLarger: "@media screen and (min-width: ".concat(pureSmMin, ")"),
  mdOrLarger: "@media screen and (min-width: ".concat(pureMdMin, ")"),
  lgOrLarger: "@media screen and (min-width: ".concat(pureLgMin, ")")
};
var _stylesMediaQueriesJs = _module_$21.exports;

var _module_$20 = {
  exports: {}
};
var mediaQueries$8 = _stylesMediaQueriesJs;
_module_$20.exports = aphrodite.StyleSheet.create({
  perseusInteractive: {
    zIndex: zIndexInteractiveComponent,
    position: "relative"
  },
  aboveScratchpad: {
    position: "relative",
    zIndex: zIndexAboveScratchpad
  },
  blankBackground: {
    // TODO(emily): Use KhanUtil._BACKGROUND?
    backgroundColor: "#FDFDFD"
  },
  perseusSrOnly: {
    border: 0,
    clip: "rect(0,0,0,0)",
    height: 1,
    margin: -1,
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: 1
  },
  responsiveLabel: {
    // NOTE(charlie): The values used here should be kept in sync with the
    // caption text sizing in articles.less.
    // TODO(charlie): Migrate the captions over to using this style.
    [mediaQueries$8.smOrSmaller]: {
      fontSize: 14,
      lineHeight: 1.3
    },
    [mediaQueries$8.md]: {
      fontSize: 17,
      lineHeight: 1.4
    },
    [mediaQueries$8.lgOrLarger]: {
      fontSize: 20,
      lineHeight: 1.4
    }
  },
  responsiveInput: {
    display: "inline-block",
    WebkitAppearance: "none",
    appearance: "none",
    "::-ms-check": {
      display: "none"
    },
    backgroundColor: "#fff",
    border: "2px solid #fff",
    boxShadow: "0 0px 0px 1px ".concat(radioBorderColor$1),
    outline: "none",
    boxSizing: "border-box",
    flexShrink: 0,
    marginBottom: 1,
    marginLeft: 1,
    marginRight: 1,
    marginTop: 1,
    height: circleSize - 2,
    width: circleSize - 2
  },
  responsiveRadioInput: {
    borderRadius: "50%",
    ":checked": {
      backgroundColor: checkedColor,
      border: "none",
      borderRadius: "50%",
      boxShadow: "inset 0px 0px 0px 2px white, " + "0 0px 0px 2px ".concat(checkedColor),
      marginTop: radioMarginWidth,
      marginBottom: radioMarginWidth,
      marginLeft: radioMarginWidth,
      marginRight: radioMarginWidth,
      height: circleSize - 2 * radioMarginWidth,
      width: circleSize - 2 * radioMarginWidth
    }
  },
  responsiveRadioInputActive: {
    backgroundColor: "#fff",
    border: "2px solid #fff",
    borderRadius: "50%",
    boxShadow: "0 0px 0px 2px ".concat(checkedColor),
    marginTop: radioMarginWidth,
    marginBottom: radioMarginWidth,
    marginLeft: radioMarginWidth,
    marginRight: radioMarginWidth,
    height: circleSize - 2 * radioMarginWidth,
    width: circleSize - 2 * radioMarginWidth,
    ":checked": {
      backgroundColor: "#fff"
    }
  },
  disableTextSelection: {
    userSelect: 'none'
  }
});
var _stylesSharedJs = _module_$20.exports;

var _module_$1$ = {
  exports: {}
};
var React$20 = _react__default["default"];
var classnames$1 = _classnames__default["default"];
var i18n$2 = window.i18n;
var Renderer$m = _rendererJsx;
var ApiOptions$w = _perseusApiJsx.Options;
var mediaQueries$7 = _stylesMediaQueriesJs;
var Gorgon$5 = _gorgonGorgonJs;
/* Renders just a hint preview */

var HintRenderer$1 = createReactClass({
  displayName: "HintRenderer",
  propTypes: {
    apiOptions: ApiOptions$w.propTypes,
    className: PropTypes.string,
    hint: PropTypes.any,
    lastHint: PropTypes.bool,
    lastRendered: PropTypes.bool,
    pos: PropTypes.number,
    totalHints: PropTypes.number,
    findExternalWidgets: PropTypes.func,
    linterContext: linterContextProps
  },

  getDefaultProps() {
    return {
      linterContext: linterContextDefault
    };
  },

  getSerializedState: function getSerializedState() {
    return this.refs.renderer.getSerializedState();
  },
  restoreSerializedState: function restoreSerializedState(state, callback) {
    this.refs.renderer.restoreSerializedState(state, callback);
  },
  render: function render() {
    var {
      apiOptions,
      className,
      hint,
      lastHint,
      lastRendered,
      pos,
      totalHints
    } = this.props;
    var {
      isMobile
    } = apiOptions;
    var classNames = classnames$1(!isMobile && "perseus-hint-renderer", isMobile && aphrodite.css(styles$q.newHint), isMobile && lastRendered && aphrodite.css(styles$q.lastRenderedNewHint), lastHint && "last-hint", lastRendered && "last-rendered", className); // TODO(charlie): Allowing `staticRender` here would require that we
    // extend `HintsRenderer` and `HintRenderer` to implement the full
    // "input' API, so that clients could access the static inputs. Allowing
    // `customKeypad` would require that we extend `ItemRenderer` to support
    // nested inputs in the `HintsRenderer`. For now, we disable these
    // options. Instead, clients will get standard <input/> elements, which
    // aren't nice to use on mobile, but are at least usable.

    var rendererApiOptions = _objectSpread2(_objectSpread2({}, apiOptions), {}, {
      customKeypad: false,
      staticRender: false
    });

    return /*#__PURE__*/React$20.createElement("div", {
      className: classNames,
      tabIndex: "-1"
    }, !apiOptions.isMobile && /*#__PURE__*/React$20.createElement("span", {
      className: "perseus-sr-only"
    }, i18n$2._("Hint #%(pos)s", {
      pos: pos + 1
    })), !apiOptions.isMobile && !apiOptions.satStyling && totalHints && pos != null && /*#__PURE__*/React$20.createElement("span", {
      className: "perseus-hint-label",
      style: {
        display: "block",
        color: apiOptions.hintProgressColor
      }
    }, "".concat(pos + 1, " / ").concat(totalHints)), /*#__PURE__*/React$20.createElement(Renderer$m, {
      ref: "renderer",
      widgets: hint.widgets,
      content: hint.content || "",
      images: hint.images,
      apiOptions: rendererApiOptions,
      findExternalWidgets: this.props.findExternalWidgets,
      linterContext: Gorgon$5.pushContextStack(this.props.linterContext, "hint")
    }));
  }
});
var styles$q = aphrodite.StyleSheet.create({
  newHint: {
    marginBottom: 1.5 * baseUnitPx,
    borderLeftColor: gray97,
    borderLeftStyle: "solid",
    borderLeftWidth: hintBorderWidth,
    // Only apply left-padding on tablets, to avoid being flush with the
    // border. On phones, padding is applied internally by the child
    // renderers. Some content on phones that is rendered at full-bleed may
    // end up flush with the border, but that's acceptable for now.
    [mediaQueries$7.lgOrSmaller]: {
      paddingLeft: baseUnitPx
    },
    [mediaQueries$7.smOrSmaller]: {
      paddingLeft: 0
    },
    ":focus": {
      outline: "none"
    }
  },
  lastRenderedNewHint: {
    marginBottom: 0,
    borderLeftColor: kaGreen
  }
});
_module_$1$.exports = HintRenderer$1;
var _hintRendererJsx = _module_$1$.exports;

var _module_$1_ = {
  exports: {}
};
var React$1$ = _react__default["default"];
var ReactDOM$w = _reactDom__default["default"];
var classnames = _classnames__default["default"];
var _$1j = _underscore__default["default"];
var i18n$1 = window.i18n;
var HintRenderer = _hintRendererJsx;
var SvgImage$4 = _componentsSvgImageJsx;
var ApiOptionsProps = _mixinsApiOptionsPropsJs;
var mediaQueries$6 = _stylesMediaQueriesJs;
var sharedStyles$3 = _stylesSharedJs;
var Gorgon$4 = _gorgonGorgonJs;
var HintsRenderer$4 = createReactClass({
  displayName: "HintsRenderer",
  propTypes: _objectSpread2(_objectSpread2({}, ApiOptionsProps.propTypes), {}, {
    className: PropTypes.string,
    hints: PropTypes.arrayOf(PropTypes.any),
    hintsVisible: PropTypes.number,
    findExternalWidgets: PropTypes.func,
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      linterContext: linterContextDefault
    };
  },
  componentDidMount: function componentDidMount() {
    this._cacheHintImages();
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    if (!_$1j.isEqual(prevProps.hints, this.props.hints) || prevProps.hintsVisible !== this.props.hintsVisible) {
      this._cacheHintImages();
    } // When a new hint is displayed we immediately focus it


    if (prevProps.hintsVisible < this.props.hintsVisible) {
      var pos = this.props.hintsVisible - 1;
      ReactDOM$w.findDOMNode(this.refs["hintRenderer" + pos]).focus();
    }
  },
  _hintsVisible: function _hintsVisible() {
    if (this.props.hintsVisible == null || this.props.hintsVisible === -1) {
      return this.props.hints.length;
    } else {
      return this.props.hintsVisible;
    }
  },
  _cacheImagesInHint: function _cacheImagesInHint(hint) {
    _$1j.each(hint.images, (data, src) => {
      var image = new Image();
      image.src = SvgImage$4.getRealImageUrl(src);
    });
  },
  _cacheHintImages: function _cacheHintImages() {
    // Only cache images in the first hint at the start. When hints are
    // taken, cache images in the rest of the hints
    if (this._hintsVisible() > 0) {
      _$1j.each(this.props.hints, this._cacheImagesInHint);
    } else if (this.props.hints.length > 0) {
      this._cacheImagesInHint(this.props.hints[0]);
    }
  },

  getApiOptions() {
    return ApiOptionsProps.getApiOptions.call(this);
  },

  getSerializedState: function getSerializedState() {
    return _$1j.times(this._hintsVisible(), i => {
      return this.refs["hintRenderer" + i].getSerializedState();
    });
  },
  restoreSerializedState: function restoreSerializedState(state, callback) {
    // We need to wait until all the renderers are finished restoring their
    // state before we fire our callback.
    var numCallbacks = 1;

    var fireCallback = () => {
      --numCallbacks;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    _$1j.each(state, (hintState, i) => {
      var hintRenderer = this.refs["hintRenderer" + i]; // This is not ideal in that it doesn't restore state
      // if the hint isn't visible, but we can't exactly restore
      // the state to an unmounted renderer, so...
      // If you want to restore state to hints, make sure to
      // have the appropriate number of hints visible already.

      if (hintRenderer) {
        ++numCallbacks;
        hintRenderer.restoreSerializedState(hintState, fireCallback);
      }
    }); // This makes sure that the callback is fired if there aren't any
    // mounted renderers.


    fireCallback();
  },
  render: function render() {
    var apiOptions = this.getApiOptions();

    var hintsVisible = this._hintsVisible();

    var hints = [];
    this.props.hints.slice(0, hintsVisible).forEach((hint, i) => {
      var lastHint = i === this.props.hints.length - 1 && !/\*\*/.test(hint.content);
      var lastRendered = i === hintsVisible - 1;
      var renderer = /*#__PURE__*/React$1$.createElement(HintRenderer, {
        lastHint: lastHint,
        lastRendered: lastRendered,
        hint: hint,
        pos: i,
        totalHints: this.props.hints.length,
        ref: "hintRenderer" + i,
        key: "hintRenderer" + i,
        apiOptions: apiOptions,
        findExternalWidgets: this.props.findExternalWidgets,
        linterContext: Gorgon$4.pushContextStack(this.props.linterContext, "hints[" + i + "]")
      });

      if (hint.replace && hints.length > 0) {
        hints[hints.length - 1] = renderer;
      } else {
        hints.push(renderer);
      }
    });
    var showGetAnotherHint = apiOptions.getAnotherHint && hintsVisible > 0 && hintsVisible < this.props.hints.length;
    var hintRatioCopy = "(".concat(hintsVisible, "/").concat(this.props.hints.length, ")");
    var classNames = classnames(this.props.className, apiOptions.isMobile && hintsVisible > 0 && aphrodite.css(styles$p.mobileHintStylesHintsRenderer));
    return /*#__PURE__*/React$1$.createElement("div", {
      className: classNames
    }, apiOptions.isMobile && hintsVisible > 0 && /*#__PURE__*/React$1$.createElement("div", {
      className: aphrodite.css(styles$p.mobileHintStylesHintTitle, sharedStyles$3.responsiveLabel)
    }, i18n$1._("Hints")), hints, showGetAnotherHint && /*#__PURE__*/React$1$.createElement("button", {
      rel: "button",
      className: aphrodite.css(styles$p.linkButton, styles$p.getAnotherHintButton, apiOptions.isMobile && styles$p.mobileHintStylesGetAnotherHintButton),
      onClick: evt => {
        evt.preventDefault();
        evt.stopPropagation();
        apiOptions.getAnotherHint();
      }
    }, /*#__PURE__*/React$1$.createElement("span", {
      className: aphrodite.css(styles$p.plusText, apiOptions.isMobile && styles$p.mobileHintStylesPlusText)
    }, "+"), /*#__PURE__*/React$1$.createElement("span", {
      className: aphrodite.css(styles$p.getAnotherHintText)
    }, i18n$1._("Get another hint"), " ", hintRatioCopy)));
  }
});
var hintIndentation = baseUnitPx + hintBorderWidth;
var styles$p = aphrodite.StyleSheet.create({
  rendererMargins: {
    marginTop: baseUnitPx
  },
  linkButton: {
    cursor: "pointer",
    border: "none",
    backgroundColor: "transparent",
    fontSize: "100%",
    fontFamily: "inherit",
    fontWeight: "bold",
    color: kaGreen,
    padding: 0,
    position: "relative"
  },
  plusText: {
    fontSize: 20,
    position: "absolute",
    top: -3,
    left: 0
  },
  getAnotherHintText: {
    marginLeft: 16
  },
  mobileHintStylesHintsRenderer: {
    marginTop: 4 * baseUnitPx,
    border: "solid ".concat(gray85),
    borderWidth: "1px 0 0 0",
    position: "relative",
    ":before": {
      content: '""',
      display: "table",
      clear: "both"
    },
    ":after": {
      content: '""',
      display: "table",
      clear: "both"
    }
  },
  mobileHintStylesHintTitle: {
    fontFamily: "inherit",
    fontStyle: "normal",
    fontWeight: "bold",
    color: gray17,
    paddingTop: baseUnitPx,
    paddingBottom: 1.5 * baseUnitPx,
    [mediaQueries$6.lgOrSmaller]: {
      paddingLeft: 0
    },
    [mediaQueries$6.smOrSmaller]: {
      // On phones, ensure that the button is aligned with the hint body
      // content, which is inset at the standard `baseUnitPx`, plus an
      // additional `hintBorderWidth`.
      paddingLeft: hintIndentation
    }
  },
  getAnotherHintButton: {
    marginTop: 1.5 * baseUnitPx
  },
  mobileHintStylesGetAnotherHintButton: {
    [mediaQueries$6.lgOrSmaller]: {
      paddingLeft: 0
    },
    [mediaQueries$6.smOrSmaller]: {
      // As with the title, on phones, ensure that the button is aligned
      // with the hint body content.
      paddingLeft: hintIndentation
    }
  },
  mobileHintStylesPlusText: {
    [mediaQueries$6.lgOrSmaller]: {
      left: 0
    },
    [mediaQueries$6.smOrSmaller]: {
      left: hintIndentation
    }
  }
});
_module_$1_.exports = HintsRenderer$4;
var _hintsRendererJsx = _module_$1_.exports;

var shapes$1 = _multiItemsShapesJs;
/**
 * Return a semantically empty ItemTree that conforms to the given shape.
 *
 * - An empty content node has an empty content string and no widgets/images.
 * - An empty hint node has an empty content string and no widgets/images.
 * - An empty array node has no elements.
 * - An empty object node has a semantically empty node for each of its keys.
 *   (That is, we recursively call buildEmptyItemTreeForShape for each key.)
 */

function buildEmptyItemTreeForShape(shape) {
  if (shape.type === "content") {
    return {
      "__type": "content",
      "content": "",
      "images": {},
      "widgets": {}
    };
  } else if (shape.type === "hint") {
    return {
      "__type": "hint",
      "replace": false,
      "content": "",
      "images": {},
      "widgets": {}
    };
  } else if (shape.type === "tags") {
    return [];
  } else if (shape.type === "array") {
    return [];
  } else if (shape.type === "object") {
    var valueShapes = shape.shape;
    var object = {};
    Object.keys(valueShapes).forEach(key => {
      object[key] = buildEmptyItemTreeForShape(valueShapes[key]);
    });
    return object;
  } else {
    throw new Error("unexpected shape type ".concat(shape.type));
  }
}
/**
 * Return a semantically empty Item that conforms to the given shape.
 *
 * - An empty content node has an empty content string and no widgets/images.
 * - An empty hint node has an empty content string and no widgets/images.
 * - An empty array node has no elements.
 * - An empty object node has a semantically empty node for each of its keys.
 *   (That is, we recursively call buildEmptyItemTreeForShape for each key.)
 */


function buildEmptyItemForShape(shape) {
  return treeToItem(buildEmptyItemTreeForShape(shape));
}
/**
 * Given an Item and its Shape, yield all of its content nodes to the callback.
 */


function findContentNodesInItem(item, shape, callback) {
  var itemTree = itemToTree(item);
  buildMapper().setContentMapper(callback).mapTree(itemTree, shape);
}
/**
 * Given an Item and its Shape, yield all of its hint nodes to the callback.
 */


function findHintNodesInItem(item, shape, callback) {
  var itemTree = itemToTree(item);
  buildMapper().setHintMapper(callback).mapTree(itemTree, shape);
}
/**
 * Given an ItemTree, return a Shape that it conforms to.
 *
 * The Shape might not be complete or correct Shape that this Item was designed
 * for. If you have access to the intended Shape, use that instead.
 */


function inferItemShape(item) {
  var itemTree = itemToTree(item);
  return inferItemTreeShape(itemTree);
}

function inferItemTreeShape(node) {
  if (Array.isArray(node)) {
    if (node.length) {
      if (typeof node[0] === "string") {
        // There's no ItemTree that can manifest as a string.
        // So, an array of strings must be a TagsNode, not ArrayNode.
        return shapes$1.tags;
      } else {
        // Otherwise, assume that this is a valid ArrayNode, and
        // therefore the shape of the first element applies to all
        // elements in the array.
        return shapes$1.arrayOf(inferItemTreeShape(node[0]));
      }
    } else {
      // The array is empty, so we arbitrarily guess that it's a content
      // array. As discussed in the docstring, this might be incorrect,
      // and you shouldn't depend on it.
      return shapes$1.arrayOf(shapes$1.content);
    }
  } else if ( // TODO(mdr): Remove #LegacyContentNode support.
  typeof node === "object" && (node.__type === "content" || node.__type === "item")) {
    return shapes$1.content;
  } else if (typeof node === "object" && node.__type === "hint") {
    return shapes$1.hint;
  } else if (typeof node === "object") {
    var valueShapes = {};
    Object.keys(node).forEach(key => {
      // $FlowFixMe: Not sure why this property deref is an error.
      valueShapes[key] = inferItemTreeShape(node[key]);
    });
    return shapes$1.shape(valueShapes);
  } else {
    throw new Error("unexpected multi-item node ".concat(JSON.stringify(node)));
  }
}
/**
 * Convert the given ItemTree to an Item, by wrapping it in the `_multi` key.
 */


function itemToTree(item) {
  return item._multi;
}
/**
 * Convert the given Item to an ItemTree, by unwrapping the `_multi` key.
 */


function treeToItem(node) {
  return {
    _multi: node
  };
}

var isObject = function isObject(obj) {
  return obj === Object(obj);
};

var merge = function merge() {
  var obj = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    if (source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  }

  return obj;
};

var clone = function clone(obj) {
  if (!isObject(obj)) {
    return obj;
  }

  return Array.isArray(obj) ? obj.slice() : merge(obj);
};

var get$2 = function get(arr, monocle) {
  return arr[monocle];
};

var set$2 = function set(arr, monocle, val) {
  var newArr = arr.splice();
  newArr[monocle] = val;
  return newArr;
};

var mod$2 = function mod(arr, monocle, f) {
  var newArr = arr.slice();
  newArr[monocle] = f(arr[monocle]);
  return newArr;
};

var del$2 = function del(arr, monocle) {
  var newArr = arr.slice();
  newArr.splice(monocle, 1);
  return newArr;
};
/*
// Lens must point to a member of an array. We'll insert into that array.
lens.prototype.insertAt = function(lensArr, toInsert) {
    var obj = this._wrapped;

    var arrLens = lensArr.slice(0, -1);
    var arr = lens(obj).get(arrLens).slice(); // slice to copy

    var arrIdx = lensArr[lensArr.length-1];
    arr.splice(arrIdx, 0, toInsert);
    return lens(obj).set(arrLens, arr);
};

lens.prototype.insertBefore = lens.prototype.insertAt;
lens.prototype.insertAfter = function(lensArr, toInsert) {
    var newLens = lensArr.slice();
    newLens[newLens.length-1] += 1;
    return lens(this._wrapped).insertAt(newLens, toInsert);
};
*/


var arr = {
  get: get$2,
  set: set$2,
  mod: mod$2,
  del: del$2
};

var get$1 = function get(obj, monocle) {
  return obj[monocle];
};

var set$1 = function set(obj, monocle, val) {
  var newObj = clone(obj);
  newObj[monocle] = val;
  return newObj;
};

var mod$1 = function mod(obj, monocle, f) {
  var newObj = clone(obj);
  newObj[monocle] = f(obj[monocle]);
  return newObj;
};

var del$1 = function del(obj, monocle) {
  var newObj = clone(obj);
  delete newObj[monocle];
  return newObj;
};

var obj = {
  get: get$1,
  set: set$1,
  mod: mod$1,
  del: del$1
};

var get = function get(arr, monocle) {
  return arr[monocle];
};

var set = function set(arr, monocle, val) {
  var newArr = arr.splice();
  newArr[monocle] = val;
  return newArr;
};

var mod = function mod(arr, monocle, f) {
  var newArr = arr.splice();
  newArr[monocle] = f(arr[monocle]);
  return newArr;
};

var del = function del(arr, monocle) {
  var newArr = arr.slice();
  newArr.splice(monocle);
  return newArr;
};

var str = {
  get: get,
  set: set,
  mod: mod,
  del: del
};

/* TODO batch *all* mutations
 * idea: freeze / thaw implementations for all types
 * lens constructor thaws, freeze delegates to type's freeze
 */
// find the implementation to use for a given object

var dispatch = function dispatch(x) {
  if (Array.isArray(x)) {
    return arr;
  } else if (isObject(x)) {
    return obj;
  } else if (typeof x === "string") {
    return str;
  }
}; // This is underscore with a different name


var lens$3 = function lens(obj) {
  if (obj instanceof lens) {
    return obj;
  }

  if (!(this instanceof lens)) {
    return new lens(obj);
  }

  var ops = dispatch(obj);
  this._wrapped = ops.thaw ? ops.thaw(obj) : obj;
};

lens$3.prototype.freeze = function () {
  var obj = this._wrapped;
  var ops = dispatch(obj);
  return ops.freeze ? ops.freeze(obj) : obj;
};

lens$3.prototype.zoom = function (lensArr) {
  if (this._zoomStack === undefined) {
    this._zoomStack = [];
  }

  this._zoomStack.push({
    zoom: lensArr,
    wrapped: this._wrapped
  });

  this._wrapped = lens$3(this._wrapped).get(lensArr);
  return this;
};

lens$3.prototype.deZoom = function () {
  var frame = this._zoomStack.pop();

  this._wrapped = lens$3(frame.wrapped).set(frame.zoom, this._wrapped).freeze();
  return this;
};

lens$3.prototype.get = function (lensArr) {
  var obj = this._wrapped;

  for (var i = 0; i < lensArr.length; i++) {
    obj = dispatch(obj).get(obj, lensArr[i]);
  }

  return obj;
};

lens$3.prototype.mod = function (lensArr, f) {
  var obj = this._wrapped;
  var newObj = clone(obj);
  var ops = dispatch(obj);

  if (lensArr.length === 0) {
    this._wrapped = f(this._wrapped);
  } else if (lensArr.length === 1) {
    this._wrapped = ops.mod(newObj, lensArr[0], f);
  } else {
    var monocle = lensArr[0];
    var shortLens = lensArr.slice(1); // newObj = ops.mod(obj[monocle], shortLens, f);

    newObj[monocle] = lens$3(obj[monocle]).mod(shortLens, f).freeze();
    this._wrapped = newObj;
  }

  return this;
}; // TODO - move to individual files


lens$3.prototype.merge = function (lensArr, props) {
  this._wrapped = lens$3(this._wrapped).mod(lensArr, function (oldProps) {
    return merge(oldProps, props);
  }).freeze();
  return this;
}; // Lens must have length >= 1 or there would be nothing to return


lens$3.prototype.del = function (lensArr) {
  var obj = this._wrapped;
  var ops = dispatch(obj);

  if (lensArr.length === 1) {
    this._wrapped = ops.del(obj, lensArr[0]);
  } else {
    var monocle = lensArr[0];
    var shortLens = lensArr.slice(1);
    var newObj = clone(obj);
    newObj[monocle] = lens$3(obj[monocle]).del(shortLens).freeze();
    this._wrapped = newObj;
  }

  return this;
};

lens$3.prototype.set = function (lensArr, set) {
  return this.mod(lensArr, function () {
    return set;
  });
};

var _excluded$3 = ["item", "children", "shape"];
var _module_$1Z = {
  exports: {}
};
var lens$2 = lens$3;
var React$1_ = _react__default["default"];
var HintsRenderer$3 = _hintsRendererJsx;
var Renderer$l = _rendererJsx;
var Util$l = Util$q;

class MultiRenderer$1 extends React$1_.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "_handleSerializedStateUpdated", (path, newState) => {
      var {
        onSerializedStateUpdated
      } = this.props;

      if (onSerializedStateUpdated) {
        var oldState = this._getSerializedState(this.props.serializedState);

        onSerializedStateUpdated(lens$2(oldState).set(path, newState).freeze());
      }
    });

    this.rendererDataTreeMapper = buildMapper().setContentMapper((c, _, p) => this._makeContentRendererData(c, p)).setHintMapper(h => this._makeHintRendererData(h)).setTagsMapper(t => null);
    this.getRenderersMapper = buildMapper().setContentMapper(c => c.makeRenderer()).setHintMapper(h => h.makeRenderer()).setArrayMapper(this._annotateRendererArray.bind(this)); // Keep state in sync with props.

    this.state = this._tryMakeRendererState(this.props);
  }
  /* eslint-enable react/sort-comp */


  componentWillReceiveProps(nextProps) {
    // Keep state in sync with props.
    if (nextProps.item !== this.props.item) {
      this.setState(this._tryMakeRendererState(nextProps));
    }
  }
  /**
   * Attempt to build a State that includes a renderer tree corresponding to
   * the item provided in props. On error, return a state with `renderError`
   * set instead.
   */


  _tryMakeRendererState(props) {
    try {
      return {
        rendererDataTree: this._makeRendererDataTree(props.item, props.shape),
        renderError: null
      };
    } catch (e) {
      // NOTE(mdr): It's appropriate to log an error traceback in a
      //     caught error condition, and console.error is supported in
      //     all target browsers. Just do it, linter.
      // eslint-disable-next-line no-console
      console.error(e);
      return {
        rendererDataTree: null,
        renderError: e
      };
    }
  }

  /**
   * Props that aren't directly used by the MultiRenderer are delegated to
   * the underlying Renderers.
   */
  _getRendererProps() {
    /* eslint-disable no-unused-vars */
    // eslint is complaining that `item` and `children` are unused. I'm
    // explicitly pulling them out of `this.props` so I don't pass them to
    // `<Renderer>`. I'm not sure how else to do this.
    var _this$props = this.props,
        otherProps = _objectWithoutProperties(_this$props, _excluded$3);
    /* eslint-enable no-unused-vars */


    return otherProps;
  }
  /**
   * Construct a Renderer and a ref placeholder for the given ContentNode.
   */


  _makeContentRendererData(content, path) {
    // NOTE(emily): The `findExternalWidgets` function here is computed
    //     inline and thus changes each time we run this function. If it
    //     were to change every render, it would cause the Renderer to
    //     re-render a lot more than is necessary. Don't re-compute this
    //     element unless it is necessary!
    // HACK(mdr): Flow can't prove that this is a ContentRendererData,
    //     because of how we awkwardly construct it in order to obtain a
    //     circular reference. But it is, I promise.
    var data = {
      ref: null,
      makeRenderer: null
    };

    var refFunc = e => data.ref = e;

    var findExternalWidgets = criterion => this._findWidgets(data, criterion);

    var handleSerializedState = state => this._handleSerializedStateUpdated(path, state);

    data.makeRenderer = () => /*#__PURE__*/React$1_.createElement(Renderer$l, _extends({}, this._getRendererProps(), content, {
      ref: refFunc,
      findExternalWidgets: findExternalWidgets,
      serializedState: this.props.serializedState ? lens$2(this.props.serializedState).get(path) : null,
      onSerializedStateUpdated: handleSerializedState
    }));

    return data;
  }
  /**
   * Construct a Renderer for the given HintNode, and keep track of the hint
   * itself for future use, too.
   */


  _makeHintRendererData(hint) {
    // TODO(mdr): Once HintsRenderer supports inter-widget communication,
    //     give it a ref. Until then, leave the ref null forever, to avoid
    //     confusing the findWidgets functions.
    //
    // NOTE(davidflanagan): As a partial step toward inter-widget
    // communication we're going to pass a findExternalWidgets function
    // (using a dummy data object). This allows passage-ref widgets in
    // hints to use findWidget() to find the passage widgets they reference.
    // Note that this is one-way only, however. It does not allow
    // widgets in the question to find widgets in the hints, for example.
    var findExternalWidgets = criterion => this._findWidgets({}, criterion);

    return {
      hint,
      findExternalWidgets,
      // _annotateRendererArray() needs this
      ref: null,
      makeRenderer: () => /*#__PURE__*/React$1_.createElement(HintsRenderer$3, _extends({}, this._getRendererProps(), {
        findExternalWidgets: findExternalWidgets,
        hints: [hint]
      }))
    };
  }
  /**
   * Construct a tree of interconnected RendererDatas, corresponding to the
   * given item. Called in `_tryMakeRendererState`, in order to store this
   * tree in the component state.
   */


  _makeRendererDataTree(item, shape) {
    var itemTree = itemToTree(item);
    return this.rendererDataTreeMapper.mapTree(itemTree, shape);
  }
  /**
   * Return all widgets that meet the given criterion, from all Renderers
   * except the Renderer that triggered this call.
   *
   * This function is provided to each Renderer's `findExternalWidgets` prop,
   * which enables widgets in different Renderers to discover each other and
   * communicate.
   */


  _findWidgets(callingData, filterCriterion) {
    var results = [];

    this._mapRenderers(data => {
      if (callingData !== data && data.ref) {
        results.push(...data.ref.findInternalWidgets(filterCriterion));
      }
    });

    return results;
  }
  /**
   * Copy the renderer tree, apply the given transformation to the leaf nodes
   * and the optional given transformation to the array nodes, and return the
   * result.
   *
   * Used to provide structured data to the call site (the Renderer tree on
   * `render`, the Score tree on `getScores`, etc.), and to traverse the
   * renderer tree even when we disregard the output (like in
   * `_findWidgets`).
   */


  _mapRenderers(leafMapper) {
    var {
      rendererDataTree
    } = this.state;

    if (!rendererDataTree) {
      return null;
    }

    var mapper = buildMapper().setContentMapper(leafMapper).setHintMapper(leafMapper);
    return mapper.mapTree(rendererDataTree, this.props.shape);
  }

  _scoreFromRef(ref) {
    if (!ref) {
      return null;
    }

    var [guess, score] = ref.guessAndScore();
    var state;

    if (ref.getSerializedState) {
      state = ref.getSerializedState();
    }

    return Util$l.keScoreFromPerseusScore(score, guess, state);
  }
  /**
   * Return a tree in the shape of the multi-item, with scores at each of
   * the content nodes and `null` at the other leaf nodes.
   */


  getScores() {
    return this._mapRenderers(data => this._scoreFromRef(data.ref));
  }
  /**
   * Return a single composite score for all rendered content nodes.
   * The `guess` is a tree in the shape of the multi-item, with an individual
   * guess at each content node and `null` at the other leaf nodes.
   */


  score() {
    var scores = [];
    var state = [];

    var guess = this._mapRenderers(data => {
      if (!data.ref) {
        return null;
      }

      if (data.ref.getSerializedState) {
        state.push(data.ref.getSerializedState());
      }

      scores.push(data.ref.score());
      return data.ref.getUserInput();
    });

    var combinedScore = scores.reduce(Util$l.combineScores);
    return Util$l.keScoreFromPerseusScore(combinedScore, guess, state);
  }
  /**
   * Return a tree in the shape of the multi-item, with serialized state at
   * each of the content nodes and `null` at the other leaf nodes.
   *
   * If the lastSerializedState argument is supplied, this function will fill
   * in the state of not-currently-rendered content and hint nodes with the
   * values from the previous serialized state. If no lastSerializedState is
   * supplied, `null` will be returned for not-currently-rendered content and
   * hint nodes.
   */


  _getSerializedState(lastSerializedState) {
    return this._mapRenderers((data, _, path) => {
      if (data.ref) {
        return data.ref.getSerializedState();
      } else if (lastSerializedState) {
        return lens$2(lastSerializedState).get(path);
      } else {
        return null;
      }
    });
  }
  /**
   * Given a tree in the shape of the multi-item, with serialized state at
   * each of the content nodes, restore each state to the corresponding
   * renderer if currently mounted.
   */


  restoreSerializedState(serializedState, callback) {
    // We want to call our async callback only once all of the childrens'
    // callbacks have run. We add one to this counter before we call out to
    // each renderer and decrement it when it runs our callback.
    var numCallbacks = 0;

    var countCallback = () => {
      numCallbacks--;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this._mapRenderers((data, _, path) => {
      if (!data.ref) {
        return;
      }

      var state = lens$2(serializedState).get(path);

      if (!state) {
        return;
      }

      numCallbacks++;
      data.ref.restoreSerializedState(state, countCallback);
    });
  }
  /**
   * Given an array of renderers, if it happens to be an array of *hint*
   * renderers, then attach a `firstN` method to the array, which allows the
   * layout to render the hints together in one HintsRenderer.
   */


  _annotateRendererArray(renderers, rendererDatas, shape) {
    if (shape.elementShape.type === "hint") {
      // The shape says that these are HintRendererDatas, even though
      // it's not provable at compile time, so perform a cast.
      var hintRendererDatas = rendererDatas;
      renderers = [...renderers];

      renderers.firstN = n => /*#__PURE__*/React$1_.createElement(HintsRenderer$3, _extends({}, this._getRendererProps(), {
        findExternalWidgets: hintRendererDatas[0] ? hintRendererDatas[0].findExternalWidgets : undefined,
        hints: hintRendererDatas.map(d => d.hint),
        hintsVisible: n
      }));
    }

    return renderers;
  }
  /**
   * Return a tree in the shape of the multi-item, with a Renderer at each
   * content node and a HintRenderer at each hint node.
   *
   * This is generated by running each of the `makeRenderer` functions at the
   * leaf nodes.
   */


  _getRenderers() {
    return this.getRenderersMapper.mapTree(this.state.rendererDataTree, this.props.shape);
  }

  render() {
    if (this.state.renderError) {
      return /*#__PURE__*/React$1_.createElement("div", {
        className: aphrodite.css(styles$o.error)
      }, "Error rendering: ", String(this.state.renderError));
    } // Pass the renderer tree to the `children` function, which will
    // determine the actual content of this component.


    return this.props.children({
      renderers: this._getRenderers()
    });
  }

}

var styles$o = aphrodite.StyleSheet.create({
  error: {
    color: "red"
  }
});
_module_$1Z.exports = MultiRenderer$1;
var _multiItemsMultiRendererJsx = _module_$1Z.exports;

var _module_$1Y = {
  exports: {}
};
var MultiRenderer = _multiItemsMultiRendererJsx;
var shapes = _multiItemsShapesJs;
_module_$1Y.exports = {
  // Tools for rendering your multi-items
  MultiRenderer,
  // Tools for declaring your multi-item shapes
  shapes,
  buildPropTypeForShape,
  // Tools for generically manipulating multi-items
  buildEmptyItemForShape,
  findContentNodesInItem,
  findHintNodesInItem,
  inferItemShape
};
var _multiItemsJs = _module_$1Y.exports;

var _module_$1X = {
  exports: {}
};
/* eslint-disable object-curly-spacing */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * A mixin that renders a custom software keypad in additional to the base
 * component. The base component will receive blur events when the keypad is
 * dismissed and can access the keypad element itself so as to manage its
 * activation and dismissal.
 *
 * TODO(charlie): This would make a nicer higher-order component, except that
 * we need to expose methods on the base component (i.e., `ItemRenderer`). When
 * `ItemRenderer` and friends are written as ES6 Classes, we can have them
 * extend a `ProvideKeypad` component instead of using this mixin.
 */

var React$1Z = _react__default["default"];
var ReactDOM$v = _reactDom__default["default"];
var {
  Keypad
} = _mathInput__default["default"].components;
var ProvideKeypad$3 = {
  propTypes: {
    apiOptions: PropTypes.shape({
      customKeypad: PropTypes.bool
    }),
    // An Aphrodite style object, to be applied to the keypad container.
    // Note that, given our awkward structure of injecting the keypad, this
    // style won't be applied or updated dynamically. Rather, it will only
    // be applied in `componentDidMount`.
    keypadStyle: PropTypes.any
  },

  getInitialState() {
    return {
      keypadElement: null
    };
  },

  componentDidMount() {
    if (this.props.apiOptions && this.props.apiOptions.customKeypad) {
      // TODO(charlie): Render this and the wrapped component in the same
      // React tree. We may also want to add this keypad asynchronously or
      // on-demand in the future.
      this._keypadContainer = document.createElement('div');
      document.body.appendChild(this._keypadContainer);
      ReactDOM$v.render( /*#__PURE__*/React$1Z.createElement(Keypad, {
        onElementMounted: element => {
          this.setState({
            keypadElement: element
          });
        },
        onDismiss: () => {
          this.blur && this.blur();
        },
        style: this.props.keypadStyle
      }), this._keypadContainer);
    }
  },

  componentWillUnmount() {
    if (this._keypadContainer) {
      ReactDOM$v.unmountComponentAtNode(this._keypadContainer);

      if (this._keypadContainer.parentNode) {
        // Note ChildNode.remove() isn't available in older Android
        // webviews.
        this._keypadContainer.parentNode.removeChild(this._keypadContainer);
      }

      this._keypadContainer = null;
    }
  },

  keypadElement() {
    return this.state.keypadElement;
  }

};
_module_$1X.exports = ProvideKeypad$3;
var _mixinsProvideKeypadJsx = _module_$1X.exports;

var _module_$1W = {
  exports: {}
};
/**
 * A copy of the ItemRenderer which renders its question renderer and hints
 * renderer normally instead of ReactDOM.render()ing them into elements in the
 * DOM.
 *
 * This allows this component to be used in server-rendering of a perseus
 * exercise.
 */

var React$1Y = _react__default["default"];
var ReactDOM$u = _reactDom__default["default"];
var _$1i = _underscore__default["default"];
var ApiOptions$v = _perseusApiJsx.Options;
var HintsRenderer$2 = _hintsRendererJsx;
var ProvideKeypad$2 = _mixinsProvideKeypadJsx;
var Renderer$k = _rendererJsx;
var Util$k = Util$q;
var RP$1 = PropTypes;
var ItemRenderer$2 = createReactClass({
  displayName: "ItemRenderer",
  propTypes: _objectSpread2(_objectSpread2({}, ProvideKeypad$2.propTypes), {}, {
    apiOptions: RP$1.any,
    hintsVisible: RP$1.number,
    item: RP$1.shape({
      answerArea: RP$1.shape({
        calculator: RP$1.bool,
        chi2Table: RP$1.bool,
        periodicTable: RP$1.bool,
        tTable: RP$1.bool,
        zTable: RP$1.bool
      }),
      hints: RP$1.arrayOf(RP$1.object),
      question: RP$1.object
    }).isRequired,
    problemNum: RP$1.number,
    reviewMode: RP$1.bool
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      apiOptions: {} // a deep default is done in `this.update()`

    };
  },
  getInitialState: function getInitialState() {
    return _objectSpread2(_objectSpread2({}, ProvideKeypad$2.getInitialState()), {}, {
      questionCompleted: false,
      questionHighlightedWidgets: []
    });
  },
  componentDidMount: function componentDidMount() {
    ProvideKeypad$2.componentDidMount.call(this);
    this._currentFocus = null;
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      questionHighlightedWidgets: []
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    if (this.props.apiOptions.answerableCallback) {
      var isAnswerable = this.questionRenderer.emptyWidgets().length === 0;
      this.props.apiOptions.answerableCallback(isAnswerable);
    }
  },

  componentWillUnmount() {
    ProvideKeypad$2.componentWillUnmount.call(this);
  },

  keypadElement() {
    return ProvideKeypad$2.keypadElement.call(this);
  },

  _handleFocusChange: function _handleFocusChange(newFocus, oldFocus) {
    if (newFocus != null) {
      this._setCurrentFocus(newFocus);
    } else {
      this._onRendererBlur(oldFocus);
    }
  },
  // Sets the current focus path and element and
  // send an onChangeFocus event back to our parent.
  _setCurrentFocus: function _setCurrentFocus(newFocus) {
    var keypadElement = this.keypadElement(); // By the time this happens, newFocus cannot be a prefix of
    // prevFocused, since we must have either been called from
    // an onFocusChange within a renderer, which is only called when
    // this is not a prefix, or between the question and answer areas,
    // which can never prefix each other.

    var prevFocus = this._currentFocus;
    this._currentFocus = newFocus; // Determine whether the newly focused path represents an input.

    var inputPaths = this.getInputPaths();
    var didFocusInput = this._currentFocus && inputPaths.some(inputPath => {
      return Util$k.inputPathsEqual(inputPath, this._currentFocus);
    });

    if (this.props.apiOptions.onFocusChange != null) {
      this.props.apiOptions.onFocusChange(this._currentFocus, prevFocus, didFocusInput && keypadElement && ReactDOM$u.findDOMNode(keypadElement));
    }

    if (keypadElement) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  },
  _onRendererBlur: function _onRendererBlur(blurPath) {
    var blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
    // before blur

    if (!_$1i.isEqual(blurPath, blurringFocusPath)) {
      return;
    } // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused.
    // If a different widget was focused, we'll see an onBlur event
    // now, but then an onFocus event on a different element before
    // this callback is executed


    _$1i.defer(() => {
      if (_$1i.isEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    });
  },

  /**
   * Accepts a question area widgetId, or an answer area widgetId of
   * the form "answer-input-number 1", or the string "answer-area"
   * for the whole answer area (if the answer area is a single widget).
   */
  _setWidgetProps: function _setWidgetProps(widgetId, newProps, callback) {
    this.questionRenderer._setWidgetProps(widgetId, newProps, callback);
  },
  _handleAPICall: function _handleAPICall(functionName, path) {
    // Get arguments to pass to function, including `path`
    var functionArgs = _$1i.rest(arguments);

    var caller = this.questionRenderer;
    return caller[functionName](...functionArgs);
  },
  setInputValue: function setInputValue(path, newValue, focus) {
    return this._handleAPICall("setInputValue", path, newValue, focus);
  },
  focusPath: function focusPath(path) {
    return this._handleAPICall("focusPath", path);
  },
  blurPath: function blurPath(path) {
    return this._handleAPICall("blurPath", path);
  },
  getDOMNodeForPath: function getDOMNodeForPath(path) {
    return this._handleAPICall("getDOMNodeForPath", path);
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(path) {
    return this._handleAPICall("getGrammarTypeForPath", path);
  },
  getInputPaths: function getInputPaths() {
    var questionAreaInputPaths = this.questionRenderer.getInputPaths();
    return questionAreaInputPaths;
  },
  handleInteractWithWidget: function handleInteractWithWidget(widgetId) {
    var withRemoved = _$1i.difference(this.state.questionHighlightedWidgets, [widgetId]);

    this.setState({
      questionCompleted: false,
      questionHighlightedWidgets: withRemoved
    });

    if (this.props.apiOptions.interactionCallback) {
      this.props.apiOptions.interactionCallback();
    }
  },
  focus: function focus() {
    return this.questionRenderer.focus();
  },
  blur: function blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  },
  getNumHints: function getNumHints() {
    return this.props.item.hints.length;
  },

  /**
   * Grades the item.
   *
   * Returns a KE-style score of {
   *     empty: bool,
   *     correct: bool,
   *     message: string|null,
   *     guess: Array
   * }
   */
  scoreInput: function scoreInput() {
    var guessAndScore = this.questionRenderer.guessAndScore();
    var guess = guessAndScore[0];
    var score = guessAndScore[1]; // Continue to include an empty guess for the now defunct answer area.
    // TODO(alex): Check whether we rely on the format here for
    //             analyzing ProblemLogs. If not, remove this layer.

    var maxCompatGuess = [guess, []];
    var keScore = Util$k.keScoreFromPerseusScore(score, maxCompatGuess, this.questionRenderer.getSerializedState());
    var emptyQuestionAreaWidgets = this.questionRenderer.emptyWidgets();
    this.setState({
      questionCompleted: keScore.correct,
      questionHighlightedWidgets: emptyQuestionAreaWidgets
    });
    return keScore;
  },

  /**
   * Returns an array of all widget IDs in the order they occur in
   * the question content.
   */
  getWidgetIds: function getWidgetIds() {
    return this.questionRenderer.getWidgetIds();
  },

  /**
   * Returns an object mapping from widget ID to KE-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */
  scoreWidgets: function scoreWidgets() {
    var qScore = this.questionRenderer.scoreWidgets();
    var qGuess = this.questionRenderer.getUserInputForWidgets();
    var state = this.questionRenderer.getSerializedState();
    return mapObject(qScore, (score, id) => {
      return Util$k.keScoreFromPerseusScore(score, qGuess[id], state);
    });
  },

  /**
   * Get a representation of the current state of the item.
   */
  getSerializedState: function getSerializedState() {
    return {
      question: this.questionRenderer.getSerializedState(),
      hints: this.hintsRenderer.getSerializedState()
    };
  },
  restoreSerializedState: function restoreSerializedState(state, callback) {
    // We need to wait for both the question renderer and the hints
    // renderer to finish restoring their states.
    var numCallbacks = 2;

    var fireCallback = () => {
      --numCallbacks;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this.questionRenderer.restoreSerializedState(state.question, fireCallback);
    this.hintsRenderer.restoreSerializedState(state.hints, fireCallback);
  },

  showRationalesForCurrentlySelectedChoices() {
    this.questionRenderer.showRationalesForCurrentlySelectedChoices();
  },

  deselectIncorrectSelectedChoices() {
    this.questionRenderer.deselectIncorrectSelectedChoices();
  },

  render: function render() {
    var apiOptions = _objectSpread2(_objectSpread2(_objectSpread2({}, ApiOptions$v.defaults), this.props.apiOptions), {}, {
      onFocusChange: this._handleFocusChange
    });

    var questionRenderer = /*#__PURE__*/React$1Y.createElement(Renderer$k, _extends({
      keypadElement: this.keypadElement(),
      problemNum: this.props.problemNum,
      onInteractWithWidget: this.handleInteractWithWidget,
      highlightedWidgets: this.state.questionHighlightedWidgets,
      apiOptions: apiOptions,
      questionCompleted: this.state.questionCompleted,
      reviewMode: this.props.reviewMode,
      ref: elem => this.questionRenderer = elem
    }, this.props.item.question));
    var hintsRenderer = /*#__PURE__*/React$1Y.createElement(HintsRenderer$2, {
      hints: this.props.item.hints,
      hintsVisible: this.props.hintsVisible,
      apiOptions: apiOptions,
      ref: elem => this.hintsRenderer = elem
    });
    return /*#__PURE__*/React$1Y.createElement("div", null, /*#__PURE__*/React$1Y.createElement("div", null, questionRenderer), /*#__PURE__*/React$1Y.createElement("div", {
      className: // Avoid adding any horizontal padding when applying the
      // mobile hint styles, which are flush to the left.
      // NOTE(charlie): We may still want to apply this
      // padding for desktop exercises.
      !apiOptions.isMobile && aphrodite.css(styles$n.hintsContainer)
    }, hintsRenderer));
  }
});
var styles$n = aphrodite.StyleSheet.create({
  hintsContainer: {
    marginLeft: 50
  }
});
_module_$1W.exports = ItemRenderer$2;
var _serverItemRendererJsx = _module_$1W.exports;

var _module_$1V = {
  exports: {}
};
/* eslint-disable no-var, prefer-spread */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1X = _react__default["default"];
var ReactDOM$t = _reactDom__default["default"];
var _$1h = _underscore__default["default"];
var ApiOptions$u = _perseusApiJsx.Options;
var HintsRenderer$1 = _hintsRendererJsx;
var Renderer$j = _rendererJsx;
var ProvideKeypad$1 = _mixinsProvideKeypadJsx;
var Util$j = Util$q;
var Gorgon$3 = _gorgonGorgonJs;
var RP = PropTypes;
var ItemRenderer$1 = createReactClass({
  displayName: "ItemRenderer",
  propTypes: _objectSpread2(_objectSpread2({}, ProvideKeypad$1.propTypes), {}, {
    // defaults are set in `this.update()` so as to adhere to
    // `ApiOptions.PropTypes`, though the API options that are passed in
    // can be in any degree of completeness
    apiOptions: RP.shape({
      interactionCallback: RP.func,
      onFocusChange: RP.func,
      setDrawingAreaAvailable: RP.func
    }),
    // Whether this component should control hiding/showing peripheral
    // item-related components (for list, see item.answerArea below).
    // TODO(alex): Generalize this to an 'expectsToBeInTemplate' prop
    controlPeripherals: RP.bool,
    hintsAreaSelector: RP.string,
    initialHintsVisible: RP.number,
    item: RP.shape({
      answerArea: RP.shape({
        calculator: RP.bool,
        chi2Table: RP.bool,
        periodicTable: RP.bool,
        tTable: RP.bool,
        zTable: RP.bool
      }),
      hints: RP.arrayOf(RP.object),
      question: RP.object
    }).isRequired,
    onShowCalculator: RP.func,
    onShowChi2Table: RP.func,
    onShowPeriodicTable: RP.func,
    onShowTTable: RP.func,
    onShowZTable: RP.func,
    problemNum: RP.number,
    reviewMode: PropTypes.bool,
    savedState: RP.any,
    workAreaSelector: RP.string,
    linterContext: linterContextProps,
    legacyPerseusLint: PropTypes.arrayOf(PropTypes.string)
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      apiOptions: {},
      // defaults are set in `this.update()`
      controlPeripherals: true,
      hintsAreaSelector: "#hintsarea",
      initialHintsVisible: 0,
      workAreaSelector: "#workarea",
      reviewMode: false,
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return _objectSpread2(_objectSpread2({}, ProvideKeypad$1.getInitialState()), {}, {
      hintsVisible: this.props.initialHintsVisible,
      questionCompleted: false,
      questionHighlightedWidgets: []
    });
  },
  componentDidMount: function componentDidMount() {
    ProvideKeypad$1.componentDidMount.call(this);

    if (this.props.controlPeripherals && this.props.apiOptions.setDrawingAreaAvailable) {
      this.props.apiOptions.setDrawingAreaAvailable(true);
    }

    this._currentFocus = null;
    this.update();
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      questionHighlightedWidgets: []
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    this.update();
  },
  componentWillUnmount: function componentWillUnmount() {
    ProvideKeypad$1.componentWillUnmount.call(this);
    ReactDOM$t.unmountComponentAtNode(document.querySelector(this.props.workAreaSelector));
    ReactDOM$t.unmountComponentAtNode(document.querySelector(this.props.hintsAreaSelector));

    if (this.props.controlPeripherals) {
      var answerArea = this.props.item.answerArea || {};

      if (answerArea.calculator) {
        $("#calculator").hide();
      }

      if (answerArea.periodicTable) {
        $(".periodic-table-info-box").hide();
      }

      if (answerArea.zTable) {
        $(".z-table-info-box").hide();
      }

      if (answerArea.tTable) {
        $(".t-table-info-box").hide();
      }

      if (answerArea.chi2Table) {
        $(".chi2-table-info-box").hide();
      }
    }
  },

  keypadElement() {
    return ProvideKeypad$1.keypadElement.call(this);
  },

  update: function update() {
    var apiOptions = _objectSpread2(_objectSpread2(_objectSpread2({}, ApiOptions$u.defaults), this.props.apiOptions), {}, {
      onFocusChange: this._handleFocusChange
    }); // Since the item renderer works by rendering things into three divs
    // that have completely different places in the DOM, we have to do this
    // strangeness instead of relying on React's normal render() method.
    // TODO(alpert): Figure out how to clean this up somehow


    this.questionRenderer = ReactDOM$t.render( /*#__PURE__*/React$1X.createElement(Renderer$j, _extends({
      keypadElement: this.keypadElement(),
      problemNum: this.props.problemNum,
      onInteractWithWidget: this.handleInteractWithWidget,
      highlightedWidgets: this.state.questionHighlightedWidgets,
      apiOptions: apiOptions,
      questionCompleted: this.state.questionCompleted,
      reviewMode: this.props.reviewMode,
      savedState: this.props.savedState,
      linterContext: Gorgon$3.pushContextStack(this.props.linterContext, "question")
    }, this.props.item.question, {
      legacyPerseusLint: this.props.legacyPerseusLint
    })), document.querySelector(this.props.workAreaSelector));
    this.hintsRenderer = ReactDOM$t.render( /*#__PURE__*/React$1X.createElement(HintsRenderer$1, {
      hints: this.props.item.hints,
      hintsVisible: this.state.hintsVisible,
      apiOptions: apiOptions,
      linterContext: Gorgon$3.pushContextStack(this.props.linterContext, "hints")
    }), document.querySelector(this.props.hintsAreaSelector));
    var answerArea = this.props.item.answerArea || {};

    if (this.props.controlPeripherals) {
      $("#calculator").toggle(answerArea.calculator || false);
      $(".periodic-table-info-box").toggle(answerArea.periodicTable || false);
      $(".z-table-info-box").toggle(answerArea.zTable || false);
      $(".t-table-info-box").toggle(answerArea.tTable || false);
      $(".chi2-table-info-box").toggle(answerArea.chi2Table || false);
    } else {
      if (answerArea.calculator) {
        this.props.onShowCalculator && this.props.onShowCalculator();
      }

      if (answerArea.periodicTable) {
        this.props.onShowPeriodicTable && this.props.onShowPeriodicTable();
      }

      if (answerArea.zTable) {
        this.props.onShowZTable && this.props.onShowZTable();
      }

      if (answerArea.tTable) {
        this.props.onShowTTable && this.props.onShowTTable();
      }

      if (answerArea.chi2Table) {
        this.props.onShowChi2Table && this.props.onShowChi2Table();
      }
    }

    if (apiOptions.answerableCallback) {
      var isAnswerable = this.questionRenderer.emptyWidgets().length === 0;
      apiOptions.answerableCallback(isAnswerable);
    }
  },
  _handleFocusChange: function _handleFocusChange(newFocus, oldFocus) {
    if (newFocus != null) {
      this._setCurrentFocus(newFocus);
    } else {
      this._onRendererBlur(oldFocus);
    }
  },
  // Sets the current focus path and element and send an onChangeFocus event
  // back to our parent.
  _setCurrentFocus: function _setCurrentFocus(newFocus) {
    var keypadElement = this.keypadElement(); // By the time this happens, newFocus cannot be a prefix of
    // prevFocused, since we must have either been called from
    // an onFocusChange within a renderer, which is only called when
    // this is not a prefix, or between the question and answer areas,
    // which can never prefix each other.

    var prevFocus = this._currentFocus;
    this._currentFocus = newFocus; // Determine whether the newly focused path represents an input.

    var inputPaths = this.getInputPaths();
    var didFocusInput = this._currentFocus && inputPaths.some(inputPath => {
      return Util$j.inputPathsEqual(inputPath, this._currentFocus);
    });

    if (this.props.apiOptions.onFocusChange != null) {
      this.props.apiOptions.onFocusChange(this._currentFocus, prevFocus, didFocusInput && keypadElement && ReactDOM$t.findDOMNode(keypadElement));
    }

    if (keypadElement) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  },
  _onRendererBlur: function _onRendererBlur(blurPath) {
    var blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
    // before blur.

    if (!Util$j.inputPathsEqual(blurPath, blurringFocusPath)) {
      return;
    } // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused, since if there were a focus change
    // across Renderers (e.g., from the HintsRenderer to the
    // QuestionRenderer), we could receive the blur before the focus.


    setTimeout(() => {
      if (Util$j.inputPathsEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    });
  },

  /**
   * Accepts a question area widgetId, or an answer area widgetId of
   * the form "answer-input-number 1", or the string "answer-area"
   * for the whole answer area (if the answer area is a single widget).
   */
  _setWidgetProps: function _setWidgetProps(widgetId, newProps, callback) {
    this.questionRenderer._setWidgetProps(widgetId, newProps, callback);
  },
  _handleAPICall: function _handleAPICall(functionName, path) {
    // Get arguments to pass to function, including `path`.
    var functionArgs = _$1h.rest(arguments); // TODO(charlie): Extend this API to support inputs in the
    // HintsRenderer as well.


    var caller = this.questionRenderer;
    return caller[functionName].apply(caller, functionArgs);
  },
  setInputValue: function setInputValue(path, newValue, focus) {
    return this._handleAPICall("setInputValue", path, newValue, focus);
  },
  focusPath: function focusPath(path) {
    return this._handleAPICall("focusPath", path);
  },
  blurPath: function blurPath(path) {
    return this._handleAPICall("blurPath", path);
  },
  getDOMNodeForPath: function getDOMNodeForPath(path) {
    return this._handleAPICall("getDOMNodeForPath", path);
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(path) {
    return this._handleAPICall("getGrammarTypeForPath", path);
  },
  getInputPaths: function getInputPaths() {
    var questionAreaInputPaths = this.questionRenderer.getInputPaths();
    return questionAreaInputPaths;
  },
  handleInteractWithWidget: function handleInteractWithWidget(widgetId) {
    var withRemoved = _$1h.difference(this.state.questionHighlightedWidgets, [widgetId]);

    this.setState({
      questionCompleted: false,
      questionHighlightedWidgets: withRemoved
    });

    if (this.props.apiOptions.interactionCallback) {
      this.props.apiOptions.interactionCallback();
    }
  },
  focus: function focus() {
    return this.questionRenderer.focus();
  },
  blur: function blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  },
  showHint: function showHint() {
    if (this.state.hintsVisible < this.getNumHints()) {
      this.setState({
        hintsVisible: this.state.hintsVisible + 1
      });
    }
  },
  getNumHints: function getNumHints() {
    return this.props.item.hints.length;
  },

  /**
   * Grades the item.
   *
   * Returns a KE-style score of {
   *     empty: bool,
   *     correct: bool,
   *     message: string|null,
   *     guess: Array
   * }
   */
  scoreInput: function scoreInput() {
    var guessAndScore = this.questionRenderer.guessAndScore();
    var guess = guessAndScore[0];
    var score = guessAndScore[1]; // Continue to include an empty guess for the now defunct answer area.
    // TODO(alex): Check whether we rely on the format here for
    //             analyzing ProblemLogs. If not, remove this layer.

    var maxCompatGuess = [guess, []];
    var keScore = Util$j.keScoreFromPerseusScore(score, maxCompatGuess, this.questionRenderer.getSerializedState());
    var emptyQuestionAreaWidgets = this.questionRenderer.emptyWidgets();
    this.setState({
      questionCompleted: keScore.correct,
      questionHighlightedWidgets: emptyQuestionAreaWidgets
    });
    return keScore;
  },

  /**
   * Returns an array of all widget IDs in the order they occur in
   * the question content.
   */
  getWidgetIds: function getWidgetIds() {
    return this.questionRenderer.getWidgetIds();
  },

  /**
   * Returns an object mapping from widget ID to KE-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */
  scoreWidgets: function scoreWidgets() {
    var qScore = this.questionRenderer.scoreWidgets();
    var qGuess = this.questionRenderer.getUserInputForWidgets();
    var state = this.questionRenderer.getSerializedState();
    return mapObject(qScore, (score, id) => {
      return Util$j.keScoreFromPerseusScore(score, qGuess[id], state);
    });
  },

  /**
   * Get a representation of the current state of the item.
   */
  getSerializedState: function getSerializedState() {
    return {
      question: this.questionRenderer.getSerializedState(),
      hints: this.hintsRenderer.getSerializedState()
    };
  },
  restoreSerializedState: function restoreSerializedState(state, callback) {
    // We need to wait for both the question renderer and the hints
    // renderer to finish restoring their states.
    var numCallbacks = 2;

    var fireCallback = () => {
      --numCallbacks;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this.questionRenderer.restoreSerializedState(state.question, fireCallback);
    this.hintsRenderer.restoreSerializedState(state.hints, fireCallback);
  },

  showRationalesForCurrentlySelectedChoices() {
    this.questionRenderer.showRationalesForCurrentlySelectedChoices();
  },

  deselectIncorrectSelectedChoices() {
    this.questionRenderer.deselectIncorrectSelectedChoices();
  },

  render: function render() {
    return /*#__PURE__*/React$1X.createElement("div", null);
  }
});
_module_$1V.exports = ItemRenderer$1;
var _itemRendererJsx = _module_$1V.exports;

/**
 * A copy of the ItemRenderer which renders its question renderer and hints
 * renderer normally instead of ReactDOM.render()ing them into elements in the
 * DOM.
 *
 * As well as check answer, grading, and hints buttons built in
 */

var styles$m = aphrodite.StyleSheet.create({
  hintsContainer: {
    marginLeft: 50
  },
  checkAnswerButton: {
    padding: 10,
    color: "white",
    fontSize: 14,
    borderRadius: 5,
    display: "inline-grid",
    gridTemplateColumns: "1fr",
    gridTemplateRows: "1fr"
  },
  checkAnswerText: {
    gridArea: "1 / 1 / 2 / 2"
  }
});
var QuestionRenderer$1 = createReactClass({
  displayName: "QuestionRenderer",
  propTypes: _objectSpread2(_objectSpread2({}, _mixinsProvideKeypadJsx.propTypes), {}, {
    apiOptions: PropTypes.any,
    initialHintsVisible: PropTypes.number,
    item: PropTypes.shape({
      answerArea: PropTypes.shape({
        calculator: PropTypes.bool,
        chi2Table: PropTypes.bool,
        periodicTable: PropTypes.bool,
        tTable: PropTypes.bool,
        zTable: PropTypes.bool
      }),
      hints: PropTypes.arrayOf(PropTypes.object),
      question: PropTypes.object
    }).isRequired,
    problemNum: PropTypes.number,
    reviewMode: PropTypes.bool,
    onAnswer: PropTypes.func,
    onHint: PropTypes.func
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      apiOptions: {},
      // a deep default is done in `this.update()`
      initialHintsVisible: 0,
      problemNum: 0,
      reviewMode: false,
      onAnswer: () => {},
      onHint: () => {}
    };
  },
  getInitialState: function getInitialState() {
    return _objectSpread2(_objectSpread2({}, _mixinsProvideKeypadJsx.getInitialState()), {}, {
      hintsVisible: this.props.initialHintsVisible,
      answerState: 'unanswered',
      questionHighlightedWidgets: []
    });
  },
  componentDidMount: function componentDidMount() {
    _mixinsProvideKeypadJsx.componentDidMount.call(this);
    this._currentFocus = null;
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      questionHighlightedWidgets: []
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    if (this.props.apiOptions.answerableCallback) {
      var isAnswerable = this.questionRenderer.emptyWidgets().length === 0;
      this.props.apiOptions.answerableCallback(isAnswerable);
    }
  },

  componentWillUnmount() {
    _mixinsProvideKeypadJsx.componentWillUnmount.call(this);
  },

  keypadElement() {
    return _mixinsProvideKeypadJsx.keypadElement.call(this);
  },

  _handleFocusChange: function _handleFocusChange(newFocus, oldFocus) {
    if (newFocus != null) {
      this._setCurrentFocus(newFocus);
    } else {
      this._onRendererBlur(oldFocus);
    }
  },
  // Sets the current focus path and element and
  // send an onChangeFocus event back to our parent.
  _setCurrentFocus: function _setCurrentFocus(newFocus) {
    var keypadElement = this.keypadElement(); // By the time this happens, newFocus cannot be a prefix of
    // prevFocused, since we must have either been called from
    // an onFocusChange within a renderer, which is only called when
    // this is not a prefix, or between the question and answer areas,
    // which can never prefix each other.

    var prevFocus = this._currentFocus;
    this._currentFocus = newFocus; // Determine whether the newly focused path represents an input.

    var inputPaths = this.getInputPaths();
    var didFocusInput = this._currentFocus && inputPaths.some(inputPath => {
      return Util$q.inputPathsEqual(inputPath, this._currentFocus);
    });

    if (this.props.apiOptions.onFocusChange != null) {
      this.props.apiOptions.onFocusChange(this._currentFocus, prevFocus, didFocusInput && keypadElement && _reactDom__default["default"].findDOMNode(keypadElement));
    }

    if (keypadElement) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  },
  _onRendererBlur: function _onRendererBlur(blurPath) {
    var blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
    // before blur

    if (!_underscore__default["default"].isEqual(blurPath, blurringFocusPath)) {
      return;
    } // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused.
    // If a different widget was focused, we'll see an onBlur event
    // now, but then an onFocus event on a different element before
    // this callback is executed


    _underscore__default["default"].defer(() => {
      if (_underscore__default["default"].isEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    });
  },

  /**
   * Accepts a question area widgetId, or an answer area widgetId of
   * the form "answer-input-number 1", or the string "answer-area"
   * for the whole answer area (if the answer area is a single widget).
   */
  _setWidgetProps: function _setWidgetProps(widgetId, newProps, callback) {
    this.questionRenderer._setWidgetProps(widgetId, newProps, callback);
  },
  _handleAPICall: function _handleAPICall(functionName, path) {
    // Get arguments to pass to function, including `path`
    var functionArgs = _underscore__default["default"].rest(arguments);

    var caller = this.questionRenderer;
    return caller[functionName](...functionArgs);
  },
  setInputValue: function setInputValue(path, newValue, focus) {
    return this._handleAPICall("setInputValue", path, newValue, focus);
  },
  focusPath: function focusPath(path) {
    return this._handleAPICall("focusPath", path);
  },
  blurPath: function blurPath(path) {
    return this._handleAPICall("blurPath", path);
  },
  getDOMNodeForPath: function getDOMNodeForPath(path) {
    return this._handleAPICall("getDOMNodeForPath", path);
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(path) {
    return this._handleAPICall("getGrammarTypeForPath", path);
  },
  getInputPaths: function getInputPaths() {
    var questionAreaInputPaths = this.questionRenderer.getInputPaths();
    return questionAreaInputPaths;
  },
  handleInteractWithWidget: function handleInteractWithWidget(widgetId) {
    var withRemoved = _underscore__default["default"].difference(this.state.questionHighlightedWidgets, [widgetId]);

    this.setState({
      answerState: "unanswered",
      questionHighlightedWidgets: withRemoved
    });

    if (this.props.apiOptions.interactionCallback) {
      this.props.apiOptions.interactionCallback();
    }
  },
  focus: function focus() {
    return this.questionRenderer.focus();
  },
  blur: function blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  },
  showHint: function showHint() {
    if (this.state.hintsVisible < this.getNumHints()) {
      this.props.onHint(this.state.hintsVisible + 1, this.getNumHints());
      this.setState({
        hintsVisible: this.state.hintsVisible + 1
      });
    }
  },
  getNumHints: function getNumHints() {
    return this.props.item.hints.length;
  },

  /**
   * Grades the item.
   *
   * Returns a KE-style score of {
   *     empty: bool,
   *     correct: bool,
   *     message: string|null,
   *     guess: Array
   * }
   */
  scoreInput: function scoreInput() {
    var [guess, score] = this.questionRenderer.guessAndScore();
    var isCorrect = score.type === "points" && score.earned >= score.total;
    var emptyQuestionAreaWidgets = this.questionRenderer.emptyWidgets(); // TODO(aria): Add in "unfinished"/invalid suppost to answerState
    // for better check answer messages

    this.setState({
      answerState: isCorrect ? "correct" : "incorrect",
      questionHighlightedWidgets: emptyQuestionAreaWidgets
    });
    return [guess, score];
  },
  checkAnswer: function checkAnswer(e) {
    e.preventDefault();
    var [guess, score] = this.scoreInput();
    this.props.onAnswer(guess, score);
  },

  /**
   * Returns an array of all widget IDs in the order they occur in
   * the question content.
   */
  getWidgetIds: function getWidgetIds() {
    return this.questionRenderer.getWidgetIds();
  },

  /**
   * Returns an object mapping from widget ID to KE-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */
  scoreWidgets: function scoreWidgets() {
    var qScore = this.questionRenderer.scoreWidgets();
    var qGuess = this.questionRenderer.getUserInputForWidgets();
    var state = this.questionRenderer.getSerializedState();
    return mapObject(qScore, (score, id) => {
      return Util$q.keScoreFromPerseusScore(score, qGuess[id], state);
    });
  },

  /**
   * Get a representation of the current state of the item.
   */
  getSerializedState: function getSerializedState() {
    return {
      question: this.questionRenderer.getSerializedState(),
      hints: this.hintsRenderer.getSerializedState()
    };
  },
  restoreSerializedState: function restoreSerializedState(state, callback) {
    // We need to wait for both the question renderer and the hints
    // renderer to finish restoring their states.
    var numCallbacks = 2;

    var fireCallback = () => {
      --numCallbacks;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this.questionRenderer.restoreSerializedState(state.question, fireCallback);
    this.hintsRenderer.restoreSerializedState(state.hints, fireCallback);
  },

  showRationalesForCurrentlySelectedChoices() {
    this.questionRenderer.showRationalesForCurrentlySelectedChoices();
  },

  deselectIncorrectSelectedChoices() {
    this.questionRenderer.deselectIncorrectSelectedChoices();
  },

  render: function render() {
    var apiOptions = _objectSpread2(_objectSpread2(_objectSpread2({}, Options.defaults), this.props.apiOptions), {}, {
      onFocusChange: this._handleFocusChange
    });

    var questionRenderer = /*#__PURE__*/_react__namespace.createElement(_rendererJsx, _extends({
      keypadElement: this.keypadElement(),
      problemNum: this.props.problemNum,
      onInteractWithWidget: this.handleInteractWithWidget,
      highlightedWidgets: this.state.questionHighlightedWidgets,
      apiOptions: apiOptions,
      questionCompleted: this.state.answerState === "correct",
      reviewMode: this.props.reviewMode,
      ref: elem => this.questionRenderer = elem
    }, this.props.item.question));
    var hintsRenderer = /*#__PURE__*/_react__namespace.createElement(_hintsRendererJsx, {
      hints: this.props.item.hints,
      hintsVisible: this.state.hintsVisible,
      apiOptions: apiOptions,
      ref: elem => this.hintsRenderer = elem
    });
    var isOutOfHints = this.state.hintsVisible >= this.getNumHints();
    return /*#__PURE__*/_react__namespace.createElement("form", {
      className: "framework-perseus",
      onSubmit: this.checkAnswer
    }, /*#__PURE__*/_react__namespace.createElement("div", null, questionRenderer), /*#__PURE__*/_react__namespace.createElement("div", {
      style: {
        paddingTop: 10,
        paddingBottom: 10
      }
    }, /*#__PURE__*/_react__namespace.createElement("button", {
      type: "submit",
      className: "check-answer-button " + aphrodite.css(styles$m.checkAnswerButton),
      style: {
        backgroundColor: this.state.answerState === "incorrect" ? "orange" : "green"
      },
      disabled: this.state.answerState === "correct"
    }, /*#__PURE__*/_react__namespace.createElement("span", {
      className: aphrodite.css(styles$m.checkAnswerText),
      style: {
        visibility: this.state.answerState === "correct" ? "visible" : "hidden"
      }
    }, "\uD83C\uDF1F Yes! You got it!"), /*#__PURE__*/_react__namespace.createElement("span", {
      className: aphrodite.css(styles$m.checkAnswerText),
      style: {
        visibility: this.state.answerState === "incorrect" ? "visible" : "hidden"
      }
    }, "Try again"), /*#__PURE__*/_react__namespace.createElement("span", {
      className: aphrodite.css(styles$m.checkAnswerText),
      style: {
        visibility: this.state.answerState === "unanswered" ? "visible" : "hidden"
      }
    }, "Check answer")), /*#__PURE__*/_react__namespace.createElement("div", {
      style: {
        display: 'inline-block',
        width: 10
      }
    }), /*#__PURE__*/_react__namespace.createElement("button", {
      type: "button",
      style: {
        padding: 10,
        backgroundColor: isOutOfHints ? "darkgray" : "orange",
        color: "white",
        fontSize: 14,
        borderRadius: 5
      },
      disabled: isOutOfHints,
      onClick: this.showHint
    }, isOutOfHints ? "We're out of hints!" : "I'd like a hint!")), /*#__PURE__*/_react__namespace.createElement("div", {
      className: // Avoid adding any horizontal padding when applying the
      // mobile hint styles, which are flush to the left.
      // NOTE(charlie): We may still want to apply this
      // padding for desktop exercises.
      !apiOptions.isMobile && aphrodite.css(styles$m.hintsContainer)
    }, hintsRenderer));
  }
});

var _module_$1U = {
  exports: {}
};
/**
 * An article renderer. Articles are long-form pieces of content,
 * composed of multiple (Renderer) sections concatenated together.
 */

var React$1W = _react__default["default"];
var ReactDOM$s = _reactDom__default["default"];
var classNames$d = _classnames__default["default"];
var Util$i = Util$q;
var ApiOptions$t = _perseusApiJsx.Options;
var ApiClassNames$c = _perseusApiJsx.ClassNames;
var Renderer$i = _rendererJsx;
var ProvideKeypad = _mixinsProvideKeypadJsx;
var Gorgon$2 = _gorgonGorgonJs;
var rendererProps = PropTypes.shape({
  content: PropTypes.string,
  widgets: PropTypes.object,
  images: PropTypes.object
});
var ArticleRenderer$1 = createReactClass({
  displayName: "ArticleRenderer",
  propTypes: _objectSpread2(_objectSpread2({}, ProvideKeypad.propTypes), {}, {
    apiOptions: PropTypes.shape({
      onFocusChange: PropTypes.func,
      isMobile: PropTypes.bool
    }),
    json: PropTypes.oneOfType([rendererProps, PropTypes.arrayOf(rendererProps)]).isRequired,
    // Whether to use the new Bibliotron styles for articles
    useNewStyles: PropTypes.bool,
    linterContext: linterContextProps,
    legacyPerseusLint: PropTypes.arrayOf(PropTypes.string)
  }),

  getDefaultProps() {
    return {
      apiOptions: {},
      useNewStyles: false,
      linterContext: linterContextDefault
    };
  },

  getInitialState() {
    return ProvideKeypad.getInitialState();
  },

  componentDidMount() {
    ProvideKeypad.componentDidMount.call(this);
    this._currentFocus = null;
  },

  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  },

  componentWillUnmount() {
    ProvideKeypad.componentWillUnmount.call(this);
  },

  keypadElement() {
    return ProvideKeypad.keypadElement.call(this);
  },

  _handleFocusChange(newFocusPath, oldFocusPath) {
    // TODO(charlie): DRY this up--some of this logic is repeated in
    // ItemRenderer.
    if (newFocusPath) {
      this._setCurrentFocus(newFocusPath);
    } else {
      this._onRendererBlur(oldFocusPath);
    }
  },

  _setCurrentFocus(newFocusPath) {
    var keypadElement = this.keypadElement();
    var prevFocusPath = this._currentFocus;
    this._currentFocus = newFocusPath; // Use the section prefix to extract the relevant Renderer's input
    // paths, so as to check whether the focused path represents an
    // input.

    var didFocusInput = false;

    if (this._currentFocus) {
      var [sectionRef, ...focusPath] = this._currentFocus;
      var inputPaths = this.refs[sectionRef].getInputPaths();
      didFocusInput = inputPaths.some(inputPath => {
        return Util$i.inputPathsEqual(inputPath, focusPath);
      });
    }

    if (this.props.apiOptions.onFocusChange != null) {
      this.props.apiOptions.onFocusChange(this._currentFocus, prevFocusPath, didFocusInput && keypadElement && ReactDOM$s.findDOMNode(keypadElement));
    }

    if (keypadElement) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  },

  _onRendererBlur(blurPath) {
    var blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
    // before blur.

    if (!Util$i.inputPathsEqual(blurPath, blurringFocusPath)) {
      return;
    } // Wait until after any new focus events fire this tick before declaring
    // that nothing is focused, since if there were a focus change across
    // sections, we could receive the blur before the focus.


    setTimeout(() => {
      if (Util$i.inputPathsEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    });
  },

  blur() {
    if (this._currentFocus) {
      var [sectionRef, ...inputPath] = this._currentFocus;
      this.refs[sectionRef].blurPath(inputPath);
    }
  },

  _sections() {
    return Array.isArray(this.props.json) ? this.props.json : [this.props.json];
  },

  render() {
    var apiOptions = _objectSpread2(_objectSpread2(_objectSpread2({}, ApiOptions$t.defaults), this.props.apiOptions), {}, {
      isArticle: true
    });

    var classes = classNames$d({
      "framework-perseus": true,
      "perseus-article": true,
      "bibliotron-article": this.props.useNewStyles,
      // NOTE(charlie): For exercises, this is applied outside of Perseus
      // (in webapp).
      [ApiClassNames$c.MOBILE]: apiOptions.isMobile
    }); // TODO(alex): Add mobile api functions and pass them down here

    var sections = this._sections().map((section, i) => {
      var refForSection = "section-".concat(i);
      return /*#__PURE__*/React$1W.createElement("div", {
        key: i,
        className: "clearfix"
      }, /*#__PURE__*/React$1W.createElement(Renderer$i, _extends({}, section, {
        ref: refForSection,
        key: i,
        key_: i,
        keypadElement: this.keypadElement(),
        apiOptions: _objectSpread2(_objectSpread2({}, apiOptions), {}, {
          onFocusChange: (newFocusPath, oldFocusPath) => {
            // Prefix the paths with the relevant section,
            // so as to allow us to distinguish between
            // equivalently-named inputs across Renderers.
            this._handleFocusChange(newFocusPath && [refForSection].concat(newFocusPath), oldFocusPath && [refForSection].concat(oldFocusPath));
          }
        }),
        linterContext: Gorgon$2.pushContextStack(this.props.linterContext, "article"),
        legacyPerseusLint: this.props.legacyPerseusLint
      })));
    });

    return /*#__PURE__*/React$1W.createElement("div", {
      className: classes
    }, sections);
  }

});
_module_$1U.exports = ArticleRenderer$1;
var _articleRendererJsx = _module_$1U.exports;

var _module_$1T = {
  exports: {}
};
/**
 * These are things that widgets should exclude when serializing themselves.
 *
 * The use of this list needs to die. Basically, there are codepaths that
 * blindly serialize the "props" of a widget so that it can pass around its
 * info. Unfortunately, props aren't guaranteed to be serializable, and
 * automatically serializing schemaless list of attributes causes issues (e.g.
 * circular JSON structures sometimes).
 *
 * This blacklists things that we know don't need to be serialized.
 */

_module_$1T.exports = [// standard props "added" by react
// (technically the renderer still adds them)
"key", "ref", // added by src/renderer.jsx
"containerSizeClass", "widgetId", "onChange", "problemNum", "apiOptions", "questionCompleted", "findWidgets", // added by src/editor.jsx, for widgets removing themselves
// this is soooo not the right place for this, but alas.
"onRemove", // also added by src/editor.jsx
"id", // Callbacks and items for interaction handling
"onBlur", "onFocus", "trackInteraction", "keypadElement"];
var _mixinsWidgetPropBlacklistJsx = _module_$1T.exports;

var _module_$1S = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var _$1g = _underscore__default["default"];
var WIDGET_PROP_BLACKLIST$2 = _mixinsWidgetPropBlacklistJsx;
var EditorJsonify$o = {
  serialize: function serialize() {
    // Omit props that get passed to all widgets
    return _$1g.omit(this.props, WIDGET_PROP_BLACKLIST$2);
  }
};
_module_$1S.exports = EditorJsonify$o;
var _mixinsEditorJsonifyJsx = _module_$1S.exports;

/**
 * Changeable
 *
 * Adds a this.change() function to a component
 *
 * This.change takes prop changes as parameters, and calls
 * this.props.onChange with the modified props.
 */

var USAGE = "Usage:\n" + "  this.change({propName: 5}, callback);\n" + "  this.change(\"propName\", 5, callback);\n" + "  this.change(\"propName\")";
/**
 * Primary helper function for this.change()
 *
 * Takes the parameters in a consistent style, once this.change() has
 * figured out which way it was called.
 */

var _changeMultiple = function _changeMultiple(component, newProps, callback) {
  // Omit "default" props:
  // ref and key come from react, and don't actually represent
  //   the conceptual state of our component
  // onChange comes from our parent to allow this modification,
  //   and doesn't conceptually represent the state of our component
  var currProps = _underscore__default["default"].omit(component.props, _mixinsWidgetPropBlacklistJsx);

  var nextProps = _underscore__default["default"].extend(currProps, newProps);

  component.props.onChange(nextProps, callback);
};
/**
 * Helper function for changing a single prop
 */


var _changeSingle = function _changeSingle(component, propName, value, callback) {
  if (value === undefined) {
    // If called with a single prop name, return a lambda to change
    // a single prop on the current object
    return _underscore__default["default"].partial(_changeSingle, component, propName);
  } else {
    // If called with two values, change a single prop of the
    // current object
    var newProps = {};
    newProps[propName] = value;

    _changeMultiple(component, newProps, callback);
  }
};
/**
 * this.change()
 *
 * Can be called as follows:
 * this.change(newProps, callback);
 *
 * this.change(propName, propValue, callback);
 *
 * this.change(propName) -> returns a lambda that takes a prop value to
 * set and a callback to call after having set that value.
 */


var change = function change(newPropsOrSinglePropName, propValue, callback) {
  if (_underscore__default["default"].isObject(newPropsOrSinglePropName) && callback === undefined) {
    // Called with an object of multiple props to change
    callback = propValue;
    return _changeMultiple(this, newPropsOrSinglePropName, // object newProps
    callback);
  } else if (_underscore__default["default"].isString(newPropsOrSinglePropName)) {
    // Called with a string propName of a single prop to change
    return _changeSingle(this, newPropsOrSinglePropName, // string propName
    propValue, callback);
  } else {
    throw new Error("Invalid types sent to this.change(): " + _underscore__default["default"].toArray(arguments).join() + "\n" + USAGE);
  }
};
var propTypes = {
  onChange: _propTypes__default["default"].func.isRequired
};
({
  onChange: _propTypes__default["default"].func.isRequired
});
var Changeable$Q = {
  change: change,
  propTypes: propTypes
};

/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * This is the editor for the simple-markdown-tester widget. This is what shows
 * up on the left side of the screen in the demo. Only the question writer
 * sees this.
 */

var React$1V = _react__default["default"];
var Changeable$P = Changeable$Q;
var EditorJsonify$n = _mixinsEditorJsonifyJsx;
var TextArea = createReactClass({
  displayName: "TextArea",
  render: function render() {
    return /*#__PURE__*/React$1V.createElement("textarea", {
      ref: "input",
      value: this.props.value || "",
      onChange: this.changeValue
    });
  },
  focus: function focus() {
    this.refs.input.focus();
    return true;
  },
  changeValue: function changeValue(e) {
    // Translating from the js event e to the value
    // of the textbox to send to onChange
    this.props.onChange(e.target.value);
  }
});
createReactClass({
  displayName: "SimpleMarkdownTesterEditor",
  propTypes: _objectSpread2({}, Changeable$P.propTypes),
  getDefaultProps: function getDefaultProps() {
    return {
      value: ""
    };
  },
  render: function render() {
    return /*#__PURE__*/React$1V.createElement("div", null, /*#__PURE__*/React$1V.createElement("label", null, /*#__PURE__*/React$1V.createElement("div", null, "Simple markdown contents:"), /*#__PURE__*/React$1V.createElement("div", null, /*#__PURE__*/React$1V.createElement(TextArea, {
      value: this.props.value,
      onChange: this.change("value"),
      ref: "input"
    }))));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$P.change.apply(this, args);
  },

  focus: function focus() {
    this.refs.input.focus();
    return true;
  },

  serialize() {
    return EditorJsonify$n.serialize.call(this);
  }

});

/* eslint-disable comma-dangle, no-var, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1U = _react__default["default"];
var _$1f = _underscore__default["default"];
var Changeable$O = Changeable$Q;
var PerseusMarkdown$2 = _perseusMarkdownJsx;
var mdParse = PerseusMarkdown$2.parse;
var mdOutput = PerseusMarkdown$2.basicOutput;
var SimpleMarkdownTester = createReactClass({
  displayName: "SimpleMarkdownTester",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$O.propTypes), {}, {
    value: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      value: ""
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$O.change.apply(this, args);
  },

  toJSON: function toJSON() {
    return {};
  },
  render: function render() {
    var parsed = mdParse(this.props.value);
    var output = mdOutput(parsed);
    return /*#__PURE__*/React$1U.createElement("div", null, output);
  },

  /**
   * Widgets that are focusable should add a focus method that returns
   * true if focusing succeeded. The first such widget found will be
   * focused on page load.
   */
  focus: function focus() {
    this.refs.input.focus();
    return true;
  },

  /**
   * simpleValidate is called for grading. Rubric is the result of calling
   * toJSON() on the editor that created this widget.
   *
   * Should return an object representing the grading result, such as
   * {
   *     type: "points",
   *     earned: 1,
   *     total: 1,
   *     message: null
   * }
   */
  simpleValidate: function simpleValidate(rubric) {
    return SimpleMarkdownTester.validate(this.toJSON(), rubric);
  }
});
/**
 * This is the widget's grading function
 */

_$1f.extend(SimpleMarkdownTester, {
  /**
   * simpleValidate generally defers to this function
   *
   * state is usually the result of toJSON on the widget
   * rubric is the result of calling toJSON() on the editor
   */
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});
/**
 * For this widget to work, we must require() this file in src/all-widgets.js
 */


({
  name: "simple-markdown-tester",
  displayName: "Simple Markdown Tester",
  hidden: true,
  // Hides this widget from the Perseus.Editor widget select
  widget: SimpleMarkdownTester,
  transform: _$1f.identity
});

/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1T = _react__default["default"];
var Changeable$N = Changeable$Q;
var EditorJsonify$m = _mixinsEditorJsonifyJsx;
/**
 * This is the widget's editor. This is what shows up on the left side
 * of the screen in the demo. Only the question writer sees this.
 */

createReactClass({
  displayName: "ExampleWidgetEditor",
  propTypes: _objectSpread2({}, Changeable$N.propTypes),
  getDefaultProps: function getDefaultProps() {
    return {
      correct: ""
    };
  },
  handleAnswerChange: function handleAnswerChange(event) {
    this.change({
      correct: event.target.value
    });
  },
  render: function render() {
    return /*#__PURE__*/React$1T.createElement("div", null, /*#__PURE__*/React$1T.createElement("label", null, "Correct answer:", /*#__PURE__*/React$1T.createElement("input", {
      value: this.props.correct,
      onChange: this.handleAnswerChange,
      ref: "input"
    })));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$N.change.apply(this, args);
  },

  focus: function focus() {
    this.refs.input.focus();
    return true;
  },

  serialize() {
    return EditorJsonify$m.serialize.call(this);
  }

});

/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * This is a simple number-entry widget
 * It is not as powerful as number-input, but has a simpler, more
 * representative structure as an example widget, and is easier to
 * test new ideas on.
 *
 * TODO(jack): Add more comments
 */

var React$1S = _react__default["default"];
var Changeable$M = Changeable$Q;
var _$1e = _underscore__default["default"];
var TextInput$b = createReactClass({
  displayName: "TextInput",
  render: function render() {
    return /*#__PURE__*/React$1S.createElement("input", {
      ref: "input",
      value: this.props.value || "",
      onChange: this.changeValue
    });
  },
  focus: function focus() {
    this.refs.input.focus();
    return true;
  },
  changeValue: function changeValue(e) {
    // Translating from the js event e to the value
    // of the textbox to send to onChange
    this.props.onChange(e.target.value);
  }
});
/**
 * This is the widget's renderer. It shows up in the right column
 * in the demo, and is what is visible to users, and where
 * users enter their answers.
 */

var ExampleWidget = createReactClass({
  displayName: "ExampleWidget",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$M.propTypes), {}, {
    value: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      value: ""
    };
  },

  /**
   * Tell our parent to update our props.
   */
  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$M.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$1S.createElement(TextInput$b, {
      ref: "input",
      value: this.props.value,
      onChange: this.change("value")
    });
  },
  getUserInput: function getUserInput() {
    return this.props.value;
  },

  /**
   * Widgets that are focusable should add a focus method that returns
   * true if focusing succeeded. The first such widget found will be
   * focused on page load.
   */
  focus: function focus() {
    this.refs.input.focus();
    return true;
  },

  /**
   * simpleValidate is called for grading. Rubric is the result of calling
   * getUserInput() on the editor that created this widget.
   *
   * Should return an object representing the grading result, such as
   * {
   *     type: "points",
   *     earned: 1,
   *     total: 1,
   *     message: null
   * }
   */
  simpleValidate: function simpleValidate(rubric) {
    return ExampleWidget.validate(this.getUserInput(), rubric);
  }
});
/**
 * This is the widget's grading function
 */

_$1e.extend(ExampleWidget, {
  /**
   * simpleValidate generally defers to this function
   *
   * value is usually the result of getUserInput on the widget
   * rubric is the result of calling serialize() on the editor
   */
  validate: function validate(value, rubric) {
    if (value === "") {
      return {
        type: "invalid",
        message: "It looks like you haven't answered all of the " + "question yet."
      };
    } else if (value === rubric.correct) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    } else {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
  }
});

var _module_$1R = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* Free implementation of getUserInput. This should be used sparingly, since it
 * just returns all the widget's props rather than picking out those which were
 * input by the user.
 */

var WIDGET_PROP_BLACKLIST$1 = _mixinsWidgetPropBlacklistJsx;
var _$1d = _underscore__default["default"];
var WidgetJsonifyDeprecated$6 = {
  getUserInput: function getUserInput() {
    // Omit props that get passed to all widgets
    return _$1d.omit(this.props, WIDGET_PROP_BLACKLIST$1);
  }
};
_module_$1R.exports = WidgetJsonifyDeprecated$6;
var _mixinsWidgetJsonifyDeprecatedJsx = _module_$1R.exports;

var _module_$1Q = {
  exports: {}
};
/* eslint-disable brace-style, comma-dangle, no-unused-vars, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * This is an example graphie-using widget
 *
 * TODO(jack): Add more comments
 */

var React$1R = _react__default["default"];
var _$1c = _underscore__default["default"];
var ApiOptions$s = _perseusApiJsx.Options;
var Util$h = Util$q;
var Changeable$L = Changeable$Q;
var WidgetJsonifyDeprecated$5 = _mixinsWidgetJsonifyDeprecatedJsx;
var Graphie$5 = _componentsGraphieJsx;
var MovablePoint$4 = Graphie$5.MovablePoint;
_kmath3.number;
var kpoint$5 = _kmath3.point;
/**
 * This is the widget's renderer. It shows up in the right column
 * in the demo, and is what is visible to users, and where
 * users enter their answers.
 */

var ExampleGraphieWidget$1 = createReactClass({
  displayName: "ExampleGraphieWidget",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$L.propTypes), {}, {
    apiOptions: ApiOptions$s.propTypes,
    graph: PropTypes.object.isRequired,
    coord: PropTypes.arrayOf(PropTypes.number)
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      // We want to allow our coord to be null to test if the
      // user has interacted with this widget yet when grading it
      coord: null,
      graph: {
        box: [400, 400],
        labels: ["x", "y"],
        range: [[-10, 10], [-10, 10]],
        step: [1, 1],
        gridStep: [1, 1],
        valid: true,
        backgroundImage: null,
        markings: "grid",
        showProtractor: false
      }
    };
  },
  getUserInput: function getUserInput() {
    return WidgetJsonifyDeprecated$5.getUserInput.call(this);
  },
  render: function render() {
    return /*#__PURE__*/React$1R.createElement(Graphie$5, {
      ref: "graphie",
      box: this.props.graph.box,
      range: this.props.graph.range,
      options: this.props.graph,
      setup: this.setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }, /*#__PURE__*/React$1R.createElement(MovablePoint$4, {
      pointSize: 5,
      coord: this.props.coord || [0, 0],
      constraints: [MovablePoint$4.constraints.snap(), MovablePoint$4.constraints.bound()],
      onMove: this.movePoint
    }));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$L.change.apply(this, args);
  },

  movePoint: function movePoint(newCoord) {
    this.change({
      coord: newCoord
    });
  },
  _getGridConfig: function _getGridConfig(options) {
    return _$1c.map(options.step, function (step, i) {
      return Util$h.gridDimensionConfig(step, options.range[i], options.box[i], options.gridStep[i]);
    });
  },
  setupGraphie: function setupGraphie(graphie, options) {
    var gridConfig = this._getGridConfig(options);

    graphie.graphInit({
      range: options.range,
      scale: _$1c.pluck(gridConfig, "scale"),
      axisArrows: "<->",
      labelFormat: function labelFormat(s) {
        return "\\small{" + s + "}";
      },
      gridStep: options.gridStep,
      tickStep: _$1c.pluck(gridConfig, "tickStep"),
      labelStep: 1,
      unityLabels: _$1c.pluck(gridConfig, "unityLabel")
    });
    graphie.label([0, options.range[1][1]], options.labels[1], "above");
  },
  simpleValidate: function simpleValidate(rubric) {
    return ExampleGraphieWidget$1.validate(this.getUserInput(), rubric);
  }
});
/**
 * This is the widget's grading function
 */

_$1c.extend(ExampleGraphieWidget$1, {
  validate: function validate(state, rubric) {
    if (state.coord == null) {
      return {
        type: "invalid",
        message: null
      };
    } else if (kpoint$5.equal(state.coord, rubric.correct)) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    } else {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
  }
});
/**
 * For this widget to work, we must export it.
 * We also must require() this file in src/all-widgets.js
 */


_module_$1Q.exports = {
  name: "example-graphie-widget",
  displayName: "Example Graphie Widget",
  hidden: true,
  // Hides this widget from the Perseus.Editor widget select
  widget: ExampleGraphieWidget$1
};
var _exampleGraphieWidgetJsx = _module_$1Q.exports;

/* eslint-disable comma-dangle, no-var, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1Q = _react__default["default"];
var Changeable$K = Changeable$Q;
var EditorJsonify$l = _mixinsEditorJsonifyJsx;
var ExampleGraphieWidget = _exampleGraphieWidgetJsx.widget;
/**
 * This is the widget's editor. This is what shows up on the left side
 * of the screen in the demo page. Only the question writer sees this.
 */

createReactClass({
  displayName: "ExampleGraphieWidgetEditor",
  propTypes: _objectSpread2({}, Changeable$K.propTypes),
  getDefaultProps: function getDefaultProps() {
    return {
      correct: [4, 4],
      graph: {
        box: [340, 340],
        labels: ["x", "y"],
        range: [[-10, 10], [-10, 10]],
        step: [1, 1],
        gridStep: [1, 1],
        valid: true,
        backgroundImage: null,
        markings: "grid",
        showProtractor: false
      }
    };
  },
  render: function render() {
    return /*#__PURE__*/React$1Q.createElement("div", null, /*#__PURE__*/React$1Q.createElement(ExampleGraphieWidget, {
      graph: this.props.graph,
      coord: this.props.correct,
      onChange: this.handleChange,
      apiOptions: this.props.apiOptions
    }));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$K.change.apply(this, args);
  },

  handleChange: function handleChange(newProps) {
    if (newProps.coord) {
      this.change({
        correct: newProps.coord
      });
    }
  },

  serialize() {
    return EditorJsonify$l.serialize.call(this);
  }

});

var module$8 = {
  exports: {}
};
var React$1P = _react__default["default"];
var createReactClass$7 = _createReactClass__default["default"];
var PropTypes$7 = _propTypes__default["default"];
/* You know when you want to propagate input to a parent...
 * but then that parent does something with the input...
 * then changing the props of the input...
 * on every keystroke...
 * so if some input is invalid or incomplete...
 * the input gets reset or otherwise effed...
 *
 * This is the solution.
 *
 * Enough melodrama. Its an input that only sends changes
 * to its parent on blur.
 */

var BlurInput$6 = createReactClass$7({
  displayName: "BlurInput",
  propTypes: {
    className: PropTypes$7.string,
    style: PropTypes$7.any,
    value: PropTypes$7.string.isRequired,
    onChange: PropTypes$7.func.isRequired
  },
  getInitialState: function getInitialState() {
    return {
      value: this.props.value
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      value: nextProps.value
    });
  },
  handleChange: function handleChange(e) {
    this.setState({
      value: e.target.value
    });
  },
  handleBlur: function handleBlur(e) {
    this.props.onChange(e.target.value);
  },
  render: function render() {
    return /*#__PURE__*/React$1P.createElement("input", {
      className: this.props.className,
      style: this.props.style,
      type: "text",
      value: this.state.value,
      onChange: this.handleChange,
      onBlur: this.handleBlur
    });
  }
});
module$8.exports = BlurInput$6;
var _reactComponentsBlurInputJsx = module$8.exports;

var module$7 = {
  exports: {}
};
var React$1O = _react__default["default"];
var createReactClass$6 = _createReactClass__default["default"];
var PropTypes$6 = _propTypes__default["default"];
var colors = {
  grayLight: '#aaa',
  basicBorderColor: '#ccc',
  white: '#fff'
};
var triangleBeforeAfter = {
  borderBottom: '9px solid transparent',
  borderTop: '9px solid transparent',
  content: '" "',
  height: '0',
  position: 'absolute',
  top: '0',
  width: '0'
};
var styles$l = aphrodite.StyleSheet.create({
  infoTip: {
    display: 'inline-block',
    marginLeft: '5px',
    position: 'relative'
  },
  infoTipContainer: {
    position: 'absolute',
    top: '-12px',
    left: '22px',
    zIndex: '1000'
  },
  infoTipTriangle: {
    height: '10px',
    left: '0',
    position: 'absolute',
    top: '8px',
    width: '0',
    zIndex: '1',
    ':before': Object.assign({}, triangleBeforeAfter, {
      borderRight: '9px solid #bbb',
      right: '0'
    }),
    ':after': Object.assign({}, triangleBeforeAfter, {
      borderRight: "9px solid ".concat(colors.white),
      right: '-1px'
    })
  },
  verticalShadow: {
    border: "1px solid ".concat(colors.basicBorderColor),
    boxShadow: "0 1px 3px ".concat(colors.basicBorderColor),
    borderBottom: "1px solid ".concat(colors.grayLight)
  },
  infoTipContentContainer: {
    background: colors.white,
    padding: '5px 10px',
    width: '240px'
  }
});
var questionMark = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBB' + 'ZG9iZSBJbWFnZVJlYWR5ccllPAAAA3NpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/' + 'eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+' + 'IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2Jl' + 'IFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAg' + 'ICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5' + 'LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9' + 'IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHht' + 'bG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3Vy' + 'Y2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHht' + 'cE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2N2M3NTAxYS04YmVlLTQ0M2Mt' + 'YmRiNS04OGM2N2IxN2NhYzEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUJCRTk4' + 'Qjc4NjAwMTFFMzg3QUJDNEI4Mzk2QTRGQkQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5p' + 'aWQ6OUJCRTk4QjY4NjAwMTFFMzg3QUJDNEI4Mzk2QTRGQkQiIHhtcDpDcmVhdG9yVG9v' + 'bD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRG' + 'cm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NGE5ZDI0OTMtODk1NC00OGFkLTlh' + 'MTgtZDAwM2MwYWNjNDJlIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3Yzc1MDFh' + 'LThiZWUtNDQzYy1iZGI1LTg4YzY3YjE3Y2FjMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4g' + 'PC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pqm89uYAAADM' + 'SURBVHjaXJA9DoJAEIUH1M4TUHIFsCMGen9OwCGw1YRGW2ntKel0exsojHIBC0ouQAyU' + 'viFDstmXfNmZeS+zm7XSNCXRFiRgJf0bXIHixpbhGdxBBJYC1w/xaA424MhNEATkui71' + 'fU9KqfEU78UbD9PdbJRlOdae55GmhIP+1NV1TcMwkOM41DSNHvRtMhTHMRVFQW3b6mOL' + 'gx99kue5GRp/gIOZuZGvNpTNwjD8oliANU+qqqKu6/TQBdymN57AHjzBT+B6Jx79BRgA' + 'vc49kQA4yxgAAAAASUVORK5CYII=';
var InfoTip$p = createReactClass$6({
  displayName: "InfoTip",
  propTypes: {
    children: PropTypes$6.node
  },
  getInitialState: function getInitialState() {
    return {
      hover: false
    };
  },
  handleMouseEnter: function handleMouseEnter() {
    this.setState({
      hover: true
    });
  },
  handleMouseLeave: function handleMouseLeave() {
    this.setState({
      hover: false
    });
  },
  render: function render() {
    return /*#__PURE__*/React$1O.createElement("div", {
      className: aphrodite.css(styles$l.infoTip)
    }, /*#__PURE__*/React$1O.createElement("img", {
      width: 10,
      height: 10,
      src: questionMark,
      onMouseEnter: this.handleMouseEnter,
      onMouseLeave: this.handleMouseLeave
    }), /*#__PURE__*/React$1O.createElement("div", {
      className: aphrodite.css(styles$l.infoTipContainer),
      style: {
        display: this.state.hover ? 'block' : 'none'
      }
    }, /*#__PURE__*/React$1O.createElement("div", {
      className: aphrodite.css(styles$l.infoTipTriangle)
    }), /*#__PURE__*/React$1O.createElement("div", {
      className: aphrodite.css(styles$l.verticalShadow, styles$l.infoTipContentContainer)
    }, this.props.children)));
  }
});
module$7.exports = InfoTip$p;
var _reactComponentsInfoTipJsx = module$7.exports;

var _module_$1P = {
  exports: {}
};
/**
 * A wrapper around react-components/info-tip.jsx that can be rendered on the
 * server without causing a checksum mismatch on the client.
 * (RCSS generates classnames with a randomSuffix, which ensures that any
 * two sets of generated classnames will not match.)
 */

var React$1N = _react__default["default"];
var ReactComponentsInfoTip = _reactComponentsInfoTipJsx;
var InfoTip$o = createReactClass({
  displayName: "InfoTip",
  getInitialState: function getInitialState() {
    return {
      didMount: false
    };
  },
  componentDidMount: function componentDidMount() {
    /* eslint-disable react/no-did-mount-set-state */
    this.setState({
      didMount: true
    });
    /* eslint-enable react/no-did-mount-set-state */
  },
  render: function render() {
    if (this.state.didMount) {
      return /*#__PURE__*/React$1N.createElement(ReactComponentsInfoTip, this.props);
    } else {
      return /*#__PURE__*/React$1N.createElement("div", null);
    }
  }
});
_module_$1P.exports = InfoTip$o;
var _componentsInfoTipJsx = _module_$1P.exports;

var _module_$1O = {
  exports: {}
};
/* eslint-disable no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1M = _react__default["default"];
var Changeable$J = Changeable$Q;
var EditorJsonify$k = _mixinsEditorJsonifyJsx;
var InfoTip$n = _componentsInfoTipJsx;
var BlurInput$5 = _reactComponentsBlurInputJsx;
var KA_VIDEO_URL = /khanacademy\.org\/.*\/v\/(.*)$/;
/**
 * Turns Khan Academy URLs into the KA slugs, if possible. Any other URLs are
 * returned unchanged.
 */

function getSlugFromUrl(url) {
  var match = KA_VIDEO_URL.exec(url);

  if (match) {
    return match[1];
  }

  return url;
}
/**
 * This is the main editor for this widget, to specify all the options.
 */


var VideoEditor = createReactClass({
  displayName: "VideoEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$J.propTypes), {}, {
    location: PropTypes.string,
    onChange: PropTypes.func
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      location: ""
    };
  },
  _handleUrlChange: function _handleUrlChange(url) {
    this.props.onChange({
      location: getSlugFromUrl(url)
    });
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$J.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$k.serialize.call(this);
  },

  render: function render() {
    return /*#__PURE__*/React$1M.createElement("div", null, /*#__PURE__*/React$1M.createElement("label", null, "URL or KA Video Slug:", " ", /*#__PURE__*/React$1M.createElement(BlurInput$5, {
      name: "location",
      value: this.props.location,
      style: {
        width: 290
      },
      onChange: this._handleUrlChange
    }), /*#__PURE__*/React$1M.createElement(InfoTip$n, null, "You can paste any URL here. KA video URLs will be converted to just the slug.")));
  }
});
_module_$1O.exports = VideoEditor;
var _widgetsVideoEditorJsx = _module_$1O.exports;

var _module_$1N = {
  exports: {}
};
/* eslint-disable no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * This is a video widget for embedding videos in articles.
 */

var React$1L = _react__default["default"];
var _$1b = _underscore__default["default"];
var Changeable$I = Changeable$Q;
var FixedToResponsive = _componentsFixedToResponsiveJsx; // Current default is 720p, based on the typical videos we upload currently

var DEFAULT_WIDTH$1 = 1280;
var DEFAULT_HEIGHT$1 = 720;
var KA_EMBED = "https://{hostname}/embed_video?slug={slug}" + "&internal_video_only=1";
var IS_URL = /^https?:\/\//;
var IS_KA_SITE$1 = /khanacademy\.org/;
/**
 * Video renderer.
 */

var Video = createReactClass({
  displayName: "Video",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$I.propTypes), {}, {
    alignment: PropTypes.string,
    location: PropTypes.string
  }),
  getUserInput: function getUserInput() {
    return null;
  },
  simpleValidate: function simpleValidate(rubric) {
    return Video.validate(null, rubric);
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$I.change.apply(this, args);
  },

  render: function render() {
    var location = this.props.location;

    if (!location) {
      return /*#__PURE__*/React$1L.createElement("div", null);
    }

    var url;

    if (IS_URL.test(location)) {
      url = location;
    } else {
      url = KA_EMBED.replace("{slug}", location);
      var currentHostname = document.location.hostname;
      var embedHostname = "www.khanacademy.org";

      if (IS_KA_SITE$1.test(currentHostname)) {
        embedHostname = currentHostname;
      }

      url = url.replace("{hostname}", embedHostname);
    }

    return /*#__PURE__*/React$1L.createElement(FixedToResponsive // @Nolint this is fine, the linter is wrong
    , {
      width: DEFAULT_WIDTH$1,
      height: DEFAULT_HEIGHT$1 // The key is here for the benefit of the editor, to ensure that
      // any changes cause a re-rendering of the frame.
      ,
      key: location + this.props.alignment
    }, /*#__PURE__*/React$1L.createElement("iframe", {
      className: "perseus-video-widget",
      sandbox: "allow-same-origin allow-scripts",
      width: DEFAULT_WIDTH$1,
      height: DEFAULT_HEIGHT$1,
      src: url,
      allowFullScreen: true
    }));
  }
});
/**
 * This is the widget's grading function.
 * Points for videos are tallied by the embedded video itself, in the case
 * of Khan Academy videos.
 */

_$1b.extend(Video, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

_module_$1N.exports = {
  name: "video",
  displayName: "Video",
  defaultAlignment: "block",
  supportedAlignments: ["block", "float-left", "float-right", "full-width"],
  widget: Video
};
var _widgetsVideoJsx = _module_$1N.exports;

/* eslint-disable eqeqeq, indent, keyword-spacing, max-len, no-mixed-spaces-and-tabs, no-unused-vars, no-var, semi, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/*
 * A class for formatting number to significant digits.
 * Copyright (C) 2001 Stephen Ostermiller
 * http://ostermiller.org/contact.pl?regarding?JavaScript+Significant+Figures
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**
 * An object tho both scans floating points to
 * determine the number of significant figures.
 * and can display a floating point using any number
 * of significant figures.
 *
 * @param s A string representation of a floating point.
 */

function SignificantFigures(s) {
  this.order = parseOrder(s);
  this.mantissa = parseMantissa(s);
  this.positive = parseSign(s);
  /**
   * Get the number of significant figures this object uses.
   * Leading zeros are not significant.  Traling zeros up to
   * and after the decimal point are significant.
   * Significant figures is good to know when the number is
   * used in multiplication.
   *
   * @return the number of significant figures.
   */

  this.sigFigs = this.mantissa.length;
  /**
   * Get the least significant decimal this object uses.
   * This is useful to know if a number is being used
   * in addition.
   * 400 - 2 the hundreds place (10^2) is the least significant decimal.
   * 75 - 0 the ones place (10^0) is the least significant decimal.
   * .543 - -3 the 1/1000's place (10^-3) is the least significant decimal.
   *
   * @return an integer representing the least significant decimal place.
   */

  this.sigDecs = this.order - this.mantissa.length;
}
/**
 * Format a floating point for display using the specified
 * number of significant figures and least significant decimal.
 * Scientific notation may used by this method if this
 * object is very small, very large, has many significant
 * figures, or the number of significant figures would be
 * ambiguous in the output if scientific notation were not
 * used.
 *
 * @param f A floating point number that should be displayed
 * @param sigFigs desired number of significant figures (integer).
 * @param sigDecs the least significant decimal place (integer).
 * @param scientific true iff scientific notation should always be used.
 * @return a string of this object formatted correctly.
 */

function displaySigFigs(f, sigFigs, sigDecs, scientific) {
  var s = "" + f;
  var order = parseOrder(s);
  var mantissa = parseMantissa(s);
  var positive = parseSign(s);
  var add;
  var decAdd;
  var sigAdd;
  var zeroScientific = false;

  if (f == 0 || mantissa == "" || mantissa == "0") {
    mantissa = "";

    for (i = 0; i < sigFigs; i++) {
      mantissa += "0";
    }

    order = sigFigs + sigDecs;

    if (sigDecs < 0 && -sigDecs >= sigFigs) {
      zeroScientific = true;
    }
  } else {
    decAdd = order - mantissa.length - sigDecs;
    sigAdd = sigFigs - mantissa.length;
    add = Math.min(sigAdd, decAdd);

    if (add < 0) {
      var rounded = round(mantissa, -add);

      if (rounded.length > mantissa.length + add) {
        order++;

        if (decAdd > sigAdd) {
          rounded = round(rounded, 1);
        }
      }

      mantissa = rounded;
    } else if (add > 0) {
      for (i = 0; i < add; i++) {
        mantissa += "0";
      }
    }

    if (mantissa == "" || mantissa == "0") {
      mantissa = "0";
      positive = true;
      order = 1 + sigDecs;

      if (order != 0) {
        zeroScientific = true;
      }
    }
  }

  var useScientific = scientific || mantissa.length > 20 || order > 4 || order < -2 || order - mantissa.length > 0 && trailingZeros(mantissa) > 0 || zeroScientific;
  var returnVal = "";

  if (!positive) {
    returnVal += "-";
  }

  if (useScientific) {
    returnVal += mantissa.charAt(0);

    if (mantissa.length > 1) {
      returnVal += "." + mantissa.substring(1, mantissa.length);
    }

    if (order - 1 != 0) {
      returnVal += " x 10^" + (order - 1);
    }
  } else {
    var wholePart = "";
    var fractPart = "";
    var needDot = true;

    if (order > 0) {
      if (mantissa.length > order) {
        wholePart = mantissa.substring(0, order);
        fractPart = mantissa.substring(order, mantissa.length);
      } else {
        wholePart = mantissa;
        needDot = trailingZeros(mantissa) != 0;

        for (var i = 0; i < order - mantissa.length; i++) {
          wholePart += "0";
        }
      }
    } else {
      for (i = 0; i < -order; i++) {
        fractPart += "0";
      }

      fractPart += mantissa;
    }

    returnVal += (wholePart == "" ? "0" : wholePart) + (needDot ? "." : "") + fractPart;
  }

  return returnVal;
}
/**
 * Count the significant trailing zeros on this object.
 *
 * @return the number of trailing zeros
 */

function trailingZeros(mantissa) {
  var zeros = 0;

  for (var i = mantissa.length - 1; i >= 0; i--) {
    var c = mantissa.charAt(i);

    if (c == "0") {
      zeros++;
    } else {
      return zeros;
    }
  }

  return zeros;
}
/**
 * Parse a string representation of a floating point
 * and pull out the sign.
 *
 * @param s the string representation of a floating point.
 * @return true iff this is a positive number
 */


function parseSign(s) {
  var beginning = true;
  var seenDot = false;
  var seenSomething = false;
  var zeros = "";
  var all = "";
  var pos = true;

  for (var i = 0; i < s.length; i++) {
    var c = s.charAt(i);

    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;

      beginning = false;
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        }
      } else {

        if (seenSomething) {
          zeros += c;
        }
      }

      beginning = false;
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
      beginning = false;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      parseInt(s.substring(i + 1, s.length));
      i = s.length;
    } else if (beginning && (c == "+" || c == "-")) {
      if (c == "-") {
        pos = !pos;
      }
    }
  }

  if (all == "") {
    return true;
  } else {
    return pos;
  }
}
/**
 * Parse a string representation of a floating point
 * and pull out the mantissa.
 *
 * @param s the string representation of a floating point.
 * @return the mantissa of this number.
 */


function parseMantissa(s) {
  var seenDot = false;
  var seenSomething = false;
  var zeros = "";
  var leadZeros = "";
  var all = "";

  for (var i = 0; i < s.length; i++) {
    var c = s.charAt(i);

    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        } else {
          leadZeros += c;
        }
      } else {

        if (seenSomething) {
          leadZeros += c;
          zeros += c;
        } else {
          leadZeros += c;
        }
      }
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      parseInt(s.substring(i + 1, s.length));
      i = s.length;
    } else ;
  }

  if (all == "") {
    return leadZeros;
  } else {
    return all;
  }
}
/**
 * Parse a string representation of a floating point
 * and pull out the exponent.
 *
 * @param s the string representation of a floating point.
 * @return (integer) the number after the e.
 */


function parseOrder(s) {
  var seenDot = false;
  var seenSomething = false;
  var zeros = "";
  var all = "";
  var decPlaces = 0;
  var totalDecs = 0;

  for (var i = 0; i < s.length; i++) {
    var c = s.charAt(i);

    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;

      if (!seenDot) {
        totalDecs++;
        decPlaces++;
      }
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        } else {
          decPlaces--;
        }
      } else {
        totalDecs++;

        if (seenSomething) {
          decPlaces++;
          zeros += c;
        }
      }
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      var raised = parseInt(s.substring(i + 1, s.length));
      decPlaces += raised;
      totalDecs += raised;
      i = s.length;
    } else ;
  }

  if (all == "") {
    return totalDecs;
  } else {
    return decPlaces;
  }
}
/**
 * Remove the specified number of digits from string by
 * rounding.  Proper rounding rules for scientific purposes
 * are followed.
 * This method may cause an extra significant figure
 * to be added to the number.  For example, if 999999
 * were rounded, A one would carry over and become
 * a significant figure.  Those who call this method
 * should check for this and call round again if needed.
 *
 * @param mantissa A string representing an whole number of arbitrary length.
 * @param digits A number of digits to remove
 * @return A string represted the rounded version of mantissa
 */


function round(mantissa, digits) {
  var last = mantissa.length - digits - 1;

  if (last < 0) {
    return "";
  } else if (last >= mantissa.length - 1) {
    return mantissa;
  } else {
    var nextToLast = mantissa.charAt(last + 1);
    var lastChar = mantissa.charAt(last);
    var roundUp = false;

    if (nextToLast > "5") {
      roundUp = true;
    } else if (nextToLast == "5") {
      for (var j = last + 2; j < mantissa.length; j++) {
        if (mantissa.charAt(j) != "0") {
          roundUp = true;
        }
      }

      if (lastChar % 2 == 1) {
        roundUp = true;
      }
    }

    var result = "";

    for (var i = last; i >= 0; i--) {
      var c = mantissa.charAt(i);

      if (roundUp) {
        var nextChar;

        if (c == "9") {
          nextChar = "0";
        } else {
          switch (c) {
            case "0":
              nextChar = "1";
              break;

            case "1":
              nextChar = "2";
              break;

            case "2":
              nextChar = "3";
              break;

            case "3":
              nextChar = "4";
              break;

            case "4":
              nextChar = "5";
              break;

            case "5":
              nextChar = "6";
              break;

            case "6":
              nextChar = "7";
              break;

            case "7":
              nextChar = "8";
              break;

            case "8":
              nextChar = "9";
              break;
          }

          roundUp = false;
        }

        result = nextChar + result;
      } else {
        result = c + result;
      }
    }

    if (roundUp) {
      result = "1" + result;
    }

    return result;
  }
}

var _module_$1M = {
  exports: {}
};
/* eslint-disable react/prop-types, react/sort-comp */

var classNames$c = _classnames__default["default"];
var React$1K = _react__default["default"];
var ReactDOM$r = _reactDom__default["default"];
var _$1a = _underscore__default["default"];
var firstNumericalParse$1 = Util$q.firstNumericalParse;
var captureScratchpadTouchStart$3 = Util$q.captureScratchpadTouchStart;
var knumber$8 = _kmath3.number;
var KhanMath$6 = _utilMathJs;
var toNumericString = KhanMath$6.toNumericString;
var getNumericFormat = KhanMath$6.getNumericFormat;
/* An input box that accepts only numeric strings
 *
 * Calls onChange(value, format) for valid numbers.
 * Reverts to the current value onBlur or on [ENTER],
 *   but maintains the format (i.e. 3/2, 1 1/2, 150%)
 * Accepts empty input and sends it to onChange as null
 *   if no numeric placeholder is set.
 * If given a checkValidity function, will turn
 *   the background/outline red when invalid
 * If useArrowKeys is set to true, up/down arrows will
 *   increment/decrement integers
 * Optionally takes a size ("mini", "small", "normal")
 */

var NumberInput$j = createReactClass({
  displayName: "NumberInput",
  propTypes: {
    value: PropTypes.number,
    format: PropTypes.string,
    placeholder: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    onChange: PropTypes.func.isRequired,
    onFormatChange: PropTypes.func,
    checkValidity: PropTypes.func,
    size: PropTypes.string,
    label: PropTypes.oneOf(["put your labels outside your inputs!"])
  },
  getDefaultProps: function getDefaultProps() {
    return {
      value: null,
      placeholder: null,
      format: null,
      onFormatChange: () => null,
      checkValidity: () => true,
      useArrowKeys: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      format: this.props.format
    };
  },
  render: function render() {
    var classes = classNames$c({
      "number-input": true,
      "invalid-input": !this._checkValidity(this.props.value),
      mini: this.props.size === "mini",
      small: this.props.size === "small",
      normal: this.props.size === "normal"
    });

    if (this.props.className != null) {
      classes = classes + " " + this.props.className;
    }

    return /*#__PURE__*/React$1K.createElement("input", _extends({}, this.props, {
      className: classes,
      type: "text",
      ref: "input",
      onChange: this._handleChange,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      onKeyPress: this._handleBlur,
      onKeyDown: this._onKeyDown,
      onTouchStart: captureScratchpadTouchStart$3,
      defaultValue: toNumericString(this.props.value, this.state.format),
      value: undefined
    }));
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    if (!knumber$8.equal(this.getValue(), this.props.value)) {
      this._setValue(this.props.value, this.state.format);
    }
  },

  /* Return the current "value" of this input
   * If empty, it returns the placeholder (if it is a number) or null
   */
  getValue: function getValue() {
    return this.parseInputValue(ReactDOM$r.findDOMNode(this.refs.input).value);
  },

  /* Return the current string value of this input */
  getStringValue: function getStringValue() {
    return ReactDOM$r.findDOMNode(this.refs.input).value.toString();
  },
  parseInputValue: function parseInputValue(value) {
    if (value === "") {
      var placeholder = this.props.placeholder;
      return _$1a.isFinite(placeholder) ? +placeholder : null;
    } else {
      var result = firstNumericalParse$1(value);
      return _$1a.isFinite(result) ? result : this.props.value;
    }
  },

  /* Set text input focus to this input */
  focus: function focus() {
    ReactDOM$r.findDOMNode(this.refs.input).focus();

    this._handleFocus();
  },
  blur: function blur() {
    ReactDOM$r.findDOMNode(this.refs.input).blur();

    this._handleBlur();
  },
  setSelectionRange: function setSelectionRange(selectionStart, selectionEnd) {
    ReactDOM$r.findDOMNode(this).setSelectionRange(selectionStart, selectionEnd);
  },
  getSelectionStart: function getSelectionStart() {
    return ReactDOM$r.findDOMNode(this).selectionStart;
  },
  getSelectionEnd: function getSelectionEnd() {
    return ReactDOM$r.findDOMNode(this).selectionEnd;
  },
  _checkValidity: function _checkValidity(value) {
    if (value == null) {
      return true;
    }

    var val = firstNumericalParse$1(value);
    var checkValidity = this.props.checkValidity;
    return _$1a.isFinite(val) && checkValidity(val);
  },
  _handleChange: function _handleChange(e) {
    var text = e.target.value;
    var value = this.parseInputValue(text);
    var format = getNumericFormat(text);
    this.props.onChange(value);

    if (format) {
      this.props.onFormatChange(value, format);
      this.setState({
        format: format
      });
    }
  },
  _handleFocus: function _handleFocus() {
    if (this.props.onFocus) {
      this.props.onFocus();
    }
  },
  _handleBlur: function _handleBlur(e) {
    // Only continue on blur or "enter"
    if (e && e.type === "keypress" && e.keyCode !== 13) {
      return;
    }

    this._setValue(this.props.value, this.state.format);

    if (this.props.onBlur) {
      this.props.onBlur();
    }
  },
  _onKeyDown: function _onKeyDown(e) {
    if (this.props.onKeyDown) {
      this.props.onKeyDown(e);
    }

    if (!this.props.useArrowKeys || !_$1a.contains(["ArrowUp", "ArrowDown"], e.key)) {
      return;
    }

    var val = this.getValue();

    if (val !== Math.floor(val)) {
      return; // bail if not an integer
    }

    if (e.key === "ArrowUp") {
      val = val + 1;
    } else if (e.key === "ArrowDown") {
      val = val - 1;
    }

    if (this._checkValidity(val)) {
      this.props.onChange(val);
    }
  },
  _setValue: function _setValue(val, format) {
    $__default["default"](ReactDOM$r.findDOMNode(this.refs.input)).val(toNumericString(val, format));
  }
});
_module_$1M.exports = NumberInput$j;
var _componentsNumberInputJsx = _module_$1M.exports;

var _module_$1L = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */
// TODO(joel): teach KAS how to accept an answer only if it's expressed in
// terms of a certain type.
// TODO(joel): Allow sigfigs within a range rather than an exact expected
// value?

var React$1J = _react__default["default"];
var _$19 = _underscore__default["default"];
var Changeable$H = Changeable$Q;
var EditorJsonify$j = _mixinsEditorJsonifyJsx;
var InlineIcon$h = _componentsInlineIconJsx;
var NumberInput$i = _componentsNumberInputJsx;
var ALL$1 = "all";
var SOME = "some";
var MAX_SIGFIGS$1 = 10;

var sigfigPrint$1 = function sigfigPrint(num, sigfigs) {
  return displaySigFigs(num, sigfigs, -MAX_SIGFIGS$1, false);
}; // Extract the primitive units from a unit expression. This first simplifies
// `expr` to a `Mul` like "5 kg m / s^2" then removes the first term.


var primUnits$1 = function primUnits(expr) {
  return expr.simplify().asMul().partition()[1].flatten().simplify();
}; // Show the name of a unit and whether it's recognized by KAS.
//
// In the future I plan for this to show an example of a thing that would be
// accepted in that unit.


var UnitExample = createReactClass({
  displayName: "UnitExample",
  render: function render() {
    var icon;

    if (this.state.valid) {
      icon = /*#__PURE__*/React$1J.createElement("span", null, /*#__PURE__*/React$1J.createElement("span", {
        className: "unit-example-okay"
      }, /*#__PURE__*/React$1J.createElement(InlineIcon$h, iconOk)), this.state.solvedExample);
    } else {
      icon = /*#__PURE__*/React$1J.createElement("span", {
        className: "unit-example-not-okay"
      }, /*#__PURE__*/React$1J.createElement(InlineIcon$h, iconRemove));
    }

    return /*#__PURE__*/React$1J.createElement("div", null, icon, " ", this.props.name);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this._checkValidity(nextProps);
  },
  componentWillMount: function componentWillMount() {
    this._checkValidity(this.props);
  },
  _checkValidity: function _checkValidity(_ref) {
    var {
      name,
      original,
      sigfigs
    } = _ref;
    var parseResult = KAS.unitParse(name);
    var solvedExample = ""; // A unit is valid if it parses and is equivalent to the original.

    var valid = true;

    if (parseResult.parsed && original) {
      var x = new KAS.Var("x");
      var {
        unit
      } = parseResult;
      var equality = new KAS.Eq(original, "=", new KAS.Mul(x, unit));

      try {
        var answer = equality.solveLinearEquationForVariable(x); // The third parameter is the least significant decimal place.
        // I.e. the index of the last place you care about
        // (543210.(-1)(-2)(-3) etc). We use -10 because that should
        // always be safe since we only care up to maximum 10 decimal
        // places.

        solvedExample = sigfigPrint$1(answer.eval(), sigfigs);
        valid = KAS.compare(primUnits$1(original), primUnits$1(unit)).equal;
      } catch (e) {
        valid = false;
      }
    } else {
      valid = false;
    }

    this.setState({
      valid,
      solvedExample
    });
  }
});
var UnitInputEditor = createReactClass({
  displayName: "UnitInputEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$H.propTypes), {}, {
    value: PropTypes.string,
    acceptingUnits: PropTypes.arrayOf(PropTypes.string),
    accepting: PropTypes.oneOf([ALL$1, SOME]),
    sigfigs: PropTypes.number
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      value: "5x10^5 kg m / s^2",
      accepting: ALL$1,
      sigfigs: 3
    };
  },
  render: function render() {
    var {
      acceptingUnits,
      accepting
    } = this.props;
    acceptingUnits = acceptingUnits || [];
    var acceptingElem = null;

    if (accepting === SOME) {
      var unitsArr = acceptingUnits.map((name, i) => /*#__PURE__*/React$1J.createElement(UnitExample, {
        name: name,
        original: this.original || null,
        sigfigs: this.props.sigfigs,
        key: i
      }));
      acceptingElem = /*#__PURE__*/React$1J.createElement("div", null, /*#__PURE__*/React$1J.createElement("input", {
        type: "text",
        defaultValue: acceptingUnits.join(", "),
        onChange: this.handleAcceptingUnitsChange
      }), " ", "(comma-separated)", unitsArr);
    }

    return /*#__PURE__*/React$1J.createElement("div", {
      className: "unit-editor"
    }, /*#__PURE__*/React$1J.createElement("div", null, /*#__PURE__*/React$1J.createElement("input", {
      value: this.props.value,
      className: "unit-editor-canonical",
      onBlur: this._handleBlur,
      onKeyPress: this._handleBlur,
      onChange: this.onChange
    }), " ", this.parsed ? /*#__PURE__*/React$1J.createElement("span", {
      className: "unit-example-okay"
    }, /*#__PURE__*/React$1J.createElement(InlineIcon$h, iconOk)) : /*#__PURE__*/React$1J.createElement("span", {
      className: "unit-example-not-okay"
    }, /*#__PURE__*/React$1J.createElement(InlineIcon$h, iconRemove))), /*#__PURE__*/React$1J.createElement("div", null, "Significant Figures:", " ", /*#__PURE__*/React$1J.createElement(NumberInput$i, {
      value: this.props.sigfigs,
      onChange: this.handleSigfigChange,
      checkValidity: this._checkSigfigValidity,
      useArrowKeys: true
    })), /*#__PURE__*/React$1J.createElement("div", null, /*#__PURE__*/React$1J.createElement("label", null, /*#__PURE__*/React$1J.createElement("input", {
      type: "radio",
      name: this.groupId,
      onChange: () => this._setAccepting(ALL$1),
      checked: this.props.accepting === ALL$1
    }), " Any equivalent unit "), /*#__PURE__*/React$1J.createElement("label", null, /*#__PURE__*/React$1J.createElement("input", {
      type: "radio",
      name: this.groupId,
      onChange: () => this._setAccepting(SOME),
      checked: this.props.accepting === SOME
    }), " Only these units ")), acceptingElem);
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$H.change.apply(this, args);
  },

  handleAcceptingUnitsChange: function handleAcceptingUnitsChange(event) {
    var acceptingUnits = event.target.value.split(",").map(str => str.trim()).filter(str => str !== "");
    this.change({
      acceptingUnits
    });
  },
  handleSigfigChange: function handleSigfigChange(sigfigs) {
    this.change({
      sigfigs
    });
  },
  _checkSigfigValidity: function _checkSigfigValidity(sigfigs) {
    return sigfigs > 0 && sigfigs <= MAX_SIGFIGS$1;
  },
  _setAccepting: function _setAccepting(val) {
    this.change({
      accepting: val
    });
  },
  componentWillMount: function componentWillMount() {
    this.groupId = _$19.uniqueId("accepting");

    this._doOriginal(this.props);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this._doOriginal(nextProps);
  },
  _doOriginal: function _doOriginal(props) {
    var tryParse = KAS.unitParse(props.value);
    this.parsed = false; // Only update this state if the unit parsed *and* it has a magnitude
    // attached to it. KAS can also parse units without magnitudes ("1.2
    // g" vs "g").

    if (tryParse.parsed && tryParse.type === "unitMagnitude") {
      this.original = tryParse.expr;
      this.parsed = true;
    }
  },
  onChange: function onChange(event) {
    this.props.onChange({
      value: event.target.value
    });
  },
  getSaveWarnings: function getSaveWarnings() {
    var {
      value,
      accepting,
      acceptingUnits
    } = this.props;
    var warnings = [];
    var tryParse = KAS.unitParse(value);

    if (!tryParse.parsed) {
      warnings.push("Answer did not parse");
    }

    if (accepting === SOME && acceptingUnits.length === 0) {
      warnings.push("There are no accepted units");
    }

    return warnings;
  },

  serialize() {
    return EditorJsonify$j.serialize.call(this);
  }

});
_module_$1L.exports = UnitInputEditor;
var _widgetsUnitEditorJsx = _module_$1L.exports;

var _module_$1K = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/*
 * In this file, an `expression` is some portion of valid TeX enclosed in
 * curly brackets.
 */

/*
  * Find the index at which an expression ends, i.e., has an unmatched
  * closing curly bracket. This method assumes that we start with a non-open
  * bracket character and end when we've seen more left than right brackets
  * (rather than assuming that we start with a bracket character and wait for
  * bracket equality).
  */

function findEndpoint(tex, currentIndex) {
  var bracketDepth = 0;

  for (var i = currentIndex, len = tex.length; i < len; i++) {
    var c = tex[i];

    if (c === "{") {
      bracketDepth++;
    } else if (c === "}") {
      bracketDepth--;
    }

    if (bracketDepth < 0) {
      return i;
    }
  } // If we never see unbalanced curly brackets, default to the
  // entire string


  return tex.length;
}
/*
 * Parses an individual set of curly brackets into TeX.
 */


function parseNextExpression(tex, currentIndex, handler) {
  // Find the first '{' and grab subsequent TeX
  // Ex) tex: '{3}{7}', and we want the '3'
  var openBracketIndex = tex.indexOf("{", currentIndex);
  var nextExpIndex = openBracketIndex + 1; // Truncate to only contain remaining TeX

  var endpoint = findEndpoint(tex, nextExpIndex);
  var expressionTeX = tex.substring(nextExpIndex, endpoint);
  var parsedExp = walkTex(expressionTeX, handler);
  return {
    endpoint: endpoint,
    expression: parsedExp
  };
}

function getNextFracIndex(tex, currentIndex) {
  var dfrac = "\\dfrac";
  var frac = "\\frac";
  var nextFrac = tex.indexOf(frac, currentIndex);
  var nextDFrac = tex.indexOf(dfrac, currentIndex);

  if (nextFrac > -1 && nextDFrac > -1) {
    return Math.min(nextFrac, nextDFrac);
  } else if (nextFrac > -1) {
    return nextFrac;
  } else if (nextDFrac > -1) {
    return nextDFrac;
  } else {
    return -1;
  }
}

function walkTex(tex, handler) {
  // Ex) tex: '2 \dfrac {3}{7}'
  var parsedString = "";
  var currentIndex = 0;
  var nextFrac = getNextFracIndex(tex, currentIndex); // For each \dfrac, find the two expressions (wrapped in {}) and recur

  while (nextFrac > -1) {
    // Gather first fragment, preceding \dfrac
    // Ex) parsedString: '2 '
    parsedString += tex.substring(currentIndex, nextFrac); // Remove everything preceding \dfrac, which has been parsed

    currentIndex = nextFrac; // Parse first expression and move index past it
    // Ex) firstParsedExpression.expression: '3'

    var firstParsedExpression = parseNextExpression(tex, currentIndex, handler);
    currentIndex = firstParsedExpression.endpoint + 1; // Parse second expression
    // Ex) secondParsedExpression.expression: '7'

    var secondParsedExpression = parseNextExpression(tex, currentIndex, handler);
    currentIndex = secondParsedExpression.endpoint + 1; // Add expressions to running total of parsed expressions

    if (parsedString.length) {
      parsedString += " ";
    } // Apply a custom handler based on the parsed subexpressions


    parsedString += handler(firstParsedExpression.expression, secondParsedExpression.expression); // Find next DFrac, relative to currentIndex

    nextFrac = getNextFracIndex(tex, currentIndex);
  } // Add remaining TeX, which is \dfrac-free


  parsedString += tex.slice(currentIndex);
  return parsedString;
}
/*
 * Modify a TeX expression, returning another TeX expression. The resulting
 * expression will have its innermost fractions stubbed out with \fracs
 * (as opposed to \dfracs). All other content will remain untouched.
 */


function modifyTex(tex) {
  function isNestedFraction(tex) {
    return tex.indexOf("\\frac") > -1 || tex.indexOf("\\dfrac") > -1;
  }

  var handler = function handler(exp1, exp2) {
    var prefix;

    if (isNestedFraction(exp1) || isNestedFraction(exp2)) {
      prefix = "\\dfrac";
    } else {
      prefix = "\\frac";
    }

    return prefix + " {" + exp1 + "}{" + exp2 + "}";
  };

  return walkTex(tex, handler);
}
/*
 * Parse a TeX expression into something interpretable by input-number.
 * The process is concerned with: (1) parsing fractions, i.e., \dfracs; and
 * (2) removing backslash-escaping from certain characters (right now, only
 * percent signs).
 *
 * The basic algorithm for handling \dfracs splits on \dfracs and then recurs
 * on the subsequent "expressions", i.e., the {} pairs that follow \dfrac. The
 * recursion is to allow for nested \dfrac elements.
 *
 * Backslash-escapes are removed with a simple search-and-replace.
 */


function parseTex(tex) {
  var handler = function handler(exp1, exp2) {
    return exp1 + "/" + exp2;
  };

  var texWithoutFracs = walkTex(tex, handler);
  return texWithoutFracs.replace("\\%", "%");
}

_module_$1K.exports = {
  parseTex,
  modifyTex
};
var _texWranglerJs = _module_$1K.exports;

var _module_$1J = {
  exports: {}
};
/* eslint-disable react/sort-comp */

var React$1I = _react__default["default"];
var ReactDOM$q = _reactDom__default["default"];
var _$18 = _underscore__default["default"];
var TeX$6 = _reactComponentsTexJsx;
var ApiClassNames$b = _perseusApiJsx.ClassNames;
var ModifyTex = _texWranglerJs.modifyTex;
var MathOutput$7 = createReactClass({
  displayName: "MathOutput",
  propTypes: {
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    className: PropTypes.string,
    labelText: PropTypes.string,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func
  },
  getDefaultProps: function getDefaultProps() {
    return {
      value: "",
      onFocus: function onFocus() {},
      onBlur: function onBlur() {}
    };
  },
  getInitialState: function getInitialState() {
    return {
      focused: false,
      selectorNamespace: _$18.uniqueId("math-output")
    };
  },
  _getInputClassName: function _getInputClassName() {
    var className = "math-output " + ApiClassNames$b.INPUT + " " + ApiClassNames$b.INTERACTIVE;

    if (this.state.focused) {
      className += " " + ApiClassNames$b.FOCUSED;
    }

    if (this.props.className) {
      className += " " + this.props.className;
    }

    return className;
  },
  _getDisplayValue: function _getDisplayValue(value) {
    // Cast from (potentially a) number to string
    var displayText;

    if (value != null) {
      displayText = "" + value;
    } else {
      displayText = "";
    }

    return ModifyTex(displayText);
  },
  render: function render() {
    var divStyle = {
      textAlign: "center"
    };
    return /*#__PURE__*/React$1I.createElement("span", {
      ref: "input",
      className: this._getInputClassName(),
      "aria-label": this.props.labelText,
      onMouseDown: this.focus,
      onTouchStart: this.focus
    }, /*#__PURE__*/React$1I.createElement("div", {
      style: divStyle
    }, /*#__PURE__*/React$1I.createElement(TeX$6, null, this._getDisplayValue(this.props.value))));
  },
  getValue: function getValue() {
    return this.props.value;
  },
  focus: function focus() {
    if (!this.state.focused) {
      this.props.onFocus();

      this._bindBlurHandler();

      this.setState({
        focused: true
      });
    }
  },
  blur: function blur() {
    if (this.state.focused) {
      this.props.onBlur();

      this._unbindBlurHandler();

      this.setState({
        focused: false
      });
    }
  },
  _bindBlurHandler: function _bindBlurHandler() {
    $__default["default"](document).bind("vclick." + this.state.selectorNamespace, e => {
      // Detect whether the target has our ReactDOMtags.node as a parent
      var $closestWidget = $__default["default"](e.target).closest(ReactDOM$q.findDOMNode(this));

      if (!$closestWidget.length) {
        this.blur();
      }
    });
  },
  _unbindBlurHandler: function _unbindBlurHandler() {
    $__default["default"](document).unbind("." + this.state.selectorNamespace);
  },
  componentWillUnmount: function componentWillUnmount() {
    this._unbindBlurHandler();
  }
});
_module_$1J.exports = MathOutput$7;
var _componentsMathOutputJsx = _module_$1J.exports;

var _module_$1I = {
  exports: {}
};
/* eslint-disable comma-dangle, no-redeclare, no-undef, no-unused-vars, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */
// TODO(joel): teach KAS how to accept an answer only if it's expressed in
// terms of a certain type.
// TODO(joel): Allow sigfigs within a range rather than an exact expected
// value?

var lens$1 = lens$3;
var React$1H = _react__default["default"];
var ReactDOM$p = _reactDom__default["default"];
var _$17 = _underscore__default["default"];
var ApiClassNames$a = _perseusApiJsx.ClassNames;
var ApiOptions$r = _perseusApiJsx.Options;
var Changeable$G = Changeable$Q;
var MathOutput$6 = _componentsMathOutputJsx;
var ALL = "all";
var MAX_SIGFIGS = 10;

var countSigfigs = function countSigfigs(value) {
  return new SignificantFigures(value).sigFigs;
};

var sigfigPrint = function sigfigPrint(num, sigfigs) {
  return displaySigFigs(num, sigfigs, -MAX_SIGFIGS, false);
};
/* I just wrote this, but it's old by analogy to `OldExpression`, in that it's
 * the version that non-mathquill platforms get stuck with. Constructed with an
 * <input>, a parser, popsicle sticks, and glue.
 *
 * In the same way as OldExpression, this parses continuously as you type, then
 * shows and hides an error buddy. The error message is only shown after a
* rolling two second delay, but hidden immediately on further typing.
 */


var OldUnitInput = createReactClass({
  displayName: "OldUnitInput",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$G.propTypes), {}, {
    value: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      apiOptions: ApiOptions$r.defaults,
      value: ""
    };
  },
  // TODO(joel) think about showing the error buddy
  render: function render() {
    var inputType = this.props.apiOptions.staticRender ? React$1H.createFactory(MathOutput$6) : ReactDOMtags.input;
    var input = inputType({
      onChange: this.handleChange,
      ref: "input",
      className: ApiClassNames$a.INTERACTIVE,
      value: this.props.value,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    });
    return /*#__PURE__*/React$1H.createElement("div", {
      className: "old-unit-input"
    }, input, /*#__PURE__*/React$1H.createElement("div", {
      ref: "error",
      className: "error",
      style: {
        display: "none"
      }
    }, i18n._("I don't understand that")));
  },
  _errorTimeout: null,
  _showError: function _showError() {
    if (this.props.value === "") {
      return;
    }

    var $error = $(ReactDOM$p.findDOMNode(this.refs.error));

    if (!$error.is(":visible")) {
      $error.css({
        top: 50,
        opacity: 0.1
      }).show().animate({
        top: 0,
        opacity: 1.0
      }, 300);
    }
  },
  _hideError: function _hideError() {
    var $error = $(ReactDOM$p.findDOMNode(this.refs.error));

    if ($error.is(":visible")) {
      $error.animate({
        top: 50,
        opacity: 0.1
      }, 300, function () {
        $(this).hide();
      });
    }
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$G.change.apply(this, args);
  },

  componentDidUpdate: function componentDidUpdate() {
    clearTimeout(this._errorTimeout);

    if (KAS.unitParse(this.props.value).parsed) {
      this._hideError();
    } else {
      this._errorTimeout = setTimeout(this._showError, 2000);
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    clearTimeout(this._errorTimeout);
  },
  handleBlur: function handleBlur() {
    this.props.onBlur([]);
    clearTimeout(this._errorTimeout);

    if (!KAS.unitParse(this.props.value).parsed) {
      this._showError();
    }
  },
  handleChange: function handleChange(event) {
    this._hideError();

    this.props.onChange({
      value: event.target.value
    });
  },
  simpleValidate: function simpleValidate(rubric, onInputError) {

    return OldUnitInput.validate(this.getUserInput(), rubric);
  },
  getUserInput: function getUserInput() {
    return this.props.value;
  },
  // begin mobile stuff
  getInputPaths: function getInputPaths() {
    // The widget itself is an input, so we return a single empty list to
    // indicate this.
    return [[]];
  },
  focusInputPath: function focusInputPath(inputPath) {
    ReactDOM$p.findDOMNode(this.refs.input).focus();
  },
  handleFocus: function handleFocus() {
    this.props.onFocus([]);
  },
  blurInputPath: function blurInputPath(inputPath) {
    ReactDOM$p.findDOMNode(this.refs.input).blur();
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    this.props.onChange({
      value: newValue
    }, cb);
  },
  getDOMNodeForPath: function getDOMNodeForPath() {
    return ReactDOM$p.findDOMNode(this.refs.input);
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(inputPath) {
    return "unit";
  } // end mobile stuff

}); // Extract the primitive units from a unit expression. This first simplifies
// `expr` to a `Mul` like "5 kg m / s^2" then removes the first term.

var primUnits = function primUnits(expr) {
  return expr.simplify().asMul().partition()[1].flatten().simplify();
};

_$17.extend(OldUnitInput, {
  validate: function validate(state, rubric) {
    var answer = KAS.unitParse(rubric.value).expr;
    var guess = KAS.unitParse(state);

    if (!guess.parsed) {
      return {
        type: "invalid",
        message: i18n._("I couldn't understand those units.")
      };
    } // Note: we check sigfigs, then numerical correctness, then units, so
    // the most significant things come last, that way the user will see
    // the most important message.


    var message = null; // did the user specify the right number of sigfigs?
    // TODO(joel) - add a grading mode where the wrong number of sigfigs
    // isn't marked wrong

    var sigfigs = rubric.sigfigs;
    var sigfigsCorrect = countSigfigs(guess.coefficient) === sigfigs;

    if (!sigfigsCorrect) {
      message = i18n._("Check your significant figures.");
    } // now we need to check that the answer is correct to the precision we
    // require.


    var numericallyCorrect;

    try {
      var x = new KAS.Var("x");
      var equality = new KAS.Eq(answer.simplify(), "=", new KAS.Mul(x, guess.expr.simplify()));
      var conversion = equality.solveLinearEquationForVariable(x); // Make sure the conversion factor between the user's input answer
      // and the canonical answer is 1, to sigfig places.
      // TODO(joel) is this sound?

      numericallyCorrect = Number(conversion.eval()).toPrecision(sigfigs) === Number(1).toPrecision(sigfigs);
    } catch (e) {
      numericallyCorrect = false;
    }

    if (!numericallyCorrect) {
      message = i18n._("That answer is numerically incorrect.");
    }

    var kasCorrect;
    var guessUnit = primUnits(guess.expr.simplify());
    var answerUnit = primUnits(answer.simplify());

    if (rubric.accepting === ALL) {
      // We're accepting all units - KAS does the hard work of figuring
      // out if the user's unit is equivalent to the author's unit.
      kasCorrect = KAS.compare(guessUnit, answerUnit).equal;
    } else {
      // Are any of the accepted units the same as what the user entered?
      kasCorrect = rubric.acceptingUnits.some(unit => {
        var thisAnswerUnit = primUnits(KAS.unitParse(unit).unit.simplify());
        return KAS.compare(thisAnswerUnit, guessUnit // TODO(joel) - make this work as intended.
        // { form: true }
        ).equal;
      });
    }

    if (!kasCorrect) {
      var message = i18n._("Check your units.");
    }

    var correct = kasCorrect && numericallyCorrect && sigfigsCorrect;
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message
    };
  }
});

_module_$1I.exports = {
  name: "unit-input",
  displayName: "Unit",
  defaultAlignment: "inline-block",
  widget: OldUnitInput,
  transform: x => lens$1(x).del(["value"]).freeze(),
  version: {
    major: 0,
    minor: 1
  },
  countSigfigs,
  sigfigPrint,
  hidden: true
};
var _widgetsUnitJsx = _module_$1I.exports;

var _excluded$2 = ["keypadElement", "onFocus", "value"];
var _module_$1H = {
  exports: {}
};
/**
 * A version of the `math-input` subrepo's KeypadInput component that adheres to
 * the same API as Perseus's  MathOuput and NumberInput, allowing it to be
 * dropped in as a replacement for those components without any modifications.
 *
 * TODO(charlie): Once the keypad API has stabilized, move this into the
 * `math-input` subrepo and use it everywhere as a simpler, keypad-coupled
 * interface to `math-input`'s MathInput component.
 */

var React$1G = _react__default["default"];
var {
  KeypadInput: KeypadInput$1
} = _mathInput__default["default"].components;
var {
  KeypadTypes: KeypadTypes$1
} = _mathInput__default["default"].consts;
var {
  keypadElementPropType: keypadElementPropType$7
} = _mathInput__default["default"].propTypes;
var SimpleKeypadInput$6 = createReactClass({
  displayName: "SimpleKeypadInput",
  propTypes: {
    keypadElement: keypadElementPropType$7,
    onFocus: PropTypes.func,
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  },

  focus() {
    this.refs.input.focus();
  },

  blur() {
    this.refs.input.blur();
  },

  getValue: function getValue() {
    return this.props.value;
  },

  render() {
    // Intercept the `onFocus` prop, as we need to configure the keypad
    // before continuing with the default focus logic for Perseus inputs.
    // Intercept the `value` prop so as to map `null` to the empty string,
    // as the `KeypadInput` does not support `null` values.
    var _this$props = this.props,
        {
      keypadElement,
      onFocus: _onFocus,
      value
    } = _this$props,
        rest = _objectWithoutProperties(_this$props, _excluded$2);

    return /*#__PURE__*/React$1G.createElement(KeypadInput$1, _extends({
      ref: "input",
      keypadElement: keypadElement,
      onFocus: () => {
        if (keypadElement) {
          keypadElement.configure({
            keypadType: KeypadTypes$1.FRACTION
          }, () => {
            if (this.isMounted()) {
              _onFocus && _onFocus();
            }
          });
        } else {
          _onFocus && _onFocus();
        }
      },
      value: value == null ? "" : "" + value
    }, rest));
  }

});
_module_$1H.exports = SimpleKeypadInput$6;
var _componentsSimpleKeypadInputJsx = _module_$1H.exports;

var _module_$1G = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types, react/prop-types, react/sort-comp */

var React$1F = _react__default["default"];
var ReactDOM$o = _reactDom__default["default"];
var _$16 = _underscore__default["default"];
var Util$g = Util$q;
var GraphUtils$3 = _utilGraphUtilsJs;
var SvgImage$3 = _componentsSvgImageJsx;
var defaultBackgroundImage$7 = {
  url: null
};
/* Style objects */

var defaultInstructionsStyle = {
  fontStyle: "italic",
  fontWeight: "bold",
  fontSize: "32px",
  width: "100%",
  height: "100%",
  textAlign: "center",
  backgroundColor: "white",
  position: "absolute",
  zIndex: 1,
  transition: "opacity .25s ease-in-out",
  "-moz-transition": "opacity .25s ease-in-out",
  "-webkit-transition": "opacity .25s ease-in-out"
};
var instructionsTextStyle = {
  position: "relative",
  top: "25%"
};

function numSteps$2(range, step) {
  return Math.floor((range[1] - range[0]) / step);
}

var Graph$3 = createReactClass({
  displayName: "Graph",
  propTypes: {
    box: PropTypes.array.isRequired,
    labels: PropTypes.arrayOf(PropTypes.string),
    range: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),
    step: PropTypes.arrayOf(PropTypes.number),
    gridStep: PropTypes.arrayOf(PropTypes.number),
    snapStep: PropTypes.arrayOf(PropTypes.number),
    markings: PropTypes.string,
    backgroundImage: PropTypes.shape({
      url: PropTypes.string
    }),
    showProtractor: PropTypes.bool,
    showRuler: PropTypes.bool,
    rulerLabel: PropTypes.string,
    rulerTicks: PropTypes.number,
    onGraphieUpdated: PropTypes.func,
    instructions: PropTypes.string,
    onClick: PropTypes.func,
    setDrawingAreaAvailable: PropTypes.func,
    isMobile: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      labels: ["x", "y"],
      range: [[-10, 10], [-10, 10]],
      step: [1, 1],
      gridStep: [1, 1],
      snapStep: [0.5, 0.5],
      markings: "graph",
      backgroundImage: defaultBackgroundImage$7,
      showProtractor: false,
      showRuler: false,
      rulerLabel: "",
      rulerTicks: 10,
      instructions: null,
      onGraphieUpdated: null,
      onClick: null,
      onMouseDown: null,
      isMobile: false
    };
  },
  render: function render() {
    var image;
    var imageData = this.props.backgroundImage;

    if (imageData.url) {
      var scale = this.props.box[0] / interactiveSizes.defaultBoxSize;
      image = /*#__PURE__*/React$1F.createElement(SvgImage$3, {
        src: imageData.url,
        width: imageData.width,
        height: imageData.height,
        scale: scale,
        responsive: false
      });
    } else {
      image = null;
    }

    return /*#__PURE__*/React$1F.createElement("div", {
      className: "graphie-container above-scratchpad",
      style: {
        width: this.props.box[0],
        height: this.props.box[1]
      },
      onMouseOut: this.onMouseOut,
      onMouseOver: this.onMouseOver,
      onClick: this.onClick
    }, image, /*#__PURE__*/React$1F.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  },
  componentDidMount: function componentDidMount() {
    this._setupGraphie(true);
  },
  componentDidUpdate: function componentDidUpdate() {
    // Only setupGraphie once per componentDidUpdate().
    // See explanation in setupGraphie().
    this._hasSetupGraphieThisUpdate = false;

    if (this._shouldSetupGraphie) {
      this._setupGraphie(false);

      this._shouldSetupGraphie = false;
    }
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var potentialChanges = ["labels", "range", "step", "markings", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "gridStep", "snapStep"];
    var self = this;

    _$16.each(potentialChanges, function (prop) {
      if (!_$16.isEqual(self.props[prop], nextProps[prop])) {
        self._shouldSetupGraphie = true;
      }
    });
  },

  /* Reset the graphie canvas to its initial state
   *
   * Use when re-rendering the parent component and you need a blank
   * graphie.
   */
  reset: function reset() {
    this._setupGraphie(false);
  },
  graphie: function graphie() {
    return this._graphie;
  },
  pointsFromNormalized: function pointsFromNormalized(coordsList, noSnap) {
    var self = this;
    return _$16.map(coordsList, function (coords) {
      return _$16.map(coords, function (coord, i) {
        var range = self.props.range[i];

        if (noSnap) {
          return range[0] + (range[1] - range[0]) * coord;
        } else {
          var step = self.props.step[i];
          var nSteps = numSteps$2(range, step);
          var tick = Math.round(coord * nSteps);
          return range[0] + step * tick;
        }
      });
    });
  },
  _setupGraphie: function _setupGraphie(initialMount) {
    // Only setupGraphie once per componentDidUpdate().
    // This prevents this component from rendering graphie
    // and then immediately re-render graphie because its
    // parent component asked it to. This will happen when
    // props on the parent and props on this component both
    // require graphie to be re-rendered.
    if (this._hasSetupGraphieThisUpdate) {
      return;
    }

    var graphieDiv = ReactDOM$o.findDOMNode(this.refs.graphieDiv);
    $(graphieDiv).empty();
    var labels = this.props.labels;
    var range = this.props.range;
    var graphie = this._graphie = GraphUtils$3.createGraphie(graphieDiv);

    var gridConfig = this._getGridConfig();

    graphie.snap = this.props.snapStep;

    if (this.props.markings === "graph") {
      graphie.graphInit({
        range: range,
        scale: _$16.pluck(gridConfig, "scale"),
        axisArrows: "<->",
        labelFormat: function labelFormat(s) {
          return "\\small{" + s + "}";
        },
        gridStep: this.props.gridStep,
        tickStep: _$16.pluck(gridConfig, "tickStep"),
        labelStep: 1,
        unityLabels: _$16.pluck(gridConfig, "unityLabel"),
        isMobile: this.props.isMobile
      });
      graphie.label([0, range[1][1]], labels[1], this.props.isMobile ? "below right" : "above");
      graphie.label([range[0][1], 0], labels[0], this.props.isMobile ? "above left" : "right");
    } else if (this.props.markings === "grid") {
      graphie.graphInit({
        range: range,
        scale: _$16.pluck(gridConfig, "scale"),
        gridStep: this.props.gridStep,
        axes: false,
        ticks: false,
        labels: false,
        isMobile: this.props.isMobile
      });
    } else if (this.props.markings === "none") {
      graphie.init({
        range: range,
        scale: _$16.pluck(gridConfig, "scale"),
        isMobile: this.props.isMobile
      });
    } // Add instructions just before mouse layer


    var visible = 0.5;
    var invisible = 0.0;
    var $instructionsWrapper;

    if (this.props.instructions) {
      $instructionsWrapper = $("<div/>");

      _$16.each(defaultInstructionsStyle, function (value, key) {
        $instructionsWrapper.css(key, value);
      });

      $instructionsWrapper.css("opacity", visible);
      var $instructions = $("<span/>", {
        text: this.props.instructions
      });

      _$16.each(instructionsTextStyle, function (value, key) {
        $instructions.css(key, value);
      });

      $instructionsWrapper.append($instructions);
      $(graphieDiv).append($instructionsWrapper);
    } else {
      $instructionsWrapper = undefined;
    } // Add some handlers for instructions text (if necessary)

    /* eslint-disable indent */


    var onMouseDown = $instructionsWrapper || this.props.onMouseDown ? _$16.bind(function (coord) {
      if ($instructionsWrapper) {
        $instructionsWrapper.remove();
        $instructionsWrapper = null;
      }

      this.props.onMouseDown(coord);
    }, this) : null;
    var onMouseOver = $instructionsWrapper ? function () {
      $instructionsWrapper && $instructionsWrapper.css("opacity", invisible);
    } : null;
    var onMouseOut = $instructionsWrapper ? function () {
      $instructionsWrapper && $instructionsWrapper.css("opacity", visible);
    } : null;
    /* eslint-enable indent */

    graphie.addMouseLayer({
      onClick: this.props.onClick,
      onMouseDown: onMouseDown,
      onMouseOver: onMouseOver,
      onMouseOut: onMouseOut,
      onMouseUp: this.props.onMouseUp,
      onMouseMove: this.props.onMouseMove,
      allowScratchpad: true,
      setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
    });

    this._updateProtractor();

    this._updateRuler(); // We set this flag before jumping into our callback
    // to avoid recursing if our callback calls reset() itself


    this._hasSetupGraphieThisUpdate = true;

    if (!initialMount && this.props.onGraphieUpdated) {
      // Calling a parent callback in componentDidMount is bad and
      // results in hard-to-reason-about lifecycle problems (esp. with
      // refs), so we do it only on update and rely on the parent to
      // query for the graphie object on initial mount
      this.props.onGraphieUpdated(graphie);
    }
  },
  _getGridConfig: function _getGridConfig() {
    var self = this;
    return _$16.map(self.props.step, function (step, i) {
      return Util$g.gridDimensionConfig(step, self.props.range[i], self.props.box[i], self.props.gridStep[i]);
    });
  },
  _updateProtractor: function _updateProtractor() {
    if (this.protractor) {
      this.protractor.remove();
    }

    if (this.props.showProtractor) {
      var coord = this.pointsFromNormalized([[0.5, 0.05]])[0];
      this.protractor = this._graphie.protractor(coord);
    }
  },
  _updateRuler: function _updateRuler() {
    if (this.ruler) {
      this.ruler.remove();
    }

    if (this.props.showRuler) {
      var coord = this.pointsFromNormalized([[0.5, 0.25]])[0];
      var extent = this._graphie.range[0][1] - this._graphie.range[0][0];
      this.ruler = this._graphie.ruler({
        center: coord,
        label: this.props.rulerLabel,
        pixelsPerUnit: this._graphie.scale[0],
        ticksPerUnit: this.props.rulerTicks,
        units: Math.round(0.8 * extent)
      });
    }
  },
  toJSON: function toJSON() {
    return _$16.pick(this.props, "range", "step", "markings", "labels", "backgroundImage", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "gridStep", "snapStep");
  }
});
_module_$1G.exports = Graph$3;
var _componentsGraphJsx = _module_$1G.exports;

var _module_$1F = {
  exports: {}
};
/* eslint-disable camelcase, comma-dangle, indent, max-lines, no-redeclare, no-undef, no-var, object-curly-spacing, prefer-spread, react/jsx-closing-bracket-location, react/jsx-indent-props, react/no-did-update-set-state, react/prop-types, react/sort-comp, space-before-function-paren, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1E = _react__default["default"];
var ReactDOM$n = _reactDom__default["default"];
var _$15 = _underscore__default["default"];
var Graph$2 = _componentsGraphJsx;
var InlineIcon$g = _componentsInlineIconJsx;
var NumberInput$h = _componentsNumberInputJsx;
var MathOutput$5 = _componentsMathOutputJsx;
var TeX$5 = _reactComponentsTexJsx;
var SimpleKeypadInput$5 = _componentsSimpleKeypadInputJsx;
var ApiOptions$q = _perseusApiJsx.Options;
var {
  keypadElementPropType: keypadElementPropType$6
} = _mathInput__default["default"].propTypes;
var ROTATE_SNAP_DEGREES = 15;
var DEGREE_SIGN = "\u00B0";
var RENDER_TRANSFORM_DELAY_IN_MS = 300;
var ROTATE_HANDLE_DIST = 1.5;
var REFLECT_ROTATE_HANDLE_DIST = 2;
var REFLECT_BUTTON_SIZE = 1;
var deepEq$3 = Util$q.deepEq;
var getGridStep$1 = Util$q.getGridStep;
var captureScratchpadTouchStart$2 = Util$q.captureScratchpadTouchStart;
var knumber$7 = _kmath3.number;
var kvector$3 = _kmath3.vector;
var kpoint$4 = _kmath3.point;
var kray$1 = _kmath3.ray;
var kline$1 = _kmath3.line;
var KhanMath$5 = _utilMathJs;
var KhanColors$8 = _utilColorsJs;
var assert$4 = InteractiveUtil$7.assert;
var defaultBoxSize$3 = 400;
var defaultBackgroundImage$6 = {
  url: null
};
/* Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */

function pluckObject(object, subKey) {
  return _$15.object(_$15.map(object, function (value, key) {
    return [key, value[subKey]];
  }));
}

var defaultGraphProps$1 = function defaultGraphProps(setProps, boxSize) {
  setProps = setProps || {};
  var labels = setProps.labels || ["x", "y"];
  var range = setProps.range || [[-10, 10], [-10, 10]];
  var step = setProps.step || [1, 1];
  var gridStep = setProps.gridStep || getGridStep$1(range, step, boxSize);
  return {
    box: [boxSize, boxSize],
    labels: labels,
    range: range,
    step: step,
    gridStep: gridStep,
    valid: true,
    backgroundImage: defaultBackgroundImage$6,
    markings: "grid",
    showProtractor: false
  };
};

var defaultTransformerProps$1 = {
  apiOptions: ApiOptions$q.defaults,
  gradeEmpty: false,
  graphMode: "interactive",
  listMode: "dynamic",
  graph: {},
  tools: {
    translation: {
      enabled: true,
      required: false,
      constraints: {}
    },
    rotation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [1, 6]
    },
    reflection: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coords: [[2, -4], [2, 2]]
    },
    dilation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [6, 6]
    }
  },
  drawSolutionShape: true,
  starting: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  },
  correct: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  }
};

function colorForTool(tool) {
  return tool.constraints.fixed ? KhanColors$8.DYNAMIC : KhanColors$8.INTERACTIVE;
}
/* Scales a distance from the default range of
 * [-10, 10] to a given props.range pair
 *
 * Used for sizing various transformation tools
 * (rotation handle, dilation circle)
 */


function scaleToRange$1(dist, range) {
  var spreadX = range[0][1] - range[0][0];
  var spreadY = range[1][1] - range[1][0];
  return dist * Math.max(spreadX, spreadY) / 20;
}

function dilatePointFromCenter(point, dilationCenter, scale) {
  var pv = kvector$3.subtract(point, dilationCenter);
  var pvScaled = kvector$3.scale(pv, scale);
  var transformedPoint = kvector$3.add(dilationCenter, pvScaled);
  return transformedPoint;
} // TODO(jack): i18nize this


function stringFromDecimal(number) {
  return String(KhanMath$5.roundTo(9, number));
}

function stringFromFraction(number) {
  var frac = KhanMath$5.toFraction(number, knumber$7.DEFAULT_TOLERANCE);

  if (frac[1] === 1) {
    return stringFromDecimal(number);
  } else {
    return stringFromDecimal(frac[0]) + "/" + stringFromDecimal(frac[1]);
  }
}

function texFromPoint(point) {
  return [/*#__PURE__*/React$1E.createElement(TeX$5, null, "("), stringFromDecimal(point[0]), /*#__PURE__*/React$1E.createElement(TeX$5, null, ", {}"), stringFromDecimal(point[1]), /*#__PURE__*/React$1E.createElement(TeX$5, null, ")")];
}

function texFromVector(vector) {
  return [/*#__PURE__*/React$1E.createElement(TeX$5, null, "\\langle"), stringFromDecimal(vector[0]), /*#__PURE__*/React$1E.createElement(TeX$5, null, ", {}"), stringFromDecimal(vector[1]), /*#__PURE__*/React$1E.createElement(TeX$5, null, "\\rangle")];
}

function texFromAngleDeg(angleDeg) {
  return stringFromDecimal(angleDeg) + DEGREE_SIGN;
}

function orderInsensitiveCoordsEqual$1(coords1, coords2) {
  coords1 = _$15.clone(coords1).sort(kpoint$4.compare);
  coords2 = _$15.clone(coords2).sort(kpoint$4.compare);
  return _$15.all(_$15.map(coords1, function (coord1, i) {
    var coord2 = coords2[i];
    return kpoint$4.equal(coord1, coord2);
  }));
}

var inputComponentForApiOptions = apiOptions => {
  if (apiOptions.customKeypad) {
    return SimpleKeypadInput$5;
  } else if (apiOptions.staticRender) {
    return MathOutput$5;
  } else {
    return NumberInput$h;
  }
};
/* Perform operations on raw transform objects */


var TransformOps = {
  apply: function apply(transform) {
    // Any transformation with empty text boxes is a no-op until
    // filled out (these show up as nulls in transform.vector/line/etc).
    // TODO (jack): Merge this just into reflections now that other
    // transforms are always valid (after merging transformation
    // collapsing, which may use isValid)
    if (!Transformations[transform.type].isValid(transform)) {
      return _$15.identity; // do not transform the coord
    } else {
      return Transformations[transform.type].apply(transform);
    }
  },
  append: function append(transformList, newTransform) {
    // Append newTransform to transformList, and collapse the last
    // two transforms if they are collapsable
    var results = TransformOps._appendAndCollapseLastTwo(transformList, newTransform); // Collapse any no-ops at the end of the transformation list


    return TransformOps._collapseFinalNoOps(results);
  },
  _collapseFinalNoOps: function _collapseFinalNoOps(transforms) {
    // Collapse no-op transformations at the end of the list
    if (transforms.length && TransformOps.isNoOp(_$15.last(transforms))) {
      return _$15.initial(transforms);
    } else {
      return transforms;
    }
  },
  _appendAndCollapseLastTwo: function _appendAndCollapseLastTwo(transformList, newTransform) {
    if (!transformList.length) {
      return [newTransform];
    } else {
      var collapsed = TransformOps.collapse(_$15.last(transformList), newTransform);
      return _$15.initial(transformList).concat(collapsed);
    }
  },
  isNoOp: function isNoOp(transform) {
    return Transformations[transform.type].isNoOp(transform);
  },
  collapse: function collapse(transform1, transform2) {
    // We can only collapse transforms that have the same type
    if (transform1.type !== transform2.type) {
      return [transform1, transform2];
    } // Clicking the button again removes empty transformations


    if (TransformOps.isEmpty(transform1) && TransformOps.isEmpty(transform2)) {
      return [];
    } // Don't collapse invalid transformations otherwise


    if (!TransformOps.isValid(transform1) || !TransformOps.isValid(transform2)) {
      return [transform1, transform2];
    }

    return TransformOps._collapseValidMonotypedTransforms(transform1, transform2);
  },
  isValid: function isValid(transform) {
    return Transformations[transform.type].isValid(transform);
  },
  isEmpty: function isEmpty(transform) {
    return Transformations[transform.type].isEmpty(transform);
  },
  _collapseValidMonotypedTransforms: function _collapseValidMonotypedTransforms(transform1, transform2) {
    var collapsed = Transformations[transform1.type].collapse(transform1, transform2);

    if (collapsed) {
      // Force all answers into an array
      if (!_$15.isArray(collapsed)) {
        collapsed = [collapsed];
      } // Add types to all transforms in the answer


      _$15.each(collapsed, function (transform) {
        transform.type = transform1.type;
      });

      return collapsed;
    } else {
      // These transforms can't be collapsed together
      return [transform1, transform2];
    }
  },
  toTeX: function toTeX(transform) {
    return Transformations[transform.type].toTeX(transform);
  },

  /* A react representation of this transform object */
  ListItem: createReactClass({
    displayName: "ListItem",
    render: function render() {
      if (this.props.mode === "dynamic") {
        return /*#__PURE__*/React$1E.createElement("div", null, TransformOps.toTeX(this.props.transform));
      } else if (this.props.mode === "interactive") {
        var TransformClass = Transformations[this.props.transform.type].Input;
        return /*#__PURE__*/React$1E.createElement(TransformClass, _extends({
          ref: "transform",
          onChange: this.handleChange,
          onFocus: this.props.onFocus,
          onBlur: this.props.onBlur,
          keypadElement: this.props.keypadElement,
          apiOptions: this.props.apiOptions
        }, this.props.transform));
      } else {
        throw new Error("Invalid mode: " + this.props.mode);
      }
    },
    value: function value() {
      if (this.props.mode === "interactive") {
        return _$15.extend({
          type: this.props.transform.type
        }, this.refs.transform.value());
      } else {
        return this.props.transform;
      }
    },
    handleChange: _$15.debounce(function (callback) {
      this.props.onChange(this.value(), callback);
    }, RENDER_TRANSFORM_DELAY_IN_MS),

    /* InputPath API: depending on the API call, this could involve simply
     * navigating to the right ref and calling the function on that
     * component, or threading the call down and returning the result. */
    _getComponentAtPath: function _getComponentAtPath(path) {
      var transform = this.refs.transform;

      var ref = _$15.head(path);

      return transform.refs[ref];
    },
    focus: function focus() {
      var transform = this.refs.transform;

      var path = _$15.head(transform.getInputPaths());

      if (path) {
        this.focusInputPath(path);
      }
    },
    focusInputPath: function focusInputPath(path) {
      this._getComponentAtPath(path).focus();
    },
    blurInputPath: function blurInputPath(path) {
      this._getComponentAtPath(path).blur();
    },
    getDOMNodeForPath: function getDOMNodeForPath(path) {
      return ReactDOM$n.findDOMNode(this._getComponentAtPath(path));
    },
    getGrammarTypeForPath: function getGrammarTypeForPath(path) {
      return "number";
    },
    setInputValue: function setInputValue(path, value, cb) {
      // `value` comes in as a string on mobile, but we need a number
      // We let through the empty string so that "Clear" works -- in
      // that case, the transformer widget will just act as if there is
      // no input, which is what we want.
      if (value.length) {
        value = parseFloat(value);

        if (isNaN(value)) {
          return;
        }
      }

      this.refs.transform.setInputValue(path, value, cb);
    },
    getInputPaths: function getInputPaths() {
      // If we're in dynamic mode, then the list items are made up of
      // static text.
      if (this.props.mode === "dynamic") {
        return [];
      } else {
        return this.refs.transform.getInputPaths();
      }
    }
  })
};
var Transformations = {
  translation: {
    // I18N: As in the command, "Translate the polygon"
    verbName: i18n._("Translate"),
    nounName: i18n._("Translation"),
    lowerNounName: i18n._("translation"),
    apply: function apply(transform) {
      return function (coord) {
        return kvector$3.add(coord, transform.vector);
      };
    },
    isValid: function isValid(transform) {
      return _$15.isFinite(transform.vector[0]) && _$15.isFinite(transform.vector[1]);
    },
    isEmpty: function isEmpty(transform) {
      return transform.vector[0] === null && transform.vector[1] === null;
    },
    isNoOp: function isNoOp(transform) {
      return kvector$3.equal(transform.vector, [0, 0]);
    },
    collapse: function collapse(transform1, transform2) {
      return {
        vector: kvector$3.add(transform1.vector, transform2.vector)
      };
    },
    toTeX: function toTeX(transform) {
      // I18N: As in the command, "Translation by <3, 1>"
      return $_({
        vector: texFromVector(transform.vector)
      }, "Translation by %(vector)s");
    },
    Input: createReactClass({
      displayName: "Input",
      getInitialState: function getInitialState() {
        return {
          vector: this.props.vector || [null, null]
        };
      },
      componentDidUpdate: function componentDidUpdate(prevProps) {
        if (!deepEq$3(this.props, prevProps)) {
          this.setState({
            vector: this.props.vector
          });
        }
      },
      render: function render() {
        var InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        var vector = [/*#__PURE__*/React$1E.createElement(TeX$5, null, "\\langle"), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "x",
          placeholder: 0,
          value: this.state.vector[0],
          useArrowKeys: true,
          onChange: val0 => {
            var val1 = this.state.vector[1];
            this.setState({
              vector: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "x"),
          onBlur: _$15.partial(this.props.onBlur, "x"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ", {}"), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "y",
          placeholder: 0,
          value: this.state.vector[1],
          useArrowKeys: true,
          onChange: val1 => {
            var val0 = this.state.vector[0];
            this.setState({
              vector: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "y"),
          onBlur: _$15.partial(this.props.onBlur, "y"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, "\\rangle")];
        return /*#__PURE__*/React$1E.createElement("div", null, $_({
          vector: vector
        }, "Translation by %(vector)s"));
      },
      value: function value() {
        var x = this.refs.x.getValue();
        var y = this.refs.y.getValue();
        return {
          vector: [x, y]
        };
      },

      /* InputPath API */
      setInputValue: function setInputValue(path, value, cb) {
        var id = _$15.first(path);

        var vector = _$15.clone(this.state.vector);

        if (id === "x") {
          vector[0] = value;
        } else if (id === "y") {
          vector[1] = value;
        }

        this.setState({
          vector: vector
        }, () => {
          this.props.onChange(cb);
        });
      },
      getInputPaths: function getInputPaths() {
        return [["x"], ["y"]];
      }
    })
  },
  rotation: {
    // I18N: As in the command, "Rotate the polygon"
    verbName: i18n._("Rotate"),
    nounName: i18n._("Rotation"),
    lowerNounName: i18n._("rotation"),
    apply: function apply(transform) {
      return function (coord) {
        return kpoint$4.rotateDeg(coord, transform.angleDeg, transform.center);
      };
    },
    isValid: function isValid(transform) {
      return _$15.isFinite(transform.angleDeg) && _$15.isFinite(transform.center[0]) && _$15.isFinite(transform.center[1]);
    },
    isEmpty: function isEmpty(transform) {
      return transform.angleDeg === null && transform.center[0] === null && transform.center[1] === null;
    },
    isNoOp: function isNoOp(transform) {
      return knumber$7.equal(transform.angleDeg, 0);
    },
    collapse: function collapse(transform1, transform2) {
      if (!kpoint$4.equal(transform1.center, transform2.center)) {
        return false;
      }

      return {
        center: transform1.center,
        angleDeg: transform1.angleDeg + transform2.angleDeg
      };
    },
    toTeX: function toTeX(transform) {
      return $_({
        degrees: texFromAngleDeg(transform.angleDeg),
        point: texFromPoint(transform.center)
      }, "Rotation by %(degrees)s about %(point)s");
    },
    Input: createReactClass({
      displayName: "Input",
      getInitialState: function getInitialState() {
        return {
          center: this.props.center || [null, null],
          angleDeg: this.props.angleDeg || null
        };
      },
      componentDidUpdate: function componentDidUpdate(prevProps) {
        if (!deepEq$3(this.props, prevProps)) {
          this.setState({
            center: this.props.center,
            angleDeg: this.props.angleDeg
          });
        }
      },
      render: function render() {
        var InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        var point = [/*#__PURE__*/React$1E.createElement(TeX$5, null, "("), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "centerX",
          placeholder: 0,
          value: this.state.center[0],
          useArrowKeys: true,
          onChange: val0 => {
            var val1 = this.state.center[1];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "centerX"),
          onBlur: _$15.partial(this.props.onBlur, "centerX"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ", {}"), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "centerY",
          placeholder: 0,
          value: this.state.center[1],
          useArrowKeys: true,
          onChange: val1 => {
            var val0 = this.state.center[0];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "centerY"),
          onBlur: _$15.partial(this.props.onBlur, "centerY"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ")")];
        var degrees = [/*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "angleDeg",
          placeholder: 0,
          value: this.state.angleDeg,
          useArrowKeys: true,
          onChange: val => {
            this.setState({
              angleDeg: val
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "angleDeg"),
          onBlur: _$15.partial(this.props.onBlur, "angleDeg"),
          keypadElement: this.props.keypadElement
        }), DEGREE_SIGN]; // I18N: %(point)s must come before %(degrees)s in this phrase

        var text = $_({
          point,
          degrees
        }, "Rotation about %(point)s by %(degrees)s");
        return /*#__PURE__*/React$1E.createElement("div", null, text);
      },
      value: function value() {
        var angleDeg = this.refs.angleDeg.getValue();
        var centerX = this.refs.centerX.getValue();
        var centerY = this.refs.centerY.getValue();
        return {
          angleDeg: angleDeg,
          center: [centerX, centerY]
        };
      },

      /* InputPath API */
      setInputValue: function setInputValue(path, value, cb) {
        var id = _$15.first(path);

        var angleDeg = _$15.clone(this.state.angleDeg);

        var center = _$15.clone(this.state.center);

        if (id === "angleDeg") {
          angleDeg = value;
        } else if (id === "centerX") {
          center[0] = value;
        } else if (id === "centerY") {
          center[1] = value;
        }

        this.setState({
          angleDeg: angleDeg,
          center: center
        }, () => {
          this.props.onChange(cb);
        });
      },
      getInputPaths: function getInputPaths() {
        return [["centerX"], ["centerY"], ["angleDeg"]];
      }
    })
  },
  reflection: {
    // I18N: As in the command, "Reflect the polygon"
    verbName: i18n._("Reflect"),
    nounName: i18n._("Reflection"),
    lowerNounName: i18n._("reflection"),
    apply: function apply(transform) {
      return function (coord) {
        return kpoint$4.reflectOverLine(coord, transform.line);
      };
    },
    isValid: function isValid(transform) {
      // A bit hacky, but we'll also define reflecting over a
      // single point as a no-op, to avoid NaN fun.
      return _$15.all(_$15.flatten(transform.line), _$15.isFinite) && !kpoint$4.equal(transform.line[0], transform.line[1]);
    },
    isEmpty: function isEmpty(transform) {
      return _$15.all(_$15.flatten(transform.line), _$15.isNull);
    },
    isNoOp: function isNoOp(transform) {
      // Invalid transforms are implicitly no-ops, so we don't
      // have to catch that case here.
      return false;
    },
    collapse: function collapse(transform1, transform2) {
      if (!kline$1.equal(transform1.line, transform2.line)) {
        return false;
      }

      return [];
    },
    toTeX: function toTeX(transform) {
      var point1 = transform.line[0];
      var point2 = transform.line[1];
      return $_({
        point1: texFromPoint(point1),
        point2: texFromPoint(point2)
      }, "Reflection over the line from %(point1)s to %(point2)s");
    },
    Input: createReactClass({
      displayName: "Input",
      getInitialState: function getInitialState() {
        return {
          line: this.props.line || [[null, null], [null, null]]
        };
      },
      componentDidUpdate: function componentDidUpdate(prevProps) {
        if (!deepEq$3(this.props, prevProps)) {
          this.setState({
            line: this.props.line
          });
        }
      },
      render: function render() {
        var InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        var point1 = [/*#__PURE__*/React$1E.createElement(TeX$5, null, "("), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "x1",
          value: this.state.line[0][0],
          useArrowKeys: true,
          onChange: this.changePoint.bind(this, 0, 0),
          onFocus: _$15.partial(this.props.onFocus, "x1"),
          onBlur: _$15.partial(this.props.onBlur, "x1"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ", {}"), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "y1",
          value: this.state.line[0][1],
          useArrowKeys: true,
          onChange: this.changePoint.bind(this, 0, 1),
          onFocus: _$15.partial(this.props.onFocus, "y1"),
          onBlur: _$15.partial(this.props.onBlur, "y1"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ")")];
        var point2 = [/*#__PURE__*/React$1E.createElement(TeX$5, null, "("), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "x2",
          value: this.state.line[1][0],
          useArrowKeys: true,
          onChange: this.changePoint.bind(this, 1, 0),
          onFocus: _$15.partial(this.props.onFocus, "x2"),
          onBlur: _$15.partial(this.props.onBlur, "x2"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ", {}"), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "y2",
          value: this.state.line[1][1],
          useArrowKeys: true,
          onChange: this.changePoint.bind(this, 1, 1),
          onFocus: _$15.partial(this.props.onFocus, "y2"),
          onBlur: _$15.partial(this.props.onBlur, "y2"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ")")];
        return /*#__PURE__*/React$1E.createElement("div", null, $_({
          point1,
          point2
        }, "Reflection over the line from " + "%(point1)s to %(point2)s"));
      },
      changePoint: function changePoint(i, j, val, cb) {
        var line = _$15.map(this.state.line, _$15.clone);

        line[i][j] = val;
        this.setState({
          line: line
        }, () => {
          this.props.onChange(cb);
        });
      },
      value: function value() {
        var x1 = this.refs.x1.getValue();
        var y1 = this.refs.y1.getValue();
        var x2 = this.refs.x2.getValue();
        var y2 = this.refs.y2.getValue();
        return {
          line: [[x1, y1], [x2, y2]]
        };
      },

      /* InputPath API */
      setInputValue: function setInputValue(path, value, cb) {
        var id = _$15.first(path);

        var j;

        if (id[0] === "x") {
          j = 0;
        } else if (id[0] === "y") {
          j = 1;
        }

        var i;

        if (id[1] === "1") {
          i = 0;
        } else if (id[1] === "2") {
          i = 1;
        }

        this.changePoint(i, j, value, cb);
      },
      getInputPaths: function getInputPaths() {
        return [["x1"], ["y1"], ["x2"], ["y2"]];
      }
    })
  },
  dilation: {
    // I18N: As in the command, "Dilate the polygon"
    verbName: i18n._("Dilate"),
    nounName: i18n._("Dilation"),
    lowerNounName: i18n._("dilation"),
    apply: function apply(transform) {
      return function (coord) {
        return dilatePointFromCenter(coord, transform.center, transform.scale);
      };
    },
    isValid: function isValid(transform) {
      return _$15.isFinite(transform.scale) && _$15.isFinite(transform.center[0]) && _$15.isFinite(transform.center[1]);
    },
    isEmpty: function isEmpty(transform) {
      return transform.scale === null && transform.center[0] === null && transform.center[1] === null;
    },
    isNoOp: function isNoOp(transform) {
      return knumber$7.equal(transform.scale, 1);
    },
    collapse: function collapse(transform1, transform2) {
      if (!kpoint$4.equal(transform1.center, transform2.center)) {
        return false;
      }

      return {
        center: transform1.center,
        scale: transform1.scale * transform2.scale
      };
    },
    toTeX: function toTeX(transform) {
      var scaleString = stringFromFraction(transform.scale);
      return $_({
        scale: scaleString,
        point: texFromPoint(transform.center)
      }, "Dilation of scale %(scale)s about %(point)s");
    },
    Input: createReactClass({
      displayName: "Input",
      getInitialState: function getInitialState() {
        return {
          center: this.props.center || [null, null],
          scale: this.props.scale || null
        };
      },
      componentDidUpdate: function componentDidUpdate(prevProps) {
        if (!deepEq$3(this.props, prevProps)) {
          this.setState({
            center: this.props.center,
            scale: this.props.scale
          });
        }
      },
      render: function render() {
        var InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        var point = [/*#__PURE__*/React$1E.createElement(TeX$5, null, "("), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "x",
          placeholder: 0,
          value: this.state.center[0],
          useArrowKeys: true,
          onChange: val0 => {
            var val1 = this.state.center[1];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "x"),
          onBlur: _$15.partial(this.props.onBlur, "x"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ", {}"), /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "y",
          placeholder: 0,
          value: this.state.center[1],
          useArrowKeys: true,
          onChange: val1 => {
            var val0 = this.state.center[0];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "y"),
          onBlur: _$15.partial(this.props.onBlur, "y"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React$1E.createElement(TeX$5, null, ")")];
        var scale = /*#__PURE__*/React$1E.createElement(InputComponent, {
          ref: "scale",
          placeholder: 1,
          value: this.state.scale,
          useArrowKeys: true,
          onChange: val => {
            this.setState({
              scale: val
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: _$15.partial(this.props.onFocus, "scale"),
          onBlur: _$15.partial(this.props.onBlur, "scale"),
          keypadElement: this.props.keypadElement
        });
        return /*#__PURE__*/React$1E.createElement("div", null, $_({
          point,
          scale
        }, "Dilation about %(point)s by %(scale)s"));
      },
      value: function value() {
        var scale = this.refs.scale.getValue();
        var x = this.refs.x.getValue();
        var y = this.refs.y.getValue();
        return {
          scale: scale,
          center: [x, y]
        };
      },

      /* InputPath API */
      setInputValue: function setInputValue(path, value, cb) {
        var id = _$15.first(path);

        var scale = this.state.scale;

        var center = _$15.clone(this.state.center);

        if (id === "x") {
          center[0] = value;
        } else if (id === "y") {
          center[1] = value;
        } else if (id === "scale") {
          scale = value;
        }

        this.setState({
          scale: scale,
          center: center
        }, () => {
          this.props.onChange(cb);
        });
      },
      getInputPaths: function getInputPaths() {
        return [["x"], ["y"], ["scale"]];
      }
    })
  }
};
/* Various functions to deal with different shape types */

var ShapeTypes$1 = {
  getPointCountForType: function getPointCountForType(type) {
    var splitType = type.split("-");

    if (splitType[0] === "polygon") {
      return splitType[1] || 3;
    } else if (splitType[0] === "line" || splitType[0] === "lineSegment") {
      return 2;
    } else if (splitType[0] === "angle") {
      return 3;
    } else if (splitType[0] === "circle") {
      return 2;
    } else if (splitType[0] === "point") {
      return 1;
    }
  },
  addMovableShape: function addMovableShape(graphie, options) {
    if (options.editable && options.translatable) {
      throw new Error("It doesn't make sense to have a movable shape " + "where you can stretch the points and translate them " + "simultaneously. options: " + JSON.stringify(options));
    }

    var shape;

    var points = _$15.map(options.shape.coords, function (coord) {
      var currentPoint;
      var isMoving = false;
      var previousCoord = coord;

      var onMove = function onMove(x, y) {
        if (!isMoving) {
          previousCoord = currentPoint.coord;
          isMoving = true;
        }

        var moveVector = kvector$3.subtract([x, y], currentPoint.coord); // Translate from (x, y) semantics to (dX, dY) semantics
        // This is more useful for translations on multiple points,
        // where we care about how the points moved, not where any
        // individual point ended up

        if (options.onMove) {
          moveVector = options.onMove(moveVector[0], moveVector[1]);
        } // Perform a translation on all points in this shape when
        // any point moves


        if (options.translatable) {
          _$15.each(points, function (point) {
            // The point itself will be updated by the
            // movablePoint class, so only translate the other
            // points
            if (point !== currentPoint) {
              point.setCoord(kvector$3.add(point.coord, moveVector));
            }
          });
        } // Update our shape and our currentPoint
        // Without this, some shapes (circles, angles) appear
        // "bouncy" as they are updated with currentPoint at the
        // current mouse coordinate (oldCoord), rather than newCoord


        var oldCoord = currentPoint.coord;
        var newCoord = kvector$3.add(currentPoint.coord, moveVector); // Temporarily change our coordinate so that
        // shape.update() sees the new coordinate

        currentPoint.coord = newCoord;
        shape.update(); // ...But don't break onMove, which assumes it
        // is the only thing changing our coord

        currentPoint.coord = oldCoord;
        return newCoord;
      };

      var onMoveEnd = function onMoveEnd() {
        // onMove isn't guaranteed to be called before onMoveEnd, so
        // we have to take into account that we may not have moved and
        // set previousCoord.
        if (options.onMoveEnd && isMoving) {
          isMoving = false; // We don't use the supplied x and y parameters here
          // because MovablePoint's onMoveEnd semantics suck.
          // It returns the mouseX, mouseY without processing them
          // through onMove, leaving us with weird fractional moves

          var change = kvector$3.subtract(currentPoint.coord, previousCoord);
          options.onMoveEnd(change[0], change[1]);
        }

        shape.update();
      };

      currentPoint = graphie.addMovablePoint({
        coord: coord,
        normalStyle: options.normalPointStyle,
        highlightStyle: options.highlightPointStyle,
        constraints: {
          fixed: !options.translatable && !options.editable
        },
        visible: options.showPoints,
        snapX: options.snap && options.snap[0] || 0,
        snapY: options.snap && options.snap[1] || 0,
        bounded: false,
        // Don't bound it when placing it on the graph
        onMove: onMove,
        onMoveEnd: onMoveEnd
      }); // Bound it when moving
      // We can't set this earlier, because doing so would mean any
      // points outside of the graph would be moved into a moved into
      // a position that doesn't preserve the shape

      currentPoint.bounded = true;
      return currentPoint;
    });

    shape = ShapeTypes$1.addShape(graphie, options, points);
    var removeShapeWithoutPoints = shape.remove;

    shape.remove = function () {
      removeShapeWithoutPoints.apply(shape);

      _$15.invoke(points, "remove");
    };

    return shape;
  },
  addShape: function addShape(graphie, options, points) {
    points = points || options.shape.coords;

    var types = ShapeTypes$1._typesOf(options.shape);

    var typeOptions = options.shape.options || ShapeTypes$1.defaultOptions(types);

    var shapes = ShapeTypes$1._mapTypes(types, points, function (type, points, i) {
      var shapeOptions = _$15.extend({}, options, typeOptions[i]);

      return ShapeTypes$1._addType(graphie, type, points, shapeOptions);
    });

    var updateFuncs = _$15.filter(_$15.pluck(shapes, "update"), _$15.identity);

    var update = function update() {
      _$15.invoke(updateFuncs, "call");
    };

    var removeFuncs = _$15.filter(_$15.pluck(shapes, "remove"), _$15.identity);

    var remove = function remove() {
      _$15.invoke(removeFuncs, "call");
    };

    var getOptions = function getOptions() {
      return _$15.map(shapes, function (shape) {
        if (shape.getOptions) {
          return shape.getOptions();
        } else {
          return {};
        }
      });
    };

    var toJSON = function toJSON() {
      var coords = _$15.map(points, function (pt) {
        if (_$15.isArray(pt)) {
          return pt;
        } else {
          return pt.coord;
        }
      });

      return {
        type: types,
        coords: coords,
        options: getOptions()
      };
    };

    return {
      type: types,
      points: points,
      update: update,
      remove: remove,
      toJSON: toJSON,
      getOptions: getOptions
    };
  },
  equal: function equal(shape1, shape2) {
    var types1 = ShapeTypes$1._typesOf(shape1);

    var types2 = ShapeTypes$1._typesOf(shape2);

    if (types1.length !== types2.length) {
      return false;
    }

    var shapes1 = ShapeTypes$1._mapTypes(types1, shape1.coords, ShapeTypes$1._combine);

    var shapes2 = ShapeTypes$1._mapTypes(types2, shape2.coords, ShapeTypes$1._combine);

    return _$15.all(_$15.map(shapes1, function (partialShape1, i) {
      var partialShape2 = shapes2[i];

      if (partialShape1.type !== partialShape2.type) {
        return false;
      }

      return ShapeTypes$1._forType(partialShape1.type).equal(partialShape1.coords, partialShape2.coords);
    }));
  },
  _typesOf: function _typesOf(shape) {
    var types = shape.type;

    if (!_$15.isArray(types)) {
      types = [types];
    }

    return _$15.map(types, function (type) {
      if (type === "polygon") {
        return "polygon-3";
      } else {
        return type;
      }
    });
  },
  defaultOptions: function defaultOptions(types) {
    return _$15.map(types, function (type) {
      var typeDefaultOptions = ShapeTypes$1._forType(type).defaultOptions;

      return _$15.extend({}, typeDefaultOptions);
    });
  },
  _forType: function _forType(type) {
    var baseType = type.split("-")[0];
    return ShapeTypes$1[baseType];
  },
  _mapTypes: function _mapTypes(types, points, func, context) {
    return _$15.map(types, function (type, i) {
      var pointCount = ShapeTypes$1.getPointCountForType(type);

      var currentPoints = _$15.first(points, pointCount);

      points = _$15.rest(points, pointCount);
      return func.call(context, type, currentPoints, i);
    });
  },
  _addType: function _addType(graphie, type, points, options) {
    var lineCoords = _$15.isArray(points[0]) ? {
      coordA: points[0],
      coordZ: points[1]
    } : {
      pointA: points[0],
      pointZ: points[1]
    };
    type = type.split("-")[0];

    if (type === "polygon") {
      var polygon = graphie.addMovablePolygon(_$15.extend({}, options, {
        fixed: !options.editable,
        snapX: options.snap && options.snap[0] || 0,
        snapY: options.snap && options.snap[1] || 0,
        points: points,
        constrainToGraph: false
      }));
      return {
        update: polygon.transform.bind(polygon),
        remove: polygon.remove.bind(polygon)
      };
    } else if (type === "line" || type === "lineSegment") {
      var line = graphie.addMovableLineSegment(_$15.extend({}, options, lineCoords, {
        movePointsWithLine: true,
        fixed: true,
        constraints: {
          fixed: true
        },
        extendLine: type === "line"
      })); // TODO(jack): Hide points on uneditable lines when translation
      // is a vector.
      // We can't just remove the points yet, because they are the
      // translation handle for the line.

      return {
        update: line.transform.bind(line, true),
        remove: line.remove.bind(line)
      };
    } else if (type === "angle") {
      // If this angle is editable, we want to be able to make angles
      // both larger and smaller than 180 degrees.
      // If this angle is not editable, it should always maintain
      // it's angle measure, even if it is reflected (causing the
      // clockwise-ness of the points to change)
      var shouldChangeReflexivity = options.editable ? null : false;
      var angle = graphie.addMovableAngle({
        angleLabel: "$deg0",
        fixed: true,
        points: points,
        normalStyle: options.normalStyle,
        reflex: options.reflex
      }); // Hide non-vertex points on uneditable angles

      if (!_$15.isArray(points[0]) && !options.editable) {
        points[0].remove();
        points[2].remove();
      }

      return {
        update: angle.update.bind(angle, shouldChangeReflexivity),
        remove: angle.remove.bind(angle),
        getOptions: function getOptions() {
          return {
            reflex: angle.isReflex()
          };
        }
      };
    } else if (type === "circle") {
      var perimeter = {
        // temporary object for the first removal
        remove: _$15.identity
      };

      var redrawPerim = function redrawPerim() {
        var coord0 = points[0].coord || points[0];
        var coord1 = points[1].coord || points[1];
        var radius = kpoint$4.distanceToPoint(coord0, coord1);
        perimeter.remove();
        perimeter = graphie.circle(coord0, radius, _$15.extend({
          stroke: KhanColors$8.DYNAMIC,
          "stroke-width": 2
        }, options.normalStyle));
      };

      redrawPerim();

      if (points[1].remove && !options.editable) {
        points[1].remove();
      }

      return {
        update: redrawPerim,
        remove: function remove() {
          // Not _.bind because the remove function changes
          // when the perimeter is redrawn
          perimeter.remove();
        }
      };
    } else if (type === "point") {
      // do nothing
      return {
        update: null,
        remove: null
      };
    } else {
      throw new Error("Invalid shape type " + type);
    }
  },
  _combine: function _combine(type, coords) {
    return {
      type: type,
      coords: coords
    };
  },
  polygon: {
    equal: orderInsensitiveCoordsEqual$1
  },
  line: {
    equal: kline$1.equal
  },
  lineSegment: {
    equal: orderInsensitiveCoordsEqual$1
  },
  angle: {
    equal: function equal(points1, points2) {
      if (!kpoint$4.equal(points1[1], points2[1])) {
        return false;
      }

      var line1_0 = [points1[1], points1[0]];
      var line1_2 = [points1[1], points1[2]];
      var line2_0 = [points2[1], points2[0]];
      var line2_2 = [points2[1], points2[2]];
      var equalUnflipped = kray$1.equal(line1_0, line2_0) && kray$1.equal(line1_2, line2_2);
      var equalFlipped = kray$1.equal(line1_0, line2_2) && kray$1.equal(line1_2, line2_0);
      return equalUnflipped || equalFlipped;
    },
    defaultOptions: {
      reflex: false
    }
  },
  circle: {
    equal: function equal(points1, points2) {
      var radius1 = kpoint$4.distanceToPoint(points1[0], points1[1]);
      var radius2 = kpoint$4.distanceToPoint(points2[0], points2[1]);
      return kpoint$4.equal(points1[0], points2[0]) && knumber$7.equal(radius1, radius2);
    }
  },
  point: {
    equal: kpoint$4.equal
  }
};
var TransformationListItem = TransformOps.ListItem;
var TransformationList = createReactClass({
  displayName: "TransformationList",
  render: function render() {
    if (this.props.mode === "static") {
      return /*#__PURE__*/React$1E.createElement("span", null); // don't render anything
    }

    var transformationList = _$15.map(this.props.transformations, function (transform, i) {
      return /*#__PURE__*/React$1E.createElement(TransformationListItem, {
        ref: "transformation" + i,
        key: "transformation" + i,
        transform: transform,
        mode: this.props.mode,
        onChange: this.handleChange,
        onFocus: _$15.partial(this.props.onFocus, "" + i),
        onBlur: _$15.partial(this.props.onBlur, "" + i),
        keypadElement: this.props.keypadElement,
        apiOptions: this.props.apiOptions
      });
    }, this);

    return /*#__PURE__*/React$1E.createElement("div", {
      className: "perseus-transformation-list"
    }, transformationList);
  },
  _transformationRefs: function _transformationRefs() {
    return _$15.times(this.props.transformations.length, i => {
      return this.refs["transformation" + i];
    });
  },
  value: function value() {
    return _$15.invoke(this._transformationRefs(), "value");
  },
  handleChange: function handleChange(changed, callback) {
    this.props.onChange(this.value(), callback);
  },
  focusLast: function focusLast() {
    var transformationRefs = this._transformationRefs();

    if (transformationRefs.length !== 0) {
      _$15.last(transformationRefs).focus();
    }
  }
});
var ToolButton = createReactClass({
  displayName: "ToolButton",
  render: function render() {
    var classes = this.props.toggled ? "simple-button exercise-orange toggled highlighted-tool-button" : "simple-button";
    return /*#__PURE__*/React$1E.createElement("button", {
      type: "button",
      className: classes,
      disabled: this.props.disabled,
      onClick: this.props.onClick,
      onTouchStart: captureScratchpadTouchStart$2
    }, this.props.children);
  }
});
var ToolsBar = createReactClass({
  displayName: "ToolsBar",
  getInitialState: function getInitialState() {
    return {
      selected: null
    };
  },
  render: function render() {
    var tools = _$15.map(Transformations, function (tool, type) {
      if (this.props.enabled[type]) {
        return /*#__PURE__*/React$1E.createElement(ToolButton, {
          key: type,
          disabled: this.props.apiOptions.readOnly,
          toggled: this.state.selected === type,
          onClick: this.changeSelected.bind(this, type)
        }, tool.verbName);
      }
    }, this);

    return /*#__PURE__*/React$1E.createElement("div", {
      className: "transformer-tools-bar"
    }, /*#__PURE__*/React$1E.createElement("span", {
      className: "simple-button-group"
    }, tools), /*#__PURE__*/React$1E.createElement("button", {
      className: "transformer-undo-button simple-button",
      type: "button",
      disabled: this.props.apiOptions.readOnly,
      onClick: this.props.onUndoClick,
      onTouchStart: captureScratchpadTouchStart$2
    }, /*#__PURE__*/React$1E.createElement(InlineIcon$g, iconUndo), " " + i18n._("Undo")), /*#__PURE__*/React$1E.createElement("div", {
      className: "clear"
    }));
  },
  changeSelected: function changeSelected(tool) {
    this.props.removeTool(this.state.selected);

    if (!tool || tool === this.state.selected) {
      this.setState({
        selected: null
      });
    } else {
      this.props.addTool(tool);
      this.setState({
        selected: tool
      });
    }
  }
});
var AddTransformBar = createReactClass({
  displayName: "AddTransformBar",
  render: function render() {
    var tools = _$15.map(Transformations, function (tool, type) {
      if (this.props.enabled[type]) {
        return /*#__PURE__*/React$1E.createElement(ToolButton, {
          key: type,
          toggled: false,
          disabled: this.props.apiOptions.readOnly,
          onClick: this.changeSelected.bind(this, type)
        }, /*#__PURE__*/React$1E.createElement(InlineIcon$g, iconPlus), " ", tool.nounName);
      }
    }, this);

    return /*#__PURE__*/React$1E.createElement("div", {
      className: "transformer-tools-bar"
    }, tools, /*#__PURE__*/React$1E.createElement("button", {
      className: "transformer-undo-button simple-button",
      type: "button",
      onClick: this.props.onUndoClick,
      disabled: this.props.apiOptions.readOnly,
      onTouchStart: captureScratchpadTouchStart$2
    }, /*#__PURE__*/React$1E.createElement(InlineIcon$g, iconUndo), " " + i18n._("Undo")), /*#__PURE__*/React$1E.createElement("div", {
      className: "clear"
    }));
  },
  changeSelected: function changeSelected(tool) {
    if (tool) {
      this.props.addTool(tool);
    }
  }
});
var Transformer$1 = createReactClass({
  displayName: "Transformer",
  propTypes: {
    apiOptions: ApiOptions$q.propTypes,
    keypadElement: keypadElementPropType$6,
    trackInteraction: PropTypes.func.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return _$15.defaults({
      transformations: []
    }, defaultTransformerProps$1);
  },
  render: function render() {
    // Fill in any missing value in this.props.graph
    // this can happen because the graph json doesn't include
    // box, for example
    var graph = _$15.extend(defaultGraphProps$1(this.props.graph, defaultBoxSize$3), this.props.graph);

    var interactiveToolsMode = this.props.graphMode === "interactive";
    var ToolsBarClass = interactiveToolsMode ? ToolsBar : AddTransformBar; // This style is applied inline because it is dependent on the
    // size of the graph as set by the graph.box prop, and this also
    // lets us specify it in the same place the graph's width is
    // specified.

    var toolsBar = /*#__PURE__*/React$1E.createElement("div", {
      style: {
        width: graph.box[0]
      }
    }, /*#__PURE__*/React$1E.createElement(ToolsBarClass, {
      ref: "toolsBar",
      enabled: pluckObject(this.props.tools, "enabled"),
      apiOptions: this.props.apiOptions,
      addTool: this.addTool,
      removeTool: this.removeTool,
      onUndoClick: this.handleUndoClick
    }));
    return /*#__PURE__*/React$1E.createElement("div", {
      className: "perseus-widget " + "perseus-widget-transformer"
    }, /*#__PURE__*/React$1E.createElement(Graph$2, {
      ref: "graph",
      box: graph.box,
      range: graph.range,
      labels: graph.labels,
      step: graph.step,
      gridStep: graph.gridStep,
      markings: graph.markings,
      backgroundImage: graph.backgroundImage,
      showProtractor: graph.showProtractor,
      onGraphieUpdated: this.setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }), !interactiveToolsMode && "Add transformations below:", this.props.graphMode === "static" && [/*#__PURE__*/React$1E.createElement("br", {
      key: "static-br"
    }), /*#__PURE__*/React$1E.createElement("em", {
      key: "static-nomove"
    }, " ", "Note: For this question, the shape will not move.", " ")], interactiveToolsMode && toolsBar, /*#__PURE__*/React$1E.createElement(TransformationList, {
      ref: "transformationList",
      mode: this.props.listMode,
      transformations: this.props.transformations,
      onChange: this.setTransformationProps,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      keypadElement: this.props.keypadElement,
      apiOptions: this.props.apiOptions
    }), !interactiveToolsMode && toolsBar);
  },
  componentDidMount: function componentDidMount() {
    this.setupGraphie(this.graphie());
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    if (this.shouldSetupGraphie(this.props, prevProps)) {
      this.refs.graph.reset();
    } else if (!deepEq$3(this.props.transformations, this.transformations)) {
      this.setTransformations(this.props.transformations);
    }
  },
  shouldSetupGraphie: function shouldSetupGraphie(nextProps, prevProps) {
    if (!deepEq$3(prevProps.starting, nextProps.starting)) {
      return true;
    } else if (prevProps.graphMode !== nextProps.graphMode) {
      return true;
    } else if (prevProps.listMode !== nextProps.listMode) {
      return true;
    } else if (prevProps.drawSolutionShape !== nextProps.drawSolutionShape) {
      return true;
    } else if (nextProps.drawSolutionShape && !deepEq$3(prevProps.correct.shape, nextProps.correct.shape)) {
      return true;
    } else if (!deepEq$3(this.tools, nextProps.tools)) {
      return true;
    } else {
      return false;
    }
  },
  graphie: function graphie() {
    return this.refs.graph.graphie();
  },
  setupGraphie: function setupGraphie(graphie) {
    // A background image of our solution:
    if (this.props.drawSolutionShape && this.props.correct.shape && this.props.correct.shape.coords) {
      ShapeTypes$1.addShape(graphie, {
        fixed: true,
        shape: this.props.correct.shape,
        normalStyle: {
          stroke: KhanColors$8.GRAY,
          "stroke-dasharray": "",
          "stroke-width": 2
        }
      });
    }

    this.currentTool = null;
    this.refs.toolsBar.changeSelected(null);
    this.addTransformerShape(this.props.starting.shape,
    /* translatable */
    false);
    this.setTransformations(this.props.transformations); // Save a copy of our tools so that we can check future
    // this.props.tools changes against them
    // This seems weird, but gives us an easy way to tell whether
    // props changes were self-inflicted (for which a graphie reset
    // is not required, and is in fact a bad idea right now because
    // of resetting the size of the dilation tool).
    // TODO (jack): A deepClone method would be nice here

    this.tools = {
      translation: _$15.clone(this.props.tools.translation),
      rotation: _$15.clone(this.props.tools.rotation),
      reflection: _$15.clone(this.props.tools.reflection),
      dilation: _$15.clone(this.props.tools.dilation)
    };
  },

  /* Applies all transformations in `transformations`
   * to the starting shape, and updates this.transformations
   * to reflect this
   *
   * Usually called with this.props.transformations
   */
  setTransformations: function setTransformations(transformations) {
    this.resetCoords();
    this.transformations = _$15.clone(transformations);

    _$15.each(this.transformations, this.applyTransform);
  },
  // the polygon that we transform
  addTransformerShape: function addTransformerShape(shape, translatable) {
    var self = this;
    var graphie = this.graphie();
    this.shape = ShapeTypes$1.addMovableShape(graphie, {
      shape: shape,
      editable: false,
      showPoints: this.props.graphMode !== "static",
      translatable: translatable,
      onMove: function onMove(dX, dY) {
        dX = KhanMath$5.roundToNearest(graphie.snap[0], dX);
        dY = KhanMath$5.roundToNearest(graphie.snap[1], dY);
        self.addTransform({
          type: "translation",
          vector: [dX, dY]
        });
        return [dX, dY];
      },
      normalPointStyle: {
        fill: translatable ? KhanColors$8.INTERACTIVE : KhanColors$8.DYNAMIC,
        stroke: translatable ? KhanColors$8.INTERACTIVE : KhanColors$8.DYNAMIC
      },
      highlightPointStyle: {
        fill: KhanColors$8.INTERACTING,
        stroke: KhanColors$8.INTERACTING
      }
    });
  },
  addTool: function addTool(toolId) {
    var self = this;

    if (this.props.graphMode === "interactive") {
      if (toolId === "translation") {
        this.currentTool = this.addTranslationTool();
      } else if (toolId === "rotation") {
        this.currentTool = this.addRotationTool();
      } else if (toolId === "reflection") {
        this.currentTool = this.addReflectionTool();
      } else if (toolId === "dilation") {
        this.currentTool = this.addDilationTool();
      } else {
        throw new Error("Invalid tool id: " + toolId);
      }
    } else {
      var transform;

      if (toolId === "translation") {
        transform = {
          type: toolId,
          vector: [null, null]
        };
      } else if (toolId === "rotation") {
        transform = {
          type: toolId,
          center: [null, null],
          angleDeg: null
        };
      } else if (toolId === "reflection") {
        // Reflections with nulls in them won't be applied until
        // fills in the blanks
        transform = {
          type: toolId,
          line: [[null, null], [null, null]]
        };
      } else if (toolId === "dilation") {
        transform = {
          type: toolId,
          center: [null, null],
          scale: null
        };
      } else {
        throw new Error("Invalid tool id: " + toolId);
      }

      this.doTransform(transform, function () {
        self.refs.transformationList.focusLast();
      });
    }
  },
  removeTool: function removeTool(toolId) {
    if (this.currentTool) {
      this.currentTool.remove();
    }

    this.currentTool = null;
  },
  addTranslationTool: function addTranslationTool() {
    var self = this;
    this.shape.remove();
    this.addTransformerShape(this.shape.toJSON(),
    /* translatable */
    true);
    return {
      remove: function remove() {
        self.shape.remove();
        self.addTransformerShape(self.shape.toJSON(),
        /* translatable */
        false);
      }
    };
  },
  // Snaps a coord to this.graphie()'s snap
  snapCoord: function snapCoord(coord) {
    var graphie = this.graphie();
    return _$15.map(coord, function (val, dim) {
      return KhanMath$5.roundToNearest(graphie.snap[dim], val);
    });
  },
  // Normalize the coords into something that fits the new 45 degree
  // reflection line.
  normalizeReflectionCoords: function normalizeReflectionCoords(messyCoords) {
    var midpoint = this.snapCoord(kline$1.midpoint(messyCoords));
    var origDirectionPolar = kvector$3.polarDegFromCart(kvector$3.subtract(messyCoords[0], messyCoords[1]));
    var directionPolar = [1, KhanMath$5.roundToNearest(45, origDirectionPolar[1])];
    var direction = kvector$3.cartFromPolarDeg(directionPolar);

    var coords = _$15.map([-1, 1], function (directionCoefficient) {
      var coord = kvector$3.add(midpoint, kvector$3.scale(direction, directionCoefficient * this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST)));
      return this.snapCoord(coord);
    }, this);

    return coords;
  },
  addReflectionTool: function addReflectionTool() {
    var options = this.props.tools.reflection;

    if (!options.enabled) {
      return;
    }

    var self = this;
    var graphie = this.refs.graph.graphie();

    var updateReflectionTool = function updateReflectionTool() {
      self.changeTool("reflection", {
        coords: _$15.pluck(reflectPoints, "coord")
      });
    };

    var coords = this.normalizeReflectionCoords(options.coords); // The points defining the line of reflection; hidden from the
    // user.

    var reflectPoints = _$15.map(coords, function (coord) {
      return graphie.addMovablePoint({
        coord: coord,
        visible: false
      });
    }, this); // the line of reflection
    // TODO(jack): graphie.style here is a hack to prevent the dashed
    // style from leaking into the rest of the shapes. Remove when
    // graphie.addMovableLineSegment doesn't leak styles anymore.


    var reflectLine;
    var normalColor = colorForTool(options);
    graphie.style({}, function () {
      reflectLine = graphie.addMovableLineSegment({
        fixed: options.constraints.fixed,
        constraints: options.constraints,
        pointA: reflectPoints[0],
        pointZ: reflectPoints[1],
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        extendLine: true,
        normalStyle: {
          stroke: normalColor,
          "stroke-width": 2,
          "stroke-dasharray": "- "
        },
        highlightStyle: {
          stroke: KhanColors$8.INTERACTING,
          "stroke-width": 2,
          "stroke-dasharray": "- " // TODO(jack) solid doesn't
          // work here, but would be
          // nicer

        },
        movePointsWithLine: true,
        onMoveEnd: updateReflectionTool
      });
    }); // the "button" point in the center of the line of reflection

    var reflectButton = graphie.addReflectButton({
      fixed: options.constraints.fixed,
      line: reflectLine,
      size: this.scaleToCurrentRange(REFLECT_BUTTON_SIZE),
      onClick: function onClick() {
        self.doTransform({
          type: "reflection",
          line: _$15.pluck(reflectPoints, "coord")
        });

        if (reflectRotateHandle) {
          // flip the rotation handle
          reflectRotateHandle.setCoord(kvector$3.add(reflectButton.coord, kvector$3.subtract(reflectButton.coord, reflectRotateHandle.coord)));
          reflectRotateHandle.update();
        }
      },
      normalStyle: {
        stroke: normalColor,
        "stroke-width": 2,
        fill: normalColor
      },
      highlightStyle: {
        stroke: KhanColors$8.INTERACTING,
        "stroke-width": 3,
        fill: KhanColors$8.INTERACTING
      },
      onMoveEnd: updateReflectionTool
    });
    var reflectRotateHandle = null;

    if (!options.constraints.fixed) {
      // The rotation handle for rotating the line of reflection
      var initRotateHandleAngle = kvector$3.polarDegFromCart(kvector$3.subtract(reflectPoints[1].coord, reflectPoints[0].coord))[1] + 90; // 90 degrees off of the line

      reflectRotateHandle = graphie.addRotateHandle({
        center: reflectButton,
        radius: this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST),
        angleDeg: initRotateHandleAngle,
        width: this.scaleToCurrentRange(0.24),
        hoverWidth: this.scaleToCurrentRange(0.4),
        lengthAngle: 17,
        onMove: function onMove(newAngle) {
          return KhanMath$5.roundToNearest(45, newAngle);
        },
        onMoveEnd: updateReflectionTool
      });
    } // Move the reflectButton and reflectRotateHandle with the line


    $(reflectLine).on("move", function () {
      reflectButton.update();
      $(reflectButton).trigger("move"); // update the rotation handle,
      // which watches for this in util/interactive.js.
    }); // Update the line and reflect button when the reflectRotateHandle is
    // rotated

    if (reflectRotateHandle) {
      $(reflectRotateHandle).on("move", function () {
        var rotateHandleApprox = self.snapCoord(reflectRotateHandle.coord);
        var rotateVector = kvector$3.subtract(rotateHandleApprox, reflectButton.coord);
        var flipped = reflectButton.isFlipped() ? 1 : 0;
        reflectPoints[flipped].setCoord(kvector$3.add(reflectButton.coord, kvector$3.rotateDeg(rotateVector, 90)));
        reflectPoints[1 - flipped].setCoord(kvector$3.add(reflectButton.coord, kvector$3.rotateDeg(rotateVector, -90)));
        reflectLine.transform(true);
        reflectButton.update();
      });
    }

    return {
      remove: function remove() {
        reflectButton.remove();

        if (reflectRotateHandle) {
          reflectRotateHandle.remove();
        }

        reflectLine.remove();
        reflectPoints[0].remove();
        reflectPoints[1].remove();
      }
    };
  },

  /* Scales a distance from the default range of
   * [-10, 10] to the current this.props.graph.range
   *
   * Used for sizing various transformation tools
   * (rotation handle, dilation circle)
   */
  scaleToCurrentRange: function scaleToCurrentRange(dist) {
    return scaleToRange$1(dist, this.refs.graph.props.range);
  },
  addRotationTool: function addRotationTool() {
    var options = this.props.tools.rotation;

    if (!options.enabled) {
      return;
    }

    var self = this;
    var graphie = this.refs.graph.graphie();
    var pointColor = colorForTool(options); // The center of our rotation, which can be moved to change the
    // center of rotation

    this.rotatePoint = graphie.addMovablePoint({
      constraints: options.constraints,
      coord: options.coord,
      snapX: graphie.snap[0],
      snapY: graphie.snap[1],
      normalStyle: {
        // ugh, this seems to be a global and
        "stroke-dasharray": "",
        // is set to dash above
        stroke: pointColor,
        fill: pointColor
      },
      highlightStyle: {
        "stroke-dasharray": "",
        stroke: KhanColors$8.INTERACTING,
        fill: KhanColors$8.INTERACTING
      }
    }); // The point that we move around the center of rotation to actually
    // cause rotations

    this.rotateHandle = graphie.addRotateHandle({
      center: this.rotatePoint,
      radius: this.scaleToCurrentRange(ROTATE_HANDLE_DIST),
      width: this.scaleToCurrentRange(0.24),
      hoverWidth: this.scaleToCurrentRange(0.4),
      onMove: function onMove(newAngle, oldAngle) {
        var transform = self.getRotationTransformFromAngle(self.rotatePoint.coord, newAngle - oldAngle); // Rotate polygon with rotateHandle

        self.doTransform(transform);
        return oldAngle + transform.angleDeg;
      }
    }); // Update tools.rotation.coord

    this.rotatePoint.onMoveEnd = function (x, y) {
      self.changeTool("rotation", {
        coord: [x, y]
      });
    };

    return {
      remove: function remove() {
        self.rotateHandle.remove();
        self.rotatePoint.remove();
      }
    };
  },
  addDilationTool: function addDilationTool() {
    var options = this.props.tools.dilation;

    if (!options.enabled) {
      return;
    }

    var self = this;
    var graphie = this.refs.graph.graphie();
    var pointColor = colorForTool(options); // the circle for causing dilation transforms

    self.dilationCircle = graphie.addCircleGraph({
      centerConstraints: options.constraints,
      center: options.coord,
      radius: self.scaleToCurrentRange(2),
      snapX: graphie.snap[0],
      snapY: graphie.snap[1],
      minRadius: self.scaleToCurrentRange(1),
      snapRadius: self.scaleToCurrentRange(0.5),
      onResize: function onResize(newRadius, oldRadius) {
        self.doTransform({
          type: "dilation",
          center: self.dilationCircle.centerPoint.coord,
          scale: newRadius / oldRadius
        });
      },
      circleNormalStyle: {
        stroke: pointColor,
        "stroke-width": 2,
        "stroke-dasharray": "- ",
        "fill-opacity": 0
      },
      circleHighlightStyle: {
        stroke: KhanColors$8.INTERACTING,
        "stroke-width": 2,
        "stroke-dasharray": "",
        fill: KhanColors$8.INTERACTING,
        "fill-opacity": 0.05
      },
      centerNormalStyle: {
        stroke: pointColor,
        fill: pointColor,
        "stroke-width": 2,
        "stroke-dasharray": ""
      },
      centerHighlightStyle: {
        stroke: pointColor,
        fill: pointColor,
        "stroke-width": 2,
        "stroke-dasharray": ""
      }
    });
    var origOnMoveEnd = this.dilationCircle.centerPoint.onMoveEnd;

    this.dilationCircle.centerPoint.onMoveEnd = function () {
      if (origOnMoveEnd) {
        origOnMoveEnd.apply(this, _$15.toArray(arguments));
      }

      self.changeTool("dilation", {
        coord: self.dilationCircle.centerPoint.coord
      });
    };

    return {
      remove: function remove() {
        self.dilationCircle.remove();
      }
    };
  },
  // returns a transformation object representing a rotation
  // rounds the angle to the nearest 15 degrees
  getRotationTransformFromAngle: function getRotationTransformFromAngle(center, angleChanged) {
    angleChanged = (angleChanged + 360) % 360;

    if (angleChanged > 180) {
      angleChanged -= 360;
    }

    var roundedAngle = Math.round(angleChanged / ROTATE_SNAP_DEGREES) * ROTATE_SNAP_DEGREES;
    return {
      type: "rotation",
      center: center,
      angleDeg: roundedAngle
    };
  },
  // apply and save a transform
  doTransform: function doTransform(transform, callback) {
    this.applyTransform(transform);
    this.addTransform(transform, callback);
  },
  // apply a transform to our polygon (without modifying our transformation
  // list)
  applyTransform: function applyTransform(transform) {
    if (this.props.graphMode !== "static") {
      var transformFunc = TransformOps.apply(transform);
      this.applyCoordTransformation(transformFunc);
    }
  },
  // transform our polygon by transforming each point using a given function
  applyCoordTransformation: function applyCoordTransformation(pointTransform) {
    _$15.each(this.shape.points, function (point) {
      var newCoord = pointTransform(point.coord);
      point.setCoord(newCoord);
    });

    this.shape.update();
  },
  resetCoords: function resetCoords() {
    var startCoords = this.props.starting.shape.coords;

    _$15.each(this.shape.points, function (point, i) {
      point.setCoord(startCoords[i]);
    });

    this.shape.update();
  },
  // Remove the last transformation
  handleUndoClick: function handleUndoClick() {
    this.refs.toolsBar.changeSelected(null);

    if (this.props.transformations.length) {
      this.props.onChange({
        transformations: _$15.initial(this.props.transformations)
      });
    }
  },
  setTransformationProps: function setTransformationProps(newTransfomationList, callback) {
    this.props.onChange({
      transformations: newTransfomationList
    }, callback);
  },
  // add a transformation to our props list of transformation
  addTransform: function addTransform(transform, callback) {
    this.transformations = TransformOps.append(this.transformations, transform);
    this.props.onChange({
      transformations: _$15.clone(this.transformations)
    }, callback);
  },
  changeTool: function changeTool(tool, changes) {
    var newTools = _$15.clone(this.props.tools);

    newTools[tool] = _$15.extend({}, this.props.tools[tool], changes);
    this.tools[tool] = _$15.clone(newTools[tool]);
    this.props.onChange({
      tools: newTools
    });
    this.props.trackInteraction();
  },
  simpleValidate: function simpleValidate(rubric) {
    return Transformer$1.validate(this.getUserInput(), rubric);
  },

  /**
   * Calculate where the coordinates would be if they were
   * moved, even if we're in formal mode with no movement
   * (and thus the actual movablepoints may not have moved
   */
  getCoords: function getCoords() {
    var startCoords = this.props.starting.shape.coords;
    var transforms = this.props.transformations;
    return _$15.reduce(transforms, function (coords, transform) {
      return _$15.map(coords, TransformOps.apply(transform));
    }, startCoords);
  },
  getEditorJSON: function getEditorJSON() {
    var json = _$15.pick(this.props, "grading", "starting", "graphMode", "listMode", "tools", "drawSolutionShape", "gradeEmpty");

    json.graph = this.refs.graph.toJSON();
    json.version = 1.2; // Give us some safety to change the format
    // when we realize that I wrote
    // a horrible json spec for this widget

    json.answer = this.getUserInput();
    return json;
  },
  getUserInput: function getUserInput() {
    return {
      transformations: this.props.transformations,
      // This doesn't call this.shape.toJSON() because that doesn't
      // handle coordinates in formal mode without movement, since
      // the movablepoints never move
      shape: {
        type: this.shape.type,
        coords: this.getCoords(),
        options: this.shape.getOptions()
      }
    };
  },

  /* InputPath API */
  _handleFocus: function _handleFocus() {
    var path = Array.prototype.slice.call(arguments);
    this.props.onFocus(path);
  },
  _handleBlur: function _handleBlur() {
    var path = Array.prototype.slice.call(arguments);
    this.props.onBlur(path);
  },
  _getTransformationForID: function _getTransformationForID(transformationID) {
    // Returns the 'transformation' component corresponding to a given ID
    var refPath = ["transformationList", "transformation" + transformationID]; // Follow the path of references

    var component = this;

    _$15.each(refPath, ref => {
      component = component.refs[ref];
    });

    return component;
  },
  getInputPaths: function getInputPaths() {
    // If we're in static mode, then there is no transformation list, and,
    // as a result, no input paths.
    if (this.props.listMode === "static") {
      return [];
    }

    var inputPaths = [];

    _$15.each(this.props.transformations, (transformation, i) => {
      var transformation = this._getTransformationForID(i);

      var innerPaths = transformation.getInputPaths();

      var fullPaths = _$15.map(innerPaths, innerPath => {
        return ["" + i].concat(innerPath);
      });

      inputPaths = inputPaths.concat(fullPaths);
    });

    return inputPaths;
  },
  _passToInner: function _passToInner(functionName, path) {
    if (!path || !path.length) {
      return;
    } // First argument tells us which transformation will receive the call;
    // remaining arguments are used within that transformation to identify
    // a specific input.


    var innerPath = _$15.rest(path);

    var args = [innerPath].concat(_$15.rest(arguments, 2)); // Pass arguments down to appropriate 'transformation' component

    var transformationID = _$15.head(path);

    var caller = this._getTransformationForID(transformationID);

    return caller[functionName].apply(caller, args);
  },
  focus: function focus() {
    // Just focus the first showing input
    var inputs = this.getInputPaths();

    if (inputs.length > 0) {
      this.focusInputPath(inputs[0]);
      return true;
    }

    return false;
  },
  focusInputPath: function focusInputPath(path) {
    // Since the transformer exposes the input API, it needs to be robust
    // to empty paths. We don't expect this to happen, as entire-widget
    // focusing is typically done through the focus() method, which already
    // handles the empty path case properly, but it's better to be safe
    // here.
    if (path.length === 0) {
      return false;
    }

    assert$4(path.length >= 2);
    return this._passToInner("focusInputPath", path);
  },
  blurInputPath: function blurInputPath(path) {
    // Since the transformer exposes the input API, it needs to be robust
    // to empty paths (which indicate a blurring of the entire widget,
    // e.g., when switching from interacting with the transformer to
    // interacting with some other widget).
    if (path.length === 0) {
      return false;
    }

    assert$4(path.length >= 2);
    return this._passToInner("blurInputPath", path);
  },
  setInputValue: function setInputValue(path, value, cb) {
    assert$4(path.length >= 2);
    return this._passToInner("setInputValue", path, value, cb);
  },
  getDOMNodeForPath: function getDOMNodeForPath(path) {
    assert$4(path.length >= 2);
    return this._passToInner("getDOMNodeForPath", path);
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(path) {
    assert$4(path.length >= 2);
    return this._passToInner("getGrammarTypeForPath", path);
  }
});

_$15.extend(Transformer$1, {
  validate: function validate(guess, rubric) {
    // Check for any required transformations
    for (var type in Transformations) {
      if (rubric.tools[type].required) {
        var isUsed = _$15.any(_$15.map(guess.transformations, function (transform) {
          // Required transformations must appear in the
          // transformation list, and must not be no-ops
          return transform.type === type && !TransformOps.isEmpty(transform) && !TransformOps.isNoOp(transform);
        }));

        if (!isUsed) {
          return {
            type: "invalid",
            message: i18n._("Your transformation must use a " + "%(type)s.", {
              type: Transformations[type].lowerNounName
            })
          };
        }
      }
    } // Compare shapes


    if (ShapeTypes$1.equal(guess.shape, rubric.correct.shape)) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    } else if (!rubric.gradeEmpty && deepEq$3(guess.shape.coords, rubric.starting.shape.coords)) {
      return {
        type: "invalid",
        message: i18n._("Use the interactive graph to define a " + "correct transformation.")
      };
    } else {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
  }
});

_module_$1F.exports = {
  name: "transformer",
  displayName: "Transformer",
  widget: Transformer$1
};
var _widgetsTransformerJsx = _module_$1F.exports;

var _module_$1E = {
  exports: {}
};
/* eslint-disable react/prop-types, react/sort-comp */

var React$1D = _react__default["default"];
var _$14 = _underscore__default["default"];
/* A checkbox that syncs its value to props using the
 * renderer's onChange method, and gets the prop name
 * dynamically from its props list
 */

var PropCheckBox$f = createReactClass({
  displayName: "PropCheckBox",
  propTypes: {
    labelAlignment: PropTypes.oneOf(["left", "right"])
  },
  DEFAULT_PROPS: {
    label: null,
    onChange: null,
    labelAlignment: "left"
  },
  getDefaultProps: function getDefaultProps() {
    return this.DEFAULT_PROPS;
  },
  propName: function propName() {
    var propName = _$14.find(_$14.keys(this.props), function (localPropName) {
      return !_$14.has(this.DEFAULT_PROPS, localPropName);
    }, this);

    if (!propName) {
      throw new Error("Attempted to create a PropCheckBox with no prop!");
    }

    return propName;
  },
  _labelAlignLeft: function _labelAlignLeft() {
    return this.props.labelAlignment === "left";
  },
  render: function render() {
    var propName = this.propName();
    return /*#__PURE__*/React$1D.createElement("label", null, this._labelAlignLeft() && this.props.label, /*#__PURE__*/React$1D.createElement("input", {
      type: "checkbox",
      checked: this.props[propName],
      onChange: this.toggle
    }), !this._labelAlignLeft() && this.props.label);
  },
  toggle: function toggle() {
    var propName = this.propName();
    var changes = {};
    changes[propName] = !this.props[propName];
    this.props.onChange(changes);
  }
});
_module_$1E.exports = PropCheckBox$f;
var _componentsPropCheckBoxJsx = _module_$1E.exports;

var _module_$1D = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types, react/sort-comp */

var React$1C = _react__default["default"];
var NumberInput$g = _componentsNumberInputJsx;

var truth = () => true;
/* A minor abstraction on top of NumberInput for ranges
 *
 */


var RangeInput$6 = createReactClass({
  displayName: "RangeInput",
  propTypes: {
    value: PropTypes.array.isRequired,
    onChange: PropTypes.func.isRequired,
    placeholder: PropTypes.array,
    checkValidity: PropTypes.func
  },
  getDefaultProps: function getDefaultProps() {
    return {
      placeholder: [null, null]
    };
  },
  render: function render() {
    var value = this.props.value;

    var _checkValidity = this.props.checkValidity || truth;

    return /*#__PURE__*/React$1C.createElement("div", {
      className: "range-input"
    }, /*#__PURE__*/React$1C.createElement(NumberInput$g, _extends({}, this.props, {
      value: value[0],
      checkValidity: val => _checkValidity([val, value[1]]),
      onChange: this.onChange.bind(this, 0),
      placeholder: this.props.placeholder[0]
    })), /*#__PURE__*/React$1C.createElement(NumberInput$g, _extends({}, this.props, {
      value: value[1],
      checkValidity: val => _checkValidity([value[0], val]),
      onChange: this.onChange.bind(this, 1),
      placeholder: this.props.placeholder[1]
    })));
  },
  onChange: function onChange(i, newVal) {
    var value = this.props.value;

    if (i === 0) {
      this.props.onChange([newVal, value[1]]);
    } else {
      this.props.onChange([value[0], newVal]);
    }
  }
});
_module_$1D.exports = RangeInput$6;
var _componentsRangeInputJsx = _module_$1D.exports;

var module$6 = {
  exports: {}
};
var button = aphrodite.StyleSheet.create({
  buttonStyle: {
    backgroundColor: 'white',
    border: '1px solid #ccc',
    borderLeft: '0',
    cursor: 'pointer',
    margin: '0',
    padding: '5px 10px',
    position: 'relative',
    // for hover
    ':first-child': {
      borderLeft: '1px solid #ccc',
      borderTopLeftRadius: '3px',
      borderBottomLeftRadius: '3px'
    },
    ':last-child': {
      borderRight: '1px solid #ccc',
      borderTopRightRadius: '3px',
      borderBottomRightRadius: '3px'
    },
    ':hover': {
      backgroundColor: '#ccc'
    },
    ':focus': {
      zIndex: '2'
    }
  },
  selectedStyle: {
    backgroundColor: '#ddd'
  }
});
module$6.exports = {
  button: button
};
var _stylesJs = module$6.exports;

var module$5 = {
  exports: {}
};
/* ButtonGroup is an aesthetically pleasing group of buttons.
 *
 * The class requires these properties:
 *   buttons - an array of objects with keys:
 *     "value": this is the value returned when the button is selected
 *     "content": this is the JSX shown within the button, typically a string
 *         that gets rendered as the button's display text
 *     "title": this is the title-text shown on hover
 *   onChange - a function that is provided with the updated value
 *     (which it then is responsible for updating)
 *
 * The class has these optional properties:
 *   value - the initial value of the button selected, defaults to null.
 *   allowEmpty - if false, exactly one button _must_ be selected; otherwise
 *     it defaults to true and _at most_ one button (0 or 1) may be selected.
 *
 * Requires stylesheets/perseus-admin-package/editor.less to look nice.
 */

var React$1B = _react__default["default"];
var ReactDOM$m = _reactDom__default["default"];
var createReactClass$5 = _createReactClass__default["default"];
var PropTypes$5 = _propTypes__default["default"];
var styles$k = _stylesJs;
var ButtonGroup$8 = createReactClass$5({
  displayName: "ButtonGroup",
  propTypes: {
    value: PropTypes$5.any,
    buttons: PropTypes$5.arrayOf(PropTypes$5.shape({
      value: PropTypes$5.any.isRequired,
      content: PropTypes$5.node,
      title: PropTypes$5.string
    })).isRequired,
    onChange: PropTypes$5.func.isRequired,
    allowEmpty: PropTypes$5.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      value: null,
      allowEmpty: true
    };
  },
  focus: function focus() {
    ReactDOM$m.findDOMNode(this).focus();
    return true;
  },
  toggleSelect: function toggleSelect(newValue) {
    var value = this.props.value;

    if (this.props.allowEmpty) {
      // Select the new button or unselect if it's already selected
      this.props.onChange(value !== newValue ? newValue : null);
    } else {
      this.props.onChange(newValue);
    }
  },
  render: function render() {
    var value = this.props.value;
    var buttons = this.props.buttons.map((button, i) => {
      return /*#__PURE__*/React$1B.createElement("button", {
        title: button.title,
        type: "button",
        id: "" + i,
        ref: "button" + i,
        key: "" + i,
        className: aphrodite.css(styles$k.button.buttonStyle, button.value === value && styles$k.button.selectedStyle),
        onClick: this.toggleSelect.bind(this, button.value)
      }, button.content || "" + button.value);
    });
    var outerStyle = {
      display: 'inline-block'
    };
    return /*#__PURE__*/React$1B.createElement("div", {
      style: outerStyle
    }, buttons);
  }
});
module$5.exports = ButtonGroup$8;
var _reactComponentsButtonGroupJsx = module$5.exports;

var _module_$1C = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types */

var React$1A = _react__default["default"];
var ReactDOM$l = _reactDom__default["default"];
var _$13 = _underscore__default["default"];
var Changeable$F = Changeable$Q;
var ButtonGroup$7 = _reactComponentsButtonGroupJsx;
var InfoTip$m = _componentsInfoTipJsx;
var PropCheckBox$e = _componentsPropCheckBoxJsx;
var RangeInput$5 = _componentsRangeInputJsx;
var TeX$4 = _reactComponentsTexJsx;
var Util$f = Util$q;
var KhanMath$4 = _utilMathJs;
var defaultBackgroundImage$5 = {
  url: null,
  width: 0,
  height: 0
};

function numSteps$1(range, step) {
  return Math.floor((range[1] - range[0]) / step);
}

var GraphSettings$4 = createReactClass({
  displayName: "GraphSettings",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$F.propTypes), {}, {
    editableSettings: PropTypes.arrayOf(PropTypes.oneOf(["canvas", "graph", "snap", "image", "measure"])),
    box: PropTypes.arrayOf(PropTypes.number),
    labels: PropTypes.arrayOf(PropTypes.string),
    range: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),
    step: PropTypes.arrayOf(PropTypes.number),
    gridStep: PropTypes.arrayOf(PropTypes.number),
    snapStep: PropTypes.arrayOf(PropTypes.number),
    valid: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
    backgroundImage: PropTypes.object,
    markings: PropTypes.oneOf(["graph", "grid", "none"]),
    showProtractor: PropTypes.bool,
    showRuler: PropTypes.bool,
    showTooltips: PropTypes.bool,
    rulerLabel: PropTypes.string,
    rulerTicks: PropTypes.number
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      editableSettings: ["graph", "snap", "image", "measure"],
      box: [interactiveSizes.defaultBoxSizeSmall, interactiveSizes.defaultBoxSizeSmall],
      labels: ["x", "y"],
      range: [[-10, 10], [-10, 10]],
      step: [1, 1],
      gridStep: [1, 1],
      snapStep: [1, 1],
      valid: true,
      backgroundImage: defaultBackgroundImage$5,
      markings: "graph",
      showProtractor: false,
      showRuler: false,
      showTooltips: false,
      rulerLabel: "",
      rulerTicks: 10
    };
  },
  getInitialState: function getInitialState() {
    return this.stateFromProps(this.props);
  },
  componentDidMount: function componentDidMount() {
    this.changeGraph = _$13.debounce(this.changeGraph, 300);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    // Make sure that state updates when switching
    // between different items in a multi-item editor.
    if (!_$13.isEqual(this.props.labels, nextProps.labels) || !_$13.isEqual(this.props.gridStep, nextProps.gridStep) || !_$13.isEqual(this.props.snapStep, nextProps.snapStep) || !_$13.isEqual(this.props.step, nextProps.step) || !_$13.isEqual(this.props.range, nextProps.range) || !_$13.isEqual(this.props.backgroundImage, nextProps.backgroundImage)) {
      this.setState(this.stateFromProps(nextProps));
    }
  },
  stateFromProps: function stateFromProps(props) {
    return {
      labelsTextbox: props.labels,
      gridStepTextbox: props.gridStep,
      snapStepTextbox: props.snapStep,
      stepTextbox: props.step,
      rangeTextbox: props.range,
      backgroundImage: _$13.clone(props.backgroundImage)
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$F.change.apply(this, args);
  },

  // TODO(aria): Make either a wrapper for standard events to work
  // with this.change, or make these use some TextInput/NumberInput box
  changeRulerLabel: function changeRulerLabel(e) {
    this.change({
      rulerLabel: e.target.value
    });
  },
  changeRulerTicks: function changeRulerTicks(e) {
    this.change({
      rulerTicks: +e.target.value
    });
  },
  changeBackgroundUrl: function changeBackgroundUrl(e) {
    // Only continue on blur or "enter"
    if (e.type === "keypress" && e.key !== "Enter") {
      return;
    }

    var setUrl = (url, width, height) => {
      var image = _$13.clone(this.props.backgroundImage);

      image.url = url;
      image.width = width;
      image.height = height;
      this.setState({
        backgroundImage: image
      }, this.changeGraph);
    };

    var url = ReactDOM$l.findDOMNode(this.refs["bg-url"]).value;

    if (url) {
      Util$f.getImageSize(url, (width, height) => {
        if (this.isMounted()) {
          setUrl(url, width, height);
        }
      });
    } else {
      setUrl(null, 0, 0);
    }
  },
  renderLabelChoices: function renderLabelChoices(choices) {
    return _$13.map(choices, function (nameAndValue) {
      return /*#__PURE__*/React$1A.createElement("option", {
        value: nameAndValue[1]
      }, nameAndValue[0]);
    });
  },
  validRange: function validRange(range) {
    var numbers = _$13.every(range, function (num) {
      return _$13.isFinite(num);
    });

    if (!numbers) {
      return "Range must be a valid number";
    }

    if (range[0] >= range[1]) {
      return "Range must have a higher number on the right";
    }

    return true;
  },
  validateStepValue: function validateStepValue(settings) {
    var {
      step,
      range,
      name,
      minTicks,
      maxTicks
    } = settings;

    if (!_$13.isFinite(step)) {
      return name + " must be a valid number";
    }

    var nSteps = numSteps$1(range, step);

    if (nSteps < minTicks) {
      return name + " is too large, there must be at least " + minTicks + " ticks.";
    }

    if (nSteps > maxTicks) {
      return name + " is too small, there can be at most " + maxTicks + " ticks.";
    }

    return true;
  },
  validSnapStep: function validSnapStep(step, range) {
    return this.validateStepValue({
      step: step,
      range: range,
      name: "Snap step",
      minTicks: 5,
      maxTicks: 60
    });
  },
  validGridStep: function validGridStep(step, range) {
    return this.validateStepValue({
      step: step,
      range: range,
      name: "Grid step",
      minTicks: 3,
      maxTicks: 60
    });
  },
  validStep: function validStep(step, range) {
    return this.validateStepValue({
      step: step,
      range: range,
      name: "Step",
      minTicks: 3,
      maxTicks: 20
    });
  },
  validBackgroundImageSize: function validBackgroundImageSize(image) {
    // Ignore empty images
    if (!image.url) {
      return true;
    }

    var validSize = image.width <= 450 && image.height <= 450;

    if (!validSize) {
      return "Image must be smaller than 450px x 450px.";
    }

    return true;
  },
  validateGraphSettings: function validateGraphSettings(range, step, gridStep, snapStep, image) {
    var self = this;
    var msg;

    var goodRange = _$13.every(range, function (range) {
      msg = self.validRange(range);
      return msg === true;
    });

    if (!goodRange) {
      return msg;
    }

    var goodStep = _$13.every(step, function (step, i) {
      msg = self.validStep(step, range[i]);
      return msg === true;
    });

    if (!goodStep) {
      return msg;
    }

    var goodGridStep = _$13.every(gridStep, function (gridStep, i) {
      msg = self.validGridStep(gridStep, range[i]);
      return msg === true;
    });

    if (!goodGridStep) {
      return msg;
    }

    var goodSnapStep = _$13.every(snapStep, function (snapStep, i) {
      msg = self.validSnapStep(snapStep, range[i]);
      return msg === true;
    });

    if (!goodSnapStep) {
      return msg;
    }

    var goodImageSize = this.validBackgroundImageSize(image);

    if (goodImageSize !== true) {
      msg = goodImageSize;
      return msg;
    }

    return true;
  },
  changeLabel: function changeLabel(i, e) {
    var val = e.target.value;
    var labels = this.state.labelsTextbox.slice();
    labels[i] = val;
    this.setState({
      labelsTextbox: labels
    }, this.changeGraph);
  },
  changeRange: function changeRange(i, values) {
    var ranges = this.state.rangeTextbox.slice();
    ranges[i] = values;
    var step = this.state.stepTextbox.slice();
    var gridStep = this.state.gridStepTextbox.slice();
    var snapStep = this.state.snapStepTextbox.slice();
    var scale = Util$f.scaleFromExtent(ranges[i], this.props.box[i]);

    if (this.validRange(ranges[i]) === true) {
      step[i] = Util$f.tickStepFromExtent(ranges[i], this.props.box[i]);
      gridStep[i] = Util$f.gridStepFromTickStep(step[i], scale);
      snapStep[i] = gridStep[i] / 2;
    }

    this.setState({
      stepTextbox: step,
      gridStepTextbox: gridStep,
      snapStepTextbox: snapStep,
      rangeTextbox: ranges
    }, this.changeGraph);
  },
  changeStep: function changeStep(step) {
    this.setState({
      stepTextbox: step
    }, this.changeGraph);
  },
  changeSnapStep: function changeSnapStep(snapStep) {
    this.setState({
      snapStepTextbox: snapStep
    }, this.changeGraph);
  },
  changeGridStep: function changeGridStep(gridStep) {
    this.setState({
      gridStepTextbox: gridStep,
      snapStepTextbox: _$13.map(gridStep, function (step) {
        return step / 2;
      })
    }, this.changeGraph);
  },
  changeGraph: function changeGraph() {
    var labels = this.state.labelsTextbox;

    var range = _$13.map(this.state.rangeTextbox, function (range) {
      return _$13.map(range, Number);
    });

    var step = _$13.map(this.state.stepTextbox, Number);

    var gridStep = this.state.gridStepTextbox;
    var snapStep = this.state.snapStepTextbox;
    var image = this.state.backgroundImage; // validationResult is either:
    //   true -> the settings are valid
    //   a string -> the settings are invalid, and the explanation
    //               is contained in the string
    // TODO(aria): Refactor this to not be confusing

    var validationResult = this.validateGraphSettings(range, step, gridStep, snapStep, image);

    if (validationResult === true) {
      // either true or a string
      this.change({
        valid: true,
        labels: labels,
        range: range,
        step: step,
        gridStep: gridStep,
        snapStep: snapStep,
        backgroundImage: image
      });
    } else {
      this.change({
        valid: validationResult // a string message, not false

      });
    }
  },
  render: function render() {
    var scale = [KhanMath$4.roundTo(2, Util$f.scaleFromExtent(this.props.range[0], this.props.box[0])), KhanMath$4.roundTo(2, Util$f.scaleFromExtent(this.props.range[1], this.props.box[1]))];
    return /*#__PURE__*/React$1A.createElement("div", null, _$13.contains(this.props.editableSettings, "canvas") && /*#__PURE__*/React$1A.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, "Canvas size (x,y pixels)", /*#__PURE__*/React$1A.createElement(RangeInput$5, {
      value: this.props.box,
      onChange: box => {
        this.change({
          box: box
        });
      }
    })), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, "Scale (px per div):", " ", /*#__PURE__*/React$1A.createElement(TeX$4, null, "(" + scale[0] + ", " + scale[1] + ")"))), _$13.contains(this.props.editableSettings, "graph") && /*#__PURE__*/React$1A.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-left-col"
    }, " ", "x Label", /*#__PURE__*/React$1A.createElement("input", {
      type: "text",
      className: "graph-settings-axis-label",
      ref: "labels-0",
      onChange: e => this.changeLabel(0, e),
      value: this.state.labelsTextbox[0]
    })), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-right-col"
    }, "y Label", /*#__PURE__*/React$1A.createElement("input", {
      type: "text",
      className: "graph-settings-axis-label",
      ref: "labels-1",
      onChange: e => this.changeLabel(1, e),
      value: this.state.labelsTextbox[1]
    }))), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-left-col"
    }, "x Range", /*#__PURE__*/React$1A.createElement(RangeInput$5, {
      value: this.state.rangeTextbox[0],
      onChange: vals => this.changeRange(0, vals)
    })), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-right-col"
    }, "y Range", /*#__PURE__*/React$1A.createElement(RangeInput$5, {
      value: this.state.rangeTextbox[1],
      onChange: vals => this.changeRange(1, vals)
    }))), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-left-col"
    }, "Tick Step", /*#__PURE__*/React$1A.createElement(RangeInput$5, {
      value: this.state.stepTextbox,
      onChange: this.changeStep
    })), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-right-col"
    }, "Grid Step", /*#__PURE__*/React$1A.createElement(RangeInput$5, {
      value: this.state.gridStepTextbox,
      onChange: this.changeGridStep
    }))), _$13.contains(this.props.editableSettings, "snap") && /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-left-col"
    }, "Snap Step", /*#__PURE__*/React$1A.createElement(RangeInput$5, {
      value: this.state.snapStepTextbox,
      onChange: this.changeSnapStep
    }))), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1A.createElement("label", null, "Markings: "), /*#__PURE__*/React$1A.createElement(ButtonGroup$7, {
      value: this.props.markings,
      allowEmpty: false,
      buttons: [{
        value: "graph",
        content: "Graph"
      }, {
        value: "grid",
        content: "Grid"
      }, {
        value: "none",
        content: "None"
      }],
      onChange: this.change("markings")
    })), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-left-col"
    }, /*#__PURE__*/React$1A.createElement(PropCheckBox$e, {
      label: "Show tooltips",
      showTooltips: this.props.showTooltips,
      onChange: this.change
    }))), _$13.contains(this.props.editableSettings, "image") && /*#__PURE__*/React$1A.createElement("div", {
      className: "image-settings"
    }, /*#__PURE__*/React$1A.createElement("div", null, "Background image:"), /*#__PURE__*/React$1A.createElement("div", null, "Url:", " ", /*#__PURE__*/React$1A.createElement("input", {
      type: "text",
      className: "graph-settings-background-url",
      ref: "bg-url",
      value: this.state.backgroundImage.url,
      onChange: e => {
        var image = _$13.clone(this.props.backgroundImage);

        image.url = e.target.value;
        this.setState({
          backgroundImage: image
        });
      },
      onKeyPress: this.changeBackgroundUrl,
      onBlur: this.changeBackgroundUrl
    }), /*#__PURE__*/React$1A.createElement(InfoTip$m, null, /*#__PURE__*/React$1A.createElement("p", null, "Create an image in graphie, or use the \"Add image\" function to create a background.")))), _$13.contains(this.props.editableSettings, "measure") && /*#__PURE__*/React$1A.createElement("div", {
      className: "misc-settings"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-left-col"
    }, /*#__PURE__*/React$1A.createElement(PropCheckBox$e, {
      label: "Show ruler",
      showRuler: this.props.showRuler,
      onChange: this.change
    })), /*#__PURE__*/React$1A.createElement("div", {
      className: "perseus-widget-right-col"
    }, /*#__PURE__*/React$1A.createElement(PropCheckBox$e, {
      label: "Show protractor",
      showProtractor: this.props.showProtractor,
      onChange: this.change
    }))), this.props.showRuler && /*#__PURE__*/React$1A.createElement("div", null, /*#__PURE__*/React$1A.createElement("div", null, /*#__PURE__*/React$1A.createElement("label", null, " ", "Ruler label:", " ", /*#__PURE__*/React$1A.createElement("select", {
      onChange: this.changeRulerLabel,
      value: this.props.rulerLabel
    }, /*#__PURE__*/React$1A.createElement("option", {
      value: ""
    }, "None"), /*#__PURE__*/React$1A.createElement("optgroup", {
      label: "Metric"
    }, this.renderLabelChoices([["milimeters", "mm"], ["centimeters", "cm"], ["meters", "m"], ["kilometers", "km"]])), /*#__PURE__*/React$1A.createElement("optgroup", {
      label: "Imperial"
    }, this.renderLabelChoices([["inches", "in"], ["feet", "ft"], ["yards", "yd"], ["miles", "mi"]]))))), /*#__PURE__*/React$1A.createElement("div", null, /*#__PURE__*/React$1A.createElement("label", null, " ", "Ruler ticks:", " ", /*#__PURE__*/React$1A.createElement("select", {
      onChange: this.changeRulerTicks,
      value: this.props.rulerTicks
    }, _$13.map([1, 2, 4, 8, 10, 16], function (n) {
      return /*#__PURE__*/React$1A.createElement("option", {
        value: n
      }, n);
    })))))));
  }
});
_module_$1C.exports = GraphSettings$4;
var _componentsGraphSettingsJsx = _module_$1C.exports;

var _module_$1B = {
  exports: {}
};
/* eslint-disable brace-style, camelcase, comma-dangle, indent, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1z = _react__default["default"];
var _$12 = _underscore__default["default"];
var ApiOptions$p = _perseusApiJsx.Options;
var Graph$1 = _componentsGraphJsx;
var GraphSettings$3 = _componentsGraphSettingsJsx;
var InfoTip$l = _componentsInfoTipJsx;
var PropCheckBox$d = _componentsPropCheckBoxJsx;
var Transformer = _widgetsTransformerJsx.widget;
var deepEq$2 = Util$q.deepEq;
var getGridStep = Util$q.getGridStep;
var kline = _kmath3.line;
var knumber$6 = _kmath3.number;
var kpoint$3 = _kmath3.point;
var kray = _kmath3.ray;
var kvector$2 = _kmath3.vector;
var KhanColors$7 = _utilColorsJs;

function arraySum(array) {
  return _$12.reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}

var defaultBackgroundImage$4 = {
  url: null
};
/* Scales a distance from the default range of
 * [-10, 10] to a given props.range pair
 *
 * Used for sizing various transformation tools
 * (rotation handle, dilation circle)
 */

function scaleToRange(dist, range) {
  var spreadX = range[0][1] - range[0][0];
  var spreadY = range[1][1] - range[1][0];
  return dist * Math.max(spreadX, spreadY) / 20;
}

function orderInsensitiveCoordsEqual(coords1, coords2) {
  coords1 = _$12.clone(coords1).sort(kpoint$3.compare);
  coords2 = _$12.clone(coords2).sort(kpoint$3.compare);
  return _$12.all(_$12.map(coords1, function (coord1, i) {
    var coord2 = coords2[i];
    return kpoint$3.equal(coord1, coord2);
  }));
}

var defaultGraphProps = function defaultGraphProps(setProps, boxSize) {
  setProps = setProps || {};
  var labels = setProps.labels || ["x", "y"];
  var range = setProps.range || [[-10, 10], [-10, 10]];
  var step = setProps.step || [1, 1];
  var gridStep = setProps.gridStep || getGridStep(range, step, boxSize);
  return {
    box: [boxSize, boxSize],
    labels: labels,
    range: range,
    step: step,
    gridStep: gridStep,
    valid: true,
    backgroundImage: defaultBackgroundImage$4,
    markings: "grid",
    showProtractor: false
  };
};

var defaultTransformerProps = {
  apiOptions: ApiOptions$p.defaults,
  gradeEmpty: false,
  graphMode: "interactive",
  listMode: "dynamic",
  graph: {},
  tools: {
    translation: {
      enabled: true,
      required: false,
      constraints: {}
    },
    rotation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [1, 6]
    },
    reflection: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coords: [[2, -4], [2, 2]]
    },
    dilation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [6, 6]
    }
  },
  drawSolutionShape: true,
  starting: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  },
  correct: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  }
};
var ToolSettings = createReactClass({
  displayName: "ToolSettings",
  getDefaultProps: function getDefaultProps() {
    return {
      allowFixed: true
    };
  },
  render: function render() {
    return /*#__PURE__*/React$1z.createElement("div", null, this.props.name, ": ", " ", /*#__PURE__*/React$1z.createElement(PropCheckBox$d, {
      label: "enabled:",
      enabled: this.props.settings.enabled,
      onChange: this.props.onChange
    }), " ", this.props.settings.enabled && /*#__PURE__*/React$1z.createElement(PropCheckBox$d, {
      label: "required:",
      required: this.props.settings.required,
      onChange: this.props.onChange
    }), this.props.settings.enabled && /*#__PURE__*/React$1z.createElement(InfoTip$l, null, "'Required' will only grade the answer as correct if the student has used at least one such transformation."), " ", this.props.allowFixed && this.props.settings.enabled && /*#__PURE__*/React$1z.createElement(PropCheckBox$d, {
      label: "fixed:",
      fixed: this.props.settings.constraints.fixed,
      onChange: this.changeConstraints
    }), this.props.allowFixed && this.props.settings.enabled && /*#__PURE__*/React$1z.createElement(InfoTip$l, null, "Enable 'fixed' to prevent the student from repositioning the tool. The tool will appear in the position at which it is placed in the editor below."));
  },
  changeConstraints: function changeConstraints(changed) {
    var newConstraints = _$12.extend({}, this.props.constraints, changed);

    this.props.onChange({
      constraints: newConstraints
    });
  }
});
var TransformationExplorerSettings = createReactClass({
  displayName: "TransformationExplorerSettings",
  render: function render() {
    return /*#__PURE__*/React$1z.createElement("div", {
      className: "transformer-settings"
    }, /*#__PURE__*/React$1z.createElement("div", null, " ", "Mode:", " ", /*#__PURE__*/React$1z.createElement("select", {
      value: this.getMode(),
      onChange: this.changeMode
    }, /*#__PURE__*/React$1z.createElement("option", {
      value: "interactive,dynamic"
    }, " ", "Exploration with text", " "), /*#__PURE__*/React$1z.createElement("option", {
      value: "interactive,static"
    }, " ", "Exploration without text", " "), /*#__PURE__*/React$1z.createElement("option", {
      value: "dynamic,interactive"
    }, " ", "Formal with movement", " "), /*#__PURE__*/React$1z.createElement("option", {
      value: "static,interactive"
    }, " ", "Formal without movement", " ")), /*#__PURE__*/React$1z.createElement(InfoTip$l, null, /*#__PURE__*/React$1z.createElement("ul", null, /*#__PURE__*/React$1z.createElement("li", null, /*#__PURE__*/React$1z.createElement("b", null, "Exploration:"), " Students create transformations with tools on the graph.", " "), /*#__PURE__*/React$1z.createElement("li", null, /*#__PURE__*/React$1z.createElement("b", null, "Formal with movement:"), " Students specify transformations mathematically in the transformation list. Graph shows the results of these transformations.", " "), /*#__PURE__*/React$1z.createElement("li", null, /*#__PURE__*/React$1z.createElement("b", null, "Formal without movement:"), " Students specify transformations mathematically in the transformation list. Graph does not update.", " ")))), /*#__PURE__*/React$1z.createElement(ToolSettings, {
      name: "Translations",
      settings: this.props.tools.translation,
      allowFixed: false,
      onChange: this.changeHandlerFor("translation")
    }), /*#__PURE__*/React$1z.createElement(ToolSettings, {
      name: "Rotations",
      settings: this.props.tools.rotation,
      onChange: this.changeHandlerFor("rotation")
    }), /*#__PURE__*/React$1z.createElement(ToolSettings, {
      name: "Reflections",
      settings: this.props.tools.reflection,
      onChange: this.changeHandlerFor("reflection")
    }), /*#__PURE__*/React$1z.createElement(ToolSettings, {
      name: "Dilations",
      settings: this.props.tools.dilation,
      onChange: this.changeHandlerFor("dilation")
    }), /*#__PURE__*/React$1z.createElement(PropCheckBox$d, {
      label: "Draw Solution:",
      drawSolutionShape: this.props.drawSolutionShape,
      onChange: this.props.onChange
    }));
  },
  getMode: function getMode() {
    return this.props.graphMode + "," + this.props.listMode;
  },
  changeMode: function changeMode(e) {
    var selected = e.target.value;
    var modes = selected.split(",");
    this.props.onChange({
      graphMode: modes[0],
      listMode: modes[1]
    });
  },
  changeHandlerFor: function changeHandlerFor(toolName) {
    return change => {
      var newTools = _$12.clone(this.props.tools);

      newTools[toolName] = _$12.extend({}, this.props.tools[toolName], change);
      this.props.onChange({
        tools: newTools
      });
    };
  }
});
var ShapeTypes = {
  getPointCountForType: function getPointCountForType(type) {
    var splitType = type.split("-");

    if (splitType[0] === "polygon") {
      return splitType[1] || 3;
    } else if (splitType[0] === "line" || splitType[0] === "lineSegment") {
      return 2;
    } else if (splitType[0] === "angle") {
      return 3;
    } else if (splitType[0] === "circle") {
      return 2;
    } else if (splitType[0] === "point") {
      return 1;
    }
  },
  addMovableShape: function addMovableShape(graphie, options) {
    if (options.editable && options.translatable) {
      throw new Error("It doesn't make sense to have a movable shape " + "where you can stretch the points and translate them " + "simultaneously. options: " + JSON.stringify(options));
    }

    var shape;

    var points = _$12.map(options.shape.coords, function (coord) {
      var currentPoint;
      var isMoving = false;
      var previousCoord = coord;

      var onMove = function onMove(x, y) {
        if (!isMoving) {
          previousCoord = currentPoint.coord;
          isMoving = true;
        }

        var moveVector = kvector$2.subtract([x, y], currentPoint.coord); // Translate from (x, y) semantics to (dX, dY) semantics
        // This is more useful for translations on multiple points,
        // where we care about how the points moved, not where any
        // individual point ended up

        if (options.onMove) {
          moveVector = options.onMove(moveVector[0], moveVector[1]);
        } // Perform a translation on all points in this shape when
        // any point moves


        if (options.translatable) {
          _$12.each(points, function (point) {
            // The point itself will be updated by the
            // movablePoint class, so only translate the other
            // points
            if (point !== currentPoint) {
              point.setCoord(kvector$2.add(point.coord, moveVector));
            }
          });
        } // Update our shape and our currentPoint
        // Without this, some shapes (circles, angles) appear
        // "bouncy" as they are updated with currentPoint at the
        // current mouse coordinate (oldCoord), rather than newCoord


        var oldCoord = currentPoint.coord;
        var newCoord = kvector$2.add(currentPoint.coord, moveVector); // Temporarily change our coordinate so that
        // shape.update() sees the new coordinate

        currentPoint.coord = newCoord;
        shape.update(); // ...But don't break onMove, which assumes it
        // is the only thing changing our coord

        currentPoint.coord = oldCoord;
        return newCoord;
      };

      var onMoveEnd = function onMoveEnd() {
        // onMove isn't guaranteed to be called before onMoveEnd, so
        // we have to take into account that we may not have moved and
        // set previousCoord.
        if (options.onMoveEnd && isMoving) {
          isMoving = false; // We don't use the supplied x and y parameters here
          // because MovablePoint's onMoveEnd semantics suck.
          // It returns the mouseX, mouseY without processing them
          // through onMove, leaving us with weird fractional moves

          var change = kvector$2.subtract(currentPoint.coord, previousCoord);
          options.onMoveEnd(change[0], change[1]);
        }

        shape.update();
      };

      currentPoint = graphie.addMovablePoint({
        coord: coord,
        normalStyle: options.normalPointStyle,
        highlightStyle: options.highlightPointStyle,
        constraints: {
          fixed: !options.translatable && !options.editable
        },
        visible: options.showPoints,
        snapX: options.snap && options.snap[0] || 0,
        snapY: options.snap && options.snap[1] || 0,
        bounded: false,
        // Don't bound it when placing it on the graph
        onMove: onMove,
        onMoveEnd: onMoveEnd
      }); // Bound it when moving
      // We can't set this earlier, because doing so would mean any
      // points outside of the graph would be moved into a moved into
      // a position that doesn't preserve the shape

      currentPoint.bounded = true;
      return currentPoint;
    });

    shape = ShapeTypes.addShape(graphie, options, points);
    var removeShapeWithoutPoints = shape.remove;

    shape.remove = function () {
      removeShapeWithoutPoints.apply(shape);

      _$12.invoke(points, "remove");
    };

    return shape;
  },
  addShape: function addShape(graphie, options, points) {
    points = points || options.shape.coords;

    var types = ShapeTypes._typesOf(options.shape);

    var typeOptions = options.shape.options || ShapeTypes.defaultOptions(types);

    var shapes = ShapeTypes._mapTypes(types, points, function (type, points, i) {
      var shapeOptions = _$12.extend({}, options, typeOptions[i]);

      return ShapeTypes._addType(graphie, type, points, shapeOptions);
    });

    var updateFuncs = _$12.filter(_$12.pluck(shapes, "update"), _$12.identity);

    var update = function update() {
      _$12.invoke(updateFuncs, "call");
    };

    var removeFuncs = _$12.filter(_$12.pluck(shapes, "remove"), _$12.identity);

    var remove = function remove() {
      _$12.invoke(removeFuncs, "call");
    };

    var getOptions = function getOptions() {
      return _$12.map(shapes, function (shape) {
        if (shape.getOptions) {
          return shape.getOptions();
        } else {
          return {};
        }
      });
    };

    var toJSON = function toJSON() {
      var coords = _$12.map(points, function (pt) {
        if (_$12.isArray(pt)) {
          return pt;
        } else {
          return pt.coord;
        }
      });

      return {
        type: types,
        coords: coords,
        options: getOptions()
      };
    };

    return {
      type: types,
      points: points,
      update: update,
      remove: remove,
      toJSON: toJSON,
      getOptions: getOptions
    };
  },
  equal: function equal(shape1, shape2) {
    var types1 = ShapeTypes._typesOf(shape1);

    var types2 = ShapeTypes._typesOf(shape2);

    if (types1.length !== types2.length) {
      return false;
    }

    var shapes1 = ShapeTypes._mapTypes(types1, shape1.coords, ShapeTypes._combine);

    var shapes2 = ShapeTypes._mapTypes(types2, shape2.coords, ShapeTypes._combine);

    return _$12.all(_$12.map(shapes1, function (partialShape1, i) {
      var partialShape2 = shapes2[i];

      if (partialShape1.type !== partialShape2.type) {
        return false;
      }

      return ShapeTypes._forType(partialShape1.type).equal(partialShape1.coords, partialShape2.coords);
    }));
  },
  _typesOf: function _typesOf(shape) {
    var types = shape.type;

    if (!_$12.isArray(types)) {
      types = [types];
    }

    return _$12.map(types, function (type) {
      if (type === "polygon") {
        return "polygon-3";
      } else {
        return type;
      }
    });
  },
  defaultOptions: function defaultOptions(types) {
    return _$12.map(types, function (type) {
      var typeDefaultOptions = ShapeTypes._forType(type).defaultOptions;

      return _$12.extend({}, typeDefaultOptions);
    });
  },
  _forType: function _forType(type) {
    var baseType = type.split("-")[0];
    return ShapeTypes[baseType];
  },
  _mapTypes: function _mapTypes(types, points, func, context) {
    return _$12.map(types, function (type, i) {
      var pointCount = ShapeTypes.getPointCountForType(type);

      var currentPoints = _$12.first(points, pointCount);

      points = _$12.rest(points, pointCount);
      return func.call(context, type, currentPoints, i);
    });
  },
  _addType: function _addType(graphie, type, points, options) {
    var lineCoords = _$12.isArray(points[0]) ? {
      coordA: points[0],
      coordZ: points[1]
    } : {
      pointA: points[0],
      pointZ: points[1]
    };
    type = type.split("-")[0];

    if (type === "polygon") {
      var polygon = graphie.addMovablePolygon(_$12.extend({}, options, {
        fixed: !options.editable,
        snapX: options.snap && options.snap[0] || 0,
        snapY: options.snap && options.snap[1] || 0,
        points: points,
        constrainToGraph: false
      }));
      return {
        update: polygon.transform.bind(polygon),
        remove: polygon.remove.bind(polygon)
      };
    } else if (type === "line" || type === "lineSegment") {
      var line = graphie.addMovableLineSegment(_$12.extend({}, options, lineCoords, {
        movePointsWithLine: true,
        fixed: true,
        constraints: {
          fixed: true
        },
        extendLine: type === "line"
      })); // TODO(jack): Hide points on uneditable lines when translation
      // is a vector.
      // We can't just remove the points yet, because they are the
      // translation handle for the line.

      return {
        update: line.transform.bind(line, true),
        remove: line.remove.bind(line)
      };
    } else if (type === "angle") {
      // If this angle is editable, we want to be able to make angles
      // both larger and smaller than 180 degrees.
      // If this angle is not editable, it should always maintain
      // it's angle measure, even if it is reflected (causing the
      // clockwise-ness of the points to change)
      var shouldChangeReflexivity = options.editable ? null : false;
      var angle = graphie.addMovableAngle({
        angleLabel: "$deg0",
        fixed: true,
        points: points,
        normalStyle: options.normalStyle,
        reflex: options.reflex
      }); // Hide non-vertex points on uneditable angles

      if (!_$12.isArray(points[0]) && !options.editable) {
        points[0].remove();
        points[2].remove();
      }

      return {
        update: angle.update.bind(angle, shouldChangeReflexivity),
        remove: angle.remove.bind(angle),
        getOptions: function getOptions() {
          return {
            reflex: angle.isReflex()
          };
        }
      };
    } else if (type === "circle") {
      var perimeter = {
        // temporary object for the first removal
        remove: _$12.identity
      };

      var redrawPerim = function redrawPerim() {
        var coord0 = points[0].coord || points[0];
        var coord1 = points[1].coord || points[1];
        var radius = kpoint$3.distanceToPoint(coord0, coord1);
        perimeter.remove();
        perimeter = graphie.circle(coord0, radius, _$12.extend({
          stroke: KhanColors$7.DYNAMIC,
          "stroke-width": 2
        }, options.normalStyle));
      };

      redrawPerim();

      if (points[1].remove && !options.editable) {
        points[1].remove();
      }

      return {
        update: redrawPerim,
        remove: function remove() {
          // Not _.bind because the remove function changes
          // when the perimeter is redrawn
          perimeter.remove();
        }
      };
    } else if (type === "point") {
      // do nothing
      return {
        update: null,
        remove: null
      };
    } else {
      throw new Error("Invalid shape type " + type);
    }
  },
  _combine: function _combine(type, coords) {
    return {
      type: type,
      coords: coords
    };
  },
  polygon: {
    equal: orderInsensitiveCoordsEqual
  },
  line: {
    equal: kline.equal
  },
  lineSegment: {
    equal: orderInsensitiveCoordsEqual
  },
  angle: {
    equal: function equal(points1, points2) {
      if (!kpoint$3.equal(points1[1], points2[1])) {
        return false;
      }

      var line1_0 = [points1[1], points1[0]];
      var line1_2 = [points1[1], points1[2]];
      var line2_0 = [points2[1], points2[0]];
      var line2_2 = [points2[1], points2[2]];
      var equalUnflipped = kray.equal(line1_0, line2_0) && kray.equal(line1_2, line2_2);
      var equalFlipped = kray.equal(line1_0, line2_2) && kray.equal(line1_2, line2_0);
      return equalUnflipped || equalFlipped;
    },
    defaultOptions: {
      reflex: false
    }
  },
  circle: {
    equal: function equal(points1, points2) {
      var radius1 = kpoint$3.distanceToPoint(points1[0], points1[1]);
      var radius2 = kpoint$3.distanceToPoint(points2[0], points2[1]);
      return kpoint$3.equal(points1[0], points2[0]) && knumber$6.equal(radius1, radius2);
    }
  },
  point: {
    equal: kpoint$3.equal
  }
};
var TransformationsShapeEditor = createReactClass({
  displayName: "TransformationsShapeEditor",
  render: function render() {
    return /*#__PURE__*/React$1z.createElement("div", null, /*#__PURE__*/React$1z.createElement(Graph$1, {
      ref: "graph",
      box: this.props.graph.box,
      range: this.props.graph.range,
      labels: this.props.graph.labels,
      step: this.props.graph.step,
      gridStep: this.props.graph.gridStep,
      markings: this.props.graph.markings,
      backgroundImage: this.props.graph.backgroundImage,
      onGraphieUpdated: this.setupGraphie
    }), /*#__PURE__*/React$1z.createElement("select", {
      key: "type-select",
      value: this.getTypeString(this.props.shape.type),
      onChange: this.changeType
    }, /*#__PURE__*/React$1z.createElement("option", {
      value: "polygon-3"
    }, "Triangle"), /*#__PURE__*/React$1z.createElement("option", {
      value: "polygon-4"
    }, "Quadrilateral"), /*#__PURE__*/React$1z.createElement("option", {
      value: "polygon-5"
    }, "Pentagon"), /*#__PURE__*/React$1z.createElement("option", {
      value: "polygon-6"
    }, "Hexagon"), /*#__PURE__*/React$1z.createElement("option", {
      value: "line"
    }, "Line"), /*#__PURE__*/React$1z.createElement("option", {
      value: "line,line"
    }, "2 lines"), /*#__PURE__*/React$1z.createElement("option", {
      value: "lineSegment"
    }, "Line segment"), /*#__PURE__*/React$1z.createElement("option", {
      value: "lineSegment,lineSegment"
    }, " ", "2 line segments", " "), /*#__PURE__*/React$1z.createElement("option", {
      value: "angle"
    }, "Angle"), /*#__PURE__*/React$1z.createElement("option", {
      value: "circle"
    }, "Circle")));
  },

  /* Return the option string for a given type */
  getTypeString: function getTypeString(type) {
    if (_$12.isArray(type)) {
      return _$12.map(type, this.getTypeString).join(",");
    } else if (type === "polygon") {
      return "polygon-" + this.props.shape.coords.length;
    } else {
      return type;
    }
  },

  /* Change the type on the window event e
   *
   * e.target.value is the new type string
   */
  changeType: function changeType(e) {
    var types = String(e.target.value).split(",");
    var pointCount = arraySum(_$12.map(types, ShapeTypes.getPointCountForType));
    var radius = scaleToRange(4, this.refs.graph.props.range);
    var offset = (1 / 2 - 1 / pointCount) * 180;

    var coords = _$12.times(pointCount, function (i) {
      return kpoint$3.rotateDeg([radius, 0], 360 * i / pointCount + offset);
    });

    this.props.onChange({
      shape: {
        type: types,
        coords: coords,
        options: ShapeTypes.defaultOptions(types)
      }
    });
  },
  componentDidMount: function componentDidMount() {
    this.setupGraphie(this.refs.graph.graphie());
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    if (!deepEq$2(prevProps.shape, this.props.shape)) {
      this.refs.graph.reset();
    }
  },
  updateCoords: function updateCoords() {
    this.props.onChange({
      shape: this.shape.toJSON()
    });
  },
  setupGraphie: function setupGraphie(graphie) {
    this.shape = ShapeTypes.addMovableShape(graphie, {
      editable: true,
      snap: graphie.snap,
      shape: this.props.shape,
      onMoveEnd: this.updateCoords
    });
  }
});
var TransformerEditor = createReactClass({
  displayName: "TransformerEditor",
  // TODO (jack): These should be refactored into a nice object at the top
  // so that we don't have all this duplication
  getDefaultProps: function getDefaultProps() {
    return defaultTransformerProps;
  },
  render: function render() {
    // Fill in any missing value in this.props.graph
    // this can happen because the graph json doesn't include
    // box, for example
    var graph = _$12.extend(defaultGraphProps(this.props.graph, 340), this.props.graph);

    return /*#__PURE__*/React$1z.createElement("div", null, /*#__PURE__*/React$1z.createElement("div", null, /*#__PURE__*/React$1z.createElement(PropCheckBox$d, {
      label: "Grade empty answers as wrong:",
      gradeEmpty: this.props.gradeEmpty,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$1z.createElement(InfoTip$l, null, /*#__PURE__*/React$1z.createElement("p", null, "We generally do not grade empty answers. This usually works well, but sometimes can result in giving away part of an answer in a multi-part question."), /*#__PURE__*/React$1z.createElement("p", null, "If this is a multi-part question (there is another widget), you probably want to enable this option. Otherwise, you should leave it disabled."), /*#__PURE__*/React$1z.createElement("p", null, "Confused? Talk to Elizabeth."))), /*#__PURE__*/React$1z.createElement("div", null, "Graph settings:"), /*#__PURE__*/React$1z.createElement(GraphSettings$3, {
      box: graph.box,
      labels: graph.labels,
      range: graph.range,
      step: graph.step,
      gridStep: graph.gridStep,
      valid: graph.valid,
      backgroundImage: graph.backgroundImage,
      markings: graph.markings,
      showProtractor: graph.showProtractor,
      onChange: this.changeGraph
    }), /*#__PURE__*/React$1z.createElement("div", null, "Transformation settings:"), /*#__PURE__*/React$1z.createElement(TransformationExplorerSettings, {
      ref: "transformationSettings",
      graphMode: this.props.graphMode,
      listMode: this.props.listMode,
      tools: this.props.tools,
      drawSolutionShape: this.props.drawSolutionShape,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$1z.createElement("div", null, "Starting location:"), /*#__PURE__*/React$1z.createElement(TransformationsShapeEditor, {
      ref: "shapeEditor",
      graph: graph,
      shape: this.props.starting.shape,
      onChange: this.changeStarting,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }), /*#__PURE__*/React$1z.createElement("div", null, "Solution transformations:"), /*#__PURE__*/React$1z.createElement(Transformer, {
      ref: "explorer",
      graph: graph,
      graphMode: this.props.graphMode,
      listMode: this.props.listMode,
      gradeEmpty: this.props.gradeEmpty,
      tools: this.props.tools,
      drawSolutionShape: this.props.drawSolutionShape,
      starting: this.props.starting,
      correct: this.props.starting,
      transformations: this.props.correct.transformations,
      onChange: this.changeTransformer,
      trackInteraction: () => {}
    }));
  },
  // propagate a props change on our graph settings to
  // this.props.graph
  changeGraph: function changeGraph(graphChanges, callback) {
    var newGraph = _$12.extend({}, this.props.graph, graphChanges);

    this.props.onChange({
      graph: newGraph
    }, callback);
  },
  // propagate a props change on our starting graph to
  // this.props.starting
  changeStarting: function changeStarting(startingChanges) {
    var newStarting = _$12.extend({}, this.props.starting, startingChanges);

    this.props.onChange({
      starting: newStarting
    });
  },
  // propagate a transformations change onto correct.transformations
  changeTransformer: function changeTransformer(changes, callback) {
    if (changes.transformations) {
      changes.correct = _objectSpread2(_objectSpread2({}, this.props.correct), {}, {
        transformations: changes.transformations
      });
      delete changes.transformations;
    }

    this.props.onChange(changes, callback);
  },
  serialize: function serialize() {
    var json = this.refs.explorer.getEditorJSON();
    json.correct = json.answer;
    delete json.answer;
    return json;
  }
});
_module_$1B.exports = TransformerEditor;
var _widgetsTransformerEditorJsx = _module_$1B.exports;

var _module_$1A = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/prop-types, react/sort-comp, space-before-function-paren */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1y = _react__default["default"];
var ReactDOM$k = _reactDom__default["default"];
var _$11 = _underscore__default["default"];
var MathOutput$4 = _componentsMathOutputJsx;
var SimpleKeypadInput$4 = _componentsSimpleKeypadInputJsx;
var Renderer$h = _rendererJsx;
var Util$e = Util$q;
var {
  keypadElementPropType: keypadElementPropType$5
} = _mathInput__default["default"].propTypes;
var ApiOptions$o = _perseusApiJsx.Options;
var KhanAnswerTypes$4 = _utilAnswerTypesJs;
var assert$3 = InteractiveUtil$7.assert;
/* Input handling: Maps a (row, column) pair to a unique ref used by React,
 * and extracts (row, column) pairs from input paths, used to allow outsiders
 * to focus, blur, set input values, etc. */

var getInputPath$1 = function getInputPath(row, column) {
  return ["" + row, "" + column];
};

var getDefaultPath$1 = function getDefaultPath() {
  return getInputPath$1(0, 0);
};

var getRowFromPath$1 = function getRowFromPath(path) {
  // 'path' should be a (row, column) pair
  assert$3(_$11.isArray(path) && path.length === 2);
  return +path[0];
};

var getColumnFromPath$1 = function getColumnFromPath(path) {
  // 'path' should be a (row, column) pair
  assert$3(_$11.isArray(path) && path.length === 2);
  return +path[1];
};

var getRefForPath$1 = function getRefForPath(path) {
  var row = getRowFromPath$1(path);
  var column = getColumnFromPath$1(path);
  return "answer" + row + "," + column;
};

var Table$1 = createReactClass({
  displayName: "Table",
  propTypes: {
    answers: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),
    editableHeaders: PropTypes.bool,
    // The editor to use when editableHeaders is enabled
    Editor: PropTypes.func,
    headers: PropTypes.arrayOf(PropTypes.string),
    keypadElement: keypadElementPropType$5,
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    var defaultRows = 4;
    var defaultColumns = 1;

    var blankAnswers = _$11.times(defaultRows, function () {
      return Util$e.stringArrayOfSize(defaultColumns);
    });

    return {
      apiOptions: ApiOptions$o.defaults,
      headers: [""],
      editableHeaders: false,
      rows: defaultRows,
      columns: defaultColumns,
      answers: blankAnswers,
      linterContext: linterContextDefault
    };
  },
  _getRows: function _getRows() {
    return this.props.answers.length;
  },
  _getColumns: function _getColumns() {
    return this.props.answers[0].length;
  },
  render: function render() {
    var rows = this._getRows();

    var columns = this._getColumns();

    var headers = this.props.headers;
    var InputComponent;
    var inputStyle;

    if (this.props.apiOptions.customKeypad) {
      InputComponent = SimpleKeypadInput$4; // NOTE(charlie): This is intended to match the "width: 80px" in
      // input in table.less. Those values should be kept in-sync.

      inputStyle = {
        width: 80
      };
    } else if (this.props.apiOptions.staticRender) {
      InputComponent = MathOutput$4;
      inputStyle = {};
    } else {
      InputComponent = "input";
      inputStyle = {};
    }

    return /*#__PURE__*/React$1y.createElement("table", {
      className: "perseus-widget-table-of-values non-markdown"
    }, /*#__PURE__*/React$1y.createElement("thead", null, /*#__PURE__*/React$1y.createElement("tr", null, _$11.map(headers, (header, i) => {
      if (this.props.editableHeaders) {
        return /*#__PURE__*/React$1y.createElement("th", {
          key: i
        }, /*#__PURE__*/React$1y.createElement(this.props.Editor, {
          ref: "columnHeader" + i,
          apiOptions: this.props.apiOptions,
          content: header,
          widgetEnabled: false,
          onChange: _$11.partial(this.onHeaderChange, i)
        }));
      } else {
        return /*#__PURE__*/React$1y.createElement("th", {
          key: i
        }, /*#__PURE__*/React$1y.createElement(Renderer$h, {
          content: header,
          linterContext: this.props.linterContext
        }));
      }
    }))), /*#__PURE__*/React$1y.createElement("tbody", null, _$11.times(rows, r => {
      return /*#__PURE__*/React$1y.createElement("tr", {
        key: r
      }, _$11.times(columns, c => {
        return /*#__PURE__*/React$1y.createElement("td", {
          key: c
        }, /*#__PURE__*/React$1y.createElement(InputComponent, {
          ref: getRefForPath$1(getInputPath$1(r, c)),
          type: "text",
          value: this.props.answers[r][c],
          keypadElement: this.props.keypadElement,
          disabled: this.props.apiOptions.readOnly,
          onFocus: _$11.partial(this._handleFocus, getInputPath$1(r, c)),
          onBlur: _$11.partial(this._handleBlur, getInputPath$1(r, c)),
          onChange: _$11.partial(this.onValueChange, r, c),
          style: inputStyle
        }));
      }));
    })));
  },
  getUserInput: function getUserInput() {
    return _$11.map(this.props.answers, _$11.clone);
  },
  onValueChange: function onValueChange(row, column, eventOrValue) {
    var answers = _$11.map(this.props.answers, _$11.clone); // If this is coming from an "input", the last argument will be an
    // event. If it's coming from a SimpleKeypadInput, it'll be the value.


    answers[row][column] = eventOrValue.target ? eventOrValue.target.value : eventOrValue;
    this.props.onChange({
      answers: answers
    });
    this.props.trackInteraction();
  },
  onHeaderChange: function onHeaderChange(index, e) {
    var headers = this.props.headers.slice();
    headers[index] = e.content;
    this.props.onChange({
      headers: headers
    });
  },
  simpleValidate: function simpleValidate(rubric) {
    return Table$1.validate(this.getUserInput(), rubric);
  },
  _handleFocus: function _handleFocus(inputPath) {
    this.props.onFocus(inputPath);
  },
  _handleBlur: function _handleBlur(inputPath) {
    this.props.onBlur(inputPath);
  },
  focus: function focus() {
    this.focusInputPath(getDefaultPath$1());
    return true;
  },
  focusInputPath: function focusInputPath(path) {
    var inputID = getRefForPath$1(path);
    var inputComponent = this.refs[inputID];

    if (this.props.apiOptions.customKeypad) {
      inputComponent.focus();
    } else if (this.props.apiOptions.staticRender) {
      inputComponent.focus();
    } else {
      ReactDOM$k.findDOMNode(inputComponent).focus();
    }
  },
  blurInputPath: function blurInputPath(path) {
    var inputID = getRefForPath$1(path);
    var inputComponent = this.refs[inputID];

    if (this.props.apiOptions.customKeypad) {
      inputComponent.blur();
    } else if (this.props.apiOptions.staticRender) {
      inputComponent.blur();
    } else {
      ReactDOM$k.findDOMNode(inputComponent).blur();
    }
  },
  getDOMNodeForPath: function getDOMNodeForPath(path) {
    var inputID = getRefForPath$1(path);
    return ReactDOM$k.findDOMNode(this.refs[inputID]);
  },
  getInputPaths: function getInputPaths() {
    var rows = this._getRows();

    var columns = this._getColumns();

    var inputPaths = [];

    _$11.times(rows, r => {
      _$11.times(columns, c => {
        var inputPath = getInputPath$1(r, c);
        inputPaths.push(inputPath);
      });
    });

    return inputPaths;
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(inputPath) {
    return "number";
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    // Extract row, column information
    var row = getRowFromPath$1(path);
    var column = getColumnFromPath$1(path);

    var answers = _$11.map(this.props.answers, _$11.clone);

    answers[row][column] = newValue;
    this.props.onChange({
      answers: answers
    }, cb);
  }
});

_$11.extend(Table$1, {
  validate: function validate(state, rubric) {
    var filterNonEmpty = function filterNonEmpty(table) {
      return _$11.filter(table, function (row) {
        // Check if row has a cell that is nonempty
        return _$11.some(row, _$11.identity);
      });
    };

    var solution = filterNonEmpty(rubric.answers);
    var supplied = filterNonEmpty(state);

    var hasEmptyCell = _$11.some(supplied, function (row) {
      return _$11.some(row, function (cell) {
        return cell === "";
      });
    });

    if (hasEmptyCell || !supplied.length) {
      return {
        type: "invalid",
        message: null
      };
    }

    if (supplied.length !== solution.length) {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }

    var createValidator = KhanAnswerTypes$4.number.createValidatorFunctional;
    var message = null;

    var allCorrect = _$11.every(solution, function (rowSolution) {
      var i;

      for (i = 0; i < supplied.length; i++) {
        var rowSupplied = supplied[i];

        var correct = _$11.every(rowSupplied, function (cellSupplied, i) {
          var cellSolution = rowSolution[i];
          var validator = createValidator(cellSolution, {
            simplify: true
          });
          var result = validator(cellSupplied);

          if (result.message) {
            message = result.message;
          }

          return result.correct;
        });

        if (correct) {
          supplied.splice(i, 1);
          return true;
        }
      }

      return false;
    });

    return {
      type: "points",
      earned: allCorrect ? 1 : 0,
      total: 1,
      message: message
    };
  }
});

var propTransform$5 = editorProps => {
  // Remove answers before passing to widget
  var rows = editorProps.answers.length;
  var columns = editorProps.answers[0].length;

  var blankAnswers = _$11.times(rows, function () {
    return Util$e.stringArrayOfSize(columns);
  });

  return _$11.extend({}, editorProps, {
    answers: blankAnswers
  });
};

_module_$1A.exports = {
  name: "table",
  displayName: "Table of values",
  accessible: true,
  widget: Table$1,
  transform: propTransform$5,
  hidden: true,
  isLintable: true
};
var _widgetsTableJsx = _module_$1A.exports;

var _module_$1z = {
  exports: {}
};
// This means that if I wanted to insert text at the current cursor location,
// I could just pass in editorState, but if I wanted it to insert text at a
// custom location, I would just pass in a selection as well

var _fillData = draftData => {
  var {
    editorState,
    contentState,
    selection
  } = draftData;
  var newData = {};
  newData.editorState = editorState || null;
  newData.contentState = contentState || editorState && editorState.getCurrentContent() || null;
  newData.selection = selection || editorState && editorState.getSelection() || contentState && contentState.getSelectionAfter() || null;
  return newData;
}; // Draft.js bugs currently emerge when the editor doesn't have focus.  This
// avoids those by ensuring that the editor state always assumes it is focused


var _createEmptySelection = block => {
  return draftJs.SelectionState.createEmpty(block.getKey()).set("hasFocus", true);
};

function regexStrategy(contentBlock, callback, regex, selectionFromMatch) {
  var text = contentBlock.getText();
  var matchArr;

  while ((matchArr = regex.exec(text)) !== null) {
    if (selectionFromMatch) {
      var {
        start,
        end
      } = selectionFromMatch(matchArr);
      callback(start, end);
    } else {
      var _start = matchArr.index;
      callback(_start, _start + matchArr[0].length);
    }
  }
} // TODO: Make this return an array of all matches, rather than first


function findPattern(contentState, regExp) {
  // The entire content is organized into blocks, and so each one must be
  // searched in order to find every widget
  var blocks = contentState.getBlockMap().values();

  for (var block of blocks) {
    var match = regExp.exec(block.getText());

    if (match !== null) {
      var base = _createEmptySelection(block);

      var selection = base.merge({
        anchorOffset: match.index,
        focusOffset: match.index + match[0].length
      });
      return selection;
    }
  }
}

function replaceSelection(draftData, text) {
  var entity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var data = _fillData(draftData);

  var newData = {};
  newData.contentState = draftJs.Modifier.replaceText(data.contentState, data.selection, text, null, // For custom styling, but we use a decorator instead
  entity);

  if (data.editorState) {
    newData.editorState = draftJs.EditorState.push(data.editorState, newData.contentState, "insert-characters");
  }

  return newData;
}

function deleteSelection(draftData) {
  var data = _fillData(draftData);

  var newData = {};
  newData.contentState = draftJs.Modifier.removeRange(data.contentState, data.selection, "backward");

  if (data.editorState) {
    newData.editorState = draftJs.EditorState.push(data.editorState, newData.contentState, "remove-range");
  }

  return newData;
}

var _getBlocksForSelection = (contentState, selection) => {
  var blocks = [];
  var startKey = selection.getStartKey();
  var endKey = selection.getEndKey();
  var pastEndKey = contentState.getKeyAfter(endKey);

  for (var blockKey = startKey; blockKey !== pastEndKey; blockKey = contentState.getKeyAfter(blockKey)) {
    blocks.push(contentState.getBlockForKey(blockKey));
  }

  return blocks;
}; // Returns an array of all entiies contained within
// the provided selection, or in the entire contentState
// if no selection is provided


function getEntities(contentState, selection) {
  var blockMap = null; // Overriden if a selection is specified

  var filter = () => true;

  if (!selection) {
    blockMap = contentState.getBlockMap();
  } else {
    var blocks = _getBlocksForSelection(contentState, selection);

    blockMap = draftJs.BlockMapBuilder.createFromArray(blocks); // Ensure that entities in the same block as the start/end of the
    // selection are not included if they are not fully contained
    // within the selection

    var startKey = selection.getStartKey();
    var endKey = selection.getEndKey();

    filter = (key, start, end) => {
      if (key === startKey && start < selection.getStartOffset()) {
        return false;
      }

      if (key === endKey && end > selection.getEndOffset()) {
        return false;
      }

      return true;
    };
  }

  var entities = [];
  blockMap.forEach((block, blockKey) => {
    block.findEntityRanges(char => char.getEntity() !== null, (start, end) => {
      if (filter(blockKey, start, end)) {
        entities.push(draftJs.Entity.get(block.getEntityAt(start)));
      }
    });
  });
  return entities;
}

function findEntity(contentState, filter) {
  var blocks = contentState.getBlocksAsArray();
  var selection = null;
  blocks.some(block => {
    block.findEntityRanges(char => char.getEntity() !== null && filter(draftJs.Entity.get(char.getEntity())), (start, end) => {
      var base = _createEmptySelection(block);

      selection = base.merge({
        anchorOffset: start,
        focusOffset: end,
        isBackward: false
      });
    });
    return !!selection;
  });
  return selection;
}
/*
    This function is needed in cases like pasting, where raw text must be
    converted into Draft.js ContentBlocks.
    The sanitizer allows for actions such as stripping characters and
    adding in entities where needed
    */


var NEWLINE_REGEX = /\r\n?|\n/g;

function insertText(draftData, rawText) {
  var sanitizer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => null;

  var data = _fillData(draftData);

  var newData = {}; // To insert text such that it will appear as multiple blocks,
  // createFragment must be used.  A fragment is an ordered map of
  // ContentBlocks.  There should be a ContentBlock for each paragraph

  var textLines = rawText.split(NEWLINE_REGEX); // Without basic character data, the text appears blank

  var charData = draftJs.CharacterMetadata.create(); // Create an array of ContentBlock objects, one for each line

  var contentBlocks = textLines.map(textLine => {
    // Styles and entities in draft.js are applied per character, therefore
    // each block uses a list, where each element corresponds to a single
    // character.
    var text = textLine;
    var characterList = Array(textLine.length).fill(charData);
    var sanitizedObj = sanitizer(text, characterList);

    if (sanitizedObj !== null) {
      text = sanitizedObj.text;
      characterList = sanitizedObj.characterList;
    }

    return new draftJs.ContentBlock({
      key: draftJs.genKey(),
      text: text,
      type: "unstyled",
      characterList: immutable.List(characterList)
    });
  });
  var fragment = draftJs.BlockMapBuilder.createFromArray(contentBlocks);
  newData.contentState = draftJs.Modifier.replaceWithFragment(data.contentState, data.selection, fragment);

  if (data.editorState) {
    newData.editorState = draftJs.EditorState.push(data.editorState, newData.contentState, "insert-fragment");
  }

  return newData;
}

function selectEnd(block) {
  var emptySelection = _createEmptySelection(block);

  var newSelection = emptySelection.merge({
    focusOffset: block.getCharacterList().size,
    anchorOffset: block.getCharacterList().size
  });
  return newSelection;
} // An offset is editable if it is not inside an immutable entity


var _canEditOffset = (block, offset) => {
  if (offset === 0 || offset === block.getLength()) {
    return true;
  }

  var leftKey = block.getEntityAt(offset - 1);
  var rightKey = block.getEntityAt(offset);
  var isImmutableEntity = rightKey ? draftJs.Entity.get(rightKey).mutability === "IMMUTABLE" : false; // false if not an entity at all

  return !(isImmutableEntity && leftKey === rightKey);
};

var _getSkippedOffset = (contentBlock, startOffset, step) => {
  var currOffset = startOffset;

  while (currOffset > 0 && currOffset < contentBlock.getLength() && !_canEditOffset(contentBlock, currOffset)) {
    currOffset += step;
  }

  return currOffset;
};

function snapSelectionOutsideEntities(draftData, prevSelection) {
  var data = _fillData(draftData);

  var {
    contentState,
    selection,
    editorState
  } = data;
  var anchorBlock = contentState.getBlockForKey(selection.getAnchorKey());
  var focusBlock = contentState.getBlockForKey(selection.getFocusKey());
  var anchorOffset = selection.getAnchorOffset();
  var focusOffset = selection.getFocusOffset();
  var direction = selection.getIsBackward() ? -1 : 1; // If the cursor has moved by one, that means the user is moving it
  // manually with the arrow keys.  If that is happening and the cursor
  // moves from non-entity to entity, it should skip over the entity.

  var focusDiff = focusOffset - prevSelection.getFocusOffset();
  var isSameBlock = selection.getFocusKey() === prevSelection.getFocusKey();

  if (isSameBlock && Math.abs(focusDiff) === 1 && !_canEditOffset(focusBlock, focusOffset)) {
    focusOffset = _getSkippedOffset(focusBlock, focusOffset, focusDiff);
  } // These no-op if the offsets aren't/are no longer on entities


  focusOffset = _getSkippedOffset(focusBlock, focusOffset, direction);
  anchorOffset = _getSkippedOffset(anchorBlock, anchorOffset, -direction);

  if (selection.isCollapsed()) {
    anchorOffset = focusOffset;
  }

  var newData = {
    contentState
  };
  newData.selection = selection.merge({
    focusOffset,
    anchorOffset
  });

  if (editorState) {
    // EditorState.forceSelection results in strange behavior
    // where characters are repeated when typing normally
    newData.editorState = draftJs.EditorState.set(editorState, {
      selection: newData.selection,
      forceSelection: true
    });
  }

  return newData;
}

var _surroundWithText = (contentState, block, left, right, text) => {
  var area = _createEmptySelection(block);

  var content = contentState;
  area = area.merge({
    anchorOffset: right,
    focusOffset: right
  });
  content = draftJs.Modifier.insertText(content, area, text);
  area = area.merge({
    anchorOffset: left,
    focusOffset: left
  });
  content = draftJs.Modifier.insertText(content, area, text);
  return content;
};

var _clearSurrounding = (contentState, block, left, right, text) => {
  var area = _createEmptySelection(block);

  var content = contentState;
  area = area.merge({
    anchorOffset: right - text.length,
    focusOffset: right
  });
  content = draftJs.Modifier.removeRange(content, area);
  area = area.merge({
    anchorOffset: left,
    focusOffset: left + text.length
  });
  content = draftJs.Modifier.removeRange(content, area);
  return content;
};

function toggleDecoration(draftData, decoration) {
  var data = _fillData(draftData);

  var newData = {};
  var {
    contentState,
    selection
  } = data;

  var blocks = _getBlocksForSelection(contentState, selection); // If all the blocks are already surrounded by the decoration, we must
  // instead be disabling the decoration.  To do this without duplicating
  // code, two copies are made, one as if we were decorating, and another
  // as if we were removing a decoration.  If it was the case that all
  // the selected text was already decorated, we use the version which
  // removed all decoration, otherwise we use the newly decorated one


  var allSurrounded = true;
  var decorated = data.contentState;
  var undecorated = data.contentState;
  blocks.forEach(block => {
    var leftOffset = 0;
    var rightOffset = block.getLength();

    if (block.getKey() === selection.getStartKey()) {
      leftOffset = selection.getStartOffset();
    }

    if (block.getKey() === selection.getEndKey()) {
      rightOffset = selection.getEndOffset();
    } // Ignore unless there is something to decorate


    if (leftOffset === rightOffset) {
      return;
    } // Check if we are undecorating


    var selectedStr = block.getText().substring(leftOffset, rightOffset);

    if (!allSurrounded || !selectedStr.endsWith(decoration) || !selectedStr.startsWith(decoration)) {
      allSurrounded = false;
    } else {
      undecorated = _clearSurrounding(undecorated, block, leftOffset, rightOffset, decoration);
    } // Decorate the decorated version


    decorated = _surroundWithText(decorated, block, leftOffset, rightOffset, decoration);
  });

  if (allSurrounded) {
    newData.contentState = undecorated;
  } else {
    newData.contentState = decorated;
  }

  if (data.editorState) {
    newData.editorState = draftJs.EditorState.push(data.editorState, newData.contentState, allSurrounded ? "remove-range" : "insert-characters"); // Shift the selection to deal with the added/removed characters

    var newEndOffset = selection.getEndOffset();

    if (newEndOffset > 0) {
      // If not ending on an empty block (no-ops)
      var change = allSurrounded ? -2 : 2;
      newEndOffset += change * decoration.length;
    }

    var newSelection = null;

    if (selection.getIsBackward()) {
      newSelection = selection.merge({
        anchorOffset: newEndOffset
      });
    } else {
      newSelection = selection.merge({
        focusOFfset: newEndOffset
      });
    }

    newData.editorState = draftJs.EditorState.forceSelection(newData.editorState, newSelection);
  }

  return newData;
}

_module_$1z.exports = {
  regexStrategy,
  findPattern,
  replaceSelection,
  deleteSelection,
  getEntities,
  findEntity,
  insertText,
  selectEnd,
  snapSelectionOutsideEntities,
  toggleDecoration
};
var _draftUtilsJs = _module_$1z.exports;

var _module_$1y = {
  exports: {}
};
/*
This is essentially a more advanced `textarea`, using Draft.js
https://facebook.github.io/draft-js/

The important Draft.js concepts needed to understand this file are:
    - Everything is immutable, and inputs all result in a new `editorState`
      object being passed to `handleChange`.  All changes must be done by
      constructing new objects.  This means simply editing text involves
      creating a new ContentState, which is used to create a new EditorState
    - `EditorState` contains a `ContentState` property which contains the data
      relevant to the text content
    - `ContentState` is organized into individual "Blocks", which helps with
      performance as updates only affect a single block
    - Specific text in blocks can be denoted as "Entities", which can store
      data relevant to its text.  This is what allows backspacing a widget
      to result in its deletion in Perseus
    - Special styling is done using Decorators, which allow substituting text
      content with a custom react element
    - Modifier is a collection of helpful utilities for modification purposes

TODO(samiskin): Make tasks such as "addWidget" and "updateWidget" not functions
                that you call on the PerseusEditor component (Can do once this
                fully replacess the old editor).
*/

var React$1x = _react__default["default"];
var Widgets$1 = Widgets$5;
var DraftUtils = _draftUtilsJs; // This controls the minimum time between when updates for the parent
// component are generated.  The best time for this number sort of depends
// on the user's typing speed though, as if the time between each letter being
// typed is longer than the throttle, they would notice a freeze when the update
// is being calculated.
// TODO(samiskin): Figure out whats the best value for this number
// 100 is best for my typing speed, but may not work as well for slower typists

var UPDATE_PARENT_THROTTLE = 100;
var widgetPlaceholder$1 = "[[\u2603 {id}]]";
var widgetRegExp$1 = /\[\[\u2603 [a-z-]+ [0-9]+\]\]/g;
var widgetPartsRegExp = /^\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]$/;

var widgetRegexForId = id => new RegExp("(\\[\\[\u2603 ".concat(id, "\\]\\])"), "gm");

var partialWidgetRegex = /\[\[([a-z-]+)$/; // Used for autocompletion

var imageRegExp = /!\[[^\]]*?\]\([^\)].*?\)/g; // Note: Nested decorators currently do not work, therefore this will not
//       work when nesting bold/italics/underline.  Hopefully this is
//       fixed in future versions of Draft.js

var boldRegExp = /\*\*([\s\S]+?)\*\*(?!\*)/g;
var italicsRegExp = /\**(?:^|[^*])((\*|_)(\w+(\s\w+)*)\2)/g; // copied from https://github.com/ayberkt/RFMarkdownTextView/blob/387312e602f03b87f3ef82dc82c62df455d6fd30/RFMarkdownTextView/RFMarkdownSyntaxStorage.m

var boldItalicsRegExp = /(\*\*\*\w+(\s\w+)*\*\*\*)/g;
var underlineRegExp = /__([\s\S]+?)__(?!_)/g;
var headerRegExp = /^ *(#{1,6})([^\n]+)$/g;
/*
    Styled ranges in Draft.js are done using a `CompositeDecorator`,
    where a `strategy` is given to denote what ranges of text to style,
    and a `component` is given to denote how that range should be rendered
*/

var entityStrategy = (contentBlock, callback, type) => contentBlock.findEntityRanges(char => char.getEntity() && draftJs.Entity.get(char.getEntity()).type === type, callback);

var styledBlock = (props, style) => /*#__PURE__*/React$1x.createElement("span", _extends({}, props, {
  style: style
}), props.children);

styledBlock.propTypes = {
  children: PropTypes.any
};

var highlightedBlock = (props, backgroundColor) => styledBlock(props, {
  backgroundColor
});

var entityColorDecorator = (type, color) => ({
  strategy: function strategy() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return entityStrategy(...args, type);
  },
  component: props => highlightedBlock(props, color)
});

var regexColorDecorator = (regex, color) => ({
  strategy: function strategy() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return DraftUtils.regexStrategy(...args, regex);
  },
  component: props => highlightedBlock(props, color)
});

var boldDecorator = {
  strategy: function strategy() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return DraftUtils.regexStrategy(...args, boldRegExp);
  },
  component: props => styledBlock(props, {
    fontWeight: "bold"
  })
}; // The italics regex has a group that ensures that the *___* block
// does not include the * used to create a list.  Since this results
// in match.index also including the first non-capturing group, we must
// use custom logic for this strategy

var italicsStrategy = function italicsStrategy() {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return DraftUtils.regexStrategy(...args, italicsRegExp, matchArr => {
    var start = matchArr.index + matchArr[0].length - matchArr[1].length;
    var end = start + matchArr[1].length;
    return {
      start,
      end
    };
  });
};

var italicsDecorator = {
  strategy: italicsStrategy,
  component: props => styledBlock(props, {
    fontStyle: "italic"
  })
};
var underlineDecorator = {
  strategy: function strategy() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return DraftUtils.regexStrategy(...args, underlineRegExp);
  },
  component: props => styledBlock(props, {
    textDecoration: "underline"
  })
};
var boldItalicsDecorator = {
  strategy: function strategy() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return DraftUtils.regexStrategy(...args, boldItalicsRegExp);
  },
  component: props => styledBlock(props, {
    fontWeight: "bold",
    fontStyle: "italic"
  })
}; // TODO: Make the headers also able to scale with the rest of the text
// when changing the fontSize percentage

var headerComponent = props => {
  var text = props.decoratedText;
  var headerSize = text.split(headerRegExp)[1].length;
  var style = {
    marginBottom: 0
  };
  return React$1x.createElement("h".concat(headerSize), {
    style
  }, props.children);
};

headerComponent.propTypes = {
  decoratedText: PropTypes.string,
  children: PropTypes.any
};
var headerDecorator = {
  strategy: function strategy() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    return DraftUtils.regexStrategy(...args, headerRegExp);
  },
  component: headerComponent
};
var decorator = new draftJs.CompositeDecorator([entityColorDecorator("WIDGET", "#DFD"), entityColorDecorator("TEMP_IMAGE", "#fdffdd"), regexColorDecorator(imageRegExp, "#dffdfa"), boldItalicsDecorator, boldDecorator, underlineDecorator, italicsDecorator, headerDecorator]); // Key bindings are handled by mapping events to strings

var keyBindings = e => {
  var isCommandPressed = draftJs.KeyBindingUtil.hasCommandModifier(e);

  if (isCommandPressed && e.keyCode === 66) {
    // 66 = b
    return "perseus-bold";
  } else if (isCommandPressed && e.keyCode === 73) {
    // 73 = i
    return "perseus-italics";
  } else if (isCommandPressed && e.keyCode === 85) {
    // 85 = u
    return "perseus-underline";
  } else if (isCommandPressed && e.keyCode === 219) {
    // 219 = [
    return "perseus-decrease-font-size";
  } else if (isCommandPressed && e.keyCode === 221) {
    // 221 = ]
    return "perseus-increase-font-size";
  } else if (isCommandPressed && e.keyCode === 220) {
    // 220 = ]
    return "perseus-reset-font-size";
  } else {
    return draftJs.getDefaultKeyBinding(e);
  }
};
/*
    This is the main Draft.js editor.  It keeps track of its internal Draft.js
    state, however what it exposes through its `onChange` is a simple string
    as well as a list of the currently active widgets.
*/


var PerseusEditor$1 = createReactClass({
  displayName: "PerseusEditor",
  propTypes: {
    onChange: PropTypes.func,
    content: PropTypes.string,
    initialWidgets: PropTypes.any,
    placeholder: PropTypes.string,
    imageUploader: PropTypes.func,
    widgetEnabled: PropTypes.bool
  },
  getDefaultProps: () => ({
    onChange: () => {},
    content: "",
    initialWidgets: {},
    widgetEnabled: true,
    placeholder: "Type here"
  }),

  getInitialState() {
    var {
      content,
      initialWidgets,
      widgetEnabled
    } = this.props;
    var contentState = draftJs.ContentState.createFromText(content);
    var editorState = draftJs.EditorState.createWithContent(contentState, decorator);

    if (widgetEnabled) {
      editorState = this._insertWidgetsAsEntities(editorState, initialWidgets);
    }

    return {
      editorState,
      widgets: initialWidgets,
      fontSizePercentage: 100
    };
  },

  // The editor can have its content changed completely by changing the
  // content prop, however if the data this component sent to its parent
  // using `this.props.onChange()` is being fed back in, ignore it
  componentDidUpdate(prevProps) {
    if (this.props.content !== this.lastContentUpdate) {
      this.lastContentUpdate = this.props.content;
      this.setState(this.getInitialState()); //eslint-disable-line
    }
  },

  // By turning widgets into Entities, we allow for widgets to be considered
  // "IMMUTABLE", that is, backspacing a widget will delete the entire text
  // rather than just a "]" character.  It also enables us to detect which
  // widget id has been deleted, as metadata can be attached to entities
  // TODO(samiskin): Turn this task of `applyEntities(pattern, createEntity)`
  // into a DraftUtils function
  _insertWidgetsAsEntities(editorState, widgets) {
    var content = editorState.getCurrentContent();
    Object.keys(widgets).forEach(id => {
      var selection = DraftUtils.findPattern(content, widgetRegexForId(id)); //eslint-disable-line max-len

      if (selection) {
        // Sometimes the widgets don't actually exist
        var entity = draftJs.Entity.create("WIDGET", "IMMUTABLE", {
          id
        });
        content = draftJs.Modifier.applyEntity(content, selection, entity);
      }
    }); // EditorState.set is used rather than push, because no state should
    // be added to the undo stack.

    var withEntity = draftJs.EditorState.set(editorState, {
      currentContent: content
    });
    return withEntity;
  },

  _getDraftData() {
    var editorState = this.state.editorState;
    var contentState = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    return {
      editorState,
      contentState,
      selection
    };
  },

  _getNextWidgetId(type) {
    var currWidgets = this.state.widgets;
    return Object.keys(currWidgets).filter(id => currWidgets[id].type === type).map(id => +id.split(" ")[1]) //ids are (([a-z-]+) ([0-9]+))
    .reduce((maxId, currId) => Math.max(maxId, currId), 0);
  },

  _createInitialWidget(widgetType) {
    // Since widgets are given IDs, adding a new widget must ensure that a
    // unique id is generated for it.
    var widgetNum = this._getNextWidgetId(widgetType);

    var id = widgetType + " " + (widgetNum + 1);
    var widget = {
      options: Widgets$1.getEditor(widgetType).defaultProps,
      type: widgetType,
      // Track widget version on creation, so that a widget editor
      // without a valid version prop can only possibly refer to a
      // pre-versioning creation time.
      version: Widgets$1.getVersion(widgetType)
    };
    return [id, widget];
  },

  addWidget(type) {
    this.focus(() => this._handleChange(this._insertNewWidget(type)));
  },

  _insertNewWidget(type, draftDataParams) {
    var draftData = _objectSpread2(_objectSpread2({}, this._getDraftData()), draftDataParams);

    var [id, widget] = this._createInitialWidget(type);

    var newWidgets = _objectSpread2(_objectSpread2({}, this.state.widgets), {}, {
      [id]: widget
    });

    var newDraftData = this._insertWidgetText(draftData, id);

    return {
      editorState: newDraftData.editorState,
      widgets: newWidgets
    };
  },

  _insertWidgetText(draftData, id) {
    // Text for the widget is inserted, and an entity is assigned
    var text = widgetPlaceholder$1.replace("{id}", id);
    var entity = draftJs.Entity.create("WIDGET", "IMMUTABLE", {
      id
    });
    return DraftUtils.replaceSelection(draftData, text, entity);
  },

  updateWidget(id, newProps) {
    this.setState({
      widgets: _objectSpread2(_objectSpread2({}, this.state.widgets), {}, {
        [id]: newProps
      })
    });
  },

  // This function only removes the widget from the content, and then
  // handleChange handles removing widgets from the state, as widgets
  // can also be deleted by editor actions such as backspace and delete
  removeWidget(id) {
    this.focus(() => {
      var {
        editorState,
        contentState
      } = this._getDraftData();

      var selection = DraftUtils.findPattern(contentState, widgetRegexForId(id)); //eslint-disable-line max-len

      var newDraftData = DraftUtils.deleteSelection({
        editorState,
        selection
      });

      this._handleChange({
        editorState: newDraftData.editorState
      });
    });
  },

  addTemplate(templateType) {
    this.focus(() => {
      this._addTemplate(templateType);
    });
  },

  _addTemplate(templateType) {
    var {
      editorState,
      contentState,
      selection
    } = this._getDraftData();

    var widgets = _objectSpread2({}, this.state.widgets); // Templates shouldn't interrupt a line if the cursor is not at the end


    var currBlock = contentState.getBlockForKey(selection.getEndKey());
    selection = DraftUtils.selectEnd(currBlock); // Insert a new line at the beginning if there is content there, that
    // way the template appears on a newline in the rendered markdown

    if (currBlock.getText().length > 0) {
      contentState = draftJs.Modifier.splitBlock(contentState, selection);
      selection = contentState.getSelectionAfter();
    }

    if (templateType === "allWidgets") {
      var allTypes = Widgets$1.getAllWidgetTypes().sort(); // Insert a newline at the beginning

      contentState = draftJs.Modifier.splitBlock(contentState, selection);
      contentState = allTypes.reduce((content, type) => {
        var [id, widget] = this._createInitialWidget(type);

        widgets[id] = widget;
        content = this._insertWidgetText({
          contentState: content,
          selection: content.getSelectionAfter()
        }, id).contentState;
        return draftJs.Modifier.splitBlock( // Put each widget on a new line
        content, content.getSelectionAfter());
      }, contentState);
      editorState = draftJs.EditorState.push(editorState, contentState, "insert-fragment");
    } else {
      var template = "";

      if (templateType === "table") {
        template = "header 1 | header 2 | header 3\n" + "- | - | -\n" + "data 1 | data 2 | data 3\n" + "data 4 | data 5 | data 6\n" + "data 7 | data 8 | data 9";
      } else if (templateType === "titledTable") {
        template = "|| **Table title** ||\n" + "header 1 | header 2 | header 3\n" + "- | - | -\n" + "data 1 | data 2 | data 3\n" + "data 4 | data 5 | data 6\n" + "data 7 | data 8 | data 9";
      } else if (templateType === "alignment") {
        template = "$\\begin{align} x+5 &= 30 \\\\\n" + "x+5-5 &= 30-5 \\\\\n" + "x &= 25 \\end{align}$";
      } else if (templateType === "piecewise") {
        template = "$f(x) = \\begin{cases}\n" + "7 & \\text{if }x=1 \\\\\n" + "f(x-1)+5 & \\text{if }x > 1\n" + "\\end{cases}$";
      }

      editorState = DraftUtils.insertText({
        editorState,
        contentState,
        selection
      }, "\n".concat(template, "\n")).editorState;
    }

    this._handleChange({
      editorState,
      widgets
    });
  },

  _handleCopy() {
    var {
      contentState,
      selection
    } = this._getDraftData();

    var entities = DraftUtils.getEntities(contentState, selection);
    var copiedWidgets = entities.reduce((map, entity) => {
      var id = entity.getData().id;
      map[id] = this.state.widgets[id];
      return map;
    }, {});
    localStorage.perseusLastCopiedWidgets = JSON.stringify(copiedWidgets);
    return false;
  },

  // Widgets cannot have ID conflicts, therefore this function exists
  // to return a mapping of { new id -> safe id }
  _createSafeWidgetMapping(newWidgets, currentWidgets) {
    // Create a mapping of { type -> largest id of that type }
    var maxIds = Object.keys(currentWidgets).reduce((idMap, widget) => {
      var [type, id] = widget.split(" ");
      idMap[type] = idMap[type] ? Math.max(idMap[type], +id) : +id;
      return idMap;
    }, {});
    var safeWidgetMapping = Object.keys(newWidgets).reduce((safeMap, widget) => {
      var type = widget.split(" ")[0];
      maxIds[type] = maxIds[type] ? maxIds[type] + 1 : 1;
      safeMap[widget] = type + " " + maxIds[type];
      return safeMap;
    }, {});
    return safeWidgetMapping;
  },

  // Pasting text from another Perseus editor instance should also copy over
  // the widgets.  To do this properly, we must parse the text, replace the
  // widget ids with non-conflicting ones, store them, and also assign them
  // proper entities.  Sadly Draft.js only supports `handlePastedText` which
  // happens prior to the new content state being generated (which is needed
  // to add entities to).  We therefore must reimplement the default Paste
  // functionality, in order to add our custom steps afterwards
  _handlePaste(pastedText, html, selection) {
    // If no widgets are in localstorage, just use default behavior
    var sourceWidgetsJSON = localStorage.perseusLastCopiedWidgets;

    if (!sourceWidgetsJSON) {
      return false;
    }

    var sourceWidgets = JSON.parse(sourceWidgetsJSON);

    var widgets = _objectSpread2({}, this.state.widgets);

    var safeWidgetMapping = this._createSafeWidgetMapping(sourceWidgets, widgets); //eslint-disable-line max-len


    var charData = draftJs.CharacterMetadata.create(); // insertText takes a sanitizer function which gets ran on every
    // line.  It is used here in order to fix the new widgets to not
    // have conflicting IDs, as well as fill in the widget data

    var sanitizeText = textLine => {
      var sanitized = textLine.replace(new RegExp("\r", "g"), ""); //eslint-disable-line no-control-regex

      var characterList = Array(sanitized.length).fill(charData);
      var safeText = sanitized.replace(widgetRegExp$1, (syntax, offset) => {
        //eslint-disable-line max-len
        var match = widgetPartsRegExp.exec(syntax);
        var fullText = match[0]; // The entire [[ widgetName id ]]

        var widgetId = match[1]; // Just the "widgetName id" part

        var newId = safeWidgetMapping[widgetId];
        var newText = widgetPlaceholder$1.replace("{id}", newId); // Create an entity for the new widget, and assign it to the
        // characters that match up to the new widget text (splice)

        var entity = draftJs.Entity.create("WIDGET", "IMMUTABLE", {
          id: newId
        }); //eslint-disable-line max-len

        var entityChar = draftJs.CharacterMetadata.applyEntity(charData, entity); //eslint-disable-line max-len

        var entityChars = Array(newText.length).fill(entityChar);
        characterList.splice(offset, fullText.length, ...entityChars);
        widgets[newId] = sourceWidgets[widgetId];
        return fullText.replace(widgetId, newId);
      });
      return {
        text: safeText,
        characterList
      };
    };

    var data = this._getDraftData();

    data.selection = selection || data.selection;
    var {
      editorState
    } = DraftUtils.insertText(data, pastedText, sanitizeText);

    this._handleChange({
      editorState,
      widgets
    });

    return true; // True means draft doesn't run its default behavior
  },

  _handleDrop(selection, dataTransfer) {
    // All insertions are done to the end of the current block
    var contentState = this.state.editorState.getCurrentContent();
    var endKey = selection.getEndKey();
    var endBlock = contentState.getBlockForKey(endKey);
    var endSelection = DraftUtils.selectEnd(endBlock);
    var imageUrl = dataTransfer.getLink();

    if (imageUrl) {
      // Adds new lines and collapses the selection
      var {
        editorState
      } = DraftUtils.insertText(_objectSpread2(_objectSpread2({}, this._getDraftData()), {}, {
        selection: endSelection
      }), "\n![](".concat(imageUrl, ")"));

      this._handleChange({
        editorState
      });
    } else {
      var text = dataTransfer.getText();
      return this._handlePaste(text, null, endSelection);
    }

    return true; // Disable default draft drop handler
  },

  _handleDroppedFiles(selection, files) {
    var images = files.filter(file => file.type.match("image.*"));
    var contentState = this.state.editorState.getCurrentContent();
    images.forEach(image => {
      // Insert placeholder text to show that the image is being uploaded
      var text = "![](".concat(image.name, "...)");
      var id = draftJs.genKey();
      var entity = draftJs.Entity.create("TEMP_IMAGE", "IMMUTABLE", {
        id
      });
      var charData = draftJs.CharacterMetadata.create().merge({
        entity
      });
      var characterList = Array(text.length).fill(charData);

      var sanitizer = textLine => textLine === text ? {
        text,
        characterList
      } : null;

      var blockKey = selection.getEndKey();
      var contentBlock = contentState.getBlockForKey(blockKey);
      var endOfBlockSelection = DraftUtils.selectEnd(contentBlock);
      contentState = DraftUtils.insertText({
        contentState,
        selection: endOfBlockSelection
      }, "\n".concat(text, "\n"), sanitizer).contentState; // Begin uploading the image, and update the link once complete

      this.props.imageUploader(image, url => {
        var currEditor = this.state.editorState;
        var currContent = currEditor.getCurrentContent();
        var placeholderLocation = DraftUtils.findEntity(currContent, c => c.getData().id === id);
        var newDraftData = DraftUtils.replaceSelection({
          editorState: currEditor,
          contentState: currContent,
          selection: placeholderLocation
        }, "![](".concat(url, ")"));

        this._handleChange({
          editorState: newDraftData.editorState
        });
      });
    });
    var editorState = draftJs.EditorState.push(this.state.editorState, contentState, "insert-fragment");

    this._handleChange({
      editorState
    });

    return true; // Disable default draft drop handler
  },

  // This implements tab completion for widgets.  When the user
  // has typed [[d, then presses tab, we should replace [[d
  // with the full [[ {emoji} dropdown 1 ]] text
  _handleTab(e) {
    var {
      contentState,
      selection
    } = this._getDraftData(); // isCollapsed means that there is no active selection, its just
    // a blinking cursor.  For the SelectionState object, this
    // essentially means that anchorOffset === focusOffset


    if (!selection.isCollapsed() || !this.props.widgetEnabled) {
      return;
    }

    e.preventDefault();
    var currBlock = contentState.getBlockForKey(selection.getEndKey());
    var text = currBlock.getText().substring(0, selection.getEndOffset());
    var match = text.match(partialWidgetRegex);

    if (match) {
      var partialName = match[1];
      var allWidgets = Widgets$1.getAllWidgetTypes();
      var matchingWidgets = allWidgets.filter(widget => {
        return widget.substring(0, partialName.length) === partialName;
      }); // If only one match is available, complete it

      if (matchingWidgets.length === 1) {
        var widgetType = matchingWidgets[0];
        var replacementArea = selection.merge({
          anchorOffset: match.index
        });

        this._handleChange(this._insertNewWidget(widgetType, {
          selection: replacementArea
        }));
      }
    }

    return true; // Say that we've handled the event, no other work needed
  },

  _getDecorationForStyle(style) {
    switch (style) {
      case "perseus-bold":
        return "**";

      case "perseus-italics":
        return "*";

      case "perseus-underline":
        return "__";

      default:
        return null;
    }
  },

  _handleKeyCommand(command) {
    // Check if the font size should be changed
    var {
      fontSizePercentage
    } = this.state;

    if (command === "perseus-increase-font-size") {
      this.setState({
        fontSizePercentage: fontSizePercentage + 10
      });
      return true;
    } else if (command === "perseus-decrease-font-size") {
      this.setState({
        fontSizePercentage: fontSizePercentage - 10
      });
      return true;
    } else if (command === "perseus-reset-font-size") {
      this.setState({
        fontSizePercentage: 100
      });
      return true;
    } // Check whether a style such as bold/italics/underline should be added


    var decoration = this._getDecorationForStyle(command);

    if (decoration !== null) {
      var data = this._getDraftData();

      var {
        editorState
      } = DraftUtils.toggleDecoration(data, decoration);

      this._handleChange({
        editorState
      });

      return true;
    }

    return false;
  },

  lastContentUpdate: "",

  _updateParent(content, widgets) {
    // The parent component should know of only the active widgets,
    // however the widgets are not deleted from this.state because a
    // user undoing a widget deletion should also recover the
    // widget's metadata
    var currEntities = DraftUtils.getEntities(content);
    var visibleWidgets = currEntities.reduce((map, entity) => {
      var id = entity.getData().id;
      map[id] = widgets[id];
      return map;
    }, {});
    this.lastContentUpdate = content.getPlainText("\n"); // Provide the parent component with the current text
    // representation, as well as the current active widgets

    this.props.onChange({
      content: this.lastContentUpdate,
      widgets: visibleWidgets
    });
  },

  pastContentState: null,
  lastIdleCallback: null,

  _handleChange(newState) {
    var state = _objectSpread2(_objectSpread2({}, this.state), newState);

    var widgets = state.widgets;
    var editorState = state.editorState; // The cursor should not exist within an entity

    editorState = DraftUtils.snapSelectionOutsideEntities({
      editorState
    }, this.state.editorState.getSelection()).editorState;
    var newContent = editorState.getCurrentContent(); // editorState contains more than just the content, such as the current
    // cursor position.  This means `handleChange` gets called for more than
    // just content changes, so certain calculations aren't always needed.

    if (newContent !== this.pastContentState) {
      // This ensures that unless the content stops changing for a certain
      // short duration, no processing will be done to update the parent.
      // This allows the editing to remain performant for large files,
      // as basic tasks only occur on individual ContentBlocks, while
      // updating the parent involves iterating through them all
      clearTimeout(this.lastIdleCallback);
      this.lastIdleCallback = setTimeout(() => this._updateParent(newContent, widgets), UPDATE_PARENT_THROTTLE);
    }

    this.pastContentState = newContent;
    this.setState({
      editorState,
      widgets
    });
  },

  // HACK: There are currently serious Draft.js bugs related to mutating the
  //       editorState when it is not in focus, then pressing undo.  This
  //       workaround uses a callback parameter to run code after the
  //       editorState has been updated to be in focus, that way functions
  //       such as addWidget will not bring up serious issues when undone
  focus(callback) {
    this.editor.focus();
    var editorState = this.state.editorState;
    editorState = draftJs.EditorState.set(editorState, {
      selection: editorState.getSelection().set("hasFocus", true),
      forceSelection: true
    });
    this.setState({
      editorState
    }, callback);
  },

  render() {
    return /*#__PURE__*/React$1x.createElement("div", {
      onCopy: this._handleCopy,
      onCut: this._handleCopy,
      onDragStart: this._handleCopy,
      style: {
        fontSize: "".concat(this.state.fontSizePercentage, "%")
      }
    }, /*#__PURE__*/React$1x.createElement(draftJs.Editor, {
      ref: e => this.editor = e,
      editorState: this.state.editorState,
      onChange: editorState => this._handleChange({
        editorState
      }),
      spellCheck: true,
      stripPastedStyles: true,
      placeholder: this.props.placeholder,
      handlePastedText: this._handlePaste,
      handleDroppedFiles: this._handleDroppedFiles,
      handleDrop: this._handleDrop,
      keyBindingFn: keyBindings,
      handleKeyCommand: this._handleKeyCommand,
      onTab: this._handleTab
    }));
  }

});
_module_$1y.exports = PerseusEditor$1;
var _perseusEditorJsx = _module_$1y.exports;

var _module_$1x = {
  exports: {}
};
/**
 * Displays a collapsable list of KaTeX rendering errors.
 */

var React$1w = _react__default["default"];
var KatexErrorView$1 = createReactClass({
  displayName: "KatexErrorView",
  propTypes: {
    errorList: PropTypes.arrayOf(PropTypes.shape({
      math: PropTypes.string.isRequired,
      message: PropTypes.string.isRequired
    })).isRequired
  },

  getInitialState() {
    return {
      showErrors: false
    };
  },

  handleToggleKatexErrors(e) {
    this.setState({
      showErrors: !this.state.showErrors
    });
  },

  render() {
    var {
      errorList
    } = this.props;
    var {
      showErrors
    } = this.state; // TODO(riley) replace with SVG icons

    var disclosureClass = showErrors ? "icon-chevron-down" : "icon-chevron-right";
    return /*#__PURE__*/React$1w.createElement("div", {
      className: aphrodite.css(styles$j.errorContainer)
    }, /*#__PURE__*/React$1w.createElement("div", {
      className: aphrodite.css(styles$j.title),
      onClick: this.handleToggleKatexErrors
    }, /*#__PURE__*/React$1w.createElement("i", {
      className: disclosureClass,
      style: {
        fontSize: 14
      }
    }), "\xA0 KaTeX Errors (", errorList.length, ")"), showErrors && /*#__PURE__*/React$1w.createElement("div", {
      className: aphrodite.css(styles$j.errorExplanation)
    }, "These errors will cause your LaTeX to load really slowly for the student. Please fix them if you can. If you can\u2019t because KaTeX doesn\u2019t support the feature you need, please message Cam."), showErrors && errorList.map((e, index) => /*#__PURE__*/React$1w.createElement("div", {
      className: aphrodite.css(styles$j.error),
      key: index
    }, /*#__PURE__*/React$1w.createElement("div", {
      style: {
        color: "red"
      }
    }, e.math), /*#__PURE__*/React$1w.createElement("div", null, e.message))));
  }

});
var styles$j = aphrodite.StyleSheet.create({
  title: {
    backgroundColor: "#eee",
    fontSize: "1.25em",
    padding: "4px 10px"
  },
  errorContainer: {
    border: "1px solid #ddd",
    borderTop: "none"
  },
  errorExplanation: {
    padding: "4px 10px",
    backgroundColor: "pink"
  },
  error: {
    padding: "4px 10px"
  }
});
_module_$1x.exports = KatexErrorView$1;
var _katexErrorViewJsx = _module_$1x.exports;

var module$4 = {
  exports: {}
};
/* This component makes its children a drag target. Example:
 *
 *     <DragTarget onDrop={this.handleDrop}>Drag to me</DragTarget>
 *
 *     ...
 *
 *     handleDrop: function(e) {
 *         this.addImages(e.nativeEvent.dataTransfer.files);
 *     }
 *
 * Now "Drag to me" will be a drag target - when something is dragged over it,
 * the element will become partially transparent as a visual indicator that
 * it's a target.
 */
// TODO(joel) - indicate before the hover is over the target that it's possible
// to drag into the target. This would (I think) require a high level handler -
// like on Perseus itself, waiting for onDragEnter, then passing down the
// event. Sounds like a pain. Possible workaround - create a div covering the
// entire page...
//
// Other extensions:
// * custom styles for global drag and dragOver
// * only respond to certain types of drags (only images for instance)!

var React$1v = _react__default["default"];
var createReactClass$4 = _createReactClass__default["default"];
var PropTypes$4 = _propTypes__default["default"];
var DragTarget$1 = createReactClass$4({
  displayName: "DragTarget",
  propTypes: {
    // All props not listed here are forwarded to the root element without
    // modification.
    onDrop: PropTypes$4.func.isRequired,
    component: PropTypes$4.any,
    // component type
    shouldDragHighlight: PropTypes$4.func,
    style: PropTypes$4.any
  },
  getDefaultProps: function getDefaultProps() {
    return {
      component: "div",
      shouldDragHighlight: () => true
    };
  },
  getInitialState: function getInitialState() {
    return {
      dragHover: false
    };
  },
  handleDrop: function handleDrop(e) {
    e.stopPropagation();
    e.preventDefault();
    this.setState({
      dragHover: false
    });
    this.props.onDrop(e);
  },
  handleDragEnd: function handleDragEnd() {
    this.setState({
      dragHover: false
    });
  },
  handleDragOver: function handleDragOver(e) {
    e.preventDefault();
  },
  handleDragLeave: function handleDragLeave() {
    this.setState({
      dragHover: false
    });
  },
  handleDragEnter: function handleDragEnter(e) {
    this.setState({
      dragHover: this.props.shouldDragHighlight(e)
    });
  },
  render: function render() {
    var opacity = this.state.dragHover ? {
      "opacity": 0.3
    } : {};
    var Component = this.props.component;
    var forwardProps = Object.assign({}, this.props);
    delete forwardProps.component;
    delete forwardProps.shouldDragHighlight;
    return /*#__PURE__*/React$1v.createElement(Component, _extends({}, forwardProps, {
      style: Object.assign({}, this.props.style, opacity),
      onDrop: this.handleDrop,
      onDragEnd: this.handleDragEnd,
      onDragOver: this.handleDragOver,
      onDragEnter: this.handleDragEnter,
      onDragLeave: this.handleDragLeave
    }));
  }
});
module$4.exports = DragTarget$1;
var _reactComponentsDragTargetJsx = module$4.exports;

var createFragment = function createFragment(obj) {
  return React.createElement(React.Fragment, null, Object.keys(obj).map(key => React.createElement(React.Fragment, {
    key: key
  }, obj[key])));
};

var _module_$1w = {
  exports: {}
};
/* eslint-disable max-lines, no-console, no-var, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals katex */

var React$1u = _react__default["default"];
var ReactDOM$j = _reactDom__default["default"];
var ReactCreateFragment = createFragment;
var $$2 = $__default["default"];
var _$10 = _underscore__default["default"];
var ApiOptions$n = _perseusApiJsx.Options;
var DragTarget = _reactComponentsDragTargetJsx;
var InlineIcon$f = _componentsInlineIconJsx;
var KatexErrorView = _katexErrorViewJsx;
var PerseusMarkdown$1 = _perseusMarkdownJsx;
var PropCheckBox$c = _componentsPropCheckBoxJsx;
var Util$d = Util$q;
var Widgets = Widgets$5;
var preprocessTex = _utilKatexPreprocessJs;
var PerseusEditor = _perseusEditorJsx;
var WIDGET_PROP_BLACKLIST = _mixinsWidgetPropBlacklistJsx; // like [[snowman input-number 1]]

var widgetPlaceholder = "[[\u2603 {id}]]";
var widgetRegExp = "(\\[\\[\u2603 {id}\\]\\])";
var rWidgetSplit = new RegExp(widgetRegExp.replace("{id}", "[a-z-]+ [0-9]+"), "g");
var shortcutRegexp = /^\[\[([a-z\-]+)$/; // like [[nu, [[int, etc

var ENDS_WITH_A_PARAGRAPH = /(?:\n{2,}|^\n*)$/;
var TRAILING_NEWLINES = /(\n*)$/;
var LEADING_NEWLINES = /^(\n*)/;

var commafyInteger = n => {
  var str = n.toString();

  if (str.length >= 5) {
    str = str.replace(/(\d)(?=(\d{3})+$)/g, "$1{,}");
  }

  return str;
};

var makeEndWithAParagraphIfNecessary = content => {
  if (!ENDS_WITH_A_PARAGRAPH.test(content)) {
    var newlines = TRAILING_NEWLINES.exec(content)[1];
    return content + "\n\n".slice(0, 2 - newlines.length);
  } else {
    return content;
  }
};

var makeStartWithAParagraphAlways = content => {
  var newlines = LEADING_NEWLINES.exec(content)[1];
  return "\n\n".slice(0, 2 - newlines.length) + content;
};

var WidgetSelect = createReactClass({
  displayName: "WidgetSelect",
  shouldComponentUpdate: function shouldComponentUpdate() {
    return false;
  },
  handleChange: function handleChange(e) {
    var widgetType = e.target.value;

    if (widgetType === "") {
      // TODO(alpert): Not sure if change will trigger here
      // but might as well be safe
      return;
    }

    if (this.props.onChange) {
      this.props.onChange(widgetType);
    }
  },
  render: function render() {
    var widgets = Widgets.getPublicWidgets();

    var orderedWidgetNames = _$10.sortBy(_$10.keys(widgets), name => {
      return widgets[name].displayName;
    });

    var addWidgetString = "Add a widget\u2026";
    return /*#__PURE__*/React$1u.createElement("select", {
      value: "",
      onChange: this.handleChange
    }, /*#__PURE__*/React$1u.createElement("option", {
      value: ""
    }, addWidgetString), /*#__PURE__*/React$1u.createElement("option", {
      disabled: true
    }, "--"), _$10.map(orderedWidgetNames, name => {
      return /*#__PURE__*/React$1u.createElement("option", {
        key: name,
        value: name
      }, widgets[name].displayName);
    }));
  }
}); // This component handles upgading widget editor props via prop
// upgrade transforms. Widget editors will always be rendered
// with all available transforms applied, but the results of those
// transforms will not be propogated upwards until serialization.

var WidgetEditor = createReactClass({
  displayName: "WidgetEditor",
  propTypes: {
    // Unserialized props
    id: PropTypes.string.isRequired,
    onChange: PropTypes.func.isRequired,
    onRemove: PropTypes.func.isRequired,
    apiOptions: ApiOptions$n.propTypes,
    // Serialized props
    type: PropTypes.string.isRequired,
    alignment: PropTypes.string,
    static: PropTypes.bool,
    graded: PropTypes.bool,
    options: PropTypes.any,
    version: PropTypes.shape({
      major: PropTypes.number.isRequired,
      minor: PropTypes.number.isRequired
    })
  },
  getInitialState: function getInitialState() {
    return {
      showWidget: false
    };
  },
  componentWillMount: function componentWillMount() {
    this._upgradeWidgetInfo(this.props);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this._upgradeWidgetInfo(nextProps);
  },
  _upgradeWidgetInfo: function _upgradeWidgetInfo(props) {
    // We can't call serialize here because this.refs.widget
    // doesn't exist before this component is mounted.
    var filteredProps = _$10.omit(props, WIDGET_PROP_BLACKLIST);

    var info = Widgets.upgradeWidgetInfoToLatestVersion(filteredProps);
    this.setState({
      widgetInfo: info
    });
  },
  _toggleWidget: function _toggleWidget(e) {
    e.preventDefault();
    this.setState({
      showWidget: !this.state.showWidget
    });
  },
  _handleWidgetChange: function _handleWidgetChange(newProps, cb, silent) {
    var newWidgetInfo = _$10.clone(this.state.widgetInfo);

    newWidgetInfo.options = _$10.extend(this.refs.widget.serialize(), newProps);
    this.props.onChange(newWidgetInfo, cb, silent);
  },
  _toggleStatic: function _toggleStatic(e) {
    e.preventDefault();

    var newWidgetInfo = _$10.extend({}, this.state.widgetInfo, {
      static: !this.state.widgetInfo.static
    });

    this.props.onChange(newWidgetInfo);
  },
  _handleAlignmentChange: function _handleAlignmentChange(e) {
    var newAlignment = e.target.value;

    var newWidgetInfo = _$10.clone(this.state.widgetInfo);

    newWidgetInfo.alignment = newAlignment;
    this.props.onChange(newWidgetInfo);
  },
  render: function render() {
    var widgetInfo = this.state.widgetInfo;
    var Ed = Widgets.getEditor(widgetInfo.type);
    var supportedAlignments;

    if (this.props.apiOptions.showAlignmentOptions) {
      supportedAlignments = Widgets.getSupportedAlignments(widgetInfo.type);
    } else {
      supportedAlignments = ["default"];
    }

    var supportsStaticMode = Widgets.supportsStaticMode(widgetInfo.type);
    var isUngradedEnabled = widgetInfo.type === "transformer";
    var gradedPropBox = /*#__PURE__*/React$1u.createElement(PropCheckBox$c, {
      label: "Graded:",
      graded: widgetInfo.graded,
      onChange: this.props.onChange
    });
    return /*#__PURE__*/React$1u.createElement("div", {
      className: "perseus-widget-editor"
    }, /*#__PURE__*/React$1u.createElement("div", {
      className: "perseus-widget-editor-title " + (this.state.showWidget ? "open" : "closed")
    }, /*#__PURE__*/React$1u.createElement("a", {
      className: "perseus-widget-editor-title-id",
      href: "#",
      onClick: this._toggleWidget
    }, this.props.id, this.state.showWidget ? /*#__PURE__*/React$1u.createElement(InlineIcon$f, iconChevronDown) : /*#__PURE__*/React$1u.createElement(InlineIcon$f, iconChevronRight)), supportsStaticMode && /*#__PURE__*/React$1u.createElement("input", {
      type: "button",
      onClick: this._toggleStatic,
      className: "simple-button--small",
      value: widgetInfo.static ? "Unset as static" : "Set as static"
    }), supportedAlignments.length > 1 && /*#__PURE__*/React$1u.createElement("select", {
      className: "alignment",
      value: widgetInfo.alignment,
      onChange: this._handleAlignmentChange
    }, supportedAlignments.map(alignment => /*#__PURE__*/React$1u.createElement("option", {
      key: alignment
    }, alignment))), /*#__PURE__*/React$1u.createElement("a", {
      href: "#",
      className: "remove-widget " + "simple-button simple-button--small orange",
      onClick: e => {
        e.preventDefault();
        this.props.onRemove();
      }
    }, /*#__PURE__*/React$1u.createElement(InlineIcon$f, iconTrash))), /*#__PURE__*/React$1u.createElement("div", {
      className: "perseus-widget-editor-content " + (this.state.showWidget ? "enter" : "leave")
    }, isUngradedEnabled && gradedPropBox, /*#__PURE__*/React$1u.createElement(Ed, _extends({
      ref: "widget",
      onChange: this._handleWidgetChange,
      static: widgetInfo.static,
      apiOptions: this.props.apiOptions
    }, widgetInfo.options))));
  },
  getSaveWarnings: function getSaveWarnings() {
    var issuesFunc = this.refs.widget.getSaveWarnings;
    return issuesFunc ? issuesFunc() : [];
  },
  serialize: function serialize() {
    // TODO(alex): Make this properly handle the case where we load json
    // with a more recent widget version than this instance of Perseus
    // knows how to handle.
    var widgetInfo = this.state.widgetInfo;
    return {
      type: widgetInfo.type,
      alignment: widgetInfo.alignment,
      static: widgetInfo.static,
      graded: widgetInfo.graded,
      options: this.refs.widget.serialize(),
      version: widgetInfo.version
    };
  }
}); // This is more general than the actual markdown image parsing regex,
// which is fine for correctness since it should only mean we could
// store extra image dimensions, unless the question is insanely
// formatted.
// A simplified regex here should hopefully be easier to keep in
// sync if the markdown parsing changes, though if it becomes
// easy to hook into the actual markdown regex without copy-pasting
// it, we should do that.

var IMAGE_REGEX = /!\[[^\]]*\]\(([^\s\)]+)[^\)]*\)/g;
/**
 * Find all the matches to a /g regex.
 *
 * Returns an array of the regex matches. Infinite loops if `regex` does not
 * have a /g modifier.
 *
 * Note: Returns an array of the capture objects, whereas String::match
 * ignores captures. If you don't need captures, use String::match
 */

var allMatches = function allMatches(regex, str) {
  var result = [];

  while (true) {
    // eslint-disable-line no-constant-condition
    var match = regex.exec(str);

    if (!match) {
      break;
    }

    result.push(match);
  }

  return result;
};
/**
 * Return an array of URLs of all the images in the given renderer
 * markdown.
 */


var imageUrlsFromContent = function imageUrlsFromContent(content) {
  return _$10.map(allMatches(IMAGE_REGEX, content), capture => capture[1]);
};
/**
 * NOTE: This Editor class contains a ton of legacy logic which is not used,
 *        as a rewrite using Draft.js was implemented in perseus-editor.jsx.
 *        This code remains as a backup in case bugs in the rewrite block
 *        content creators.
 *        If you are going to make Editor changes, you likely want to navigate
 *        to perseus-editor.jsx
 * TODO: Clear out all the textarea code and replace with Draft.js once we are
 *       comfortable that it is working well consistently
 */


var Editor$b = createReactClass({
  displayName: "Editor",
  propTypes: {
    apiOptions: ApiOptions$n.propTypes,
    imageUploader: PropTypes.func,
    onChange: PropTypes.func
  },
  getDefaultProps: function getDefaultProps() {
    return {
      content: "",
      placeholder: "",
      widgets: {},
      images: {},
      disabled: false,
      widgetEnabled: true,
      immutableWidgets: false,
      showWordCount: false,
      warnNoPrompt: false,
      warnNoWidgets: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      showKatexErrors: false
    };
  },
  getWidgetEditor: function getWidgetEditor(id, type) {
    if (!Widgets.getEditor(type)) {
      return;
    }

    return /*#__PURE__*/React$1u.createElement(WidgetEditor, _extends({
      ref: id,
      id: id,
      type: type,
      onChange: this._handleWidgetEditorChange.bind(this, id),
      onRemove: this._handleWidgetEditorRemove.bind(this, id),
      apiOptions: this.props.apiOptions
    }, this.props.widgets[id]));
  },
  _handleWidgetEditorChange: function _handleWidgetEditorChange(id, newProps, cb, silent) {
    var widgets = _$10.clone(this.props.widgets);

    widgets[id] = _$10.extend({}, widgets[id], newProps);

    if (this.props.apiOptions.useDraftEditor) {
      this.refs.textarea.updateWidget(id, newProps);
    }

    this.props.onChange({
      widgets: widgets
    }, cb, silent);
  },
  _handleWidgetEditorRemove: function _handleWidgetEditorRemove(id) {
    var textarea = this.refs.textarea;

    if (this.props.apiOptions.useDraftEditor) {
      textarea.removeWidget(id);
    } else {
      var re = new RegExp(widgetRegExp.replace("{id}", id), "gm");
      this.props.onChange({
        content: textarea.value.replace(re, "")
      });
    }
  },

  /**
   * Calculate the size of all the images in props.content, and send
   * those sizes to this.props.images using props.onChange.
   */
  _sizeImages: function _sizeImages(props) {
    var imageUrls = imageUrlsFromContent(props.content); // Discard any images in our dimension table that no
    // longer exist in content.

    var images = _$10.pick(props.images, imageUrls); // Only calculate sizes for images that were not present previously.
    // Most content edits shouldn't have new images.
    // This could get weird in the case of multiple images with the same
    // URL, if you've changed the backing image size, but given graphie
    // hashes it's probably an edge case.


    var newImageUrls = _$10.filter(imageUrls, url => !images[url]); // TODO(jack): Q promises would make this nicer and only
    // fire once.


    _$10.each(newImageUrls, url => {
      Util$d.getImageSize(url, (width, height) => {
        // We keep modifying the same image object rather than a new
        // copy from this.props because all changes here are additive.
        // Maintaining old changes isn't strictly necessary if
        // props.onChange calls are not batched, but would be if they
        // were, so this is nice from that anti-race-condition
        // perspective as well.
        images[url] = {
          width: width,
          height: height
        };
        props.onChange({
          images: _$10.clone(images)
        }, null, // callback
        true // silent
        );
      });
    });
  },
  componentDidMount: function componentDidMount() {
    // This can't be in componentWillMount because that's happening during
    // the middle of our parent's render, so we can't call
    // this.props.onChange during that, since it calls our parent's
    // setState
    this._sizeImages(this.props);

    if (!this.props.apiOptions.useDraftEditor) {
      $$2(ReactDOM$j.findDOMNode(this.refs.textarea)).on("copy cut", this._maybeCopyWidgets).on("paste", this._maybePasteWidgets);
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    // TODO(alpert): Maybe fix React so this isn't necessary
    var textarea = ReactDOM$j.findDOMNode(this.refs.textarea);
    textarea.value = this.props.content; // This can't be in componentWillReceiveProps because that's happening
    // during the middle of our parent's render.

    if (this.props.content !== prevProps.content) {
      this._sizeImages(this.props);
    }
  },
  handleDrop: function handleDrop(e) {
    if (this.props.apiOptions.useDraftEditor) {
      return;
    }

    var content = this.props.content;
    var dataTransfer = e.nativeEvent.dataTransfer; // files will hold something if the drag was from the desktop or a file
    // located on the user's computer.

    var files = dataTransfer.files; // ... but we only get a url if the drag originated in another window

    if (files.length === 0) {
      var imageUrl = dataTransfer.getData("URL");

      if (imageUrl) {
        // TODO(joel) - relocate when the image upload dialog lands
        var newContent = content + "\n\n![](" + imageUrl + ")";
        this.props.onChange({
          content: newContent
        });
      }

      return;
    }
    /* For each file we make sure it's an image, then create a sentinel -
     * snowman + identifier to insert into the current text. The sentinel
     * only lives there temporarily until we get a response back from the
     * server that the image is now hosted on AWS, at which time we replace
     * the temporary sentinel with the permanent url for the image.
     *
     * There is an abuse of tap in the middle of the pipeline to make sure
     * everything is sequenced in the correct order. We want to modify the
     * content (given any number of images) at the same time, i.e. only
     * once, so we do that step with the tap. After the content has been
     * changed we send off the request for each image.
     *
     * Note that the snowman doesn't do anything special in this case -
     * it's effectively just part of a broken link. Perseus could be
     * extended to recognize this sentinel and highlight it like for
     * widgets.
     */


    _$10.chain(files).map(function (file) {
      if (!file.type.match("image.*")) {
        return null;
      }

      var sentinel = "\u2603 " + _$10.uniqueId("image_"); // TODO(joel) - figure out how to temporarily include the image
      // before the server returns.


      content += "\n\n![](" + sentinel + ")";
      return {
        file: file,
        sentinel: sentinel
      };
    }).reject(_$10.isNull).tap(() => {
      this.props.onChange({
        content: content
      });
    }).each(fileAndSentinel => {
      this.props.imageUploader(fileAndSentinel.file, url => {
        this.props.onChange({
          content: this.props.content.replace(fileAndSentinel.sentinel, url)
        });
      });
    });
  },
  handleChange: function handleChange() {
    var textarea = ReactDOM$j.findDOMNode(this.refs.textarea);
    this.props.onChange({
      content: textarea.value
    });
  },
  _handleKeyDown: function _handleKeyDown(e) {
    // Tab-completion of widgets. For example, to insert an image:
    // type `[[im`, then tab.
    if (e.key === "Tab") {
      var textarea = ReactDOM$j.findDOMNode(this.refs.textarea);
      var word = Util$d.textarea.getWordBeforeCursor(textarea);
      var matches = word.string.toLowerCase().match(shortcutRegexp);

      if (matches != null) {
        var text = matches[1];
        var widgets = Widgets.getAllWidgetTypes();

        var matchingWidgets = _$10.filter(widgets, name => {
          return name.substring(0, text.length) === text;
        });

        if (matchingWidgets.length === 1) {
          var widgetType = matchingWidgets[0];

          this._addWidgetToContent(this.props.content, [word.pos.start, word.pos.end + 1], widgetType);
        }

        e.preventDefault();
      }
    }
  },
  _maybeCopyWidgets: function _maybeCopyWidgets(e) {
    // If there are widgets being cut/copied, put the widget JSON in
    // localStorage.perseusLastCopiedWidgets to allow copy-pasting of
    // widgets between Editors. Also store the text to be pasted in
    // localStorage.perseusLastCopiedText since we want to know if the user
    // is actually pasting something originally from Perseus later.
    var textarea = e.target;
    var selectedText = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);

    var widgetNames = _$10.map(selectedText.match(rWidgetSplit), syntax => {
      return Util$d.rWidgetParts.exec(syntax)[1];
    });

    var widgetData = _$10.pick(this.serialize().widgets, widgetNames);

    localStorage.perseusLastCopiedText = selectedText;
    localStorage.perseusLastCopiedWidgets = JSON.stringify(widgetData);
    console.log("Widgets copied: ".concat(localStorage.perseusLastCopiedWidgets));
  },
  _maybePasteWidgets: function _maybePasteWidgets(e) {
    // Use the data from localStorage to paste any widgets we copied
    // before. Avoid name conflicts by renumbering pasted widgets so that
    // their numbers are always higher than the highest numbered widget of
    // their type.
    // TODO(sam): Fix widget numbering in the widget editor titles
    var widgetJSON = localStorage.perseusLastCopiedWidgets;
    var lastCopiedText = localStorage.perseusLastCopiedText;
    var textToBePasted = e.originalEvent.clipboardData.getData("text"); // Only intercept if we have widget data to paste and the user is
    // pasting something originally from Perseus.
    // TODO(sam/aria/alex): Make it so that you can paste arbitrary text
    // (e.g. from a text editor) instead of exactly what was copied, and
    // let the widgetJSON match up with it. This would let you copy text
    // into a buffer, perform complex operations on it, then paste it back.

    if (widgetJSON && lastCopiedText === textToBePasted) {
      e.preventDefault();
      var widgetData = JSON.parse(widgetJSON);

      var safeWidgetMapping = this._safeWidgetNameMapping(widgetData); // Use safe widget name map to construct the new widget data
      // TODO(aria/alex): Don't use `rWidgetSplit` or other piecemeal
      // regexes directly; abstract this out so that we don't have to
      // worry about potential edge cases.


      var safeWidgetData = {};

      for (var [key, data] of Object.entries(widgetData)) {
        safeWidgetData[safeWidgetMapping[key]] = data;
      }

      var newWidgets = _$10.extend(safeWidgetData, this.props.widgets); // Use safe widget name map to construct new text


      var safeText = lastCopiedText.replace(rWidgetSplit, syntax => {
        var match = Util$d.rWidgetParts.exec(syntax);
        var completeWidget = match[0];
        var widget = match[1];
        return completeWidget.replace(widget, safeWidgetMapping[widget]);
      }); // Add pasted text to previous content, replacing selected text to
      // replicate normal paste behavior.

      var textarea = e.target;
      var selectionStart = textarea.selectionStart;
      var newContent = this.props.content.substr(0, selectionStart) + safeText + this.props.content.substr(textarea.selectionEnd);
      this.props.onChange({
        content: newContent,
        widgets: newWidgets
      }, () => {
        var expectedCursorPosition = selectionStart + safeText.length;
        Util$d.textarea.moveCursor(textarea, expectedCursorPosition);
      });
    }
  },
  _safeWidgetNameMapping: function _safeWidgetNameMapping(widgetData) {
    // Helper function for _maybePasteWidgets.
    // For each widget about to be pasted, construct a mapping from
    // old widget name to a new widget name that doesn't have conflicts
    // with widgets already in the editor.
    // eg. If there is an "image 2" already present in the editor and we're
    // about to paste in two new images, return
    // { "image 1": "image 3", "image 2": "image 4" }
    // List of widgets about to be pasted as [[name, number], ...]
    var widgets = _$10.keys(widgetData).map(name => name.split(" "));

    var widgetTypes = _$10.uniq(widgets.map(widget => widget[0])); // List of existing widgets as [[name, number], ...]


    var existingWidgets = _$10.keys(this.props.widgets).map(name => name.split(" ")); // Mapping of widget type to a safe (non-conflicting) number
    // eg. { "image": 2, "dropdown": 1 }


    var safeWidgetNums = {};

    _$10.each(widgetTypes, type => {
      safeWidgetNums[type] = _$10.chain(existingWidgets).filter(existingWidget => existingWidget[0] === type).map(existingWidget => +existingWidget[1] + 1).max().value(); // If there are no existing widgets _.max returns -Infinity

      safeWidgetNums[type] = Math.max(safeWidgetNums[type], 1);
    }); // Construct mapping, incrementing the vals in safeWidgetNums as we go


    var safeWidgetMapping = {};

    _$10.each(widgets, widget => {
      var widgetName = widget.join(" ");
      var widgetType = widget[0];
      safeWidgetMapping[widgetName] = "".concat(widgetType, " ").concat(safeWidgetNums[widgetType]);
      safeWidgetNums[widgetType]++;
    });

    return safeWidgetMapping;
  },
  _addWidgetToContent: function _addWidgetToContent(oldContent, cursorRange, widgetType) {
    var textarea = ReactDOM$j.findDOMNode(this.refs.textarea); // Note: we have to use _.map here instead of Array::map
    // because the results of a .match might be null if no
    // widgets were found.

    var allWidgetIds = _$10.map(oldContent.match(rWidgetSplit), syntax => {
      var match = Util$d.rWidgetParts.exec(syntax);
      var type = match[2];
      var num = +match[3];
      return [type, num];
    });

    var widgetNum = _$10.reduce(allWidgetIds, (currentNum, otherId) => {
      var [otherType, otherNum] = otherId;

      if (otherType === widgetType) {
        return Math.max(otherNum + 1, currentNum);
      } else {
        return currentNum;
      }
    }, 1);

    var id = widgetType + " " + widgetNum;
    var widgetContent = widgetPlaceholder.replace("{id}", id); // Add newlines before block-display widgets like graphs

    var isBlock = Widgets.getDefaultAlignment(widgetType) === "block";
    var prelude = oldContent.slice(0, cursorRange[0]);
    var postlude = oldContent.slice(cursorRange[1]);
    var newPrelude = isBlock ? makeEndWithAParagraphIfNecessary(prelude) : prelude;
    var newPostlude = isBlock ? makeStartWithAParagraphAlways(postlude) : postlude;
    var newContent = newPrelude + widgetContent + newPostlude;

    var newWidgets = _$10.clone(this.props.widgets);

    newWidgets[id] = {
      options: Widgets.getEditor(widgetType).defaultProps,
      type: widgetType,
      // Track widget version on creation, so that a widget editor
      // without a valid version prop can only possibly refer to a
      // pre-versioning creation time.
      version: Widgets.getVersion(widgetType)
    };
    this.props.onChange({
      content: newContent,
      widgets: newWidgets
    }, function () {
      Util$d.textarea.moveCursor(textarea, // We want to put the cursor after the widget
      // and after any added newlines
      newContent.length - postlude.length);
    });
  },
  _addWidget: function _addWidget(widgetType) {
    var textarea = this.refs.textarea;

    if (this.props.apiOptions.useDraftEditor) {
      textarea.addWidget(widgetType);
    } else {
      this._addWidgetToContent(this.props.content, [textarea.selectionStart, textarea.selectionEnd], widgetType);

      textarea.focus();
    }
  },
  // NOTE: These templates are all duplicated verbatim in perseus-editor.jsx
  //        so any changes should also be done there, until this code is all
  //        deleted in favor of perseus-editor.jsx
  addTemplate: function addTemplate(e) {
    var templateType = e.target.value;

    if (templateType === "") {
      return;
    }

    e.target.value = "";

    if (this.props.apiOptions.useDraftEditor) {
      this.refs.textarea.addTemplate(templateType);
      return;
    }

    var oldContent = this.props.content; // Force templates to have a blank line before them,
    // as they are usually used as block elements
    // (especially important for tables)

    oldContent = oldContent.replace(/\n*$/, "\n\n");
    var template;

    if (templateType === "table") {
      template = "header 1 | header 2 | header 3\n" + "- | - | -\n" + "data 1 | data 2 | data 3\n" + "data 4 | data 5 | data 6\n" + "data 7 | data 8 | data 9";
    } else if (templateType === "titledTable") {
      template = "|| **Table title** ||\n" + "header 1 | header 2 | header 3\n" + "- | - | -\n" + "data 1 | data 2 | data 3\n" + "data 4 | data 5 | data 6\n" + "data 7 | data 8 | data 9";
    } else if (templateType === "alignment") {
      template = "$\\begin{align} x+5 &= 30 \\\\\n" + "x+5-5 &= 30-5 \\\\\n" + "x &= 25 \\end{align}$";
    } else if (templateType === "piecewise") {
      template = "$f(x) = \\begin{cases}\n" + "7 & \\text{if }x=1 \\\\\n" + "f(x-1)+5 & \\text{if }x > 1\n" + "\\end{cases}$";
    } else if (templateType === "allWidgets") {
      template = Widgets.getAllWidgetTypes().map(type => "[[".concat(Util$d.snowman, " ").concat(type, " 1]]")).join("\n\n");
    } else {
      throw new Error("Invalid template type: " + templateType);
    }

    var newContent = oldContent + template;
    this.props.onChange({
      content: newContent
    }, this.focusAndMoveToEnd);
  },
  getSaveWarnings: function getSaveWarnings() {
    var widgetIds = _$10.intersection(this.widgetIds, _$10.keys(this.refs));

    var warnings = _$10.chain(widgetIds).map(id => {
      var issuesFunc = this.refs[id].getSaveWarnings;
      var issues = issuesFunc ? issuesFunc() : [];
      return _$10.map(issues, issue => id + ": " + issue);
    }).flatten(true).value();

    return warnings;
  },
  focus: function focus() {
    ReactDOM$j.findDOMNode(this.refs.textarea).focus();
  },
  focusAndMoveToEnd: function focusAndMoveToEnd() {
    this.focus();
    var textarea = ReactDOM$j.findDOMNode(this.refs.textarea);
    textarea.selectionStart = textarea.value.length;
    textarea.selectionEnd = textarea.value.length;
  },
  render: function render() {
    var pieces;
    var widgets;
    var underlayPieces;
    var widgetsDropDown;
    var templatesDropDown;
    var widgetsAndTemplates;
    var wordCountDisplay;
    var katexErrorList = [];

    if (this.props.showWordCount) {
      var numChars = PerseusMarkdown$1.characterCount(this.props.content);
      var numWords = Math.floor(numChars / 6);
      wordCountDisplay = /*#__PURE__*/React$1u.createElement("span", {
        className: "perseus-editor-word-count",
        title: "~" + commafyInteger(numWords) + " words (" + commafyInteger(numChars) + " characters)"
      }, commafyInteger(numWords));
    }

    if (this.props.widgetEnabled) {
      pieces = Util$d.split(this.props.content, rWidgetSplit);
      widgets = {};
      underlayPieces = [];

      for (var i = 0; i < pieces.length; i++) {
        if (i % 2 === 0) {
          // Normal text
          underlayPieces.push(pieces[i]);
          var ast = PerseusMarkdown$1.parse(pieces[i]);
          PerseusMarkdown$1.traverseContent(ast, node => {
            if (node.type === "math" || node.type === "blockMath") {
              var content = preprocessTex(node.content);

              try {
                katex.renderToString(content);
              } catch (e) {
                katexErrorList.push({
                  math: content,
                  message: e.message
                });
              }
            }
          });
        } else {
          // Widget reference
          var match = Util$d.rWidgetParts.exec(pieces[i]);
          var id = match[1];
          var type = match[2];
          var selected = false; // TODO(alpert):
          // var selected = focused && selStart === selEnd &&
          //         offset <= selStart &&
          //         selStart < offset + text.length;
          // if (selected) {
          //     selectedWidget = id;
          // }

          var duplicate = (id in widgets);
          widgets[id] = this.getWidgetEditor(id, type);
          var classes = (duplicate || !widgets[id] ? "error " : "") + (selected ? "selected " : "");
          var key = duplicate ? i : id;
          underlayPieces.push( /*#__PURE__*/React$1u.createElement("b", {
            className: classes,
            key: key
          }, pieces[i]));
        }
      } // TODO(alpert): Move this to the content-change event handler
      // _.each(_.keys(this.props.widgets), function(id) {
      //     if (!(id in widgets)) {
      //         // It's strange if these preloaded options stick around
      //         // since it's inconsistent with how things work if you
      //         // don't have the serialize/deserialize step in the
      //         // middle
      //         // TODO(alpert): Save options in a consistent manner so
      //         // that you can undo the deletion of a widget
      //         delete this.props.widgets[id];
      //     }
      // }, this);


      this.widgetIds = _$10.keys(widgets);
      widgetsDropDown = /*#__PURE__*/React$1u.createElement(WidgetSelect, {
        ref: "widgetSelect",
        onChange: this._addWidget
      });
      var insertTemplateString = "Insert template\u2026";
      templatesDropDown = /*#__PURE__*/React$1u.createElement("select", {
        onChange: this.addTemplate
      }, /*#__PURE__*/React$1u.createElement("option", {
        value: ""
      }, insertTemplateString), /*#__PURE__*/React$1u.createElement("option", {
        disabled: true
      }, "--"), /*#__PURE__*/React$1u.createElement("option", {
        value: "table"
      }, "Table"), /*#__PURE__*/React$1u.createElement("option", {
        value: "titledTable"
      }, "Titled table"), /*#__PURE__*/React$1u.createElement("option", {
        value: "alignment"
      }, "Aligned equations"), /*#__PURE__*/React$1u.createElement("option", {
        value: "piecewise"
      }, "Piecewise function"), /*#__PURE__*/React$1u.createElement("option", {
        disabled: true
      }, "--"), /*#__PURE__*/React$1u.createElement("option", {
        value: "allWidgets"
      }, "All widgets (for testing)"));

      if (!this.props.immutableWidgets) {
        widgetsAndTemplates = /*#__PURE__*/React$1u.createElement("div", {
          className: "perseus-editor-widgets"
        }, /*#__PURE__*/React$1u.createElement("div", {
          className: "perseus-editor-widgets-selectors"
        }, widgetsDropDown, templatesDropDown, wordCountDisplay), ReactCreateFragment(widgets)); // Prevent word count from being displayed elsewhere

        wordCountDisplay = null;
      }
    } else {
      underlayPieces = [this.props.content];
    } // Without this, the underlay isn't the proper size when the text ends
    // with a newline.


    underlayPieces.push( /*#__PURE__*/React$1u.createElement("br", {
      key: "end"
    }));
    var completeTextarea = [/*#__PURE__*/React$1u.createElement("div", {
      className: "perseus-textarea-underlay",
      ref: "underlay",
      key: "underlay"
    }, underlayPieces), /*#__PURE__*/React$1u.createElement("textarea", {
      ref: "textarea",
      key: "textarea",
      onChange: this.handleChange,
      onKeyDown: this._handleKeyDown,
      placeholder: this.props.placeholder,
      disabled: this.props.disabled,
      value: this.props.content
    })];

    if (this.props.apiOptions.useDraftEditor) {
      completeTextarea = /*#__PURE__*/React$1u.createElement(PerseusEditor, {
        ref: "textarea",
        onChange: this.props.onChange,
        content: this.props.content,
        placeholder: this.props.placeholder,
        initialWidgets: this.props.widgets,
        imageUploader: this.props.imageUploader,
        widgetEnabled: this.props.widgetEnabled
      });
    }

    var textareaWrapper;

    if (this.props.imageUploader) {
      textareaWrapper = /*#__PURE__*/React$1u.createElement(DragTarget, {
        onDrop: this.handleDrop,
        className: "perseus-textarea-pair"
      }, completeTextarea);
    } else {
      textareaWrapper = /*#__PURE__*/React$1u.createElement("div", {
        className: "perseus-textarea-pair"
      }, completeTextarea);
    }

    var contentWithoutWidgets = this.props.content.replace(/\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]/g, "");
    var noPrompt = contentWithoutWidgets.trim().length === 0;
    var noWidgets = !/\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]/g.test(this.props.content);
    var warningStyle = {
      borderTop: "none",
      padding: 4,
      backgroundColor: "pink"
    };
    return /*#__PURE__*/React$1u.createElement("div", {
      className: "perseus-single-editor " + (this.props.className || "")
    }, textareaWrapper, katexErrorList.length > 0 && /*#__PURE__*/React$1u.createElement(KatexErrorView, {
      errorList: katexErrorList
    }), this.props.warnNoPrompt && noPrompt && /*#__PURE__*/React$1u.createElement("div", {
      style: warningStyle
    }, "Graded Groups should contain a prompt"), this.props.warnNoWidgets && noWidgets && /*#__PURE__*/React$1u.createElement("div", {
      style: warningStyle
    }, "Graded Groups should contain at least one widget"), wordCountDisplay, widgetsAndTemplates);
  },
  serialize: function serialize(options) {
    // need to serialize the widgets since the state might not be
    // completely represented in props. ahem //transformer// (and
    // interactive-graph and plotter).
    var widgets = {};

    var widgetIds = _$10.intersection(this.widgetIds, _$10.keys(this.refs));

    _$10.each(widgetIds, id => {
      widgets[id] = this.refs[id].serialize();
    }); // Preserve the data associated with deleted widgets in their last
    // modified form. This is only intended to be useful in the context of
    // immediate cut and paste operations if Editor.serialize() is called
    // in between the two (which ideally should not be happening).
    // TODO(alex): Remove this once all widget.serialize() methods
    //             have been fixed to only return props,
    //             and the above no longer applies.


    if (options && options.keepDeletedWidgets) {
      _$10.chain(this.props.widgets).keys().reject(id => _$10.contains(widgetIds, id)).each(id => {
        widgets[id] = this.props.widgets[id];
      });
    }

    return {
      replace: this.props.replace,
      content: this.props.content,
      images: this.props.images,
      widgets: widgets
    };
  }
});
_module_$1w.exports = Editor$b;
var _editorJsx = _module_$1w.exports;

var _module_$1v = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1t = _react__default["default"];
var ReactDOM$i = _reactDom__default["default"];
var _$$ = _underscore__default["default"];
var Util$c = Util$q;
var InfoTip$k = _componentsInfoTipJsx;
var NumberInput$f = _componentsNumberInputJsx;
var Editor$a = _editorJsx;
var Table = _widgetsTableJsx.widget;
var TableEditor = createReactClass({
  displayName: "TableEditor",
  propTypes: {
    rows: PropTypes.number,
    columns: PropTypes.number,
    headers: PropTypes.arrayOf(PropTypes.string),
    answers: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string))
  },
  getDefaultProps: function getDefaultProps() {
    var defaultRows = 4;
    var defaultColumns = 1;

    var blankAnswers = _$$.times(defaultRows, function () {
      return Util$c.stringArrayOfSize(defaultColumns);
    });

    return {
      headers: [""],
      rows: defaultRows,
      columns: defaultColumns,
      answers: blankAnswers
    };
  },
  focus: function focus() {
    ReactDOM$i.findDOMNode(this.refs.numberOfColumns).focus();
  },
  render: function render() {
    var tableProps = _$$.pick(this.props, "headers", "answers", "onChange", "apiOptions");

    _$$.extend(tableProps, {
      editableHeaders: true,
      Editor: Editor$a,
      onFocus: () => {},
      onBlur: () => {},
      trackInteraction: () => {}
    });

    return /*#__PURE__*/React$1t.createElement("div", null, /*#__PURE__*/React$1t.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1t.createElement("label", null, "Number of columns:", " ", /*#__PURE__*/React$1t.createElement(NumberInput$f, {
      ref: "numberOfColumns",
      value: this.props.columns,
      onChange: val => {
        if (val) {
          this.onSizeInput(this.props.rows, val);
        }
      },
      useArrowKeys: true
    }))), /*#__PURE__*/React$1t.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1t.createElement("label", null, "Number of rows:", " ", /*#__PURE__*/React$1t.createElement(NumberInput$f, {
      ref: "numberOfRows",
      value: this.props.rows,
      onChange: val => {
        if (val) {
          this.onSizeInput(val, this.props.columns);
        }
      },
      useArrowKeys: true
    }))), /*#__PURE__*/React$1t.createElement("div", null, " ", "Table of answers:", " ", /*#__PURE__*/React$1t.createElement(InfoTip$k, null, /*#__PURE__*/React$1t.createElement("p", null, "The student has to fill out all cells in the table. For partially filled tables create a table using the template, and insert text input boxes as desired."))), /*#__PURE__*/React$1t.createElement("div", null, /*#__PURE__*/React$1t.createElement(Table, tableProps)));
  },
  onSizeInput: function onSizeInput(numRawRows, numRawColumns) {
    var rows = +numRawRows || 0;
    var columns = +numRawColumns || 0;
    rows = Math.min(Math.max(1, rows), 30);
    columns = Math.min(Math.max(1, columns), 6);
    var oldColumns = this.props.columns;
    var oldRows = this.props.rows;
    var answers = this.props.answers; // Truncate if necessary; else, append

    if (rows <= oldRows) {
      answers.length = rows;
    } else {
      _$$.times(rows - oldRows, function () {
        answers.push(Util$c.stringArrayOfSize(oldColumns));
      });
    }

    function fixColumnSizing(array) {
      // Truncate if necessary; else, append
      if (columns <= oldColumns) {
        array.length = columns;
      } else {
        _$$.times(columns - oldColumns, function () {
          array.push("");
        });
      }
    }

    var headers = this.props.headers;
    fixColumnSizing(headers);

    _$$.each(answers, fixColumnSizing);

    this.props.onChange({
      rows: rows,
      columns: columns,
      answers: answers,
      headers: headers
    });
  },
  serialize: function serialize() {
    var json = _$$.pick(this.props, "headers", "rows", "columns");

    return _$$.extend({}, json, {
      answers: _$$.map(this.props.answers, _$$.clone)
    });
  }
});
_module_$1v.exports = TableEditor;
var _widgetsTableEditorJsx = _module_$1v.exports;

var _module_$1u = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1s = _react__default["default"];
var _$_ = _underscore__default["default"];
var InfoTip$j = _componentsInfoTipJsx;
var PropCheckBox$b = _componentsPropCheckBoxJsx;
var TextListEditor$4 = _componentsTextListEditorJsx;
var HORIZONTAL$4 = "horizontal";
var VERTICAL$4 = "vertical";
var SorterEditor = createReactClass({
  displayName: "SorterEditor",
  propTypes: {
    correct: PropTypes.array,
    layout: PropTypes.oneOf([HORIZONTAL$4, VERTICAL$4]),
    padding: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      correct: ["$x$", "$y$", "$z$"],
      layout: HORIZONTAL$4,
      padding: true
    };
  },
  render: function render() {
    var editor = this;
    return /*#__PURE__*/React$1s.createElement("div", null, /*#__PURE__*/React$1s.createElement("div", null, " ", "Correct answer:", " ", /*#__PURE__*/React$1s.createElement(InfoTip$j, null, /*#__PURE__*/React$1s.createElement("p", null, "Enter the correct answer (in the correct order) here. The preview on the right will have the cards in a randomized order, which is how the student will see them."))), /*#__PURE__*/React$1s.createElement(TextListEditor$4, {
      options: this.props.correct,
      onChange: function onChange(options, cb) {
        editor.props.onChange({
          correct: options
        }, cb);
      },
      layout: this.props.layout
    }), /*#__PURE__*/React$1s.createElement("div", null, /*#__PURE__*/React$1s.createElement("label", null, " ", "Layout:", " ", /*#__PURE__*/React$1s.createElement("select", {
      value: this.props.layout,
      onChange: this.onLayoutChange
    }, /*#__PURE__*/React$1s.createElement("option", {
      value: HORIZONTAL$4
    }, "Horizontal"), /*#__PURE__*/React$1s.createElement("option", {
      value: VERTICAL$4
    }, "Vertical"))), /*#__PURE__*/React$1s.createElement(InfoTip$j, null, /*#__PURE__*/React$1s.createElement("p", null, "Use the horizontal layout for short text and small images. The vertical layout is best for longer text and larger images."))), /*#__PURE__*/React$1s.createElement("div", null, /*#__PURE__*/React$1s.createElement(PropCheckBox$b, {
      label: "Padding:",
      padding: this.props.padding,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$1s.createElement(InfoTip$j, null, /*#__PURE__*/React$1s.createElement("p", null, "Padding is good for text, but not needed for images."))));
  },
  onLayoutChange: function onLayoutChange(e) {
    this.props.onChange({
      layout: e.target.value
    });
  },
  serialize: function serialize() {
    return _$_.pick(this.props, "correct", "layout", "padding");
  }
});
_module_$1u.exports = SorterEditor;
var _widgetsSorterEditorJsx = _module_$1u.exports;

var _module_$1t = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types, react/prop-types, react/sort-comp */

var React$1r = _react__default["default"];
var ReactDOM$h = _reactDom__default["default"];
var _$Z = _underscore__default["default"];
var Util$b = Util$q;
var Renderer$g = _rendererJsx;
var ApiClassNames$9 = _perseusApiJsx.ClassNames;
var Gorgon$1 = _gorgonGorgonJs;
var HORIZONTAL$3 = "horizontal";
var VERTICAL$3 = "vertical";
var STATIC = "static";
var DRAGGING = "dragging";
var ANIMATING = "animating";
var DISABLED = "disabled"; // A placeholder that appears in the sortable whenever an item is dragged.

var Placeholder = createReactClass({
  displayName: "Placeholder",
  propTypes: {
    layout: PropTypes.oneOf([HORIZONTAL$3, VERTICAL$3]),
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired
  },
  render: function render() {
    var {
      layout
    } = this.props;
    var className = aphrodite.css(styles$i.card, styles$i.placeholder, layout === HORIZONTAL$3 && styles$i.horizontalCard);
    var style = {
      width: this.props.width,
      height: this.props.height
    };

    if (this.props.margin != null) {
      style.margin = this.props.margin;
    }

    return /*#__PURE__*/React$1r.createElement("li", {
      className: className,
      style: style
    });
  }
}); // A draggable item in the sortable. Can be in one of four states:
//     Static:    The item is not being interacted with.
//     Dragging:  The item is being dragged.
//     Animating: The item has been released, and is moving to its destination.
//     Disabled:  The item cannot be interacted with.
//
// Usual flow:      Static -> Dragging -> Animating -> Static
// [Dis|en]abling:  Static|Dragging|Animating -> Disabled -> Static

var Draggable = createReactClass({
  displayName: "Draggable",
  propTypes: {
    content: PropTypes.string.isRequired,
    endPosition: PropTypes.object.isRequired,
    includePadding: PropTypes.bool,
    layout: PropTypes.oneOf([HORIZONTAL$3, VERTICAL$3]),
    onAnimationEnd: PropTypes.func.isRequired,
    onMouseDown: PropTypes.func.isRequired,
    onMouseMove: PropTypes.func.isRequired,
    onMouseUp: PropTypes.func.isRequired,
    onRender: PropTypes.func.isRequired,
    type: PropTypes.oneOf([STATIC, DRAGGING, ANIMATING, DISABLED]),
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      includePadding: true,
      type: STATIC,
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      startPosition: {
        left: 0,
        top: 0
      },
      startMouse: {
        left: 0,
        top: 0
      },
      mouse: {
        left: 0,
        top: 0
      }
    };
  },
  componentDidMount: function componentDidMount() {
    this.isMouseMoveUpBound = false;
  },
  componentWillUnmount: function componentWillUnmount() {
    // Event handlers should be unbound before component unmounting, but
    // just in case...
    if (this.isMouseMoveUpBound) {
      this.unbindMouseMoveUp();
    }
  },
  getCurrentPosition: function getCurrentPosition() {
    return {
      left: this.state.startPosition.left + this.state.mouse.left - this.state.startMouse.left,
      top: this.state.startPosition.top + this.state.mouse.top - this.state.startMouse.top
    };
  },
  render: function render() {
    var {
      includePadding,
      layout,
      type
    } = this.props; // We need to keep backwards compatbility with rules specified directly
    // in CSS. Hence the hacky tacking on of manual classNames.
    // See sortable.less for details.

    var className = aphrodite.css(styles$i.card, styles$i.draggable, layout === HORIZONTAL$3 && styles$i.horizontalCard, layout === VERTICAL$3 && styles$i.verticalCard, type === DRAGGING && styles$i.dragging, type === ANIMATING && styles$i.animating, type === DISABLED && styles$i.disabled, !includePadding && styles$i.unpaddedCard) + " " + ApiClassNames$9.INTERACTIVE + " perseus-sortable-draggable";

    if (!includePadding) {
      className += " perseus-sortable-draggable-unpadded";
    }

    var style = {
      position: "static"
    };

    if (this.props.type === DRAGGING || this.props.type === ANIMATING) {
      _$Z.extend(style, {
        position: "absolute"
      }, this.getCurrentPosition());
    }

    if (this.props.width) {
      style.width = this.props.width + 1; // Fix for non-integer widths
    }

    if (this.props.height) {
      style.height = this.props.height;
    }

    if (this.props.margin != null) {
      style.margin = this.props.margin;
    }

    return /*#__PURE__*/React$1r.createElement("li", {
      className: className,
      style: style,
      onMouseDown: this.onMouseDown,
      onTouchStart: this.onMouseDown,
      onTouchMove: this.onMouseMove,
      onTouchEnd: this.onMouseUp,
      onTouchCancel: this.onMouseUp
    }, /*#__PURE__*/React$1r.createElement(Renderer$g, {
      content: this.props.content,
      linterContext: Gorgon$1.pushContextStack(this.props.linterContext, 'draggable'),
      onRender: this.props.onRender
    }));
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    if (this.props.type === prevProps.type) {
      return;
    }

    if (this.props.type === ANIMATING) {
      // Start animating
      var current = this.getCurrentPosition();
      var duration = 15 * Math.sqrt(Math.sqrt(Math.pow(this.props.endPosition.left - current.left, 2) + Math.pow(this.props.endPosition.top - current.top, 2)));
      $(ReactDOM$h.findDOMNode(this)).animate(this.props.endPosition, {
        duration: Math.max(duration, 1),
        // Animating -> Static
        complete: this.props.onAnimationEnd
      });
    } else if (this.props.type === STATIC) {
      // Ensure that any animations are done
      $(ReactDOM$h.findDOMNode(this)).finish();
    }
  },
  bindMouseMoveUp: function bindMouseMoveUp() {
    this.isMouseMoveUpBound = true;
    $(document).on("mousemove", this.onMouseMove);
    $(document).on("mouseup", this.onMouseUp);
  },
  unbindMouseMoveUp: function unbindMouseMoveUp() {
    this.isMouseMoveUpBound = false;
    $(document).off("mousemove", this.onMouseMove);
    $(document).off("mouseup", this.onMouseUp);
  },
  onMouseDown: function onMouseDown(event) {
    if (this.props.type !== STATIC) {
      return;
    }

    if (!(event.button === 0 || event.touches != null && event.touches.length === 1)) {
      return;
    }

    event.preventDefault();
    var loc = Util$b.extractPointerLocation(event);

    if (loc) {
      this.setState({
        startPosition: $(ReactDOM$h.findDOMNode(this)).position(),
        startMouse: loc,
        mouse: loc
      }, function () {
        this.bindMouseMoveUp(); // Static -> Dragging

        this.props.onMouseDown();
      });
    }
  },
  onMouseMove: function onMouseMove(event) {
    if (this.props.type !== DRAGGING) {
      return;
    }

    event.preventDefault();
    var loc = Util$b.extractPointerLocation(event);

    if (loc) {
      this.setState({
        mouse: loc
      }, this.props.onMouseMove);
    }
  },
  onMouseUp: function onMouseUp(event) {
    if (this.props.type !== DRAGGING) {
      return;
    }

    event.preventDefault();
    var loc = Util$b.extractPointerLocation(event);

    if (loc) {
      this.unbindMouseMoveUp(); // Dragging -> Animating

      this.props.onMouseUp();
    }
  }
}); // The main sortable component.

var Sortable$2 = createReactClass({
  displayName: "Sortable",
  propTypes: {
    constraints: PropTypes.object,
    disabled: PropTypes.bool,
    layout: PropTypes.oneOf([HORIZONTAL$3, VERTICAL$3]),
    margin: PropTypes.number,
    onChange: PropTypes.func,
    onMeasure: PropTypes.func,
    options: PropTypes.array.isRequired,
    padding: PropTypes.bool,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      layout: HORIZONTAL$3,
      padding: true,
      disabled: false,
      constraints: {},
      onMeasure: function onMeasure() {},
      margin: 5,
      onChange: function onChange() {},
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      items: this.itemsFromProps(this.props)
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var prevProps = this.props;

    if (!_$Z.isEqual(nextProps.options, prevProps.options)) {
      // Regenerate items
      this.setState({
        items: this.itemsFromProps(nextProps)
      });
    } else if (nextProps.layout !== prevProps.layout || nextProps.padding !== prevProps.padding || nextProps.disabled !== prevProps.disabled || !_$Z.isEqual(nextProps.constraints, prevProps.constraints)) {
      // Clear item measurements
      this.setState({
        items: this.clearItemMeasurements(this.state.items)
      });
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    // Measure items if their dimensions have been reset
    if (this.state.items.length && !this.state.items[0].width) {
      this.measureItems();
    }
  },
  itemsFromProps: function itemsFromProps(props) {
    var type = props.disabled ? DISABLED : STATIC;
    return _$Z.map(props.options, function (option, i) {
      return {
        option: option,
        key: i,
        type: type,
        endPosition: {},
        width: 0,
        height: 0
      };
    });
  },
  clearItemMeasurements: function clearItemMeasurements(items) {
    return _$Z.map(items, function (item) {
      return _$Z.extend(item, {
        width: 0,
        height: 0
      });
    });
  },
  measureItems: function measureItems() {
    // Measure all items and cache what their dimensions should be, taking
    // into account constraints and the current layout. This allows syncing
    // widths and heights for pretty rows/columns. Note that dimensions are
    // explictly set on Draggables - this prevents them from changing size
    // or shape while being dragged.
    var items = _$Z.clone(this.state.items);

    var $items = _$Z.map(items, function (item) {
      return $(ReactDOM$h.findDOMNode(this.refs[item.key]));
    }, this);

    var widths = _$Z.invoke($items, "outerWidth");

    var heights = _$Z.invoke($items, "outerHeight");

    var constraints = this.props.constraints;
    var layout = this.props.layout;
    var syncWidth;

    if (constraints.width) {
      // Items must be at least as wide as the specified constraint
      syncWidth = _$Z.max(widths.concat(constraints.width));
    } else if (layout === VERTICAL$3) {
      // Sync widths to get a clean column
      syncWidth = _$Z.max(widths);
    }

    var syncHeight;

    if (constraints.height) {
      // Items must be at least as high as the specified constraint
      syncHeight = _$Z.max(heights.concat(constraints.height));
    } else if (layout === HORIZONTAL$3) {
      // Sync widths to get a clean row
      syncHeight = _$Z.max(heights);
    }

    items = _$Z.map(items, function (item, i) {
      item.width = syncWidth || widths[i];
      item.height = syncHeight || heights[i];
      return item;
    });
    this.setState({
      items: items
    }, () => {
      this.props.onMeasure({
        widths: widths,
        heights: heights
      });
    });
  },
  remeasureItems: _$Z.debounce(function () {
    this.setState({
      // Clear item measurements
      items: this.clearItemMeasurements(this.state.items)
    });
  }, 20),
  render: function render() {
    var cards = [];
    var {
      layout
    } = this.props; // We need to keep backwards compatbility with rules specified directly
    // in CSS. See sortable.less for details.

    var className = aphrodite.css(styles$i.sortable) + " perseus-sortable";

    _$Z.each(this.state.items, function (item, i, items) {
      var isLast = i === items.length - 1;
      var isStatic = item.type === STATIC || item.type === DISABLED;
      var margin;

      if (this.props.layout === HORIZONTAL$3) {
        margin = "0 " + this.props.margin + "px 0 0"; // right
      } else if (this.props.layout === VERTICAL$3) {
        margin = "0 0 " + this.props.margin + "px 0"; // bottom
      }

      cards.push( /*#__PURE__*/React$1r.createElement(Draggable, {
        content: item.option,
        key: item.key,
        type: item.type,
        ref: item.key,
        width: item.width,
        height: item.height,
        layout: layout,
        includePadding: this.props.padding,
        margin: isLast && isStatic ? 0 : margin,
        endPosition: item.endPosition,
        linterContext: Gorgon$1.pushContextStack(this.props.linterContext, 'sortable'),
        onRender: this.remeasureItems,
        onMouseDown: this.onMouseDown.bind(this, item.key),
        onMouseMove: this.onMouseMove.bind(this, item.key),
        onMouseUp: this.onMouseUp.bind(this, item.key),
        onTouchMove: this.onMouseMove.bind(this, item.key),
        onTouchEnd: this.onMouseUp.bind(this, item.key),
        onTouchCancel: this.onMouseUp.bind(this, item.key),
        onAnimationEnd: this.onAnimationEnd.bind(this, item.key)
      }));

      if (item.type === DRAGGING || item.type === ANIMATING) {
        cards.push( /*#__PURE__*/React$1r.createElement(Placeholder, {
          key: "placeholder_" + item.key,
          ref: "placeholder_" + item.key,
          width: item.width,
          height: item.height,
          layout: layout,
          margin: isLast ? 0 : margin
        }));
      }
    }, this);

    return /*#__PURE__*/React$1r.createElement("ul", {
      className: className
    }, cards);
  },
  onMouseDown: function onMouseDown(key) {
    // Static -> Dragging
    var items = _$Z.map(this.state.items, function (item) {
      if (item.key === key) {
        item.type = DRAGGING;
      }

      return item;
    });

    this.setState({
      items: items
    });
  },
  onMouseMove: function onMouseMove(key) {
    // Dragging: Rearrange items based on draggable's position
    var $draggable = $(ReactDOM$h.findDOMNode(this.refs[key]));
    var $sortable = $(ReactDOM$h.findDOMNode(this));

    var items = _$Z.clone(this.state.items);

    var item = _$Z.findWhere(this.state.items, {
      key: key
    });

    var margin = this.props.margin;

    var currentIndex = _$Z.indexOf(items, item);

    var newIndex = 0;
    items.splice(currentIndex, 1);

    if (this.props.layout === HORIZONTAL$3) {
      var midWidth = $draggable.offset().left - $sortable.offset().left;
      var sumWidth = 0;
      var cardWidth;

      _$Z.each(items, function (item) {
        cardWidth = item.width;

        if (midWidth > sumWidth + cardWidth / 2) {
          newIndex += 1;
        }

        sumWidth += cardWidth + margin;
      });
    } else {
      var midHeight = $draggable.offset().top - $sortable.offset().top;
      var sumHeight = 0;
      var cardHeight;

      _$Z.each(items, function (item) {
        cardHeight = item.height;

        if (midHeight > sumHeight + cardHeight / 2) {
          newIndex += 1;
        }

        sumHeight += cardHeight + margin;
      });
    }

    if (newIndex !== currentIndex) {
      items.splice(newIndex, 0, item);
      this.setState({
        items: items
      });
    }
  },
  onMouseUp: function onMouseUp(key) {
    // Dragging -> Animating
    var items = _$Z.map(this.state.items, function (item) {
      if (item.key === key) {
        item.type = ANIMATING;
        item.endPosition = $(ReactDOM$h.findDOMNode(this.refs["placeholder_" + key])).position();
      }

      return item;
    }, this);

    this.setState({
      items: items
    }); // HACK: We need to know *that* the widget changed, but currently it's
    // not set up in a nice way to tell us *how* it changed, since the
    // permutation of the items is stored in state.

    this.props.onChange({});
  },
  onAnimationEnd: function onAnimationEnd(key) {
    // Animating -> Static
    var items = _$Z.map(this.state.items, function (item) {
      if (item.key === key) {
        item.type = STATIC;
      }

      return item;
    });

    this.setState({
      items: items
    });
  },
  getOptions: function getOptions() {
    return _$Z.pluck(this.state.items, "option");
  }
});
var styles$i = aphrodite.StyleSheet.create({
  sortable: {
    boxSizing: "border-box",
    float: "left",
    padding: 0,
    margin: 0
  },
  card: {
    boxSizing: "border-box",
    background: "#fff",
    border: "1px solid #ddd",
    borderRadius: 4,
    cursor: "pointer",
    minWidth: 25,
    minHeight: 44,
    padding: 10,
    listStyleType: "none",
    userSelect: "none",
    touchAction: "none"
  },
  placeholder: {
    background: "#ddd",
    border: "1px solid #ccc"
  },
  draggable: {
    textAlign: "center"
  },
  horizontalCard: {
    float: "left",
    cursor: "ew-resize"
  },
  verticalCard: {
    maxWidth: "100%",
    cursor: "ns-resize"
  },
  unpaddedCard: {
    padding: 0
  },
  dragging: {
    background: "#ffedcd",
    opacity: "0.8"
  },
  disabled: {
    backgroundColor: "inherit",
    border: "1px solid transparent",
    cursor: "default"
  }
});
_module_$1t.exports = Sortable$2;
var _componentsSortableJsx = _module_$1t.exports;

var _module_$1s = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, one-var, react/forbid-prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1q = _react__default["default"];
var _$Y = _underscore__default["default"];
var Sortable$1 = _componentsSortableJsx;
var ApiOptions$m = _perseusApiJsx.Options;
var shuffle$2 = Util$q.shuffle;
var HORIZONTAL$2 = "horizontal",
    VERTICAL$2 = "vertical";
var Sorter = createReactClass({
  displayName: "Sorter",
  propTypes: {
    apiOptions: ApiOptions$m.propTypes,
    correct: PropTypes.array,
    layout: PropTypes.oneOf([HORIZONTAL$2, VERTICAL$2]),
    onChange: PropTypes.func,
    padding: PropTypes.bool,
    problemNum: PropTypes.number,
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      correct: [],
      layout: HORIZONTAL$2,
      padding: true,
      problemNum: 0,
      onChange: function onChange() {},
      linterContext: linterContextDefault
    };
  },
  render: function render() {
    var options = shuffle$2(this.props.correct, this.props.problemNum,
    /* ensurePermuted */
    true);
    var marginPx = this.props.apiOptions.isMobile ? 8 : 5;
    return /*#__PURE__*/React$1q.createElement("div", {
      className: "perseus-widget-sorter perseus-clearfix"
    }, /*#__PURE__*/React$1q.createElement(Sortable$1, {
      options: options,
      layout: this.props.layout,
      margin: marginPx,
      padding: this.props.padding,
      onChange: this.handleChange,
      linterContext: this.props.linterContext,
      ref: "sortable"
    }));
  },
  handleChange: function handleChange(e) {
    this.props.onChange(e);
    this.props.trackInteraction();
  },
  getUserInput: function getUserInput() {
    return {
      options: this.refs.sortable.getOptions()
    };
  },
  simpleValidate: function simpleValidate(rubric) {
    return Sorter.validate(this.getUserInput(), rubric);
  }
});

_$Y.extend(Sorter, {
  validate: function validate(state, rubric) {
    var correct = _$Y.isEqual(state.options, rubric.correct);

    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
});

_module_$1s.exports = {
  name: "sorter",
  displayName: "Sorter",
  widget: Sorter,
  isLintable: true
};
var _widgetsSorterJsx = _module_$1s.exports;

var _module_$1r = {
  exports: {}
};
/* eslint-disable comma-dangle, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals i18n */

var React$1p = _react__default["default"];
var _$X = _underscore__default["default"];
var Changeable$E = Changeable$Q;
var EditorJsonify$i = _mixinsEditorJsonifyJsx;
var InfoTip$i = _componentsInfoTipJsx;
var NumberInput$e = _componentsNumberInputJsx;
var maxTrials = 5000;
var SimulatorEditor = createReactClass({
  displayName: "SimulatorEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$E.propTypes), {}, {
    xAxisLabel: PropTypes.string,
    yAxisLabel: PropTypes.string,
    numTrials: PropTypes.number,
    proportionLabel: PropTypes.string,
    proportionOrPercentage: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      xAxisLabel: "Proportion (%)",
      yAxisLabel: "Number of times seen",
      numTrials: 100,
      proportionLabel: "Underlying proportion",
      proportionOrPercentage: "proportion"
    };
  },
  render: function render() {
    return /*#__PURE__*/React$1p.createElement("div", {
      className: "perseus-widget-simulator"
    }, /*#__PURE__*/React$1p.createElement("div", null, i18n._("X-Axis Label"), ":", /*#__PURE__*/React$1p.createElement("input", {
      type: "text",
      className: "graph-settings-axis-label",
      value: this.props.xAxisLabel,
      onChange: _$X.partial(this.handleTargetValueChange, "xAxisLabel")
    })), /*#__PURE__*/React$1p.createElement("div", null, i18n._("Y-Axis Label"), ":", /*#__PURE__*/React$1p.createElement("input", {
      type: "text",
      className: "graph-settings-axis-label",
      value: this.props.yAxisLabel,
      onChange: _$X.partial(this.handleTargetValueChange, "yAxisLabel")
    })), /*#__PURE__*/React$1p.createElement("div", null, i18n._('"True Proportion" Label'), ":", /*#__PURE__*/React$1p.createElement("input", {
      type: "text",
      className: "graph-settings-axis-label",
      value: this.props.proportionLabel,
      onChange: _$X.partial(this.handleTargetValueChange, "proportionLabel")
    }), /*#__PURE__*/React$1p.createElement(InfoTip$i, null, /*#__PURE__*/React$1p.createElement("p", null, "This text will be displayed next to the box in which the user enters the sample proportion for their simulation. For example, if your question is about surveying for approval ratings, you might want this to say \"Sample approval rating\"."))), /*#__PURE__*/React$1p.createElement("div", null, i18n._("Proportion or Percentage"), ":", /*#__PURE__*/React$1p.createElement("select", {
      className: "perseus-widget-dropdown",
      value: this.props.proportionOrPercentage,
      onChange: _$X.partial(this.handleTargetValueChange, "proportionOrPercentage")
    }, /*#__PURE__*/React$1p.createElement("option", {
      key: "proportion",
      value: "proportion"
    }, "Proportion"), /*#__PURE__*/React$1p.createElement("option", {
      key: "percentage",
      value: "percentage"
    }, "Percentage")), /*#__PURE__*/React$1p.createElement(InfoTip$i, null, /*#__PURE__*/React$1p.createElement("p", null, "Do you want the user to describe their simulation in terms of a proportion or a percentage?"))), /*#__PURE__*/React$1p.createElement("div", null, i18n._("Number of trials"), ":", /*#__PURE__*/React$1p.createElement(NumberInput$e, {
      value: this.props.numTrials,
      checkValidity: val => {
        return val >= 0 && val <= maxTrials;
      },
      onChange: this.change("numTrials")
    }), /*#__PURE__*/React$1p.createElement(InfoTip$i, null, /*#__PURE__*/React$1p.createElement("p", null, "This controls the number of trials used in the simulation. For example, if you set this to 50, then the survey will be conducted 50 times. Warning: setting this too high (i.e., greater than 5000 or so) will freeze the page."))));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$E.change.apply(this, args);
  },

  handleTargetValueChange: function handleTargetValueChange(propName, e) {
    this.change(propName, e.target.value);
  },

  serialize() {
    return EditorJsonify$i.serialize.call(this);
  }

});
_module_$1r.exports = SimulatorEditor;
var _widgetsSimulatorEditorJsx = _module_$1r.exports;

var _module_$1q = {
  exports: {}
};
/* eslint-disable comma-dangle, indent, no-unused-vars, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp, space-unary-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals $_, i18n */

var InfoTip$h = _componentsInfoTipJsx;
var React$1o = _react__default["default"];
var ReactDOM$g = _reactDom__default["default"];
var _$W = _underscore__default["default"];
var Changeable$D = Changeable$Q;
var ApiOptions$l = _perseusApiJsx.Options;
var assert$2 = InteractiveUtil$7.assert;
var Graphie$4 = _componentsGraphieJsx;
var {
  Path,
  Arc,
  Circle,
  Label: Label$1,
  Line: Line$2,
  MovablePoint: MovablePoint$3,
  MovableLine: MovableLine$2
} = Graphie$4;
var NumberInput$d = _componentsNumberInputJsx;
var MathOutput$3 = _componentsMathOutputJsx;
var Util$a = Util$q;
var knumber$5 = _kmath3.number;
var KhanColors$6 = _utilColorsJs;
var KhanMath$3 = _utilMathJs;
var defaultBoxSize$2 = 400;
var maxSampleSize = 1000;
var Histogram = createReactClass({
  displayName: "Histogram",
  propTypes: {
    data: PropTypes.arrayOf(PropTypes.number),
    xAxisLabel: PropTypes.string,
    yAxisLabel: PropTypes.string,
    box: PropTypes.arrayOf(PropTypes.number)
  },
  getDefaultProps: function getDefaultProps() {
    return {
      data: null,
      xAxisLabel: "Proportion (%)",
      yAxisLabel: "Number of times seen",
      box: [defaultBoxSize$2, defaultBoxSize$2]
    };
  },
  getInitialState: function getInitialState() {
    return {
      threshold: this._getInitialThreshold(this._range())
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    // Reset the threshold if the range has changed
    var oldRange = this._range();

    var nextRange = this._range(nextProps);

    if (!Util$a.deepEq(oldRange, nextRange)) {
      this.setState({
        threshold: this._getInitialThreshold(nextRange)
      });
    }
  },

  /* Renders the vertical line that users can drag across the histogram. */
  _renderThresholdLine: function _renderThresholdLine() {
    // Recall the the y-range goes from [-1, yMax] to allow for ticks on
    // the x-axis.
    var yRange = [0, this._range()[1][1]];

    var coords = _$W.map(yRange, y => [this.state.threshold, y]); // Returns an inivisble, placeholder coord that anchors the line


    var invisiblePointForCoord = (coord, i) => {
      return /*#__PURE__*/React$1o.createElement(MovablePoint$3, {
        key: i,
        static: true,
        coord: coord,
        normalStyle: {
          stroke: "none",
          fill: "none"
        }
      });
    };

    return /*#__PURE__*/React$1o.createElement(MovableLine$2, {
      onMove: this.handleMouseInteraction
    }, _$W.map(coords, invisiblePointForCoord));
  },

  /* Renders the shaded circle in the top right. */
  _renderCircle: function _renderCircle() {
    var data = this.props.data; // Get proportion of results below threshold

    var total = _$W.reduce(data, (sum, next) => {
      return sum + next;
    }, 0);

    var numBelow = _$W.reduce(data, (sum, next, i) => {
      if (this.state.threshold != null && i <= this.state.threshold) {
        return sum + next;
      } else {
        return sum;
      }
    }, 0);

    var proportionBelow = numBelow / total; // This is a hack around the arc taking angles modulo 360.
    // TODO(charlie): Find a better way around this.

    var epsilon = 1e-5;
    var radius = 20;
    var center = [this.props.box[0] - 1.5 * radius, 1.5 * radius]; // Plot little circle

    var plotBelowCircle = () => {
      var options = {
        key: "below",
        center: center,
        radius: radius,
        startAngle: 0,
        endAngle: proportionBelow < 1 ? 360 * proportionBelow : 360 - epsilon,
        sector: proportionBelow !== 1,
        unscaled: true,
        style: {
          fill: KhanColors$6.LIGHT_RED,
          stroke: KhanColors$6.RED
        }
      };
      return /*#__PURE__*/React$1o.createElement(Arc, options);
    };

    var plotAboveCircle = () => {
      var options = {
        key: "above",
        center: center,
        radius: radius,
        startAngle: proportionBelow > 0 ? 360 * proportionBelow : epsilon,
        endAngle: 360,
        sector: proportionBelow !== 0,
        unscaled: true,
        style: {
          fill: KhanColors$6.LIGHT_BLUE,
          stroke: KhanColors$6.BLUE
        }
      };
      return /*#__PURE__*/React$1o.createElement(Arc, options);
    }; // Plot the label below the circle


    var xRange = this._range()[0];

    var formattedThreshold = Math.min(Math.max(this.state.threshold, xRange[0]), xRange[1]).toFixed(2);

    var plotLabel = () => {
      var options = {
        key: "label",
        coord: [center[0], center[1] + 1.5 * radius],
        text: numBelow + " of " + total + " results below " + formattedThreshold + "%",
        direction: "center",
        tex: false,
        unscaled: true,
        style: {
          fontSize: "12px"
        }
      };
      return /*#__PURE__*/React$1o.createElement(Label$1, options);
    };

    return [proportionBelow > 0 && plotBelowCircle(), proportionBelow < 1 && plotAboveCircle(), plotLabel()];
  },

  /* Renders the actual bars of the histogram. */
  _renderData: function _renderData() {
    var data = this.props.data;

    this._range(); // Plot bars


    var barWidth = 1;

    var pathForData = (count, i) => {
      // Avoid plotting bars of height 0, else you get a thick blue line
      // over the x-axis. We don't filter these out of the data passed in
      // to this function, however, to preserve absolute indices.
      if (!count) {
        return;
      }

      var isBelow = this.state.threshold != null && i <= this.state.threshold;
      var style = {
        fill: isBelow ? KhanColors$6.LIGHT_RED : KhanColors$6.LIGHT_BLUE,
        stroke: isBelow ? KhanColors$6.RED : KhanColors$6.BLUE
      };
      var coords = [[i, 0], [i, count], [i + barWidth, count], [i + barWidth, 0]];
      return /*#__PURE__*/React$1o.createElement(Path, {
        key: i,
        coords: coords,
        style: style
      });
    };

    return _$W.map(data, pathForData);
  },
  render: function render() {
    var data = this.props.data;

    var range = this._range();

    var options = {
      xAxisLabel: this.props.xAxisLabel,
      yAxisLabel: this.props.yAxisLabel,
      box: this.props.box,
      range: range,
      data: data,
      scale: [Util$a.scaleFromExtent(range[0], this.props.box[0]), Util$a.scaleFromExtent(range[1], this.props.box[1])]
    };
    var axisStyle = {
      stroke: "#000",
      strokeWidth: 1,
      opacity: 1.0
    };
    var origin = [range[0][0], 0];
    var bottomRight = [range[0][1], 0];
    return /*#__PURE__*/React$1o.createElement(Graphie$4, {
      box: options.box,
      range: options.range,
      options: options,
      setup: this._setupGraphie,
      onMouseMove: this.handleMouseInteraction,
      onMouseDown: this.handleMouseInteraction,
      setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
    }, /*#__PURE__*/React$1o.createElement(Line$2, {
      start: origin,
      end: bottomRight,
      style: axisStyle
    }), data && this._renderData(), data && this._renderCircle(), data && this._renderThresholdLine());
  },
  _setupGraphie: function _setupGraphie(graphie, options) {
    var data = options.data;
    var range = options.range;
    var scale = options.scale;
    /* Plot the bars that run parallel to the x-axis. */

    var xWidth = range[0][1] - range[0][0];
    var yWidth = range[1][1] - 0;
    var maxYAxisEntities = 20;
    var ySkip = Math.ceil(yWidth / maxYAxisEntities);

    _$W.each(_$W.range(0, range[1][1], ySkip), y => {
      // If there's no data, we don't label the axes
      if (data) {
        graphie.label([range[0][0], y], KhanMath$3.roundToApprox(y, 2), "left",
        /* isTeX */
        true
        /* for the \approx symbol */
        );
      }

      graphie.line([range[0][0], y], [range[0][1], y], {
        stroke: "#000",
        strokeWidth: 1,
        opacity: 0.3
      });
    }); // If there's no data, we don't label the x-axis at all


    if (data) {
      // Plot the labels below the bars
      var maxXAxisEntities = 15;
      var xSkip = Math.ceil(xWidth / maxXAxisEntities);

      _$W.each(_$W.range(range[0][0], range[0][1], xSkip), x => {
        graphie.label([x, 0], knumber$5.round(x, 2), "below", true);
        var tickHeight = 8;
        graphie.line([x, 0], [x, -tickHeight / scale[1]], {
          stroke: "#000",
          strokeWidth: 1
        });
      });
    } // Add y axis (x axis is added later to overlap the bars)


    var axisStyle = {
      stroke: "#000",
      strokeWidth: 2,
      opacity: 1.0
    };
    var origin = [range[0][0], 0];
    var topLeft = [range[0][0], range[1][1]];
    graphie.line(origin, topLeft, axisStyle); // Add axis labels

    var xMid = range[0][0] + xWidth / 2;
    var xOffset = data ? 25 : 0;
    graphie.label([xMid, -xOffset / scale[1]], options.xAxisLabel, "below", false).css("font-weight", "bold");
    var yMid = 0 + yWidth / 2;
    var yOffset = data ? 55 : 28;
    graphie.label([range[0][0] - yOffset / scale[0], yMid], options.yAxisLabel, "center", false).css("font-weight", "bold").css("-webkit-transform", "rotate(-90deg)");
  },
  handleMouseInteraction: function handleMouseInteraction(point) {
    this.setState({
      threshold: point[0]
    });
  },

  /* Convenience functions that help calculate props based on other props. */
  _range: function _range(props) {
    var defaultRange = [[0, 100], [-1, 10]];
    props = props || this.props;
    return props.data ? this._getRangeForData(props.data) : defaultRange;
  },
  _getRangeForData: function _getRangeForData(data) {
    // Find first/last non-zero entry and add some padding
    var padding = 10;

    var firstIndex = _$W.indexOf(data, _$W.find(data, n => n > 0));

    var xMin = Math.max(0, firstIndex - padding);

    var lastIndex = _$W.lastIndexOf(data, _$W.last(_$W.filter(data, n => n > 0)));

    var xMax = Math.min(100 + 1, lastIndex + 1 + padding); // The y-axis is bounded above by largest value, and below by 0.
    // However, the 'range' of the y-axis goes as low as -1 to allow
    // Graphie to draw ticks on the x-Axis that extend vertically below
    // y = 0.

    var yMin = -1;

    var yMax = _$W.max(data);

    return [[xMin, xMax], [yMin, yMax]];
  },
  _getInitialThreshold: function _getInitialThreshold(range) {
    // We pick a pretty-looking threshold, 1/3 of the way along the axis
    var xRange = range[0];
    return xRange[0] + (xRange[1] - xRange[0]) / 3;
  }
});
var Simulator = createReactClass({
  displayName: "Simulator",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$D.propTypes), {}, {
    apiOptions: ApiOptions$l.propTypes,
    data: PropTypes.arrayOf(PropTypes.number),
    numTrials: PropTypes.number,
    proportionLabel: PropTypes.string,
    proportionOrPercentage: PropTypes.string,
    randomSeed: PropTypes.number,
    sampleSize: PropTypes.number,
    trackInteraction: PropTypes.func.isRequired,
    userProportion: PropTypes.number,
    xAxisLabel: PropTypes.string,
    yAxisLabel: PropTypes.string
  }),
  getInitialState: function getInitialState() {
    return {
      invalidInput: false
    };
  },
  getDefaultProps: function getDefaultProps() {
    return {
      data: null,
      userProportion: null,
      sampleSize: null,
      numTrials: null,
      randomSeed: 0,
      xAxisLabel: "Proportion (%)",
      yAxisLabel: "Number of times seen",
      proportionLabel: "Underlying proportion",
      proportionOrPercentage: "proportion",
      apiOptions: ApiOptions$l.defaults
    };
  },
  componentWillMount: function componentWillMount() {
    if (this.props.randomSeed != null) {
      this.generateNumber = Util$a.seededRNG(this.props.randomSeed);
    }
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.randomSeed !== this.props.randomSeed) {
      this.generateNumber = Util$a.seededRNG(nextProps.randomSeed);
    }
  },
  render: function render() {
    var inputStyle = {
      marginLeft: "5px"
    };
    var highlight = "0px 0px 0px 2px rgba(255, 165, 0, 1)";

    var highlightStyle = _$W.extend({}, inputStyle, {
      WebkitBoxShadow: highlight,
      MozBoxShadow: highlight,
      boxShadow: highlight,
      transition: "all 0.15s"
    });

    var unhighlightStyle = _$W.extend({}, inputStyle, {
      transition: "all 0.15s"
    });

    var style = this.state.invalidInput ? highlightStyle : unhighlightStyle;
    var InputComponent = this.props.apiOptions.staticRender ? MathOutput$3 : NumberInput$d;
    var proportionInput = /*#__PURE__*/React$1o.createElement("div", null, /*#__PURE__*/React$1o.createElement(InputComponent, {
      ref: "userProportion",
      style: style,
      value: this.calculateDisplayProportion(),
      checkValidity: this.checkProportionValidity,
      disabled: this.props.apiOptions.readOnly,
      onChange: this.handleUserProportionChange,
      onFocus: () => this.props.onFocus(["userProportion"]),
      onBlur: () => this.props.onBlur(["userProportion"])
    }), /*#__PURE__*/React$1o.createElement(InfoTip$h, null, /*#__PURE__*/React$1o.createElement("p", null, "This controls the proportion or percentage that will be used in your simulation.")));
    var sampleSizeInput = /*#__PURE__*/React$1o.createElement("div", null, /*#__PURE__*/React$1o.createElement(InputComponent, {
      ref: "sampleSize",
      style: style,
      value: this.props.sampleSize,
      checkValidity: val => val >= 0,
      disabled: this.props.apiOptions.readOnly,
      onChange: this.handleSampleSizeChange,
      onFocus: () => this.props.onFocus(["sampleSize"]),
      onBlur: () => this.props.onBlur(["sampleSize"])
    }), /*#__PURE__*/React$1o.createElement(InfoTip$h, null, /*#__PURE__*/React$1o.createElement("p", null, "This controls the sample size that will be used in your simulation. For example, if you set this to 100, then for each trial, responses from 100 participants will be simulated.")));
    var numTrialsDisplay = /*#__PURE__*/React$1o.createElement("div", {
      style: {
        textAlign: "right"
      }
    }, /*#__PURE__*/React$1o.createElement("b", null, this.props.numTrials), /*#__PURE__*/React$1o.createElement(InfoTip$h, null, /*#__PURE__*/React$1o.createElement("p", null, "This is the number of trials used in the simulation. For example, if set to 50, then the survey will be conducted 50 times."))); // Generates a table from a set of titles and values.

    var generateTable = contents => {
      var header = /*#__PURE__*/React$1o.createElement("thead", null, /*#__PURE__*/React$1o.createElement("tr", null, /*#__PURE__*/React$1o.createElement("th", null, "Parameter"), /*#__PURE__*/React$1o.createElement("th", null, "Value")));
      var body = /*#__PURE__*/React$1o.createElement("tbody", null, _$W.map(contents, (row, i) => {
        return /*#__PURE__*/React$1o.createElement("tr", {
          key: i
        }, /*#__PURE__*/React$1o.createElement("td", null, row.title), /*#__PURE__*/React$1o.createElement("td", null, row.value));
      }));
      return /*#__PURE__*/React$1o.createElement("table", null, header, body);
    }; // Contents for the table to-be generated


    var contents = [{
      title: this.props.proportionLabel + ":",
      value: proportionInput
    }, {
      title: "Sample size:",
      value: sampleSizeInput
    }, {
      title: "Number of trials:",
      value: numTrialsDisplay
    }]; // The 'Run Simulation' button

    var buttonStyle = {
      margin: "20px 0"
    };
    var startButton = /*#__PURE__*/React$1o.createElement("button", {
      className: "simple-button",
      style: buttonStyle,
      disabled: this.props.apiOptions.readOnly,
      onClick: this.handleRunSimulation
    }, i18n._("Run simulation")); // When we plot data, ticks on the x-axis require some vertical padding

    var histogramStyle = {
      paddingBottom: this.props.data ? 40 : 0
    };
    var histogram = /*#__PURE__*/React$1o.createElement("div", {
      style: histogramStyle
    }, /*#__PURE__*/React$1o.createElement(Histogram, {
      data: this.props.data,
      xAxisLabel: this.props.xAxisLabel,
      yAxisLabel: this.props.yAxisLabel,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }));
    return /*#__PURE__*/React$1o.createElement("div", null, generateTable(contents), startButton, histogram);
  },
  calculateDisplayProportion: function calculateDisplayProportion() {
    var userProportion = this.props.userProportion; // If we want to display as a percentage, multiply proportion by 100.0.

    if (this.props.proportionOrPercentage === "percentage") {
      return Math.round(100 * userProportion);
    } else {
      return userProportion;
    }
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$D.change.apply(this, args);
  },

  checkProportionValidity: function checkProportionValidity(value) {
    return value >= 0.0 && this.props.proportionOrPercentage === "proportion" && value <= 1.0 || this.props.proportionOrPercentage === "percentage" && value <= 100.0;
  },
  handleUserProportionChange: function handleUserProportionChange(value, cb) {
    var userProportion; // If "percentage" mode is enabled, user will have entered value as
    // a percentage. However, we always store as a proportion, so we cast.

    if (this.props.proportionOrPercentage === "percentage") {
      userProportion = value / 100.0;
    } else {
      userProportion = value;
    } // If they entered a number, we may need to cap it


    if (userProportion != null) {
      userProportion = Math.min(1.0, Math.max(0.0, userProportion));
    }

    this.props.onChange({
      userProportion: userProportion
    }, cb);
  },
  handleSampleSizeChange: function handleSampleSizeChange(sampleSize, cb) {
    if (sampleSize != null) {
      sampleSize = Math.min(maxSampleSize, Math.max(0, Math.floor(sampleSize)));
    }

    this.props.onChange({
      sampleSize: sampleSize
    }, cb);
  },
  handleRunSimulation: function handleRunSimulation() {
    // If they haven't filled out a parameter field, highlight it.
    if (this.props.numTrials == null || this.props.userProportion == null || this.props.sampleSize == null) {
      this.setState({
        invalidInput: true
      });
      return;
    } else {
      this.setState({
        invalidInput: false
      });
    }

    this.props.onChange({
      data: this.generateData()
    });
    this.props.trackInteraction();
  },
  generateData: function generateData(props) {
    props = props || this.props;

    var getSampleDistribution = (sampleSize, numTrials, proportion) => {
      var draw = () => {
        return this.generateNumber() < proportion;
      };

      var sampleDistribution = _$W.times(100 + 1, () => 0);

      _$W.times(numTrials, () => {
        var results = _$W.times(sampleSize, draw);

        var count = _$W.filter(results, _$W.identity).length;

        var normalizedCount = Math.floor(100 * count / sampleSize);
        sampleDistribution[normalizedCount]++;
      });

      return sampleDistribution;
    };

    return getSampleDistribution(props.sampleSize, props.numTrials, props.userProportion);
  },

  /* InputPath API */
  getInputPaths: function getInputPaths() {
    return [["userProportion"], ["sampleSize"]];
  },
  focus: function focus() {
    var path = _$W.head(this.getInputPaths());

    this.focusInputPath(path);
    return true;
  },
  focusInputPath: function focusInputPath(path) {
    assert$2(path.length > 0);

    var inputID = _$W.head(path);

    var inputComponent = this.refs[inputID];
    inputComponent.focus();
  },
  blurInputPath: function blurInputPath(path) {
    assert$2(path.length > 0);

    var inputID = _$W.head(path);

    var inputComponent = this.refs[inputID];
    inputComponent.blur();
  },
  getDOMNodeForPath: function getDOMNodeForPath(path) {
    assert$2(path.length > 0);

    var inputID = _$W.head(path);

    return ReactDOM$g.findDOMNode(this.refs[inputID]);
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(path) {
    assert$2(path.length > 0);
    return "number";
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    assert$2(path.length > 0);

    var inputID = _$W.head(path);

    var capitalizedID = inputID.charAt(0).toUpperCase() + inputID.slice(1);
    var functionName = "handle" + capitalizedID + "Change";
    this[functionName](newValue, cb);
  },
  getUserInput: function getUserInput() {
    return null;
  },
  simpleValidate: function simpleValidate(rubric) {
    return Simulator.validate(this.getUserInput(), rubric);
  }
});

_$W.extend(Simulator, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

var propTransform$4 = editorProps => {
  var widgetProps = _$W.clone(editorProps);

  widgetProps.randomSeed = editorProps.problemNum;
  return widgetProps;
};

_module_$1q.exports = {
  name: "simulator",
  displayName: "Simulator",
  widget: Simulator,
  transform: propTransform$4,
  hidden: true
};
var _widgetsSimulatorJsx = _module_$1q.exports;

var _module_$1p = {
  exports: {}
};
/* eslint-disable comma-dangle, no-alert, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1n = _react__default["default"];
var _$V = _underscore__default["default"];
var ApiOptions$k = _perseusApiJsx.Options;
var Editor$9 = _editorJsx;
var InlineIcon$e = _componentsInlineIconJsx;
var StepControlButton = createReactClass({
  displayName: "StepControlButton",
  render: function render() {
    return /*#__PURE__*/React$1n.createElement("a", {
      href: "#",
      className: "step-control-button " + "simple-button " + "simple-button--small " + "orange",
      onClick: e => {
        e.preventDefault();
        this.props.onClick();
      }
    }, /*#__PURE__*/React$1n.createElement(InlineIcon$e, this.props.icon));
  }
});
var SequenceEditor = createReactClass({
  displayName: "SequenceEditor",
  propTypes: {
    json: PropTypes.arrayOf(PropTypes.shape({
      content: PropTypes.string,
      widgets: PropTypes.object,
      images: PropTypes.object
    })),
    apiOptions: ApiOptions$k.propTypes,
    onChange: PropTypes.func.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return {
      json: [{
        content: "",
        widgets: {},
        images: {}
      }]
    };
  },
  render: function render() {
    return /*#__PURE__*/React$1n.createElement("div", {
      className: "perseus-sequence-editor"
    }, _$V.map(this.props.json, (json, i) => {
      return /*#__PURE__*/React$1n.createElement("div", {
        key: i
      }, "Step ", i + 1, /*#__PURE__*/React$1n.createElement("div", {
        style: {
          display: "inline-block",
          float: "right"
        }
      }, i + 1 < this.props.json.length && /*#__PURE__*/React$1n.createElement(StepControlButton, {
        icon: iconCircleArrowDown,
        onClick: () => {
          this._handleMoveStepLater(i);
        }
      }), i > 0 && /*#__PURE__*/React$1n.createElement(StepControlButton, {
        icon: iconCircleArrowUp,
        onClick: () => {
          this._handleMoveStepEarlier(i);
        }
      }), /*#__PURE__*/React$1n.createElement(StepControlButton, {
        icon: iconTrash,
        onClick: () => {
          var msg = "Are you sure you " + "want to remove step " + (i + 1) + "?";

          if (confirm(msg)) {
            this._handleRemoveStep(i);
          }
        }
      }), /*#__PURE__*/React$1n.createElement(StepControlButton, {
        icon: iconPlus,
        onClick: () => {
          this._handleAddStepAfter(i);
        }
      })), /*#__PURE__*/React$1n.createElement(Editor$9, {
        ref: "editor" + i,
        apiOptions: this.props.apiOptions,
        content: json.content,
        widgets: json.widgets,
        images: json.images,
        widgetEnabled: true,
        immutableWidgets: false,
        onChange: _$V.partial(this._handleEditorChange, i)
      }));
    }));
  },
  _handleEditorChange: function _handleEditorChange(i, newProps) {
    var steps = _$V.clone(this.props.json);

    steps[i] = _$V.extend({}, steps[i], newProps);
    this.props.onChange({
      json: steps
    });
  },
  serialize: function serialize() {
    return {
      json: _$V.times(this.props.json.length, i => {
        return this.refs["editor" + i].serialize();
      })
    };
  },
  _handleMoveStepEarlier: function _handleMoveStepEarlier(i) {
    if (i === 0) {
      return;
    }

    var steps = _$V.clone(this.props.json);

    var step = steps[i];
    steps.splice(i, 1);
    steps.splice(i - 1, 0, step);
    this.props.onChange({
      json: steps
    });
  },
  _handleMoveStepLater: function _handleMoveStepLater(i) {
    var steps = _$V.clone(this.props.json);

    if (i + 1 === steps.length) {
      return;
    }

    var step = steps[i];
    steps.splice(i, 1);
    steps.splice(i + 1, 0, step);
    this.props.onChange({
      json: steps
    });
  },
  _handleAddStepAfter: function _handleAddStepAfter(i) {
    // We do a full serialization here because we
    // might be copying widgets:
    var steps = _$V.clone(this.props.json); // Here we do magic to allow you to copy-paste
    // things from the previous section into the new
    // section while preserving widgets.
    // To enable this, we preserve the widgets
    // object for the new section, but wipe out
    // the content.


    var newStep = i >= 0 ? {
      widgets: steps[i].widgets
    } : {};
    steps.splice(i + 1, 0, newStep);
    this.props.onChange({
      json: steps
    });
  },
  _handleRemoveStep: function _handleRemoveStep(i) {
    var steps = _$V.clone(this.props.json);

    steps.splice(i, 1);
    this.props.onChange({
      json: steps
    });
  }
});
_module_$1p.exports = SequenceEditor;
var _widgetsSequenceEditorJsx = _module_$1p.exports;

var _module_$1o = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1m = _react__default["default"];
var _$U = _underscore__default["default"];
var ApiOptions$j = _perseusApiJsx.Options;
var Changeable$C = Changeable$Q;
var InlineIcon$d = _componentsInlineIconJsx;
var Renderer$f = _rendererJsx;
var Util$9 = Util$q;
var Sequence = createReactClass({
  displayName: "Sequence",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$C.propTypes), {}, {
    apiOptions: ApiOptions$j.propTypes,
    json: PropTypes.arrayOf(PropTypes.shape({
      content: PropTypes.string,
      images: PropTypes.object,
      widgets: PropTypes.object
    })),
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      json: [{
        content: "",
        widgets: {},
        images: {}
      }],
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      visible: 1
    };
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  },
  render: function render() {
    var icon = /*#__PURE__*/React$1m.createElement(InlineIcon$d, _extends({}, iconOk, {
      style: {
        color: "green"
      }
    }));

    var content = _$U.chain(this.props.json).first(this.state.visible).map((step, i) => "[[".concat(Util$9.snowman, " group ").concat(i, "]]")).join("\n\n").value();

    var widgets = {};

    _$U.each(this.props.json, (step, i) => {
      var widgetId = "group ".concat(i);
      widgets[widgetId] = {
        type: "group",
        graded: true,
        version: {
          major: 0,
          minor: 0
        },
        options: _$U.extend({}, step, {
          icon: i < this.state.visible - 1 ? icon : null
        })
      };
    });

    return /*#__PURE__*/React$1m.createElement("div", {
      className: "perseus-sequence"
    }, /*#__PURE__*/React$1m.createElement(Renderer$f, {
      ref: "renderer",
      content: content,
      widgets: widgets,
      onInteractWithWidget: this._handleInteraction,
      apiOptions: this.props.apiOptions,
      linterContext: this.props.linterContext
    }));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$C.change.apply(this, args);
  },

  _handleInteraction: function _handleInteraction(groupWidgetId) {
    var step = parseInt(groupWidgetId.split(" ")[1]);

    if (step === this.state.visible - 1) {
      var widget = this.refs.renderer.getWidgetInstance("group " + step);
      widget.showRationalesForCurrentlySelectedChoices();
      var score = widget.simpleValidate();

      if (score.type === "points" && score.total === score.earned) {
        this.setState({
          visible: this.state.visible + 1
        });
        this.props.trackInteraction({
          visible: this.state.visible + 1
        });
      }
    }
  }
});

var traverseChildWidgets$3 = function traverseChildWidgets(props, traverseRenderer) {
  var oldJson = props.json;

  if (!_$U.isArray(oldJson)) {
    oldJson = [oldJson];
  }

  var json = _$U.map(oldJson, rendererOptions => {
    return traverseRenderer(rendererOptions);
  });

  return _$U.extend({}, props, {
    json: json
  });
};

_module_$1o.exports = {
  name: "sequence",
  displayName: "Graded Sequence",
  widget: Sequence,
  traverseChildWidgets: traverseChildWidgets$3,
  tracking: "all",
  hidden: true,
  isLintable: true
};
var _widgetsSequenceJsx = _module_$1o.exports;

var _excluded$1 = ["labelText"];
var _module_$1n = {
  exports: {}
};
/* eslint-disable react/sort-comp */

var React$1l = _react__default["default"];
var ReactDOM$f = _reactDom__default["default"];
var TextInput$a = createReactClass({
  displayName: "TextInput",
  propTypes: {
    value: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    className: PropTypes.string,
    labelText: PropTypes.string,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    disabled: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      value: "",
      disabled: false
    };
  },
  render: function render() {
    var _this$props = this.props,
        {
      labelText
    } = _this$props,
        props = _objectWithoutProperties(_this$props, _excluded$1);

    return /*#__PURE__*/React$1l.createElement("input", _extends({}, props, {
      type: "text",
      "aria-label": labelText,
      onChange: e => this.props.onChange(e.target.value)
    }));
  },
  focus: function focus() {
    ReactDOM$f.findDOMNode(this).focus();
  },
  blur: function blur() {
    ReactDOM$f.findDOMNode(this).blur();
  },
  getValue: function getValue() {
    return ReactDOM$f.findDOMNode(this).value;
  },
  getStringValue: function getStringValue() {
    return ReactDOM$f.findDOMNode(this).value.toString();
  },
  setSelectionRange: function setSelectionRange(selectionStart, selectionEnd) {
    ReactDOM$f.findDOMNode(this).setSelectionRange(selectionStart, selectionEnd);
  },
  getSelectionStart: function getSelectionStart() {
    return ReactDOM$f.findDOMNode(this).selectionStart;
  },
  getSelectionEnd: function getSelectionEnd() {
    return ReactDOM$f.findDOMNode(this).selectionEnd;
  }
});
_module_$1n.exports = TextInput$a;
var _componentsTextInputJsx = _module_$1n.exports;

var _module_$1m = {
  exports: {}
};
/* eslint-disable brace-style, no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1k = _react__default["default"];
var Changeable$B = Changeable$Q;
var EditorJsonify$h = _mixinsEditorJsonifyJsx;
var NumberInput$c = _componentsNumberInputJsx;
var TextInput$9 = _componentsTextInputJsx;
var ReactionDiagramWidgetEditor = createReactClass({
  displayName: "ReactionDiagramWidgetEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$B.propTypes), {}, {
    rotationAngle: PropTypes.arrayOf(PropTypes.number),
    separators: PropTypes.arrayOf(PropTypes.object),
    smiles: PropTypes.arrayOf(PropTypes.string)
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      smiles: ["", ""],
      rotationAngle: [0, 0],
      separators: [{
        type: "right",
        topText: "",
        bottomText: ""
      }]
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$B.change.apply(this, args);
  },

  updateMolecule: function updateMolecule(idx) {
    return function (newValue) {
      var newSmiles = [...this.props.smiles];
      newSmiles[idx] = newValue;
      this.change({
        smiles: newSmiles
      });
    }.bind(this);
  },
  updateRotation: function updateRotation(idx) {
    return function (newValue) {
      var newRot = [...this.props.rotationAngle];
      newRot[idx] = newValue;
      this.change({
        rotationAngle: newRot
      });
    }.bind(this);
  },
  updateSeparators: function updateSeparators(idx, propName) {
    return newValue => {
      var newSep = this.props.separators.map(sep => {
        return _objectSpread2({}, sep);
      });
      newSep[idx][propName] = newValue;
      this.change({
        separators: newSep
      });
    };
  },

  serialize() {
    return EditorJsonify$h.serialize.call(this);
  },

  render: function render() {
    // TODO(colin): use styling instead of &nbsp hacks.
    return /*#__PURE__*/React$1k.createElement("div", null, /*#__PURE__*/React$1k.createElement("div", null, /*#__PURE__*/React$1k.createElement("label", null, "LHS SMILES:\xA0", /*#__PURE__*/React$1k.createElement(TextInput$9, {
      onChange: this.updateMolecule(0),
      value: this.props.smiles[0]
    }))), /*#__PURE__*/React$1k.createElement("div", null, /*#__PURE__*/React$1k.createElement("label", null, "LHS Rotation (deg):\xA0", /*#__PURE__*/React$1k.createElement(NumberInput$c, {
      onChange: this.updateRotation(0),
      value: this.props.rotationAngle[0]
    }))), /*#__PURE__*/React$1k.createElement("div", null, /*#__PURE__*/React$1k.createElement("label", null, "RHS SMILES:\xA0", /*#__PURE__*/React$1k.createElement(TextInput$9, {
      onChange: this.updateMolecule(1),
      value: this.props.smiles[1]
    }))), /*#__PURE__*/React$1k.createElement("div", null, /*#__PURE__*/React$1k.createElement("label", null, "RHS Rotation (deg):\xA0", /*#__PURE__*/React$1k.createElement(NumberInput$c, {
      onChange: this.updateRotation(1),
      value: this.props.rotationAngle[1]
    }))), /*#__PURE__*/React$1k.createElement("div", null, /*#__PURE__*/React$1k.createElement("label", null, "Top of arrow text:\xA0", /*#__PURE__*/React$1k.createElement(TextInput$9, {
      onChange: this.updateSeparators(0, "topText"),
      value: this.props.separators[0].topText
    }))), /*#__PURE__*/React$1k.createElement("div", null, /*#__PURE__*/React$1k.createElement("label", null, "Bottom of arrow text:\xA0", /*#__PURE__*/React$1k.createElement(TextInput$9, {
      onChange: this.updateSeparators(0, "bottomText"),
      value: this.props.separators[0].bottomText
    }))));
  }
});
_module_$1m.exports = ReactionDiagramWidgetEditor;
var _widgetsReactionDiagramEditorJsx = _module_$1m.exports;

var _module_$1l = {
  exports: {}
};
// can parse.  In addition to serving as a sort of validation, this also keeps
// out unimplemented features (like cycles and stereochemistry), which use
// additional characters.

var smilesRe = new RegExp("^[A-Za-z\\[\\]()=#+-]*$"); // Regexp defining what characters are valid as atom names.  This includes
// common 1-character elements, Cl and Br for convenience, and the open
// bracket, which can be used to include anything as an atom name.

var atomRe = new RegExp("^(Cl|Br|[CONPSFBI]|\\[)");

function ParseError$1(message) {
  this.message = message;
}
/**
 * Perform a functional update of a possibly nested object.
 *
 * Args:
 *     obj: an object, will not be modified
 *     keylist: a list of keys whose values will be updated in the object.
 *         This represents a path to a value inside nested objects.  For
 *         example, if keylist == ["a", "b", "c"], then a new object is
 *         returned with obj["a"]["b"]["c"] updated.  Note that if any of the
 *         keys is not already present, this will insert {} as a default value
 *         for that key.
 *     val: the new value to associate with the keypath
 *
 * Return: a new object, which is a shallow copy of the original with the value
 *     at the specified keypath replaced.
 */


function _mset(obj, keylist, val) {
  var k0 = keylist[0];
  var rest = keylist.slice(1);
  var newObj;

  if (Array.isArray(obj)) {
    newObj = [...obj];
  } else {
    newObj = _objectSpread2({}, obj || {});
  }

  var newVal = val;

  if (rest.length > 0) {
    newVal = _mset(newObj[k0], rest, val);
  }

  newObj[k0] = newVal;
  return newObj;
}
/**
 * Perform a functional increment of a value in a nested object.
 *
 * Args:
 *     obj: an object; this will not be modified
 *     keylist: a list of keys representing a path into a nested object.  (See
 *         `_mset` for examples.)
 *
 * Return:
 *     an object that is a shallow copy of obj, with the value at the specified
 *     path incremeneted.
 */


function _inc(obj, keylist) {
  var val = keylist.reduce(function (acc, elt) {
    return acc[elt];
  }, obj);
  return _mset(obj, keylist, val + 1);
}

function validate$1(smiles) {
  return smilesRe.test(smiles);
}
/**
 * Parse a bond modifier character, updating the context object so that the
 * next bond created has this modifier.
 */


function parseBondModifier(smiles, ctx) {
  var firstChar = smiles[0];
  var rest = smiles.slice(1);

  if (firstChar === "=") {
    return parse$2(rest, _mset(ctx, ["bond", "bondType"], "double"));
  } else if (firstChar === "#") {
    return parse$2(rest, _mset(ctx, ["bond", "bondType"], "triple"));
  }

  throw new ParseError$1("Invalid character: " + firstChar);
}
/**
 * Slice the input string, removing a parenthesized expression.
 * (Will handle nested parentheses.)
 *
 * parenStack should be a list containing any open parentheses already
 * encountered.  (Usually, this will be ["("])
 */


function sliceFromMatchingCloseParen(smiles, parenStack) {
  if (parenStack.length === 0) {
    return smiles;
  }

  if (smiles === "") {
    throw new ParseError$1("Mismatched parentheses");
  }

  var firstChar = smiles[0];
  var rest = smiles.slice(1);

  if (firstChar === "(") {
    return sliceFromMatchingCloseParen(rest, parenStack.concat(firstChar));
  }

  if (firstChar === ")") {
    return sliceFromMatchingCloseParen(rest, parenStack.slice(1));
  }

  return sliceFromMatchingCloseParen(rest, parenStack);
}
/**
 * Parse a branch, as indicated by the presence of a parenthesized experession.
 *
 * This returns a list of all branches (including the continuation of the
 * backbone) that should be added to the previous atom's bond list.
 */


function parseParenthesizedExpression(smiles, ctx) {
  var firstChar = smiles[0];
  var rest = smiles.slice(1);

  if (firstChar === "(") {
    var newCtx = _objectSpread2(_objectSpread2({}, ctx), {}, {
      parens: ctx.parens + "("
    }); // increment the branch index


    newCtx = _inc(ctx, ["idx", ctx.idx.length - 1, 1]);
    var inBranchIdx = -1;

    if (ctx.idx[ctx.idx.length - 1][0] % 2 === 0) {
      // HACK(colin): this is so that we preserve the odd/even series in
      // indices in branches; the layout engine uses this to select
      // angles, and if we don't do this, editing one part of a molecule
      // can cause another to flop around oddly.
      // TODO(colin): this should just start at 0 all the time, and the
      // layout engine should figure out continuity.
      inBranchIdx = 0;
    }

    var parenCtx = _objectSpread2(_objectSpread2({}, newCtx), {}, {
      idx: newCtx.idx.concat([[inBranchIdx, 0]]),
      parens: newCtx.parens.concat("(")
    });

    var parenExpr = parse$2(rest, parenCtx);
    var remainder = parse$2(sliceFromMatchingCloseParen(rest, ["("]), newCtx);
    return [parenExpr].concat(remainder);
  } else if (firstChar === ")") {
    if (ctx.parens[ctx.parens.length - 1] !== "(") {
      throw new ParseError$1("Mismatched parentheses");
    }

    return null;
  } else {
    throw new ParseError$1("Invalid bare character: " + firstChar);
  }
}
/**
 * Get the symbol of the next atom in the molecule.
 *
 * Return a 2-element list containing that symbol and the remainder of the
 * molecule.
 */


function readAtomSymbol(smiles, _ctx) {
  var sym = null;
  var rest = null;

  if (smiles[0] === "[") {
    var closingIdx = smiles.indexOf("]");

    if (closingIdx === -1) {
      return ["", smiles];
    }

    sym = smiles.slice(1, closingIdx);
    rest = smiles.slice(closingIdx + 1);
  } else {
    var match = atomRe.exec(smiles);
    sym = match[1];
    rest = smiles.slice(sym.length);
  }

  return [sym, rest];
}
/**
 * Parse the next atom in the molecule, returning an atom object if this is the
 * first atom in the molecule, or a bond object with this atom as the
 * destination of the bond if this is not the first atom.
 */


function parseAtom(smiles, ctx) {
  var symbolInfo = readAtomSymbol(smiles);
  var atom = symbolInfo[0];

  if (atom === "") {
    return ["error", "Unable to parse bracketed atom."];
  }

  var rest = symbolInfo[1]; // Atoms are indexed by a list of two-element lists.  In each two-element
  // list, the first element is the atom counter, and the second element is
  // the branch counter.  Branches are 1-indexed so that the main chain of
  // the molecule can be indicated by 0.  Atoms may be either 0- or
  // 1-indexed, defaulting to 1, to maintain a alternating pattern of
  // odd/even indices. So, for example, if an atom has a branch off the main
  // chain, and its atom index is x, then the indices of atoms are:
  //     Atom where branch occurs: [[x, 0]]
  //     First atom in the branch: [[x, 1], [1, 0]]  (assuming x is even)
  //     Next atom in the main chain: [[x + 1, 0]]
  // increment the atom counter and reset the branch counter

  var newCtx = _mset(ctx, ["idx", ctx.idx.length - 1], [1 + ctx.idx[ctx.idx.length - 1][0], 0]);

  var restOfMolecule = parse$2(rest, _mset(newCtx, ["bond", "bondType"], "single"));

  if (!Array.isArray(restOfMolecule) && !!restOfMolecule) {
    //TODO(colin): fix this awkwardness.
    restOfMolecule = [restOfMolecule];
  }

  var atomObj = {
    type: "atom",
    symbol: atom,
    bonds: restOfMolecule,
    idx: newCtx.idx
  };

  if (ctx.bond) {
    return {
      type: "bond",
      bondType: ctx.bond.bondType,
      to: atomObj
    };
  }

  return atomObj;
}

function startsWithAtom(s) {
  return atomRe.test(s);
}

function isModifierChar(s) {
  return s === "=" || s === "#";
}
/**
 * Parse a SMILES string to an internal tree representation.
 *
 * Args:
 *   smiles [string]: a string representing the molecule.
 *
 * Returns: the parse tree (see top-of file docstring for details).
 *
 * Throws:
 *     ParseError: if the input is not valid SMILES or contains features not
 *         yet implemented.
 */


function parse$2(smiles, ctx) {
  if (!validate$1(smiles)) {
    throw new ParseError$1("Invalid input.");
  }

  if (!smiles || smiles.length === 0) {
    return null;
  }

  if (startsWithAtom(smiles)) {
    return parseAtom(smiles, ctx || {
      idx: [[0, 0]],
      parens: [],
      stack: [],
      bondModifiers: []
    });
  } else if (isModifierChar(smiles[0])) {
    // TODO(colin): add a better error message in the case where the input
    // is invalid and starts with a modifier character?
    return parseBondModifier(smiles, ctx);
  } else {
    // TODO(colin): add additional cases for unimplemented bits of SMILES
    // syntax.
    return parseParenthesizedExpression(smiles, ctx);
  }
}

_module_$1l.exports = {
  parse: parse$2,
  ParseError: ParseError$1
};
var _moleculeSmilesParserJsx = _module_$1l.exports;

/* eslint-disable brace-style */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * A molecule layout engine.
 *
 * This _module_ transforms the SMILES syntax tree into a set of rendering
 * instructions.  A rendering instruction is an object indicating what type of
 * thing to render (e.g. text or line), where to render it, and any other style
 * properties needed.
 *
 * For instance, an oxygen atom might be rendered as
 * {type: "text", value: "O", pos: [0, 0], idx: "1,0"}
 */
// Default length of the bond.  This currently corresponds directly to pixels
// in the renderer, but we may want this just to be arbitrary in the future.

var bondLength = 30;
/**
 * Compute a coordinate by moving an angle and length from an origin point.
 *
 * Args:
 *     origin: a list of the [x, y] coordinates of the origin
 *     angle: an angle in degrees from the origin, following the typical
 *         convention of +x axis = 0 degrees, +y axis = 90 degrees.
 *     length: the distance to the new point
 * Return:
 *     a two-element list containing the [x, y] coordinates of the point.
 */

function polarAdd(origin, angle, length) {
  var x = origin[0];
  var y = origin[1];
  return [x + Math.cos(angle * 2 * Math.PI / 360) * length, y + -1.0 * Math.sin(angle * 2 * Math.PI / 360) * length];
}
/**
 * Compute the layout for a single atom.
 *
 * Args:
 *     atom: the atom node for which layout is being created, as returned from
 *         convertTree; the computed position of this atom is added to this
 *         object in place, in addition to being returned in the layout
 *         instruction.
 *         TODO(colin): refactor so that we don't need to modify this in place
 *     atoms: the list of all atoms, as returned from convertTree, used to
 *         position this atom appropriately relative to its neighbors
 *     bonds: the list of all bonds, as returned from convertTree, used to
 *         determine the geometry based on bond type
 *     rotationAngle: a constant rotation for the whole molecule (in degrees)
 *
 * Return:
 *     a rendering instruction for the atom, containing a type (text), the text
 *     to render, the position, and the atom index
 */


function atomLayout(atom, atoms, bonds, rotationAngle) {
  var textValue = atom.symbol;

  if (textValue === "C" && Object.keys(atoms).length !== 1) {
    // By convention, don't render the C for carbon in a chain.
    textValue = null;
  }

  if (atom.idx === "1,0") {
    // The first atom is special-cased because there are no neighbors for
    // relative positioning.
    var _pos = [0, 0];
    atom.pos = _pos; // Conventionally, molecules are rendered where the first bond is not
    // horizontal, but at a 30 degree angle, so subtract 30 degrees for the
    // first atom's direction.

    atom.baseAngle = -30 + rotationAngle;
    return {
      type: "text",
      value: textValue,
      pos: _pos,
      idx: atom.idx
    };
  } // If we're an atom with any other index than the case just handled, we're
  // guaranteed to have a neighbor who has a defined position.


  var prevPositionedAtom = atoms[atom.connections.find(function (c) {
    return atoms[c].pos;
  })]; // Find this atom's index in the previous atom's connections

  var myIndex = prevPositionedAtom.connections.indexOf(atom.idx);
  var baseAngleIncrement = 60;
  var angleIncrement = 120;

  if (prevPositionedAtom.connections.length === 4) {
    // By convention, if an atom has 4 bonds, we represent it with 90
    // degree angles in 2D, even though it would have tetrahedral geometry
    // with ~110 degree angles in 3D.
    angleIncrement = 90;
    baseAngleIncrement = 90;
  } else if (bonds.find(bond => bond.bondType === "triple" && bond.to === atom.idx) || bonds.find(bond => bond.bondType === "triple" && bond.to === prevPositionedAtom.idx)) {
    // Triple bonds have a bond angle of 180 degrees, so don't change the
    // direction in which we made the previous bond.
    angleIncrement = 0;
    baseAngleIncrement = 0;
  }

  var angle = 0;
  var idxPath = prevPositionedAtom.idx.split(":");
  var lastAtomIdx = idxPath[idxPath.length - 1].split(",")[0]; // Conventionally, a single chain of atoms is rendered as a zig-zag pattern
  // with 120 degree angles.  This means we need to flip the angle every
  // other atom.  The parser ensures that indices always alternate odd-even,
  // including taking into account branch points.
  // TODO(colin): don't depend on the parser's indexing scheme and just track
  // this entirely in the layout engine.

  if (parseInt(lastAtomIdx) % 2 !== 0) {
    angle = prevPositionedAtom.baseAngle - (baseAngleIncrement - angleIncrement * myIndex);
  } else {
    angle = prevPositionedAtom.baseAngle + (baseAngleIncrement - angleIncrement * myIndex);
  }

  var pos = polarAdd(prevPositionedAtom.pos, angle, bondLength);
  atom.pos = pos;
  atom.baseAngle = angle;
  return {
    type: "text",
    value: textValue,
    pos: pos,
    idx: atom.idx
  };
}
/**
 * Get the start and end position for a bond connecting two atoms.
 *
 * If we have non-carbon atoms that render with explicit letters connected by a
 * bond, we don't want the line for the bond to extend into the lettering for
 * the atom.
 *
 * This function returns the start and end positions of the bond's line, taking
 * into account that one or both end points might need to be moved to make room
 * for text.
 *
 * TODO(colin): this makes assumptions about the relative sizes of the length
 * of a bond and the text.  Think about alternate ways to represent this that
 * might not have that problem.
 */


function maybeShrinkLines(fromAtom, toAtom) {
  var shrinkFactor = 0.25;
  var fromPos = [fromAtom.pos[0], fromAtom.pos[1]];
  var toPos = [toAtom.pos[0], toAtom.pos[1]];

  if (fromAtom.symbol !== "C") {
    fromPos = [toAtom.pos[0] - (1 - shrinkFactor) * (toAtom.pos[0] - fromAtom.pos[0]), toAtom.pos[1] - (1 - shrinkFactor) * (toAtom.pos[1] - fromAtom.pos[1])];
  }

  if (toAtom.symbol !== "C") {
    // For carbon atoms, conventionally we don't draw any letter, so this
    // special cases drawing the bond lines all the way to the point where
    // they meet.
    toPos = [fromAtom.pos[0] - (1 - shrinkFactor) * (fromAtom.pos[0] - toAtom.pos[0]), fromAtom.pos[1] - (1 - shrinkFactor) * (fromAtom.pos[1] - toAtom.pos[1])];
  }

  return [fromPos, toPos];
}
/**
 * Compute the layout for a bond between two atoms.
 *
 * Args:
 *     bond: the bond node for which the layout is being computed, as returned
 *         by convertTree
 *     atoms: the list of all atoms returned by convertTree, which should
 *         already have been processed for layout and thus have positions set
 *
 * Return:
 *     a rendering instruction for the bond containing a type
 *     (line:{single,double,triple}) and the line's endpoints
 */


function bondLayout(bond, atoms) {
  var fromAtom = atoms[bond.from];
  var toAtom = atoms[bond.to];
  var startAndEndPos = maybeShrinkLines(fromAtom, toAtom);
  return {
    type: "line:" + bond.bondType,
    startPos: startAndEndPos[0],
    endPos: startAndEndPos[1]
  };
}
/**
 * Convert an array of atom indices to a single string unique identifier.
 *
 * For linear molecules, or for atoms in the main chain, this will just be the
 * atom index, something like "0,1".  For branched molecules, however, we
 * uniquely identify atoms by an array of atoms where the branching happened,
 * followed by the index in the current branch (like ["0,1", "1,2", "1,1"]).
 * This function just joins the parts with a colon so that we can have nice
 * object keys that still track the series of branches to get to an atom, which
 * is guaranteed to be a unique identifier.
 *
 */


function idxString(idx) {
  return idx.join(":");
}
/**
 * Convert the parse tree output by the parser into an ordered list of atoms
 * and bonds to render.
 *
 * Args:
 *     atoms: the output list of atoms that we're in the process of building.
 *         This should be the empty list if not being called recursively.
 *     bonds: the output list of bonds that we're in the process of building.
 *         This should be the empty list if not being called recursively.
 *     tree: the parse tree generated by the SMILES parser _module_.
 *
 * Return:
 *     the final value of atoms and bonds, which are lists of all the atom
 *     nodes and bond nodes, respectively, that need to be rendered.
 */


function convertTree(atoms, bonds, tree) {
  if (tree === null) {
    return [atoms, bonds];
  }

  if (tree.type === "atom") {
    var treeIdx = idxString(tree.idx);
    atoms[treeIdx] = {
      idx: treeIdx,
      symbol: tree.symbol,
      connections: []
    };

    if (tree.bonds) {
      tree.bonds.forEach(function (b) {
        var toIdx = idxString(b.to.idx);
        atoms[treeIdx].connections.push(toIdx);
        bonds.push({
          from: treeIdx,
          to: toIdx,
          bondType: b.bondType
        });
        convertTree(atoms, bonds, b.to);
        atoms[toIdx].connections.push(treeIdx);
      });
    }
  }

  return [atoms, bonds];
}
/**
 * Recursively process the queue of atoms that need to have layout computed.
 *
 * Args:
 *     outputs: the array of atom rendering instructions we're in the process
 *         of building.  This should be the empty array if not being called
 *         recursively.
 *     atomProcessingQueue: the array of unique identifier strings (see the
 *         comment for idxString for more information about these) of atoms
 *         currently in line to be processed.  When not being called
 *         recursively, this should be a array with a single element, the
 *         unique identifier of the first atom in the structure ("1,0" in the
 *         current scheme).
 *     atoms: the array of all atom nodes to be rendered, as returned by
 *         convertTree
 *     bonds: the array of all bond nodes to be rendered, as returned by
 *         convertTree
 *
 * Return:
 *     an array of rendering instructions for all the atoms in the molecule
 */


function atomLayoutHelper(outputs, atomProcessingQueue, atoms, bonds, rotationAngle) {
  if (atomProcessingQueue.length === 0) {
    return outputs;
  }

  var queuedAtomIdx = atomProcessingQueue.shift();
  var atom = atoms[queuedAtomIdx];
  atom.connections.forEach(function (c) {
    if (!atoms[c].pos) {
      atomProcessingQueue.push(c);
    }
  });
  return atomLayoutHelper(outputs.concat(atomLayout(atom, atoms, bonds, rotationAngle)), atomProcessingQueue, atoms, bonds, rotationAngle);
}
/**
 * Recursively process the queue of bonds that need to have layout computed.
 *
 * Args:
 *     outputs: the array of bond rendering instructions we're in the process
 *         of building.  This should be the empty array or the array of all
 *         atom rendering instructions if not being called recursively.
 *     atoms: the array of all atom nodes to be rendered, as returned by
 *         convertTree
 *     bonds: the array of all bond nodes to be rendered, as returned by
 *         convertTree
 *
 * Return:
 *     an array of rendering instructions for all the bonds in the molecule
 *     concatenated to the initial value of outputs
 */


function bondLayoutHelper(outputs, atoms, bonds) {
  if (bonds.length === 0) {
    return outputs;
  }

  return bondLayoutHelper(outputs.concat(bondLayout(bonds[0], atoms)), atoms, bonds.slice(1));
}
/**
 * Compute an array of rendering instructions from the parse tree of a molecule.
 *
 * Args:
 *     tree: the parse tree as returned by the SMILES parser _module_
 *     rotationAngle: a global rotation (in degrees) to be applied to the whole
 *         molecule; this is manually adjustable in the widget.
 *
 * Return:
 *     an array of rendering instructions for all the atoms and bonds in the
 *     molecule suitable for processing by the renderer
 */


function layout(tree, rotationAngle) {
  var converted = convertTree({}, [], tree);
  var atoms = converted[0];
  var bonds = converted[1];
  var outputs = atomLayoutHelper([], ["1,0"], atoms, bonds, rotationAngle);
  return bondLayoutHelper(outputs, atoms, bonds);
}

var _module_$1k = {
  exports: {}
};
/* eslint-disable brace-style */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * Draw some text into a 2D canvas drawing context.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the text.  Must look like: {
 *         type: "text",
 *         pos: [x, y],
 *         value: "some text to draw",
 *     }
 *
 */

function drawText(ctx, item) {
  if (item.value === null) {
    return;
  }

  ctx.fillStyle = styles$h.fgColor;
  ctx.font = styles$h.font;
  ctx.fillText(item.value, item.pos[0] - styles$h.fontSizePx / 2 + 1, item.pos[1] + styles$h.fontSizePx / 2);
}
/**
 * Draw a double line into a 2D canvas drawing context.
 *
 * Apparently the way you do this is to stroke an extra-wide line in the
 * foreground color and then a smaller line in the background color. 5:3
 * foreground:background width looks reasonable for drawing chemical bonds.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:double",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */


function drawDoubleLine(ctx, item) {
  // Outer line that forms both of the bond lines.
  var path = new Path2D();
  ctx.lineWidth = 5 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path); // Inner white line that separates the two bond lines.

  path = new Path2D();
  ctx.lineWidth = 3 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.bgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);
}
/**
 * Draw a triple line into a 2D canvas drawing context.
 *
 * Following the strategy for the double line, we stroke a very wide
 * foreground-color line, then a medium background-color line, then a narrow
 * foreground-color line.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:triple",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */


function drawTripleLine(ctx, item) {
  // TODO(colin): consolidate duplicated code from the three line drawing
  // functions.
  // Outer line that will form the two outer bond lines.
  var path = new Path2D();
  ctx.lineWidth = 7 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path); // Middle white line that separates the bonds

  path = new Path2D();
  ctx.lineWidth = 5 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.bgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path); // Inner line that forms the middle bond line.

  drawLine(ctx, item);
}
/**
 * Draw a single line into a 2D canvas drawing context
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:single",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */


function drawLine(ctx, item) {
  var path = new Path2D();
  ctx.lineWidth = styles$h.lineWidth;
  ctx.strokeStyle = styles$h.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);
}
/**
 * Lookup table that maps drawing instruction types to the functions that
 * render them.
 */


var drawingFuncs = {
  text: drawText,
  "line:single": drawLine,
  "line:double": drawDoubleLine,
  "line:triple": drawTripleLine
};
/**
 * Draw a single rendering instruction into a 2D canvas drawing context.
 */

function drawItem(ctx) {
  return function (item) {
    drawingFuncs[item.type](ctx, item);
  };
}
/**
 * Lookup table for drawing priorities.
 *
 * Types with lower priorities are drawn first.
 */


var ordering = {
  "line:single": 0,
  "line:double": 0,
  "line:triple": 0,
  text: 1
};
/**
 * Sorting comparison function that orders rendering instructions according to
 * their type's priority.
 */

function compareElements(item0, item1) {
  return ordering[item0.type] - ordering[item1.type];
}
/**
 * Draw an array of rendering instructions into a 2D canvas drawing context.
 */


function draw$1(ctx, items) {
  items.sort(compareElements).forEach(drawItem(ctx));
}

var styles$h = {
  bgColor: "rgb(255, 255, 255)",
  fgColor: "rgb(0, 0, 0)",
  fontSizePx: 12,
  lineWidth: 1
};
styles$h.font = styles$h.fontSizePx + "px sans";
_module_$1k.exports = draw$1;
var _moleculeMoleculeDrawingJsx = _module_$1k.exports;

var _module_$1j = {
  exports: {}
};
/* eslint-disable brace-style, object-curly-spacing */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1j = _react__default["default"];
var draw = _moleculeMoleculeDrawingJsx;
var SmilesParser = _moleculeSmilesParserJsx;
var parse$1 = SmilesParser.parse;
var ParseError = SmilesParser.ParseError;
var borderSize = 30;
var Molecule$1 = createReactClass({
  displayName: "Molecule",
  propTypes: {
    id: PropTypes.string.isRequired,
    rotationAngle: PropTypes.number,
    smiles: PropTypes.string
  },
  getInitialState: function getInitialState() {
    return {
      parsedSmiles: null,
      error: null
    };
  },
  componentWillMount: function componentWillMount() {
    this.stateFromSmiles(this.props.smiles);
  },
  componentDidMount: function componentDidMount() {
    this.canvasRender();
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.stateFromSmiles(nextProps.smiles);
  },
  componentDidUpdate: function componentDidUpdate() {
    this.canvasRender();
  },
  stateFromSmiles: function stateFromSmiles(smiles) {
    try {
      this.setState({
        parsedSmiles: parse$1(smiles),
        error: null
      });
    } catch (e) {
      if (e instanceof ParseError) {
        this.setState({
          error: e.message
        });
      } else {
        throw e;
      }
    }
  },
  setCanvasBounds: function setCanvasBounds(canvas, items) {
    var xmax = Math.max(...items.map(item => item.pos ? item.pos[0] : -Infinity));
    var ymax = Math.max(...items.map(item => item.pos ? item.pos[1] : -Infinity));
    var xmin = Math.min(...items.map(item => item.pos ? item.pos[0] : Infinity));
    var ymin = Math.min(...items.map(item => item.pos ? item.pos[1] : Infinity));
    var width = xmax - xmin + 2 * borderSize;
    var height = ymax - ymin + 2 * borderSize;
    canvas.width = width;
    canvas.height = height;
    return [borderSize - xmin, borderSize - ymin];
  },
  canvasRender: function canvasRender() {
    // Since canvas drawing happens only through an imperative API, we sync
    // up the component with the canvas here, which happens when the
    // component mounts or updates.
    if (!!this.state.error || !this.state.parsedSmiles) {
      return;
    }

    var items = layout(this.state.parsedSmiles, this.props.rotationAngle);
    var canvas = this.refs.canvas;
    var translation = this.setCanvasBounds(canvas, items);
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(translation[0], translation[1]);
    draw(ctx, items);
    ctx.restore();
  },
  render: function render() {
    // TODO(colin): escape the punctuation in the SMILES alt text for
    // screen readers?
    var content = /*#__PURE__*/React$1j.createElement("canvas", {
      className: "molecule-canvas",
      id: this.props.id + "-molecule",
      ref: "canvas"
    }, "A molecular structure drawing. SMILES notation:", this.props.smiles, ".");

    if (this.state.error) {
      content = /*#__PURE__*/React$1j.createElement("div", {
        className: "error"
      }, this.state.error);
    }

    return /*#__PURE__*/React$1j.createElement("div", {
      className: "molecule-canvas"
    }, content);
  }
});
var MoleculeWidget = createReactClass({
  displayName: "MoleculeWidget",
  propTypes: {
    rotationAngle: PropTypes.number,
    smiles: PropTypes.string,
    widgetId: PropTypes.string
  },
  getDefaultProps: function getDefaultProps() {
    return {
      rotationAngle: 0
    };
  },
  simpleValidate: function simpleValidate() {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  },
  getUserInput: function getUserInput() {
    return [];
  },
  validate: function validate(state, rubric) {
    // TODO(colin): this is here as part of the interface for a component.
    // Figure out if there is something more appropriate that this should
    // return.
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  },
  render: function render() {
    return /*#__PURE__*/React$1j.createElement(Molecule$1, {
      id: this.props.widgetId,
      smiles: this.props.smiles,
      rotationAngle: this.props.rotationAngle
    });
  }
});
_module_$1j.exports = {
  name: "molecule-renderer",
  displayName: "Molecule renderer",
  hidden: true,
  widget: MoleculeWidget,
  molecule: Molecule$1
};
var _widgetsMoleculeJsx = _module_$1j.exports;

var _module_$1i = {
  exports: {}
};
var React$1i = _react__default["default"];
var Molecule = _widgetsMoleculeJsx.molecule;
var Separator = createReactClass({
  displayName: "Separator",
  propTypes: {
    // TODO(colin): figure out and add shape.
    data: PropTypes.any,
    index: PropTypes.number
  },
  componentDidMount: function componentDidMount() {
    this.drawArrow();
  },
  componentDidUpdate: function componentDidUpdate() {
    this.drawArrow();
  },
  arrowLength: 100,
  drawArrow: function drawArrow() {
    var canvas = this.refs["arrowCanvas" + this.props.index];
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var path = new Path2D();
    ctx.strokeStyle = "rgb(0,0,0)";
    ctx.lineWidth = 1.2;
    ctx.lineCap = "round";
    var offset = 5;
    path.moveTo(offset, canvas.height / 2);
    path.lineTo(canvas.width - offset, canvas.height / 2);
    path.moveTo(canvas.width - 2 * offset, canvas.height / 2 - offset);
    path.lineTo(canvas.width - offset, canvas.height / 2);
    path.moveTo(canvas.width - 2 * offset, canvas.height / 2 + offset);
    path.lineTo(canvas.width - offset, canvas.height / 2);
    ctx.stroke(path);
  },
  render: function render() {
    return /*#__PURE__*/React$1i.createElement("div", {
      className: "arrow-container"
    }, /*#__PURE__*/React$1i.createElement("div", {
      className: "above-text"
    }, this.props.data.topText), /*#__PURE__*/React$1i.createElement("canvas", {
      height: "30",
      id: "arrowCanvas" + this.props.index,
      ref: "arrowCanvas" + this.props.index,
      width: this.arrowLength
    }, "Reaction arrow pointing to the right."), /*#__PURE__*/React$1i.createElement("div", {
      className: "below-text"
    }, this.props.data.bottomText));
  }
});
var ReactionDiagramWidget = createReactClass({
  displayName: "ReactionDiagramWidget",
  propTypes: {
    // TODO(colin): at the moment, these must be arrays of two elements;
    // we're limited to a single reaction step.  At some point, add support
    // for more steps in the reaction.
    rotationAngle: PropTypes.arrayOf(PropTypes.number),
    separators: PropTypes.arrayOf(PropTypes.object),
    smiles: PropTypes.arrayOf(PropTypes.string),
    widgetId: PropTypes.string
  },
  getDefaultProps: function getDefaultProps() {
    return {
      smiles: [],
      rotationAngle: [],
      separators: []
    };
  },
  simpleValidate: function simpleValidate() {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  },
  getUserInput: function getUserInput() {
    return [];
  },
  validate: function validate(state, rubric) {
    // TODO(colin): this appears to be part of the perseus interface.
    // Figure out if there's a more appropriate value to return.
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  },
  focus: function focus() {
    return true;
  },
  render: function render() {
    return /*#__PURE__*/React$1i.createElement("div", {
      className: "reaction",
      ref: "reaction"
    }, this.props.smiles.map((s, i) => {
      var id = this.props.widgetId + "-" + i;
      return /*#__PURE__*/React$1i.createElement("div", {
        key: id,
        className: "molecule-container"
      }, /*#__PURE__*/React$1i.createElement(Molecule, {
        id: id,
        rotationAngle: this.props.rotationAngle[i],
        smiles: s
      }), i === this.props.smiles.length - 1 ? null : /*#__PURE__*/React$1i.createElement(Separator, {
        data: this.props.separators[i],
        index: i
      }));
    }));
  }
});
_module_$1i.exports = {
  name: "reaction-diagram",
  displayName: "Chemical reaction",
  hidden: true,
  widget: ReactionDiagramWidget
};
var _widgetsReactionDiagramJsx = _module_$1i.exports;

var _module_$1h = {
  exports: {}
};
/* eslint-disable comma-dangle, indent, max-lines, no-redeclare, no-unused-vars, no-var, object-curly-spacing, one-var, react/prop-types, react/sort-comp, space-before-function-paren */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1h = _react__default["default"];
var ReactDOM$e = _reactDom__default["default"];
var _$T = _underscore__default["default"];
var ApiClassNames$8 = _perseusApiJsx.ClassNames;
var deepEq$1 = Util$q.deepEq;
var KhanMath$2 = _utilMathJs;
var KhanColors$5 = _utilColorsJs;
var GraphUtils$2 = _utilGraphUtilsJs;
var Interactive2$2 = _interactive2Js;
var WrappedLine$2 = _interactive2WrappedLineJs;
var BAR$1 = "bar",
    LINE$1 = "line",
    PIC$1 = "pic",
    HISTOGRAM$1 = "histogram",
    DOTPLOT$1 = "dotplot";
({
  type: PropTypes.oneOf([BAR$1, LINE$1, PIC$1, HISTOGRAM$1, DOTPLOT$1]),
  labels: PropTypes.arrayOf(PropTypes.string),
  categories: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),
  scaleY: PropTypes.number,
  maxY: PropTypes.number,
  snapsPerLine: PropTypes.number,
  picSize: PropTypes.number,
  pixBoxHeight: PropTypes.number,
  picUrl: PropTypes.string,
  plotDimensions: PropTypes.arrayOf(PropTypes.number),
  labelInterval: PropTypes.number,
  starting: PropTypes.arrayOf(PropTypes.number),
  static: PropTypes.bool
});
var Plotter$1 = createReactClass({
  displayName: "Plotter",
  propTypes: {
    onChange: PropTypes.func.isRequired,
    trackInteraction: PropTypes.func.isRequired // TODO(alex): Figure out why lint chokes on this line
    // ...widgetPropTypes,

  },
  getDefaultProps: function getDefaultProps() {
    return {
      type: BAR$1,
      labels: ["", ""],
      categories: [""],
      scaleY: 1,
      maxY: 10,
      snapsPerLine: 2,
      picSize: 40,
      picBoxHeight: 48,
      picUrl: "",
      plotDimensions: [380, 300],
      labelInterval: 1
    };
  },
  getInitialState: function getInitialState() {
    return {
      values: this.props.starting || [1]
    };
  },
  DOT_PLOT_POINT_SIZE: function DOT_PLOT_POINT_SIZE() {
    return this.props.apiOptions.isMobile ? 6 : 4;
  },
  DOT_PLOT_POINT_PADDING: function DOT_PLOT_POINT_PADDING() {
    return 8;
  },
  DOT_TICK_POINT_SIZE: function DOT_TICK_POINT_SIZE() {
    return 2;
  },
  render: function render() {
    // TODO(kevinb) actually compute the size of the graphie correctly and
    // make it that size so we don't have to add extra padding.  The value
    // was determined by eye-balling the layout.  :(
    var paddingForBottomLabel = 75;
    var style = {
      marginBottom: this.props.labels[0] ? paddingForBottomLabel : 0
    };
    return /*#__PURE__*/React$1h.createElement("div", {
      className: "perseus-widget-plotter graphie " + ApiClassNames$8.INTERACTIVE,
      ref: "graphieDiv",
      style: style
    });
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    if (this.shouldSetupGraphie) {
      this.setupGraphie(prevState);
    }
  },
  componentDidMount: function componentDidMount() {
    this.setupGraphie(this.state);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var props = ["type", "labels", "categories", "scaleY", "maxY", "snapsPerLine", "picUrl", "labelInterval", "static"];
    this.shouldSetupGraphie = _$T.any(props, function (prop) {
      return !_$T.isEqual(this.props[prop], nextProps[prop]);
    }, this);

    if (!_$T.isEqual(this.props.starting, nextProps.starting) && !_$T.isEqual(this.state.values, nextProps.starting)) {
      this.shouldSetupGraphie = true;
      this.setState({
        values: nextProps.starting
      });
    }
  },
  setupGraphie: function setupGraphie(prevState) {
    var self = this;
    self.shouldSetupGraphie = false;
    var graphieDiv = ReactDOM$e.findDOMNode(self.refs.graphieDiv);
    $(graphieDiv).empty();
    var graphie = GraphUtils$2.createGraphie(graphieDiv); // TODO(jakesandlund): It's not the react way to hang
    // something off the component object, but since graphie
    // is outside React, it makes it easier to do this.

    self.graphie = graphie;
    self.graphie.pics = [];
    self.graphie.dotTicks = [];
    var isBar = self.props.type === BAR$1,
        isLine = self.props.type === LINE$1,
        isPic = self.props.type === PIC$1,
        isHistogram = self.props.type === HISTOGRAM$1,
        isDotplot = self.props.type === DOTPLOT$1;
    var isTiledPlot = isPic || isDotplot;
    var config = {};
    var c = config; // c for short

    var isMobile = this.props.apiOptions.isMobile;
    c.graph = {
      lines: [],
      bars: [],
      points: [],
      dividers: []
    };
    c.scaleY = self.props.scaleY;
    c.dimX = self.props.categories.length;
    var plotDimensions = isMobile ? [288, 336] : self.props.plotDimensions;

    if (isLine) {
      // Subtracting 0.2 makes line have equal padding on each side
      c.dimX += isMobile ? -0.2 : 1;
    } else if (isHistogram) {
      c.barPad = 0;
      c.barWidth = 1;
    } else if (isBar) {
      c.barPad = isMobile ? 0.08 : 0.15;
      c.barWidth = 1 - 2 * c.barPad;
      c.dimX += (isMobile ? -2 : 2) * c.barPad;
    } else if (isTiledPlot) {
      c.picBoxHeight = self.props.picBoxHeight;
      c.picBoxWidthPx = plotDimensions[0] / self.props.categories.length;
      var picPadAllWidth = plotDimensions[0] - c.dimX * c.picBoxWidthPx;
      c.picPad = picPadAllWidth / (2 * c.dimX + 2);
      var picFullWidth = c.picBoxWidthPx + 2 * c.picPad; // Convert from px to "unscaled"

      c.picPad = c.picPad / picFullWidth;
      c.picBoxWidth = c.picBoxWidthPx / picFullWidth;
      c.dimX += 2 * c.picPad;
    }

    if (isDotplot) {
      c.picBoxHeight = this.DOT_PLOT_POINT_SIZE() * 2 + this.DOT_PLOT_POINT_PADDING();
    }

    c.dimY = Math.ceil(self.props.maxY / c.scaleY) * c.scaleY;
    var padX = 25;
    var padY = 25;

    if ((isBar || isLine) && isMobile) {
      padX = self.props.labels[1].length !== 0 ? 17 : 11;
    } // Since dotplot doesn't have an axis along the left it looks weird
    // with the same padding as the others


    if (isDotplot) {
      padX /= 2;
    }

    if (isMobile && isTiledPlot && self.props.labels[1].length === 0) {
      padX = 0;
    }

    if (isMobile) {
      c.scale = _$T.map([[c.dimX, padX], [c.dimY, padY]], // We multiply pad by 4 because we add 3*pad padding on the left
      // and 1*pad on the right
      (_ref, i) => {
        var [dim, pad] = _ref;
        return (plotDimensions[i] - pad * 4) / dim;
      });
    } else {
      c.scale = _$T.map([c.dimX, c.dimY], function (dim, i) {
        return plotDimensions[i] / dim;
      });
    }

    padX /= c.scale[0];
    padY /= c.scale[1];

    if (isTiledPlot) {
      c.scale[1] = c.picBoxHeight / c.scaleY;
    }

    graphie.init({
      range: [[-3 * padX, c.dimX + padX], [-3 * padY, c.dimY + padY]],
      scale: c.scale,
      isMobile: this.props.apiOptions.isMobile
    });
    graphie.addMouseLayer({
      allowScratchpad: true,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    });

    if (!isTiledPlot) {
      // If we have isMobile, we skip the 0 label.
      var initialY = isMobile ? c.scaleY : 0;

      for (var y = initialY; y <= c.dimY; y += c.scaleY) {
        graphie.label([0, y], KhanMath$2.roundToApprox(y, 2), "left",
        /* isTeX */
        true
        /* for the \approx symbol */
        );
        graphie.style({
          stroke: isMobile ? "#e9ebec" : "#000",
          strokeWidth: 1,
          opacity: isMobile ? 1 : 0.3
        }, function () {
          graphie.line([0, y], [c.dimX, y]);
        });
      }
    }

    if ((isBar || isLine) && isMobile) {
      self.graphie.dragPrompt = graphie.label([c.dimX / 2, c.dimY / 2], "Drag handles to make graph", "center", false).css("font-weight", "bold").css("color", KhanColors$5.KA_GREEN).css("display", "none");
    }

    self.setupCategories(config);

    if (isTiledPlot && isMobile) {
      self.graphie.dotPrompt = graphie.label([c.dimX / 2, c.dimY / 2], "Tap to add points", "center", false).css("font-weight", "bold").css("color", KhanColors$5.KA_GREEN).css("display", "none");
    }

    if (isTiledPlot) {
      self.drawPicHeights(self.state.values, prevState.values);
    }

    graphie.style({
      stroke: "#000",
      strokeWidth: 2,
      opacity: 1.0
    }, function () {
      if (isTiledPlot) {
        if (isDotplot) {
          // Dotplot is a subtype of tiled plot, here we only draw
          // the x-axis
          graphie.style({
            stroke: isMobile ? KhanColors$5.GRAY_G : "#000",
            strokeWidth: isMobile ? 1 : 2
          }, () => graphie.line([isMobile ? 0 : 0.5, 0], [c.dimX - (isMobile ? 0 : 0.5), 0]));
        } else {
          graphie.line([0, 0], [c.dimX, 0]); // Draw the left axis for non-dotplots

          if (self.props.labels[1].length !== 0 || !isMobile) {
            graphie.style({
              stroke: isMobile ? KhanColors$5.GRAY_G : "#000",
              strokeWidth: isMobile ? 1 : 2
            }, () => graphie.line([0, 0], [0, c.dimY]));
          }
        }
      } else {
        // Draw normal axes
        graphie.style({
          stroke: isMobile ? KhanColors$5.GRAY_G : "#000",
          strokeWidth: isMobile ? 1 : 2
        }, () => graphie.line([isMobile ? -padX * 3 : 0, 0], [c.dimX + (isMobile ? padX : 0), 0]));

        if (!((isBar || isLine) && isMobile)) {
          graphie.style({
            stroke: isMobile ? KhanColors$5.GRAY_G : "#000",
            strokeWidth: isMobile ? 1 : 2
          }, () => graphie.line([0, 0], [0, c.dimY]));
        }
      }
    });
    graphie.label([c.dimX / 2, isMobile ? -padY * 3 : -35 / c.scale[1]], self.props.labels[0], isMobile ? "above" : "below", false).css("font-weight", "bold").css("color", isMobile && KhanColors$5.GRAY_F);
    graphie.label([(isMobile ? -35 : -60) / c.scale[0], c.dimY / 2], self.props.labels[1], "center", false).css("font-weight", "bold").css("color", isMobile && KhanColors$5.GRAY_F).addClass("rotate");

    if (this.props.apiOptions.isMobile) {
      this.horizHairline = new WrappedLine$2(this.graphie, [0, 0], [0, 0], {
        normalStyle: {
          strokeWidth: 1
        }
      });
      this.horizHairline.attr({
        stroke: KhanColors$5.INTERACTIVE
      });
      this.horizHairline.hide();
      this.hairlineRange = [[0, c.dimX], [0, c.dimY]];
    }
  },
  showHairlines: function showHairlines(point) {
    if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
      // Hairlines are already initialized when the graph is loaded, so
      // here we just move them to the updated location and make them
      // visible.
      this.horizHairline.moveTo([this.hairlineRange[0][0], point[1]], [this.hairlineRange[0][1], point[1]]);
      this.horizHairline.show();
    }
  },
  hideHairlines: function hideHairlines() {
    if (this.props.apiOptions.isMobile) {
      this.horizHairline.hide();
    }
  },
  labelCategory: function labelCategory(x, category) {
    var isMobile = this.props.apiOptions.isMobile;
    var graphie = this.graphie;
    category = category + "";
    var isTeX = false;
    var mathyCategory = category.match(/^\$(.*)\$$/);

    if (mathyCategory) {
      category = mathyCategory[1];
      isTeX = true;
    }

    this.props.labels[0].length !== 0;
    var labelRotation = "translateX(-50%) translateX(5px) " + "translateY(-50%) rotate(-45deg)";
    graphie.style({
      color: isMobile ? KhanColors$5.GRAY_G : "inherit",
      transform: isMobile && !mathyCategory ? labelRotation : "none",
      transformOrigin: "100%"
    }, () => graphie.label([x, isMobile ? -0.5 : 0], category, "below", isTeX));
  },
  setupCategories: function setupCategories(config) {
    var self = this;
    var c = config;
    var graphie = self.graphie;
    var isMobile = this.props.apiOptions.isMobile;

    if (self.props.type === HISTOGRAM$1) {
      // Histograms with n labels/categories have n - 1 buckets
      _$T.times(self.props.categories.length - 1, function (i) {
        self.setupBar({
          index: i,
          startHeight: self.state.values[i],
          config: config,
          isHistogram: true
        });
      }); // Label categories


      _$T.each(self.props.categories, function (category, i) {
        var x = 0.5 + i * c.barWidth;
        self.labelCategory(x, category);
        var tickHeight = 6 / c.scale[1];
        graphie.style({
          stroke: "#000",
          strokeWidth: isMobile ? 1 : 2,
          opacity: 1.0
        }, function () {
          graphie.line([x, -tickHeight], [x, 0]);
        });
      });
    } else {
      _$T.each(self.props.categories, function (category, i) {
        var startHeight = self.state.values[i];
        var x;

        if (self.props.type === BAR$1) {
          x = self.setupBar({
            index: i,
            startHeight: startHeight,
            config: config,
            isHistogram: false
          });
        } else if (self.props.type === LINE$1) {
          x = self.setupLine(i, startHeight, config);
        } else if (self.props.type === PIC$1) {
          x = self.setupPic(i, config);
        } else if (self.props.type === DOTPLOT$1) {
          x = self.setupDotplot(i, config);
        }

        var tickStart = 0;
        var tickEnd = -6 / c.scale[1];

        if (self.props.type === DOTPLOT$1 && !isMobile) {
          tickStart = -tickEnd;
        }

        if (self.props.type === DOTPLOT$1) {
          // Dotplot lets you specify to only show labels every 'n'
          // ticks. It also looks nicer if it makes the labelled
          // ticks a bit bigger.
          if (i % self.props.labelInterval === 0 || i === self.props.categories.length - 1) {
            self.labelCategory(x, category);
            tickStart *= 1.5;
            tickEnd *= 1.5;
          }
        } else {
          self.labelCategory(x, category);
        }

        graphie.style({
          stroke: isMobile ? KhanColors$5.GRAY_G : "#000",
          strokeWidth: isMobile ? 1 : 2,
          opacity: 1.0
        }, function () {
          graphie.line([x, tickStart], [x, tickEnd]);
        });
      });
    }
  },
  _clampValue: function _clampValue(v, min, max) {
    return Math.max(Math.min(v, max), min);
  },
  _maybeShowDragPrompt: function _maybeShowDragPrompt() {
    // The drag prompt is only added on certain types of plots.
    if (this.graphie.dragPrompt != null) {
      this.graphie.dragPrompt[0].style.display = "inline";
    }
  },
  _maybeHideDragPrompt: function _maybeHideDragPrompt() {
    // The drag prompt is only added on certain types of plots.
    if (this.graphie.dragPrompt != null) {
      this.graphie.dragPrompt[0].style.display = "none";
    }
  },
  setupBar: function setupBar(args) {
    var isMobile = this.props.apiOptions.isMobile;
    var i = args.index;
    var startHeight = args.startHeight;
    var config = args.config;
    var isHistogram = args.isHistogram;
    var self = this;
    var graphie = self.graphie;
    var barHalfWidth = config.barWidth / 2;
    var x;

    if (isHistogram) {
      x = 0.5 + i * config.barWidth + barHalfWidth;
    } else {
      x = (isMobile ? barHalfWidth : 0.5 + config.barPad) + i;
    }
    /**
     * Updates the bar with given index to the given height
     * @param i the index of the bar to update
     * @param height the new height of the bar
     */


    var scaleBar = function scaleBar(i, height) {
      var center = graphie.scalePoint(0); // Scale filled bucket (bar)

      config.graph.bars[i].scale(1, Math.max(isMobile ? 0.2 : 0.01, height / config.scaleY), center[0], center[1]);

      if (isHistogram) {
        // Scale dividers between buckets
        var leftDivider = config.graph.dividers[i - 1],
            rightDivider = config.graph.dividers[i];

        if (leftDivider) {
          var divHeight = Math.min(self.state.values[i - 1], height);
          leftDivider.scale(1, Math.max(0.01, divHeight / config.scaleY), center[0], center[1]);
        }

        if (rightDivider) {
          var divHeight = Math.min(self.state.values[i + 1], height);
          rightDivider.scale(1, Math.max(0.01, divHeight / config.scaleY), center[0], center[1]);
        }
      }
    };

    graphie.style({
      stroke: "none",
      fill: isMobile ? KhanColors$5.BLUE_C : KhanColors$5.LIGHT_BLUE,
      opacity: 1.0
    }, function () {
      config.graph.bars[i] = graphie.path([[x - barHalfWidth, 0], [x - barHalfWidth, config.scaleY], [x + barHalfWidth, config.scaleY], [x + barHalfWidth, 0], [x - barHalfWidth, 0]]);
    });

    if (isHistogram) {
      if (i > 0) {
        // Don't draw a divider to the left of the first bucket
        graphie.style({
          stroke: "#000",
          strokeWidth: 1,
          opacity: 0.3
        }, function () {
          config.graph.dividers.push(graphie.path([[x - barHalfWidth, 0], [x - barHalfWidth, config.scaleY]]));
        });
      }
    }

    if (isMobile) {
      var snap = config.scaleY / self.props.snapsPerLine;
      config.graph.lines[i] = Interactive2$2.addMaybeMobileMovablePoint(this, {
        coord: [x, startHeight],
        constraints: [(coord, prev, options) => {
          return [x, this._clampValue(Math.round(coord[1] / snap) * snap, 0, config.dimY)];
        }],
        onMoveStart: function onMoveStart() {
          config.graph.bars[i].attr({
            fill: KhanColors$5.INTERACTIVE
          });
        },
        onMove: function onMove() {
          var y = config.graph.lines[i].coord()[1];

          var values = _$T.clone(self.state.values);

          values[i] = y;
          self.setState({
            values: values
          });
          self.changeAndTrack({
            values: values
          });

          self._maybeHideDragPrompt();

          scaleBar(i, y);
        },
        onMoveEnd: function onMoveEnd() {
          config.graph.bars[i].attr({
            fill: KhanColors$5.BLUE_C
          });
        }
      }); // We set the z-index to 1 here so that the hairlines cover up the
      // points

      config.graph.lines[i].state.visibleShape.wrapper.style.zIndex = "1";

      self._maybeShowDragPrompt();
    } else {
      config.graph.lines[i] = graphie.addMovableLineSegment({
        coordA: [x - barHalfWidth, startHeight],
        coordZ: [x + barHalfWidth, startHeight],
        snapY: config.scaleY / self.props.snapsPerLine,
        constraints: {
          constrainX: true
        },
        normalStyle: {
          stroke: KhanColors$5.INTERACTIVE,
          // Don't display graph handles in static mode
          "stroke-width": this.props.static ? 0 : 4
        }
      });

      config.graph.lines[i].onMove = function (dx, dy) {
        var y = this.coordA[1];

        if (y < 0 || y > config.dimY) {
          y = Math.min(Math.max(y, 0), config.dimY);
          this.coordA[1] = this.coordZ[1] = y; // Snap the line back into range.

          this.transform();
        }

        var values = _$T.clone(self.state.values);

        values[i] = y;
        self.setState({
          values: values
        });
        self.changeAndTrack({
          values: values
        });
        scaleBar(i, y);
      };
    }

    scaleBar(i, startHeight);
    return x;
  },

  /**
   * Renders a segment of an interactive line to the plotter graph
   * @param i the index of the point to render
   * @param startHeight the initial height of the given point
   * @param config the graph setup, such as scale and dimensions
   */
  setupLine: function setupLine(i, startHeight, config) {
    var isMobile = this.props.apiOptions.isMobile;
    var self = this;
    var c = config;
    var graphie = self.graphie;
    var x = i + (isMobile ? 0.4 : 1);

    if (isMobile) {
      var snap = config.scaleY / self.props.snapsPerLine;
      c.graph.points[i] = Interactive2$2.addMaybeMobileMovablePoint(this, {
        coord: [x, startHeight],
        constraints: [(coord, prev, options) => {
          return [x, this._clampValue(Math.round(coord[1] / snap) * snap, 0, config.dimY)];
        }],
        onMove: function onMove() {
          var y = c.graph.points[i].coord()[1];

          var values = _$T.clone(self.state.values);

          values[i] = y;
          self.setState({
            values: values
          });
          self.changeAndTrack({
            values: values
          });

          self._maybeHideDragPrompt();
        }
      });

      self._maybeShowDragPrompt();

      if (i > 0) {
        c.graph.lines[i] = Interactive2$2.addMovableLine(graphie, {
          points: [c.graph.points[i - 1], c.graph.points[i]],
          constraints: Interactive2$2.MovablePoint.constraints.fixed(),
          normalStyle: {
            stroke: KhanColors$5.BLUE_C,
            "stroke-width": 2
          },
          highlightStyle: {
            stroke: KhanColors$5.BLUE_C,
            "stroke-width": 2
          }
        });
      }
    } else {
      c.graph.points[i] = graphie.addMovablePoint({
        coord: [x, startHeight],
        constraints: {
          constrainX: true
        },
        normalStyle: {
          fill: KhanColors$5.INTERACTIVE,
          stroke: KhanColors$5.INTERACTIVE
        },
        snapY: c.scaleY / self.props.snapsPerLine
      });

      c.graph.points[i].onMove = function (x, y) {
        y = Math.min(Math.max(y, 0), c.dimY);

        var values = _$T.clone(self.state.values);

        values[i] = y;
        self.setState({
          values: values
        });
        self.changeAndTrack({
          values: values
        });
        return [x, y];
      };

      if (i > 0) {
        c.graph.lines[i] = graphie.addMovableLineSegment({
          pointA: c.graph.points[i - 1],
          pointZ: c.graph.points[i],
          constraints: {
            fixed: true
          },
          normalStyle: {
            stroke: "#9ab8ed",
            "stroke-width": 2
          }
        });
      }
    }

    return x;
  },
  setupDotplot: function setupDotplot(i, config) {
    var graphie = this.graphie;
    var isMobile = this.props.apiOptions.isMobile;
    return this.setupTiledPlot(i, isMobile ? 0.5 : 1, config, (x, y) => {
      return graphie.ellipse([x, y], [this.DOT_PLOT_POINT_SIZE() / graphie.scale[0], this.DOT_PLOT_POINT_SIZE() / graphie.scale[1]], {
        fill: KhanColors$5.INTERACTIVE,
        stroke: KhanColors$5.INTERACTIVE
      });
    });
  },
  setupPic: function setupPic(i, config) {
    var graphie = this.graphie;
    return this.setupTiledPlot(i, 0, config, (x, y) => {
      var scaledCenter = graphie.scalePoint([x, y]);
      var size = this.props.picSize;
      return graphie.raphael.image(this.props.picUrl, scaledCenter[0] - size / 2, scaledCenter[1] - size / 2, size, size);
    });
  },
  setupTiledPlot: function setupTiledPlot(i, bottomMargin, config, createImage) {
    var self = this;
    var c = config;
    var graphie = self.graphie;
    var pics = graphie.pics;
    var dotTicks = graphie.dotTicks;
    var x = i + 0.5 + c.picPad; // In order to make sure that manipulating the graph doesn't cause
    // dragging, we disable touch actions for the whole mouselayer.
    // TODO(emily): Figure out a way to turn of touch actions for only the
    // part of the widget that can be manipulated. Putting this style
    // directly on the rects below doesn't work.

    graphie.mouselayer.canvas.style.touchAction = "none";
    pics[i] = [];
    dotTicks[i] = [];
    var n = Math.round(c.dimY / c.scaleY) + 1;

    _$T.times(n, function (j) {
      j -= 1;
      var midY = (j + 0.5) * c.scaleY;
      var leftX = x - c.picBoxWidth / 2;
      var topY = midY + 0.5 * c.scaleY;
      var coord = graphie.scalePoint([leftX, topY + bottomMargin]);
      var mouseRect = graphie.mouselayer.rect(coord[0], coord[1], c.picBoxWidthPx, c.picBoxHeight);
      $(mouseRect[0]).css({
        fill: "#000",
        opacity: 0.0,
        cursor: "pointer"
      }).on("vmousedown", function (e) {
        e.preventDefault();
        self.whichPicClicked = i;
        self.setPicHeight(i, topY);
        $(document).on("vmouseup.plotTile", function (e) {
          $(document).unbind(".plotTile");
        });
        $(document).on("vmousemove.plotTile", function (e) {
          e.preventDefault(); // Reverse-engineer the initial calculation

          var yCoord = graphie.getMouseCoord(e)[1];
          var adjustedCoord = Math.floor(yCoord - bottomMargin); // Calculate top coord from j value, but don't let them
          // go below j = -1, which is equivalent to having '0'
          // on the dot plot (due to weird indexing).

          var newJ = Math.max(-1, Math.floor(adjustedCoord / c.scaleY));
          var newMidY = (newJ + 0.5) * c.scaleY;
          var newTopY = newMidY + 0.5 * c.scaleY;
          self.setPicHeight(self.whichPicClicked, newTopY);
        });
      });

      if (j < 0) {
        // Don't show a pic underneath the axis!
        return;
      }

      pics[i][j] = createImage(x, midY + bottomMargin);
      dotTicks[i][j] = graphie.ellipse([x, midY + bottomMargin], [self.DOT_TICK_POINT_SIZE() / graphie.scale[0], self.DOT_TICK_POINT_SIZE() / graphie.scale[1]], {
        fill: "#dee1e3",
        stroke: "#dee1e3"
      });
    });

    return x;
  },
  setPicHeight: function setPicHeight(i, y) {
    var values = _$T.clone(this.state.values);

    values[i] = y;
    this.drawPicHeights(values, this.state.values);
    this.setState({
      values: values
    });
    this.changeAndTrack({
      values: values
    });
  },
  changeAndTrack: function changeAndTrack(data) {
    this.props.onChange(data);
    this.props.trackInteraction();
  },
  drawPicHeights: function drawPicHeights(values, prevValues) {
    var self = this;
    var graphie = self.graphie;
    var pics = graphie.pics;
    var isMobile = this.props.apiOptions.isMobile;

    if (isMobile) {
      var shouldDisplay = values.every(v => v === 0);
      graphie.dotPrompt[0].style.display = shouldDisplay ? "inline" : "none";
    }

    _$T.each(pics, function (ps, i) {
      _$T.each(ps, function (pic, j) {
        var y = (j + 1) * self.props.scaleY;
        var show = y <= values[i];

        if (self.props.type === DOTPLOT$1) {
          var wasShown = y <= prevValues[i];
          var wasJustShown = show && !wasShown;

          if (wasJustShown) {
            pic.animate({
              "stroke-width": 8
            }, 75, () => pic.animate({
              "stroke-width": 2
            }, 75));
          }
        }

        $(pic[0]).css({
          display: show ? "inline" : "none"
        });
        graphie.dotTicks[i][j][0].style.display = show || !isMobile ? "none" : "inline";
      });
    });
  },
  getUserInput: function getUserInput() {
    return this.state.values;
  },
  simpleValidate: function simpleValidate(rubric) {
    return Plotter$1.validate(this.getUserInput(), rubric);
  }
});

_$T.extend(Plotter$1, {
  validate: function validate(guess, rubric) {
    if (deepEq$1(guess, rubric.starting)) {
      return {
        type: "invalid",
        message: null
      };
    } else {
      return {
        type: "points",
        earned: deepEq$1(guess, rubric.correct) ? 1 : 0,
        total: 1,
        message: null
      };
    }
  }
}); // We don't need to change any of the original props for static mode


var staticTransform$3 = _$T.identity;
_module_$1h.exports = {
  name: "plotter",
  displayName: "Plotter",
  widget: Plotter$1,
  staticTransform: staticTransform$3
};
var _widgetsPlotterJsx = _module_$1h.exports;

var _module_$1g = {
  exports: {}
};
/* eslint-disable comma-dangle, max-len, no-var, one-var, react/jsx-closing-bracket-location, react/sort-comp, space-before-function-paren */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1g = _react__default["default"];
var ReactDOM$d = _reactDom__default["default"];
var _$S = _underscore__default["default"];
var BlurInput$4 = _reactComponentsBlurInputJsx;
var InfoTip$g = _componentsInfoTipJsx;
var NumberInput$b = _componentsNumberInputJsx;
var RangeInput$4 = _componentsRangeInputJsx;
var SvgImage$2 = _componentsSvgImageJsx;
var TextListEditor$3 = _componentsTextListEditorJsx;
var Plotter = _widgetsPlotterJsx.widget;
var knumber$4 = _kmath3.number;
var BAR = "bar",
    LINE = "line",
    PIC = "pic",
    HISTOGRAM = "histogram",
    DOTPLOT = "dotplot"; // Return a copy of array with length n, padded with given value

function padArray(array, n, value) {
  var copy = _$S.clone(array);

  copy.length = n;

  for (var i = array.length; i < n; i++) {
    copy[i] = value;
  }

  return copy;
}

var editorDefaults = {
  scaleY: 1,
  maxY: 10,
  snapsPerLine: 2
};
var widgetPropTypes = {
  type: PropTypes.oneOf([BAR, LINE, PIC, HISTOGRAM, DOTPLOT]),
  labels: PropTypes.arrayOf(PropTypes.string),
  categories: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),
  scaleY: PropTypes.number,
  maxY: PropTypes.number,
  snapsPerLine: PropTypes.number,
  picSize: PropTypes.number,
  pixBoxHeight: PropTypes.number,
  picUrl: PropTypes.string,
  plotDimensions: PropTypes.arrayOf(PropTypes.number),
  labelInterval: PropTypes.number,
  starting: PropTypes.arrayOf(PropTypes.number),
  correct: PropTypes.arrayOf(PropTypes.number),
  static: PropTypes.bool,
  onChange: PropTypes.func
};

var formatNumber = num => "$" + knumber$4.round(num, 2) + "$";

var PlotterEditor = createReactClass({
  displayName: "PlotterEditor",
  propTypes: widgetPropTypes,
  getDefaultProps: function getDefaultProps() {
    return _$S.extend({}, editorDefaults, {
      correct: [1],
      starting: [1],
      type: BAR,
      labels: ["", ""],
      categories: [""],
      picSize: 30,
      picBoxHeight: 36,
      picUrl: Khan.imageBase + "badges/earth-small.png",
      plotDimensions: [275, 200],
      labelInterval: 1
    });
  },
  getInitialState: function getInitialState() {
    return {
      editing: "correct",
      pic: null,
      loadedUrl: null,
      minX: null,
      maxX: null,
      tickStep: null
    };
  },
  componentWillMount: function componentWillMount() {
    this.fetchPic(this.props.picUrl);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.fetchPic(nextProps.picUrl);
  },
  fetchPic: function fetchPic(url) {
    if (this.state.loadedUrl !== url) {
      var pic = new Image();
      pic.src = url;

      pic.onload = () => {
        this.setState({
          pic: pic,
          loadedUrl: url
        });
      };
    }
  },
  render: function render() {
    var setFromScale = _$S.contains([LINE, HISTOGRAM, DOTPLOT], this.props.type);

    var canChangeSnaps = !_$S.contains([PIC, DOTPLOT], this.props.type);

    var props = _objectSpread2({
      trackInteraction: () => {}
    }, this.props);

    return /*#__PURE__*/React$1g.createElement("div", {
      className: "perseus-widget-plotter-editor"
    }, /*#__PURE__*/React$1g.createElement("div", null, "Chart type:", " ", _$S.map([BAR, LINE, PIC, HISTOGRAM, DOTPLOT], function (type) {
      return /*#__PURE__*/React$1g.createElement("label", {
        key: type
      }, /*#__PURE__*/React$1g.createElement("input", {
        type: "radio",
        name: "chart-type",
        checked: this.props.type === type,
        onChange: _$S.partial(this.changeType, type)
      }), type);
    }, this)), /*#__PURE__*/React$1g.createElement("div", null, "Labels:", " ", _$S.map(["x", "y"], function (axis, i) {
      return /*#__PURE__*/React$1g.createElement("label", {
        key: axis
      }, axis + ":", /*#__PURE__*/React$1g.createElement("input", {
        type: "text",
        onChange: _$S.partial(this.changeLabel, i),
        defaultValue: this.props.labels[i]
      }));
    }, this)), setFromScale && /*#__PURE__*/React$1g.createElement("div", {
      className: "set-from-scale-box"
    }, /*#__PURE__*/React$1g.createElement("span", {
      className: "categories-title"
    }, "Set Categories From Scale"), /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Tick Step:", " ", /*#__PURE__*/React$1g.createElement(NumberInput$b, {
      placeholder: 1,
      useArrowKeys: true,
      value: this.state.tickStep,
      onChange: this.handleChangeTickStep
    })), /*#__PURE__*/React$1g.createElement(InfoTip$g, null, /*#__PURE__*/React$1g.createElement("p", null, "The difference between adjacent ticks."))), /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Range:", " ", /*#__PURE__*/React$1g.createElement(RangeInput$4, {
      placeholder: [0, 10],
      useArrowKeys: true,
      value: [this.state.minX, this.state.maxX],
      onChange: this.handleChangeRange
    }))), /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("button", {
      onClick: this.setCategoriesFromScale
    }, "Set Categories", " "))), /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Label Interval:", " ", /*#__PURE__*/React$1g.createElement(NumberInput$b, {
      useArrowKeys: true,
      value: this.props.labelInterval,
      onChange: this.changeLabelInterval
    })), /*#__PURE__*/React$1g.createElement(InfoTip$g, null, /*#__PURE__*/React$1g.createElement("p", null, "Which ticks to display the labels for. For instance, setting this to \"4\" will only show every 4th label (plus the last one)"))), this.props.type === PIC && /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Picture:", " ", /*#__PURE__*/React$1g.createElement(BlurInput$4, {
      className: "pic-url",
      value: this.props.picUrl,
      onChange: this.changePicUrl
    }), /*#__PURE__*/React$1g.createElement(InfoTip$g, null, /*#__PURE__*/React$1g.createElement("p", null, "Use the default picture of Earth, or insert the URL for a different picture using the \"Add image\" function."))), this.state.pic && this.state.pic.width !== this.state.pic.height && /*#__PURE__*/React$1g.createElement("p", {
      className: "warning"
    }, /*#__PURE__*/React$1g.createElement("b", null, "Warning"), ": You are using a picture which is not square. This means the image will get distorted. You should probably crop it to be square.")), /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Categories:", " ", /*#__PURE__*/React$1g.createElement(TextListEditor$3, {
      ref: "categories",
      layout: "horizontal",
      options: this.props.categories,
      onChange: this.changeCategories
    }))), /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Scale (y):", " ", /*#__PURE__*/React$1g.createElement("input", {
      type: "text",
      onChange: this.changeScale,
      defaultValue: this.props.scaleY
    }))), /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Max y:", " ", /*#__PURE__*/React$1g.createElement("input", {
      type: "text",
      ref: "maxY",
      onChange: this.changeMax,
      defaultValue: this.props.maxY
    }))), canChangeSnaps && /*#__PURE__*/React$1g.createElement("div", null, /*#__PURE__*/React$1g.createElement("label", null, "Snaps per line:", " ", /*#__PURE__*/React$1g.createElement("input", {
      type: "text",
      onChange: this.changeSnaps,
      defaultValue: this.props.snapsPerLine
    })), /*#__PURE__*/React$1g.createElement(InfoTip$g, null, /*#__PURE__*/React$1g.createElement("p", null, "Creates the specified number of divisions between the horizontal lines. Fewer snaps between lines makes the graph easier for the student to create correctly."))), /*#__PURE__*/React$1g.createElement("div", null, "Editing values:", " ", _$S.map(["correct", "starting"], function (editing) {
      return /*#__PURE__*/React$1g.createElement("label", {
        key: editing
      }, /*#__PURE__*/React$1g.createElement("input", {
        type: "radio",
        name: "editing",
        checked: this.state.editing === editing,
        onChange: _$S.partial(this.changeEditing, editing)
      }), editing);
    }, this), /*#__PURE__*/React$1g.createElement(InfoTip$g, null, /*#__PURE__*/React$1g.createElement("p", null, "Use this toggle to switch between editing the correct answer (what the student will be graded on) and the starting values (what the student will see plotted when they start the problem). Note: These cannot be the same."), /*#__PURE__*/React$1g.createElement("p", null, "In static mode, the starting values are rendered out to the displayed widget."))), /*#__PURE__*/React$1g.createElement(Plotter, _extends({}, props, {
      starting: this.props[this.state.editing],
      onChange: this.handlePlotterChange
    })));
  },
  handleChangeTickStep: function handleChangeTickStep(value) {
    this.setState({
      tickStep: value
    });
  },
  handleChangeRange: function handleChangeRange(newValue) {
    this.setState({
      minX: newValue[0],
      maxX: newValue[1]
    });
  },
  changeLabelInterval: function changeLabelInterval(value) {
    this.props.onChange({
      labelInterval: value
    });
  },
  handlePlotterChange: function handlePlotterChange(newProps) {
    var props = {};
    props[this.state.editing] = newProps.values;
    this.props.onChange(props);
  },
  changeType: function changeType(type) {
    var categories;

    if (type === HISTOGRAM) {
      // Switching to histogram, add a label (0) to the left
      categories = [formatNumber(0)].concat(this.props.categories);
      this.props.onChange({
        type: type,
        categories: categories
      });
    } else if (this.props.type === HISTOGRAM) {
      // Switching from histogram, remove a label from the left
      categories = this.props.categories.slice(1);
      this.props.onChange({
        type: type,
        categories: categories
      });
    } else {
      this.props.onChange({
        type: type
      });
    }

    if (categories) {
      ReactDOM$d.findDOMNode(this.refs.categories).value = categories.join(", ");
    }
  },
  changeLabel: function changeLabel(i, e) {
    var labels = _$S.clone(this.props.labels);

    labels[i] = e.target.value;
    this.props.onChange({
      labels: labels
    });
  },
  changePicUrl: function changePicUrl(value) {
    // We don't need the labels and other data in the plotter, so just
    // extract the raw image and use that.
    // TODO(emily): Maybe indicate that such a change has happened?
    var url = SvgImage$2.getRealImageUrl(value);
    this.props.onChange({
      picUrl: url
    });
  },
  changeCategories: function changeCategories(categories) {
    var n = categories.length;

    if (this.props.type === HISTOGRAM) {
      // Histograms with n labels/categories have n - 1 buckets
      n--;
    }

    var value = this.props.scaleY;
    this.props.onChange({
      categories: categories,
      correct: padArray(this.props.correct, n, value),
      starting: padArray(this.props.starting, n, value)
    });
  },
  changeScale: function changeScale(e) {
    var oldScale = this.props.scaleY;
    var newScale = +e.target.value || editorDefaults.scaleY;

    var scale = function scale(value) {
      return value * newScale / oldScale;
    };

    var maxY = scale(this.props.maxY);
    this.props.onChange({
      scaleY: newScale,
      maxY: maxY,
      correct: _$S.map(this.props.correct, scale),
      starting: _$S.map(this.props.starting, scale)
    });
    ReactDOM$d.findDOMNode(this.refs.maxY).value = maxY;
  },
  changeMax: function changeMax(e) {
    this.props.onChange({
      maxY: +e.target.value || editorDefaults.maxY
    });
  },
  changeSnaps: function changeSnaps(e) {
    this.props.onChange({
      snapsPerLine: +e.target.value || editorDefaults.snapsPerLine
    });
  },
  changeEditing: function changeEditing(editing) {
    this.setState({
      editing: editing
    });
  },
  setCategoriesFromScale: function setCategoriesFromScale() {
    var scale = this.state.tickStep || 1;
    var min = this.state.minX || 0;
    var max = this.state.maxX || 0;
    var length = Math.floor((max - min) / scale) * scale;
    var categories;

    if (this.props.type === HISTOGRAM || this.props.type === DOTPLOT) {
      // Ranges for histogram and dotplot labels should start at zero
      categories = _$S.range(0, length + scale, scale);
    } else {
      categories = _$S.range(scale, length + scale, scale);
    }

    categories = _$S.map(categories, num => num + min);
    categories = _$S.map(categories, formatNumber);
    this.changeCategories(categories);
    ReactDOM$d.findDOMNode(this.refs.categories).value = categories.join(", ");
  },
  serialize: function serialize() {
    var json = _$S.pick(this.props, "correct", "starting", "type", "labels", "categories", "scaleY", "maxY", "snapsPerLine", "labelInterval");

    if (this.props.type === PIC) {
      json.picUrl = this.props.picUrl;
    }

    return json;
  }
});
_module_$1g.exports = PlotterEditor;
var _widgetsPlotterEditorJsx = _module_$1g.exports;

var _module_$1f = {
  exports: {}
};
/* eslint-disable comma-dangle, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1f = _react__default["default"];
var Changeable$A = Changeable$Q;
var EditorJsonify$g = _mixinsEditorJsonifyJsx;
var PassageRefTargetEditor = createReactClass({
  displayName: "PassageRefTargetEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$A.propTypes), {}, {
    content: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      content: ""
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$A.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$1f.createElement("div", null, "Content:", /*#__PURE__*/React$1f.createElement("input", {
      type: "text",
      value: this.props.content,
      onChange: this.handleContentChange
    }));
  },
  handleContentChange: function handleContentChange(e) {
    this.change({
      content: e.target.value
    });
  },

  serialize() {
    return EditorJsonify$g.serialize.call(this);
  }

});
_module_$1f.exports = PassageRefTargetEditor;
var _widgetsPassageRefTargetEditorJsx = _module_$1f.exports;

var _module_$1e = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1e = _react__default["default"];
var _$R = _underscore__default["default"];
var Changeable$z = Changeable$Q;
var WidgetJsonifyDeprecated$4 = _mixinsWidgetJsonifyDeprecatedJsx;
var Renderer$e = _rendererJsx;
var PassageRefTarget = createReactClass({
  displayName: "PassageRefTarget",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$z.propTypes), {}, {
    content: PropTypes.string,
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      content: "",
      linterContext: linterContextDefault
    };
  },
  getUserInput: function getUserInput() {
    return WidgetJsonifyDeprecated$4.getUserInput.call(this);
  },
  render: function render() {
    return /*#__PURE__*/React$1e.createElement(Renderer$e, {
      content: this.props.content,
      inline: true,
      apiOptions: this.props.apiOptions,
      linterContext: this.props.linterContext
    });
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$z.change.apply(this, args);
  },

  simpleValidate: function simpleValidate(rubric) {
    return PassageRefTarget.validate(this.getUserInput(), rubric);
  }
});

_$R.extend(PassageRefTarget, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

_module_$1e.exports = {
  name: "passage-ref-target",
  displayName: "PassageRefTarget",
  defaultAlignment: "inline",
  widget: PassageRefTarget,
  hidden: true,
  transform: editorProps => {
    return _$R.pick(editorProps, "content");
  },
  version: {
    major: 0,
    minor: 0
  },
  isLintable: true
};
var _widgetsPassageRefTargetJsx = _module_$1e.exports;

var _module_$1d = {
  exports: {}
};
/* eslint-disable react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1d = _react__default["default"];
var Changeable$y = Changeable$Q;
var EditorJsonify$f = _mixinsEditorJsonifyJsx;
var InfoTip$f = _componentsInfoTipJsx;
var NumberInput$a = _componentsNumberInputJsx;
var TextInput$8 = _componentsTextInputJsx;
var PassageRefEditor = createReactClass({
  displayName: "PassageRefEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$y.propTypes), {}, {
    passageNumber: PropTypes.number,
    referenceNumber: PropTypes.number,
    summaryText: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      passageNumber: 1,
      referenceNumber: 1,
      summaryText: ""
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$y.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$1d.createElement("div", null, /*#__PURE__*/React$1d.createElement("div", null, /*#__PURE__*/React$1d.createElement("label", null, "Passage Number: ", /*#__PURE__*/React$1d.createElement(NumberInput$a, {
      value: this.props.passageNumber,
      onChange: this.change("passageNumber")
    }))), /*#__PURE__*/React$1d.createElement("div", null, /*#__PURE__*/React$1d.createElement("label", null, "Reference Number: ", /*#__PURE__*/React$1d.createElement(NumberInput$a, {
      value: this.props.referenceNumber,
      onChange: this.change("referenceNumber")
    }))), /*#__PURE__*/React$1d.createElement("div", null, /*#__PURE__*/React$1d.createElement("label", null, "Summary Text: ", /*#__PURE__*/React$1d.createElement(TextInput$8, {
      value: this.props.summaryText,
      onChange: this.change("summaryText")
    }), /*#__PURE__*/React$1d.createElement(InfoTip$f, null, /*#__PURE__*/React$1d.createElement("p", null, "Short summary of the referenced section. This will be included in parentheses and quotes automatically."), /*#__PURE__*/React$1d.createElement("p", null, "Ex: The start ... the end")))));
  },

  serialize() {
    return EditorJsonify$f.serialize.call(this);
  }

});
_module_$1d.exports = PassageRefEditor;
var _widgetsPassageRefEditorJsx = _module_$1d.exports;

var _module_$1c = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals $_ */

var React$1c = _react__default["default"];
var _$Q = _underscore__default["default"];
var Changeable$x = Changeable$Q;
var PerseusMarkdown = _perseusMarkdownJsx;
var WidgetJsonifyDeprecated$3 = _mixinsWidgetJsonifyDeprecatedJsx;
var EN_DASH$2 = "\u2013";
var PassageRef$1 = createReactClass({
  displayName: "PassageRef",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$x.propTypes), {}, {
    passageNumber: PropTypes.number,
    referenceNumber: PropTypes.number,
    summaryText: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      passageNumber: 1,
      referenceNumber: 1,
      summaryText: ""
    };
  },
  getInitialState: function getInitialState() {
    return {
      lineRange: null,
      content: null
    };
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    return !_$Q.isEqual(this.props, nextProps) || !_$Q.isEqual(this.state, nextState);
  },
  getUserInput: function getUserInput() {
    return WidgetJsonifyDeprecated$3.getUserInput.call(this);
  },
  render: function render() {
    var lineRange = this.state.lineRange;
    var lineRangeOutput;

    if (!lineRange) {
      lineRangeOutput = $_({
        lineRange: "?".concat(EN_DASH$2, "?")
      }, "lines %(lineRange)s");
    } else if (lineRange[0] === lineRange[1]) {
      lineRangeOutput = $_({
        lineNumber: lineRange[0]
      }, "line %(lineNumber)s");
    } else {
      lineRangeOutput = $_({
        lineRange: lineRange[0] + EN_DASH$2 + lineRange[1]
      }, "lines %(lineRange)s");
    }

    var summaryOutput;

    if (this.props.summaryText) {
      var summaryTree = PerseusMarkdown.parseInline(this.props.summaryText);
      summaryOutput = /*#__PURE__*/React$1c.createElement("span", {
        "aria-hidden": true
      }, " ", "(\u201C", PerseusMarkdown.basicOutput(summaryTree), "\u201D)");
    } else {
      summaryOutput = null;
    }

    return /*#__PURE__*/React$1c.createElement("span", null, lineRangeOutput, summaryOutput, lineRange && /*#__PURE__*/React$1c.createElement("div", {
      className: "perseus-sr-only"
    }, this.state.content));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$x.change.apply(this, args);
  },

  componentDidMount: function componentDidMount() {
    this._deferredUpdateRange();

    this._throttledUpdateRange = _$Q.throttle(this._deferredUpdateRange, 500);
    window.addEventListener("resize", this._throttledUpdateRange);
  },
  componentDidUpdate: function componentDidUpdate() {
    this._deferredUpdateRange();
  },
  componentWillUnmount: function componentWillUnmount() {
    window.removeEventListener("resize", this._throttledUpdateRange);
  },
  _deferredUpdateRange: function _deferredUpdateRange() {
    _$Q.defer(this._updateRange);
  },
  _updateRange: function _updateRange() {
    var passage = this.props.findWidgets("passage " + this.props.passageNumber)[0];
    var refInfo = null;

    if (passage) {
      refInfo = passage.getReference(this.props.referenceNumber);
    }

    if (this.isMounted()) {
      if (refInfo) {
        this.setState({
          lineRange: [refInfo.startLine, refInfo.endLine],
          content: refInfo.content
        });
      } else {
        this.setState({
          lineRange: null,
          content: null
        });
      }
    }
  },
  simpleValidate: function simpleValidate(rubric) {
    return PassageRef$1.validate(this.getUserInput(), rubric);
  }
});

_$Q.extend(PassageRef$1, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

_module_$1c.exports = {
  name: "passage-ref",
  displayName: "PassageRef (SAT only)",
  defaultAlignment: "inline",
  widget: PassageRef$1,
  transform: editorProps => {
    return _$Q.pick(editorProps, "passageNumber", "referenceNumber", "summaryText");
  },
  version: {
    major: 0,
    minor: 1
  }
};
var _passageRefJsx = _module_$1c.exports;

var _module_$1b = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$1b = _react__default["default"];
var Changeable$w = Changeable$Q;
var EditorJsonify$e = _mixinsEditorJsonifyJsx;
var Editor$8 = _editorJsx;
var InfoTip$e = _componentsInfoTipJsx;
var PropCheckBox$a = _componentsPropCheckBoxJsx;
var PassageEditor = createReactClass({
  displayName: "PassageEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$w.propTypes), {}, {
    passageTitle: PropTypes.string,
    passageText: PropTypes.string,
    footnotes: PropTypes.string,
    showLineNumbers: PropTypes.bool
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      passageTitle: "",
      passageText: "",
      footnotes: "",
      showLineNumbers: true
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$w.change.apply(this, args);
  },

  render: function render() {
    var passageEditor = /*#__PURE__*/React$1b.createElement(Editor$8, {
      ref: "passage-editor",
      apiOptions: this.props.apiOptions,
      content: this.props.passageText,
      widgetEnabled: false,
      placeholder: "Type passage here...",
      onChange: newProps => {
        this.change({
          passageText: newProps.content
        });
      },
      showWordCount: true
    });
    var footnotesEditor = /*#__PURE__*/React$1b.createElement(Editor$8, {
      ref: "passage-footnotes-editor",
      apiOptions: this.props.apiOptions,
      content: this.props.footnotes,
      widgetEnabled: false,
      placeholder: "Type footnotes here...",
      onChange: newProps => {
        this.change({
          footnotes: newProps.content
        });
      }
    });
    return /*#__PURE__*/React$1b.createElement("div", {
      className: "perseus-widget-passage-editor"
    }, /*#__PURE__*/React$1b.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$1b.createElement(PropCheckBox$a, {
      label: "Show line numbers",
      labelAlignment: "right",
      showLineNumbers: this.props.showLineNumbers,
      onChange: this.props.onChange
    })), /*#__PURE__*/React$1b.createElement("div", null, "Passage title:", /*#__PURE__*/React$1b.createElement(InfoTip$e, null, /*#__PURE__*/React$1b.createElement("p", null, "An optional title that will appear directly above the passage in the same font style. (E.g. Passage 1)")), /*#__PURE__*/React$1b.createElement("div", null, /*#__PURE__*/React$1b.createElement("input", {
      type: "text",
      defaultValue: this.props.passageTitle,
      onChange: e => {
        this.change({
          passageTitle: e.target.value
        });
      }
    }))), /*#__PURE__*/React$1b.createElement("div", null, "Passage Text:", passageEditor), /*#__PURE__*/React$1b.createElement("div", null, "Footnotes:", /*#__PURE__*/React$1b.createElement(InfoTip$e, null, /*#__PURE__*/React$1b.createElement("p", null, "To add footnotes, add ^ characters where they belong in the passage. Then, add ^ in the footnotes area to reference the footnotes in the passage.")), footnotesEditor));
  },

  serialize() {
    return EditorJsonify$e.serialize.call(this);
  }

});
_module_$1b.exports = PassageEditor;
var _widgetsPassageEditorJsx = _module_$1b.exports;

var _module_$1a = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals $_ */

var React$1a = _react__default["default"];
var SimpleMarkdown = _simpleMarkdown__default["default"];
var _$P = _underscore__default["default"];
var START_REF_PREFIX = "start-ref-";
var END_REF_PREFIX = "end-ref-";
var REF_STYLE = {
  display: "inline-block",
  width: 0,
  visibility: "hidden"
};
var LABEL_OUTER_STYLE = {
  // for some reason we need these to keep the nbsp from wrapping when the
  // inner circle/square is display: inline-block
  display: "inline",
  whiteSpace: "nowrap"
};
var SQUARE_LABEL_STYLE = {
  display: "inline-block",
  color: "rgb(255, 255, 255)",
  backgroundColor: "rgb(90, 90, 90)",
  paddingLeft: 10,
  paddingRight: 10,
  userSelect: "none",
  WebkitUserSelect: "none"
};
var CIRCLE_LABEL_STYLE = {
  display: "inline-block",
  color: "rgb(255, 255, 255)",
  backgroundColor: "rgb(90, 90, 90)",
  userSelect: "none",
  WebkitUserSelect: "none",
  width: 22,
  height: 22,
  borderRadius: "50%",
  textAlign: "center"
};
var RefStart = createReactClass({
  displayName: "RefStart",
  propTypes: {
    refContent: PropTypes.node.isRequired
  },
  render: function render() {
    return /*#__PURE__*/React$1a.createElement("span", {
      style: REF_STYLE
    }, "_");
  },
  getRefContent: function getRefContent() {
    return this.props.refContent;
  }
});
var RefEnd = createReactClass({
  displayName: "RefEnd",
  render: function render() {
    return /*#__PURE__*/React$1a.createElement("span", {
      style: REF_STYLE
    }, "_");
  }
});
var rules = {
  newline: SimpleMarkdown.defaultRules.newline,
  paragraph: SimpleMarkdown.defaultRules.paragraph,
  escape: SimpleMarkdown.defaultRules.escape,
  passageFootnote: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.1,
    match: SimpleMarkdown.inlineRegex(/^\^/),
    parse: (capture, _parse, state) => {
      // if no footnotes have been seen, we're id 1. otherwise,
      // we're the next subsequent id
      var id = state.lastFootnote.id + 1;
      var footnote = {
        id: id,
        // our text is what to output. if there is only one footnote,
        // it's a *; otherwise it's a superscript number
        text: id === 1 ? "*" : "" + id
      }; // If the previous footnote was a *, we need to adjust it to be
      // a number, since now we know there is more than one footnote

      if (state.lastFootnote.text === "*") {
        state.lastFootnote.text = "" + state.lastFootnote.id;
      } // and update our last footnote, + return.


      state.lastFootnote = footnote;
      return footnote;
    },
    react: (node, output, state) => {
      return /*#__PURE__*/React$1a.createElement("sup", {
        key: state.key
      }, node.text);
    }
  },
  refStart: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.2,
    match: function match(source, state) {
      var capture = /^\{\{/.exec(source);

      if (capture) {
        // We need to do extra processing here to capture the
        // full text of the reference, which we include so that
        // we can use that information as a screenreader
        var closeIndex = 2; // start looking after the opening "{{"

        var refNestingLevel = 0; // Find the closing "}}" for our opening "{{"

        while (closeIndex < source.length) {
          var token = source.slice(closeIndex, closeIndex + 2);

          if (token === "{{") {
            refNestingLevel++; // increment an extra character so we get the
            // full 2-char token

            closeIndex++;
          } else if (token === "}}") {
            if (refNestingLevel > 0) {
              refNestingLevel--; // increment an extra character so we get the
              // full 2-char token

              closeIndex++;
            } else {
              break;
            }
          }

          closeIndex++;
        }

        var refText = source.slice(2, closeIndex); // A "magic" capture that matches the opening {{
        // but captures the full ref text internally :D

        return [capture[0], refText];
      } else {
        return null;
      }
    },
    parse: (capture, _parse2, state) => {
      if (!state.useRefs) {
        return {
          ref: null,
          refContent: null
        };
      }

      var ref = state.lastRef + 1;
      state.lastRef = ref;
      state.currentRef.push(ref);

      var refContent = _parse2( // Curly quotes
      "(\u201C" + capture[1] + "\u201D)\n\n", _$P.defaults({
        // We don't want to parse refs while looking through
        // this refs contents. We definitely don't want
        // to make those refs into react refs on the
        // passage, for instance!
        useRefs: false
      }, INITIAL_PARSE_STATE));

      return {
        ref: ref,
        refContent: refContent
      };
    },
    react: (node, output, state) => {
      if (node.ref == null) {
        return null;
      } // We don't pass state here because this is parsed
      // and output out-of-band. We don't want to affect
      // our state by the double-output here :).


      var refContent = output(node.refContent, {});
      return /*#__PURE__*/React$1a.createElement(RefStart, {
        ref: START_REF_PREFIX + node.ref,
        key: START_REF_PREFIX + node.ref,
        refContent: refContent
      });
    }
  },
  refEnd: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.3,
    match: SimpleMarkdown.inlineRegex(/^\}\}/),
    parse: (capture, _parse3, state) => {
      if (!state.useRefs) {
        return {
          ref: null
        };
      }

      var ref = state.currentRef.pop() || null;
      return {
        ref: ref
      };
    },
    react: (node, output, state) => {
      if (node.ref != null) {
        return /*#__PURE__*/React$1a.createElement(RefEnd, {
          ref: END_REF_PREFIX + node.ref,
          key: END_REF_PREFIX + node.ref
        });
      } else {
        // if we didn't have a matching start reference, or
        // we aren't parsing refs for this pass (we do this
        // inside of refContent), don't output a ref
        return null;
      }
    }
  },
  squareLabel: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.4,
    match: SimpleMarkdown.inlineRegex(/^\[\[(\w+)\]\]( *)/),
    parse: (capture, _parse4, state) => {
      if (!state.firstQuestionRef) {
        state.firstQuestionRef = capture[1];
      }

      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React$1a.createElement("span", {
        key: "visual-square",
        className: "perseus-passage-square-label",
        style: LABEL_OUTER_STYLE,
        "aria-hidden": "true"
      }, /*#__PURE__*/React$1a.createElement("span", {
        style: SQUARE_LABEL_STYLE
      }, node.content)), /*#__PURE__*/React$1a.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, $_({
        number: node.content
      }, "[Marker for question %(number)s]")), node.space ? "\u00A0" : null];
    }
  },
  circleLabel: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.5,
    match: SimpleMarkdown.inlineRegex(/^\(\((\w+)\)\)( *)/),
    parse: (capture, _parse5, state) => {
      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React$1a.createElement("span", {
        key: "visual-circle",
        className: "perseus-passage-circle-label",
        style: LABEL_OUTER_STYLE,
        "aria-hidden": true
      }, /*#__PURE__*/React$1a.createElement("span", {
        style: CIRCLE_LABEL_STYLE
      }, node.content)), /*#__PURE__*/React$1a.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, $_({
        number: node.content
      }, "[Circle marker %(number)s]")), node.space ? "\u00A0" : null];
    }
  },
  squareBracketRef: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.6,
    match: SimpleMarkdown.inlineRegex(/^\[(\d+)\]( *)/),
    parse: (capture, _parse6, state) => {
      if (!state.firstSentenceRef) {
        state.firstSentenceRef = capture[1];
      }

      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React$1a.createElement("span", {
        key: "visual-brackets",
        className: "perseus-passage-bracket-label",
        "aria-hidden": "true"
      }, "[", node.content, "]"), /*#__PURE__*/React$1a.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, $_({
        number: node.content
      }, "[Sentence %(number)s]")), node.space ? "\u00A0" : null];
    }
  },
  highlight: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.7,
    match: SimpleMarkdown.inlineRegex(/^{highlighting.start}(.+?){highlighting.end}/),
    parse: (capture, _parse7, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React$1a.createElement("span", {
        className: "perseus-highlight"
      }, node.content)];
    }
  },
  reviewHighlight: {
    order: SimpleMarkdown.defaultRules.escape.order + 0.7,
    match: SimpleMarkdown.inlineRegex(/^{review-highlighting.start}(.+?){review-highlighting.end}/),
    parse: (capture, _parse8, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React$1a.createElement("span", {
        className: "perseus-review-highlight"
      }, node.content)];
    }
  },
  strong: SimpleMarkdown.defaultRules.strong,
  u: SimpleMarkdown.defaultRules.u,
  em: SimpleMarkdown.defaultRules.em,
  del: SimpleMarkdown.defaultRules.del,
  text: _objectSpread2(_objectSpread2({}, SimpleMarkdown.defaultRules.text), {}, {
    react(node, output, state) {
      return /*#__PURE__*/React$1a.createElement("span", {
        key: state.key
      }, node.content);
    }

  })
};
var INITIAL_PARSE_STATE = {
  currentRef: [],
  useRefs: true,
  lastRef: 0,
  lastFootnote: {
    id: 0,
    text: ""
  }
};
var builtParser = SimpleMarkdown.parserFor(rules);

var parse = (source, state) => {
  state = state || {};
  var paragraphedSource = source + "\n\n";
  return builtParser(paragraphedSource, _$P.extend(state, INITIAL_PARSE_STATE));
};

_module_$1a.exports = {
  parse: parse,
  output: SimpleMarkdown.reactFor(SimpleMarkdown.ruleOutput(rules, "react")),
  START_REF_PREFIX: START_REF_PREFIX,
  END_REF_PREFIX: END_REF_PREFIX,
  _rulesForTesting: rules
};
var _passagePassageMarkdownJsx = _module_$1a.exports;

/**
 * Given two DOMRange objects, and a choice of start/end point for each, compare
 * the two chosen points. Return -1 if a's comes first in the document, return
 * 1 if b's comes first in the document, or 0 if they represent the same point
 * in the document.
 *
 * NOTE(mdr): This function exists primarily to cover over some confusing parts
 *     of the DOM's `compareBoundaryPoints` API, and to cover over a Flow bug
 *     documented here: https://github.com/facebook/flow/issues/3734.
 */

function compareRangeBoundaryPoints(a, whichA, b, whichB) {
  var mode;

  if (whichA === "start" && whichB === "start") {
    // $FlowFixMe(mdr)
    mode = Range.START_TO_START;
  } else if (whichA === "start" && whichB === "end") {
    // NOTE(mdr): Confusingly, the correct constant here is actually
    //     `END_TO_START`, which is the reverse of what you'd expect.
    // $FlowFixMe(mdr)
    mode = Range.END_TO_START;
  } else if (whichA === "end" && whichB === "start") {
    // NOTE(mdr): Confusingly, the correct constant here is actually
    //     `START_TO_END`, which is the reverse of what you'd expect.
    // $FlowFixMe(mdr)
    mode = Range.START_TO_END;
  } else {
    // $FlowFixMe(mdr)
    mode = Range.END_TO_END;
  }

  return a.compareBoundaryPoints(mode, b);
}
/**
 * Given two DOMRanges, return a DOMRange whose start point comes from A, and
 * whose end point comes from B.
 */


function spanRanges(a, b) {
  var range = a.cloneRange();
  range.setEnd(b.endContainer, b.endOffset);
  return range;
}
/**
 * Given two DOMRanges, return whether they overlap.
 *
 * We here treat ranges like closed intervals: the boundary points are
 * considered to be included in the range, and, if a ends exactly where b
 * starts, they are considered to overlap.
 */


function rangesOverlap(a, b) {
  // Two ranges do *not* overlap iff one ends before the other begins.
  var rangesDoNotOverlap = compareRangeBoundaryPoints(a, "end", b, "start") < 0 || compareRangeBoundaryPoints(b, "end", a, "start") < 0;
  return !rangesDoNotOverlap;
}
/**
 * Given two DOMRanges, return whether the first includes the second: whether
 * all points that B contains are also contained by A.
 */


function rangeIncludes(a, b) {
  var rangeIsIncluded = compareRangeBoundaryPoints(a, "start", b, "start") <= 0 && compareRangeBoundaryPoints(a, "end", b, "end") >= 0;
  return rangeIsIncluded;
}
/**
 * Given two DOMRanges, intersect them: return a range that contains all points
 * that both A contains and B contains, and contains no other points.
 *
 * If A and B do not overlap, no intersection exists; return null.
 */


function intersectRanges(a, b) {
  if (!rangesOverlap(a, b)) {
    return null;
  } // Find the range with the latest start point, and the range with the
  // earliest end point.


  var starter = compareRangeBoundaryPoints(a, "start", b, "start") > 0 ? a : b;
  var ender = compareRangeBoundaryPoints(a, "end", b, "end") < 0 ? a : b;
  return spanRanges(starter, ender);
}
/**
 * Given two DOMRanges, union them: return a range that contains all points
 * that either A contains or B contains, and contains no other points.
 *
 * If A and B do not overlap, no union exists; return null.
 */


function unionRanges(a, b) {
  if (!rangesOverlap(a, b)) {
    return null;
  } // Find the range with the earliest start point, and the range with the
  // latest end point.


  var starter = compareRangeBoundaryPoints(a, "start", b, "start") < 0 ? a : b;
  var ender = compareRangeBoundaryPoints(a, "end", b, "end") > 0 ? a : b;
  return spanRanges(starter, ender);
}
/**
 * Given a list of word ranges, and a selection range, binary search the list
 * and return the index of the goal word, or -1 if no satisfactory goal word
 * exists in the list.
 *
 * If `goal` is "first", return the index of the first word whose end point is
 * after the selection's start point.
 *
 * If `goal` is "last", return the index of the last word whose start point is
 * before the selection's end point.
 */


function findBoundaryWordIndex(selectionRange, wordRanges, goal, initialLowerBound, initialUpperBound) {
  var bestValidWordIndex = -1;
  var lowerBound = initialLowerBound;
  var upperBound = initialUpperBound;
  var iterationCount = 0;

  while (lowerBound <= upperBound) {
    iterationCount++;

    if (iterationCount > wordRanges.length * 2) {
      throw new Error("Assertion error: Binary search isn't terminating? " + "lower=".concat(lowerBound, ", upper=").concat(upperBound));
    }

    var mid = Math.floor((lowerBound + upperBound) / 2);

    if (goal === "first") {
      var rangeComparison = compareRangeBoundaryPoints(wordRanges[mid], "end", selectionRange, "start");

      if (rangeComparison <= 0) {
        // If this word's end point is before or equal to the
        // selection's start point, then this word is not a valid
        // candidate, nor are any of the words before it.
        //
        // Update our bounds to look for a valid word after this one.
        lowerBound = mid + 1;
      } else {
        // If this word's end point is after the selection's start
        // point, then this word is valid, and is, by nature of the
        // search, the earliest valid word we're aware of.
        //
        // Update our bounds to look for a better valid word before
        // this one.
        bestValidWordIndex = mid;
        upperBound = mid - 1;
      }
    } else {
      var _rangeComparison = compareRangeBoundaryPoints(wordRanges[mid], "start", selectionRange, "end");

      if (_rangeComparison >= 0) {
        // If this word's start point is after or equal to the
        // selection's end point, then this word is not a valid
        // candidate, nor are any of the words after it.
        //
        // Update our bounds to look for a valid word before this one.
        upperBound = mid - 1;
      } else {
        // If this word's start point is before the selection's end
        // point, then this word is valid, and is, by nature of the
        // search, the latest valid word we're aware of.
        //
        // Update our bounds to look for a better valid word after
        // this one.
        bestValidWordIndex = mid;
        lowerBound = mid + 1;
      }
    }
  }

  return bestValidWordIndex;
}
/**
 * Given a list of word ranges, and a selection range, binary search the list
 * and return the indexes of the first and last words that the selection
 * intersects, or `null` if the range includes no words.
 */


function findFirstAndLastWordIndexes(selectionRange, wordRanges) {
  // Find the first word whose end point is after the selection's start
  // point.
  //
  // Note that this does *not* alone prove that this word is *intersected* by
  // the current range; to intersect, the first word's start point must also
  // be before the selection's end point. This is proven by the success of
  // the second search.
  //
  // (For example, imagine highlighting the space between two words. This
  // search would return the first word after the selection, despite not
  // intersecting the selection.)
  var firstWordIndex = findBoundaryWordIndex(selectionRange, wordRanges, "first", 0, wordRanges.length - 1);

  if (firstWordIndex < 0) {
    return null;
  } // Find the last word whose start point is before the selection's end
  // point.
  //
  // Start the search with our candidate first word, because, while we don't
  // know whether our candidate first word intersects the selection, we *do*
  // know that no *earlier* word intersects the selection, or else it would
  // have been yielded as the candidate first word instead.


  var lastWordIndex = findBoundaryWordIndex(selectionRange, wordRanges, "last", firstWordIndex, wordRanges.length - 1);

  if (lastWordIndex < 0) {
    return null;
  } // Now, we have discovered a candidate first word F, and a candidate last
  // word L. Let's prove that these are indeed the first and last intersected
  // words of the selection S.
  //
  // Syntax: Let A1 and A2 represent the start and end point of range A.
  //
  // Definition: A1 <= A2 for any range A.
  //
  // Theorem 1: Two ranges A and B intersect iff A1 <= B2 and B1 <= A2.
  // Proof: See http://www.rgrjr.com/emacs/overlap.html, and extend the
  //     result to closed intervals by also accepting equality.
  //
  // Given 1: F1 <= L1 and F2 <= L2. That is, either the first and last word
  //     are the same, or the last word comes after, because we provided
  //     `firstWordIndex` as the lower bound when search for L.
  // Given 2: S1 <= F2, and no earlier word's end point is >= S1, because
  //     F was returned by `findBoundaryWordIndex` with goal "first".
  // Given 3: L1 <= S2, and no later word's start point is <= S2, because
  //     L was returned by `findBoundaryWordIndex` with goal "last".
  //
  // Conclusion 1: F intersects S.
  // Proof: By Theorem 1, we must show that F1 <= S2 and S1 <= F2.
  //     F1 <= L1 <= S2, by Given 1 and Given 3.
  //     S1 <= F2, by Given 2. QED.
  //
  // Conclusion 2: L intersects S.
  // Proof: By Theorem 1, we must show that L1 <= S2 and S1 <= L2.
  //     L1 <= S2 by Given 3.
  //     S1 <= F2 <= L2, by Given 1 and Given 2. QED.
  //
  // Conclusion 3: No word earlier than F intersects S.
  // Proof: Consider some word W earlier than F.
  //     W2 < S1, by Given 2. Therefore, it's false that S1 <= W2.
  //     Therefore, W and S do not intersect, by Theorem 1. QED.
  //
  // Conclusion 4: No word later than L intersects S.
  // Proof: Consider some word W later than L.
  //     W1 > S2, by Given 2. Therefore, it's false that W1 <= S2.
  //     Therefore, W and S do not intersect, by Theorem 1, QED.
  //
  // Therefore, while neither of these two searches alone proves that F is
  // the first intersected word of S, or that L is the last intersected word
  // of S, the implications of the two searches are sufficient proof when
  // combined. Return these two indexes with confidence, hooray!


  return [firstWordIndex, lastWordIndex];
}

/**
 * Given a list of DOMHighlights, return a new list that also includes the
 * given DOMRange as a new DOMHighlight. If the DOMHighlight intersects
 * existing DOMHighlights, the other Highlights are removed and their ranges
 * are merged into the new DOMHighlight.
 */

function addHighlight(existingHighlights, newHighlight) {
  var newHighlights = {}; // Merge the new highlight with any existing highlights that intersect it.

  var mergedDomRange = newHighlight.domRange;
  var mergedFirstWordIndex = newHighlight.firstWordIndex;
  var mergedLastWordIndex = newHighlight.lastWordIndex;

  for (var key of Object.keys(existingHighlights)) {
    var h = existingHighlights[key];
    var newMergedDomRange = unionRanges(h.domRange, mergedDomRange);

    if (newMergedDomRange) {
      // This highlight's range was successfully merged into the new
      // highlight. Update `mergedDomRange`, and *don't* add it to the
      // new set of highlights.
      mergedDomRange = newMergedDomRange;
      mergedFirstWordIndex = Math.min(h.firstWordIndex, mergedFirstWordIndex);
      mergedLastWordIndex = Math.max(h.lastWordIndex, mergedLastWordIndex);
    } else {
      // This highlight's range can't be merged into the new highlight.
      // Add it to the new set of highlights.
      newHighlights[key] = h;
    }
  }

  var newMergedHighlight = {
    firstWordIndex: mergedFirstWordIndex,
    lastWordIndex: mergedLastWordIndex,
    domRange: mergedDomRange
  }; // Add the newly-merged highlight to the set of highlights, under a new,
  // unique key.

  var existingKeys = Object.keys(newHighlights);
  var newKey = createNewUniqueKey(existingKeys);
  newHighlights[newKey] = newMergedHighlight;
  return newHighlights;
}
/**
 * Given a DOMRange and a list of word ranges, build a corresponding
 * DOMHighlight.
 *
 * If the DOMRange is not a valid highlight given the word ranges, return null.
 */


function buildHighlight(existingHighlights, wordRanges, newHighlightRange) {
  // If any existing highlight fully contains the new highlight range, it's
  // redundant and therefore not valid to build this as a highlight.
  // Return null.
  //
  // NOTE(mdr): Really, our goal is to determine whether the new range's
  //     content is already fully highlighted, so you could imagine this
  //     logic not catching the case where a range's contents are fully
  //     highlighted, but by multiple ranges.
  //
  //     However, words aren't actually adjacent; they have spaces between
  //     them. So, even if each word in the range is currently highlighted,
  //     the space between a pair of words will only be highlighted if
  //     they're included in the same highlight range.
  //
  //     Therefore, if this new range isn't fully contained by an existing
  //     highlight, then there's at *least* an unhighlighted space within the
  //     range. In that case, it makes sense to offer this as a new highlight
  //     that, when added, will merge with the highlights that it intersects.
  for (var key of Object.keys(existingHighlights)) {
    var existingHighlightRange = existingHighlights[key].domRange;

    if (rangeIncludes(existingHighlightRange, newHighlightRange)) {
      return null;
    }
  } // If the new highlight range doesn't span two words from the content, it's
  // not valid to build this as a highlight. Return null.


  var indexes = findFirstAndLastWordIndexes(newHighlightRange, wordRanges);

  if (!indexes) {
    return null;
  }

  var [firstWordIndex, lastWordIndex] = indexes;
  var firstWord = wordRanges[firstWordIndex];
  var lastWord = wordRanges[lastWordIndex];
  return {
    firstWordIndex,
    lastWordIndex,
    domRange: spanRanges(firstWord, lastWord)
  };
}
/**
 * Given a list of keys, return a new unique key that is not in the list.
 */


function createNewUniqueKey(existingKeys) {
  // The base of the key is the current time, in milliseconds since epoch.
  var base = "".concat(new Date().getTime());

  if (!existingKeys.includes(base)) {
    return base;
  } // But, if the user is a fast-clicker or time-traveler or something, and
  // already has a highlight from this millisecond, then let's attach a
  // suffix and keep incrementing it until we find an unused suffix.


  var suffix = 0;
  var key;

  do {
    key = "".concat(base, "-").concat(suffix);
    suffix++;
  } while (existingKeys.includes(key));

  return key;
}
/**
 * Given a SerializedHightlight and the current set of word ranges, return a
 * DOMHighlight representing the SerializedHighlight.
 *
 * If the SerializedHighlight is not valid given the list of word ranges, throw
 * an error.
 */


function deserializeHighlight(serializedHighlight, wordRanges) {
  var {
    firstWordIndex,
    lastWordIndex
  } = serializedHighlight.range;
  var firstWord = wordRanges[firstWordIndex];

  if (!firstWord) {
    throw new Error("first word index ".concat(firstWord, " is out of bounds: ") + "must be 0\u2013".concat(wordRanges.length - 1, " inclusive"));
  }

  var lastWord = wordRanges[lastWordIndex];

  if (!lastWord) {
    throw new Error("last word index ".concat(lastWord, " is out of bounds: ") + "must be 0\u2013".concat(wordRanges.length - 1, " inclusive"));
  }

  return {
    firstWordIndex,
    lastWordIndex,
    domRange: spanRanges(firstWord, lastWord)
  };
}
/**
 * Return a SerializedHighlight representing the given DOMHighlight.
 */


function serializeHighlight(highlight) {
  var {
    firstWordIndex,
    lastWordIndex
  } = highlight;
  return {
    range: {
      type: "word-indexes",
      firstWordIndex,
      lastWordIndex
    }
  };
}

var _module_$19 = {
  exports: {}
};
/**
 * This component, whenever its content updates, traverses the DOM to find
 * semantic words and send the corresponding DOMRanges to the caller via a
 * callback.
 *
 * A "word" here is a sequence of non-whitespace text characters, uninterrupted
 * by the start/end of a non-inline element. That is, a word can span across
 * text nodes and inline tags like <b>, but cannot span across block
 * paragraphs.
 *
 * The words yielded by WordIndexer are sorted in document order, which makes
 * them amenable to binary search - see `findBoundaryWordIndex` in ranges.js.
 */

var React$19 = _react__default["default"];

class WordIndexer$1 extends React$19.PureComponent {
  /* eslint-enable react/sort-comp */
  componentDidMount() {
    this._sendWordsUpdate();
  }

  componentDidUpdate() {
    this._sendWordsUpdate();
  }

  _sendWordsUpdate() {
    this.props.onWordsUpdate(this._getWordRanges());
  }

  _getWordRanges() {
    var container = this._container;

    if (!container) {
      throw new Error("invariant violation: `this._container` is not defined, but " + "this method is only called after mount/update");
    } // Create a TreeWalker that visits text nodes and element nodes.
    // We select the types of nodes we're interested in by bitwise-ORing
    // the desired filters together.


    var treeWalker = container.ownerDocument.createTreeWalker(container, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, () => NodeFilter.FILTER_ACCEPT, false); // Traverse the container's descendant text nodes in DOM order,
    // indexing the words we find.

    var index = [];
    var trailingWordRange = null;

    while (treeWalker.nextNode()) {
      var node = treeWalker.currentNode;

      if (node.nodeType === Node.ELEMENT_NODE) {
        var element = node;

        if (getComputedStyle(element).display !== "inline") {
          // Block-level elements interrupt text words, so set the
          // current trailing word to `null`.
          //
          // This includes exiting one paragraph to visit another,
          // but also includes text interrupted by inline-block
          // elements.
          //
          // TODO(mdr): Is this behavior *generalizably* correct?
          // TODO(mdr): I don't *fully* understand the performance
          //     implications of `getComputedStyle`, but I think it's
          //     gonna be nbd at the current call sites. If we try to
          //     generalize to frequently-updating content, we might
          //     want to watch this as a potential performance
          //     bottleneck.
          trailingWordRange = null;
        }
      } else if (node.nodeType === Node.TEXT_NODE) {
        var text = node.nodeValue; // A "word" is here simply defined as a maximal-length
        // substring of non-space characters.
        //
        // Loop over all the words in the string, by repeatedly calling
        // `wordPattern.exec(text)`.

        var wordPattern = /\S+/g;
        var wordMatch = void 0;
        var newTrailingWordRange = null;

        while ((wordMatch = wordPattern.exec(text)) !== null) {
          var startOffset = wordMatch.index;
          var endOffset = wordMatch.index + wordMatch[0].length;
          var range = void 0;

          if (startOffset === 0 && trailingWordRange) {
            // This word is at the start of this text node, and
            // there's a trailing word from the previous text node,
            // and there was no non-inline element between them.
            // This word and the trailing word are probably
            // intended to be two parts of the same word.
            //
            // So, instead of creating a new word range, we add
            // this word to the previous range by extending it.
            range = trailingWordRange;
            range.setEnd(node, endOffset);
          } else {
            // Otherwise, start a new word range here, and add it
            // to the list.
            range = node.ownerDocument.createRange();
            range.setStart(node, startOffset);
            range.setEnd(node, endOffset);
            index.push(range);
          }

          if (endOffset === text.length) {
            newTrailingWordRange = range;
          }
        }

        trailingWordRange = newTrailingWordRange;
      }
    }

    return index;
  }

  render() {
    return /*#__PURE__*/React$19.createElement("div", {
      ref: container => this._container = container
    }, this.props.children);
  }

}

_module_$19.exports = WordIndexer$1;
var _wordIndexerJsx = _module_$19.exports;

var _module_$18 = {
  exports: {}
};
/**
 * Tracks the user's current selection, and exposes it to the subtree using the
 * function-as-children pattern.
 */

var React$18 = _react__default["default"];

class SelectionTracker$1 extends React$18.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      mouseState: "up",
      trackedSelection: null
    });

    _defineProperty(this, "_handleSelectionChange", () => {
      this._updateTrackedSelection(this.props.buildHighlight);

      if (this.state.mouseState === "down") {
        this.setState({
          mouseState: "down-and-selecting"
        });
      }
    });

    _defineProperty(this, "_handleMouseDown", () => {
      this.setState({
        mouseState: "down"
      });
    });

    _defineProperty(this, "_handleMouseUp", () => {
      this.setState({
        mouseState: "up"
      });
    });
  }

  componentDidMount() {
    this._updateListeners(false, this.props.enabled);
  }

  componentWillReceiveProps(nextProps) {
    if (this.props.buildHighlight !== nextProps.buildHighlight) {
      // The highlight-building function changed, so the
      // proposedHighlight we built with it might be different, or no
      // longer be valid. Update accordingly.
      this._updateTrackedSelection(nextProps.buildHighlight);
    }

    this._updateListeners(this.props.enabled, nextProps.enabled);
  }

  componentWillUnmount() {
    this._updateListeners(this.props.enabled, false);
  }

  _updateListeners(wasListening, willListen) {
    if (!wasListening && willListen) {
      window.addEventListener("mousedown", this._handleMouseDown);
      window.addEventListener("mouseup", this._handleMouseUp);
      document.addEventListener("selectionchange", this._handleSelectionChange);
    } else if (wasListening && !willListen) {
      window.removeEventListener("mousedown", this._handleMouseDown);
      window.removeEventListener("mouseup", this._handleMouseUp);
      document.removeEventListener("selectionchange", this._handleSelectionChange); // Additionally, reset the state, to guard against errors where we
      // re-enter listening mode and have stale values stored.

      this.setState({
        mouseState: "up",
        trackedSelection: null
      });
    }
  }
  /**
   * Get the current selection focus and range, if present and non-collapsed.
   *
   * Otherwise, if there is no current selection or it's collapsed, return
   * null.
   */


  _computeFocusAndRange() {
    var selection = document.getSelection();

    if (!selection || selection.rangeCount === 0) {
      return null;
    }

    var range = selection.getRangeAt(0);

    if (range.collapsed) {
      return null;
    } // NOTE(mdr): The focus node is guaranteed to exist, because
    //     there's a range, but the Flow type annotations for
    //     Selection don't know that. Cast it ourselves.


    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    return {
      focusNode,
      focusOffset,
      range
    };
  }
  /**
   * Compute the current TrackedSelection from the document state.
   */


  _computeTrackedSelection(buildHighlight) {
    var focusAndRange = this._computeFocusAndRange();

    if (!focusAndRange) {
      return null;
    }

    var {
      focusNode,
      focusOffset,
      range
    } = focusAndRange;
    var proposedHighlight = buildHighlight(range);

    if (!proposedHighlight) {
      return null;
    }

    return {
      focusNode,
      focusOffset,
      proposedHighlight
    };
  }
  /**
   * Update the TrackedSelection to reflect the document state.
   */


  _updateTrackedSelection(buildHighlight) {
    var trackedSelection = this._computeTrackedSelection(buildHighlight);

    this.setState({
      trackedSelection
    });
  }

  render() {
    var {
      mouseState,
      trackedSelection
    } = this.state;
    var userIsMouseSelecting = mouseState === "down-and-selecting";
    return this.props.children && /*#__PURE__*/React$18.createElement("div", null, this.props.children(trackedSelection, userIsMouseSelecting));
  }

}

_module_$18.exports = SelectionTracker$1;
var _selectionTrackerJsx = _module_$18.exports;

/**
 * Given two positions relative to the same origin, return `child`'s position
 * relative to `parent`'s position.
 */

function getRelativePosition(child, parent) {
  return {
    left: child.left - parent.left,
    top: child.top - parent.top
  };
}
/**
 * `getRelativePosition`, but for Rects.
 *
 * Given a rectangle and a position relative to the same origin, return a new
 * rectangle of the same size, whose position is relative to the given
 * position.
 */

function getRelativeRect(child, parent) {
  return _objectSpread2(_objectSpread2({}, getRelativePosition(child, parent)), {}, {
    width: child.width,
    height: child.height
  });
}
/**
 * Given a DOMRange, return a list of client-relative rects that cover the text
 * inside the DOMRange.
 *
 * This behaves differently than the browser's built-in `getClientRects` method
 * for DOMRanges, because this method only gets rects for the *text* nodes,
 * whereas the browser's method will also return rects for any fully-contained
 * *element* nodes.
 *
 * For example, if an entire paragraph is selected, then `getClientRects` will
 * return a rectangle that covers the entire paragraph block, whereas this
 * method will only return rectangles for the text inside the paragraph.
 */

function getClientRectsForTextInRange(range) {
  var mutableRects = [];
  addClientRectsForTextInNodeAndRange(range.commonAncestorContainer, range, mutableRects);
  return mutableRects;
}
/**
 * A helper method for getClientRectsForTextInRange.
 *
 * Given a node and a range, find text that is contained within both the node
 * and the range by recursing down the node's subtree, and push the text's
 * client rects onto the given `mutableRects` array.
 */

function addClientRectsForTextInNodeAndRange(node, range, mutableRects) {
  var nodeContentsRange = new Range();
  nodeContentsRange.selectNodeContents(node);

  if (node.nodeType === Node.TEXT_NODE) {
    // Get the text that appears both in this text node and in the range
    // we're searching.
    var intersectedRange = intersectRanges(range, nodeContentsRange);

    if (intersectedRange) {
      addClientRectsForText(node, intersectedRange, mutableRects);
    }
  } else if (node.nodeType === Node.ELEMENT_NODE) {
    // Don't bother deep-traversing a node that doesn't even overlap the
    // range we're searching.
    if (!rangesOverlap(range, nodeContentsRange)) {
      return;
    } // NOTE(mdr): Safari returns a non-iterable `childNodes` object, so
    //     convert it to an array.


    for (var child of Array.from(node.childNodes)) {
      // TODO(mdr): If this parent has overflow: hidden, bound the child
      //     rects accordingly. This would allow us to remove the hack
      //     we added to .perseus-sr-only.
      addClientRectsForTextInNodeAndRange(child, range, mutableRects);
    }
  }
}
/**
 * Given a DOMRange of text fully contained by the given `textNode`, compute
 * rectangles that visually cover the range, and push them onto the given
 * `mutableRects` array.
 *
 * This function adjusts the rectangles to the line height of the text, to
 * match the visual behavior of native text selection, and remove annoying gaps
 * between lines that disrupt hover behavior.
 */

function addClientRectsForText(textNode, textRange, mutableRects) {
  var parentElement = textNode.parentElement;
  var computedStyle = window.getComputedStyle(parentElement); // NOTE(mdr): I'm not sure how computed line height works in all contexts
  //     in all browsers. It's valid to specify line height as a ratio,
  //     relative to font size. Latest Chrome seems to transform this into a
  //     px value, but maybe some browsers don't, so I'm being defensive here
  //     and only using the computed line height if it's explicitly a px
  //     value. We could also handle other browsers by computing font size
  //     and doing the math ourselves, but let's punt that until we need it.

  var lineHeight = null;

  if (typeof computedStyle.lineHeight === "string" && computedStyle.lineHeight.endsWith("px")) {
    var parsedLineHeight = parseFloat(computedStyle.lineHeight);

    if (!isNaN(parsedLineHeight)) {
      lineHeight = parsedLineHeight;
    }
  } // NOTE(mdr): Safari returns a non-iterable `getClientRects` object, so
  //     convert it to an array.


  var boundingRects = Array.from(textRange.getClientRects());

  for (var boundingRect of boundingRects) {
    var rect = {
      left: boundingRect.left,
      top: boundingRect.top,
      height: boundingRect.height,
      width: boundingRect.width
    }; // Adjust the rectangle according to the text's line height. It should
    // keep the same bottom coordinate, so the top coordinate will move
    // accordingly.

    if (lineHeight !== null) {
      var heightIncrease = lineHeight - rect.height;
      rect.top -= heightIncrease;
      rect.height = lineHeight;
    }

    mutableRects.push(rect);
  }
}

var _module_$17 = {
  exports: {}
};
/**
 * A tooltip to point to the focus of a highlight.
 */

var React$17 = _react__default["default"];

class HighlightTooltip$2 extends React$17.PureComponent {
  _getPosition() {
    var {
      focusNode,
      focusOffset,
      offsetParent
    } = this.props; // Get a range of *just* the focus point of the selection.

    var focusRange = document.createRange();
    focusRange.setStart(focusNode, focusOffset);
    focusRange.setEnd(focusNode, focusOffset); // Then, get the bounding box of the collapsed range. This will be a
    // zero-width rectangle, but still have positioning information, which
    // we can use the position the tooltip.
    //
    // NOTE(mdr): If we used getClientBoundingRect here instead, Safari
    //     would return an unpositioned rect. But all tested browsers at
    //     time of writing (latest Chrome, Firefox, Safari) return at least
    //     one rectangle from getClientRects, and it's well-positioned.

    var focusRect = focusRange.getClientRects()[0]; // NOTE(mdr): ...except in the case where the focus is between two
    //     paragraphs, in which case the focus range has no client rects?
    //     Not sure why, or in what browsers (only noticed in Chrome 60),
    //     but let's catch that case and bail out.
    // TODO(mdr): Instead, we should somehow walk back the range until we
    //     find an appropriate position for the tooltip. Sounds tricky!

    if (!focusRect) {
      // eslint-disable-next-line no-console
      console.warn("[Highlighting] Known bug: Could not determine the focus " + "position, so did not show an \"Add Highlight\" tooltip. " + "https://app.asana.com/0/329800276300868/413878480039713");
      return null;
    } // Compute the desired position of the tooltip relative to the offset
    // parent.


    var offsetParentRect = offsetParent.getBoundingClientRect();
    var focusPosition = getRelativePosition(focusRect, offsetParentRect);
    return focusPosition;
  }

  render() {
    var position = this._getPosition();

    if (!position) {
      return null;
    }

    return /*#__PURE__*/React$17.createElement("div", {
      className: aphrodite.css(styles$g.tooltip),
      onClick: this.props.onClick,
      onMouseEnter: this.props.onMouseEnter,
      onMouseLeave: this.props.onMouseLeave,
      style: {
        left: position.left,
        top: position.top,
        zIndex: this.props.zIndex
      }
    }, /*#__PURE__*/React$17.createElement("div", {
      className: aphrodite.css(styles$g.label)
    }, this.props.label), /*#__PURE__*/React$17.createElement("div", {
      className: aphrodite.css(styles$g.arrow)
    }));
  }

}

var styles$g = aphrodite.StyleSheet.create({
  tooltip: {
    // Positioning.
    //
    // Position the tooltip's *center-bottom* point at the left/top
    // coordinates, instead of the tooltip's top-left point, by translating
    // left by half the tooltip's width and up by the tooltip's full
    // height.
    //
    // `left`, `top`, and `zIndex` are specified via the `style` attribute.
    position: "absolute",
    transform: "translate(-50%, -100%)",
    // Cursor interaction.
    cursor: "pointer",
    userSelect: "none"
  },
  label: {
    // Box appearance.
    background: "#314453",
    borderRadius: 2,
    boxShadow: "0 1px 4px 0 rgba(97, 101, 105, 0.42)",
    padding: "8px 11px",
    // Text appearance.
    color: "white",
    fontSize: 12,
    lineHeight: 1.5,
    textAlign: "center"
  },
  // A 12px-width, 6px-height downward-facing arrow.
  //
  // Implemented by creating a box whose only content is its top, left, and
  // right borders. The joints between two borders are a diagonal line, so
  // the arrow element renders divided into these three areas:
  //
  // +-------+
  // |\ top /|
  // | \   / |
  // |  \ /  |
  // |L  v  R|
  // +-------+
  //
  // Therefore, if we color the top border, and make the left and right
  // borders transparent, we end up with a triangle!
  //
  // https://css-tricks.com/snippets/css/css-triangle/
  arrow: {
    // Make the inner dimensions of the box 0x0, so that its only content
    // is its top, left, and right borders.
    height: 0,
    width: 0,
    // The sum of our left and right border widths will be the width of our
    // triangle, so set them to 6px + 6px = 12px.
    borderLeft: "6px solid transparent",
    borderRight: "6px solid transparent",
    // The top border height will be the height of our triangle, so set it
    // to 6px.
    borderTop: "6px solid #314453",
    // Center the arrow within the tooltip container.
    margin: "0 auto"
  }
});
_module_$17.exports = HighlightTooltip$2;
var _highlightTooltipJsx = _module_$17.exports;

var _module_$16 = {
  exports: {}
};
(function () {
  /**
   * This component, given a single DOMHighlight, draws highlight rectangles in
   * the same absolute position as the highlighted content, as computed via
   * `getClientRects`.
   *
   * TODO(mdr): Many things can affect the correct positioning of highlighting,
   *     and this component does not attempt to anticipate them. If we start
   *     using this highlighting library on content with a more dynamic layout,
   *     we should add a hook to allow the parent to `forceUpdate` the
   *     `HighlightRenderer`.
   */
  var React = _react__default["default"];

  class HighlightRenderer extends React.PureComponent {
    constructor() {
      super(...arguments);

      _defineProperty(this, "state", {
        cachedHighlightRects: this._computeRects(this.props),
        tooltipIsHovered: false
      });
    }

    componentWillReceiveProps(nextProps) {
      if (this.props.highlight !== nextProps.highlight || this.props.offsetParent !== nextProps.offsetParent) {
        this.setState({
          cachedHighlightRects: this._computeRects(nextProps)
        });
      }
    }
    /**
     * Compute the set of rectangles that cover the highlighted content, with
     * coordinates relative to the offset parent. That way, we can use them
     * for CSS positioning.
     */


    _computeRects(props) {
      var {
        highlight,
        offsetParent
      } = props; // Get the set of rectangles that covers the range's text, relative to
      // the offset parent.

      var clientRects = getClientRectsForTextInRange(highlight.domRange);
      var offsetParentRect = offsetParent.getBoundingClientRect();
      var relativeRects = clientRects.map(rect => getRelativeRect(rect, offsetParentRect));
      return relativeRects;
    }
    /**
     * Return whether the given mouse position (coordinates relative to this
     * component's offset parent) is hovering over the given rectangle
     * (coordinates also relative to this component's offset parent).
     */


    _rectIsHovered(rect, mouseOffsetPosition) {
      var positionWithinRect = getRelativePosition(mouseOffsetPosition, rect);
      return 0 <= positionWithinRect.left && positionWithinRect.left < rect.width && 0 <= positionWithinRect.top && positionWithinRect.top < rect.height;
    }
    /**
     * Return whether the given mouse position (coordinates relative to the
     * viewport) is hovering over this highlight.
     */


    isHovered(mouseClientPosition) {
      if (!mouseClientPosition) {
        return false;
      }

      var {
        offsetParent
      } = this.props;
      var {
        cachedHighlightRects
      } = this.state; // Convert the client-relative mouse coordinates to be relative to the
      // offset parent. That way, we can compare them to the cached highlight
      // rectangles.

      var offsetParentRect = offsetParent.getBoundingClientRect();
      var mouseOffsetPosition = getRelativePosition(mouseClientPosition, offsetParentRect);
      return cachedHighlightRects.some(rect => this._rectIsHovered(rect, mouseOffsetPosition));
    }

    render() {
      var rects = this.state.cachedHighlightRects;
      return /*#__PURE__*/React.createElement("div", null, rects.map((rect, index) => /*#__PURE__*/React.createElement("div", {
        key: index,
        className: aphrodite.css(styles.highlightRect),
        style: {
          // NOTE(mdr): We apply `position: absolute` here
          //     rather than in Aphrodite styles, because
          //     Aphrodite styles are delayed. If this
          //     element temporarily has `position: static`,
          //     then it'll displace the content, and other
          //     highlights rendering during this update will
          //     measure the displaced content instead, oops!
          position: "absolute",
          width: rect.width,
          height: rect.height,
          top: rect.top,
          left: rect.left,
          zIndex: this.props.zIndexes.belowContent
        }
      })));
    }

  }

  var styles = aphrodite.StyleSheet.create({
    highlightRect: {
      background: "#fffabe" // highlighter yellow :)

    }
  });
  _module_$16.exports = HighlightRenderer;
}).call(_module_$16.exports);
var _highlightRendererJsx = _module_$16.exports;

var _module_$15 = {
  exports: {}
};
/**
 * Render a set of highlights. See HighlightRenderer for more details about how
 * each highlight is rendered.
 *
 * This component manages the state of the "Remove highlight" tooltip. To
 * determine the currently-hovered highlight, it calls the `isHovered` method
 * on each HighlightRenderer.
 */

var React$16 = _react__default["default"];
var HighlightRenderer = _highlightRendererJsx;
var HighlightTooltip$1 = _highlightTooltipJsx;

class HighlightSetRenderer$1 extends React$16.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      mouseClientPosition: null,
      hoveringTooltipFor: null
    });

    _defineProperty(this, "_highlightRenderers", {});

    _defineProperty(this, "_handleMouseMove", e => {
      this.setState({
        mouseClientPosition: {
          left: e.clientX,
          top: e.clientY
        }
      });
    });
  }

  componentDidMount() {
    this._updateEditListeners(false, this.props.editable);
  }

  componentWillReceiveProps(nextProps) {
    this._updateEditListeners(this.props.editable, nextProps.editable); // If we were previously hovering over the tooltip for a highlight that
    // has since been removed, reset the hover state accordingly.


    if (typeof this.state.hoveringTooltipFor === "string" && !(this.state.hoveringTooltipFor in nextProps.highlights)) {
      this.setState({
        hoveringTooltipFor: null
      });
    }
  }

  componentWillUnmount() {
    this._updateEditListeners(this.props.editable, false);
  }
  /**
   * Given whether we were previously listening to mousemove events, and
   * whether we will now listen to mousemove events, add or remove the
   * listener accordingly.
   */


  _updateEditListeners(wasListening, willListen) {
    if (!wasListening && willListen) {
      window.addEventListener("mousemove", this._handleMouseMove);
    } else if (wasListening && !willListen) {
      window.removeEventListener("mousemove", this._handleMouseMove); // Additionally, reset the mouse position. Our child components
      // won't be checking `mouseClientPosition` when we're not
      // listening, anyway, but this guards against errors where we
      // re-enter listening mode and have stale coordinates stored in
      // state.

      this.setState({
        mouseClientPosition: null
      });
    }
  }

  _getHoveredHighlightKey() {
    // If we're hovering over the tooltip, the hovered highlight is the
    // highlight that the tooltip is pointing to.
    var {
      hoveringTooltipFor
    } = this.state;

    if (typeof hoveringTooltipFor === "string") {
      return hoveringTooltipFor;
    } // Otherwise, check each highlight renderer to see whether the current
    // mouse position intersects any of the highlight rectangles.


    var highlightKeys = Object.keys(this.props.highlights);
    return highlightKeys.find(key => {
      var highlightRenderer = this._highlightRenderers[key];
      return highlightRenderer && highlightRenderer.isHovered(this.state.mouseClientPosition);
    });
  }

  _renderTooltip() {
    var hoveredHighlightKey = this._getHoveredHighlightKey();

    if (typeof hoveredHighlightKey !== "string") {
      return null;
    }

    var hoveredHighlight = this.props.highlights[hoveredHighlightKey];
    return /*#__PURE__*/React$16.createElement(HighlightTooltip$1, {
      label: i18n._("Remove highlight"),
      focusNode: hoveredHighlight.domRange.endContainer,
      focusOffset: hoveredHighlight.domRange.endOffset,
      offsetParent: this.props.offsetParent,
      zIndex: this.props.zIndexes.aboveContent,
      onClick: () => this.props.onRemoveHighlight(hoveredHighlightKey),
      onMouseEnter: () => this.setState({
        hoveringTooltipFor: hoveredHighlightKey
      }),
      onMouseLeave: () => this.setState({
        hoveringTooltipFor: null
      })
    });
  }

  render() {
    return /*#__PURE__*/React$16.createElement("div", null, Object.keys(this.props.highlights).map(key => /*#__PURE__*/React$16.createElement(HighlightRenderer, {
      ref: r => {
        if (r) {
          this._highlightRenderers[key] = r;
        } else {
          delete this._highlightRenderers[key];
        }
      },
      editable: this.props.editable,
      key: key,
      highlight: this.props.highlights[key],
      highlightKey: key,
      mouseClientPosition: this.state.mouseClientPosition,
      offsetParent: this.props.offsetParent,
      onRemoveHighlight: this.props.onRemoveHighlight,
      zIndexes: this.props.zIndexes
    })), this.props.editable && this._renderTooltip());
  }

}

_module_$15.exports = HighlightSetRenderer$1;
var _highlightSetRendererJsx = _module_$15.exports;

var _module_$14 = {
  exports: {}
};
/**
 * This component, given a set of DOMHighlights, draws highlight rectangles in
 * the same absolute position as the highlighted content, as computed by the
 * range's `getClientRects` method.
 *
 * TODO(mdr): Many things can affect the correct positioning of highlighting,
 *     and this component does not attempt to anticipate them. If we start
 *     using this highlighting library on content with a more dynamic layout,
 *     we should add a hook to allow the parent to `forceUpdate` the
 *     `HighlightingUI`.
 */

var React$15 = _react__default["default"];
var HighlightSetRenderer = _highlightSetRendererJsx;
var HighlightTooltip = _highlightTooltipJsx;
var SelectionTracker = _selectionTrackerJsx;

class HighlightingUI$1 extends React$15.PureComponent {
  _handleAddHighlight(highlightToAdd) {
    this.props.onAddHighlight(highlightToAdd); // Deselect the newly-highlighted text, by collapsing the selection
    // to the end of the range.

    var selection = document.getSelection();

    if (selection) {
      selection.collapseToEnd();
    }
  }

  _selectionIsValid(trackedSelection) {
    if (!trackedSelection) {
      return false;
    }

    var {
      contentNode
    } = this.props; // Create a range over the content node.

    var contentRange = new Range();
    contentRange.selectNodeContents(contentNode); // Create a range over the focus position.

    var focusRange = new Range();
    focusRange.setStart(trackedSelection.focusNode, trackedSelection.focusOffset);
    focusRange.collapse(true
    /* to start */
    ); // Determine whether the content range contains the focus, by checking
    // whether they intersect. Because the focus range is a single point,
    // intersection is equivalent to being fully contained.

    var contentContainsFocus = rangesOverlap(contentRange, focusRange); // If the content contains the focus, this is a valid selection. Some
    // parts of the range might go beyond the content, but that's okay; the
    // corresponding DOMHighlight is already trimmed to only contain valid
    // words. We're just checking that the tooltip we render will be inside
    // the content, because rendering a tooltip outside the content would
    // be weird.

    var selectionIsValid = contentContainsFocus;
    return selectionIsValid;
  }

  render() {
    return /*#__PURE__*/React$15.createElement(SelectionTracker, {
      buildHighlight: this.props.buildHighlight,
      enabled: this.props.editable
    }, (trackedSelection, userIsMouseSelecting) => /*#__PURE__*/React$15.createElement("div", null, /*#__PURE__*/React$15.createElement(HighlightSetRenderer, {
      editable:
      /* An existing highlight is editable when the
       * component is in editable mode, and there's no
       * selection in progress. */
      this.props.editable && !this._selectionIsValid(trackedSelection),
      highlights: this.props.highlights,
      offsetParent: this.props.offsetParent,
      onRemoveHighlight: this.props.onRemoveHighlight,
      zIndexes: this.props.zIndexes
    }), this._selectionIsValid(trackedSelection) && !userIsMouseSelecting && /*#__PURE__*/React$15.createElement(HighlightTooltip, {
      label: i18n._("Add highlight"),
      onClick: () => this._handleAddHighlight(trackedSelection.proposedHighlight),
      focusNode: trackedSelection.focusNode,
      focusOffset: trackedSelection.focusOffset,
      offsetParent: this.props.offsetParent,
      zIndex: this.props.zIndexes.aboveContent
    })));
  }

}

_module_$14.exports = HighlightingUI$1;
var _uiHighlightingUiJsx = _module_$14.exports;

var _module_$13 = {
  exports: {}
};
/**
 * The entry point for highlighting!
 *
 * Given a content node and a set of serialized highlights, this component
 * renders the content with the given highlights applied. The content's DOM is
 * not modified by this process, so any content should be safe to pass to this
 * component.
 *
 * This component also renders controls for the user to add/remove/update
 * highlights. When the user does so, this component will update the full set
 * of highlights, serialize them, and call `onSerializedHighlightsUpdate` with
 * new set of serialized highlights, which you can then persist and send back
 * down to this component. Easy peasy!
 */

var React$14 = _react__default["default"];
var HighlightingUI = _uiHighlightingUiJsx;
var WordIndexer = _wordIndexerJsx;

class HighlightableContent$1 extends React$14.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      wordRanges: []
    });

    _defineProperty(this, "_handleAddHighlight", highlight => {
      var newDomHighlights = addHighlight(this._getDOMHighlights(), highlight);
      var newSerializedHighlights = {};

      for (var key of Object.keys(newDomHighlights)) {
        newSerializedHighlights[key] = serializeHighlight(newDomHighlights[key]);
      }

      this.props.onSerializedHighlightsUpdate(newSerializedHighlights);
    });

    _defineProperty(this, "_handleRemoveHighlight", keyToRemove => {
      var {
        serializedHighlights
      } = this.props;

      var newSerializedHighlights = _objectSpread2({}, serializedHighlights);

      delete newSerializedHighlights[keyToRemove];
      this.props.onSerializedHighlightsUpdate(newSerializedHighlights);
    });

    _defineProperty(this, "_handleWordsUpdate", wordRanges => {
      this.setState({
        wordRanges
      });
    });
  }

  _buildHighlight(highlightRange) {
    // TODO(mdr): If _buildHighlight starts getting called more often, we
    //     might want to cache the DOMHighlightSet instead of recomputing
    //     it here.
    return buildHighlight(this._getDOMHighlights(), this.state.wordRanges, highlightRange);
  }
  /**
   * Take the highlights from props, and deserialize them into DOMHighlights,
   * according to the latest cache of word ranges.
   */


  _getDOMHighlights() {
    var {
      serializedHighlights
    } = this.props;
    var {
      wordRanges
    } = this.state;
    var domHighlights = {};

    for (var key of Object.keys(serializedHighlights)) {
      domHighlights[key] = deserializeHighlight(serializedHighlights[key], wordRanges);
    }

    return domHighlights;
  }
  /**
   * Add the given DOMHighlight to the current set.
   */


  render() {
    var highlights = this._getDOMHighlights(); // NOTE(mdr): This lambda is rebuilt every time this component updates,
    //     so every update to HighlightableContent triggers an update in
    //     the child HighlightingUI and SelectionTracker, even if the
    //     behavior hasn't changed.
    //
    //     Over-updating is preferable to under-updating here, because some
    //     updates in this component's props/state *do* affect
    //     `buildHighlight`'s behavior, and *should* trigger an update.
    //
    //     A more performant approach would be to cache this function
    //     object until its implicitly-bound inputs change. If profiling
    //     leads us to implement such caching, this draft might be a good
    //     starting point: https://phabricator.khanacademy.org/D35623?id=170698


    var buildHighlight = r => this._buildHighlight(r);

    return /*#__PURE__*/React$14.createElement("div", {
      className: aphrodite.css(styles$f.container),
      ref: container => this._container = container
    }, /*#__PURE__*/React$14.createElement("div", null, this.props.enabled && this._container && this._content && /*#__PURE__*/React$14.createElement(HighlightingUI, {
      buildHighlight: buildHighlight,
      contentNode: this._content,
      editable: this.props.editable,
      highlights: highlights,
      offsetParent: this._container,
      zIndexes: {
        // The content has a z-index of 1, so, to be above
        // or below the content, use z-index of 2 or 0,
        // respectively.
        aboveContent: 2,
        belowContent: 0
      },
      onAddHighlight: this._handleAddHighlight,
      onRemoveHighlight: this._handleRemoveHighlight
    })), /*#__PURE__*/React$14.createElement("div", {
      className: aphrodite.css(styles$f.content),
      ref: content => this._content = content
    }, /*#__PURE__*/React$14.createElement(WordIndexer, {
      onWordsUpdate: this._handleWordsUpdate
    }, this.props.children)));
  }

}

var styles$f = aphrodite.StyleSheet.create({
  // We render content with z-index 1, and highlights with z-index 0, so that
  // content will receive the browser's native pointer events. (Highlights
  // have their own magic code to manage hover detection, despite being
  // behind the content.)
  container: {
    // Position the container and give it a z-index, to scope the z-indexes
    // inside by creating a stacking context.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
    //
    // This way, content's z-index of 1, and highlights' z-index of 0, and
    // tooltips' z-index of 2 don't interact with anything external;
    // external UI will see `HighlightableContent` as a single flat layer
    // with a z-index of 0. This removes the need for us to coordinate our
    // choices of z-index with external UI.
    position: "relative",
    zIndex: 0
  },
  content: {
    // NOTE(mdr): Creating a stacking context for content of z-index 1 may
    //    be problematic if the content and external page want to
    //    interleave layers between each other, e.g., if the application UI
    //    wants to render something above some parts of our content, but
    //    below other parts. It's not relevant for the current Passage-only
    //    call site, but could be relevant someday…
    position: "relative",
    zIndex: 1
  }
});
_module_$13.exports = HighlightableContent$1;
var _componentsHighlightingHighlightableContentJsx = _module_$13.exports;

var _module_$12 = {
  exports: {}
};
var React$13 = _react__default["default"];
var ReactDOM$c = _reactDom__default["default"];
var _$O = _underscore__default["default"];
var $$1 = $__default["default"];
var HighlightableContent = _componentsHighlightingHighlightableContentJsx;
var Renderer$d = _rendererJsx;
var PassageMarkdown = _passagePassageMarkdownJsx; // A fake paragraph to measure the line height of the passage. In CSS we always
// set the line height to 22 pixels, but when using the browser zoom feature,
// the line height often ends up being a fractional number of pixels close to
// 22 pixels.

class LineHeightMeasurer extends React$13.Component {
  measureLineHeight() {
    if (typeof this._cachedLineHeight !== "number") {
      this.forceMeasureLineHeight();
    }

    return this._cachedLineHeight;
  }

  forceMeasureLineHeight() {
    // Add some text which magically fills an entire line.
    this.$body.text(" \u0080"); // Now, the line height is the difference between the top of the
    // second line and the top of the first line.

    this._cachedLineHeight = this.$end.offset().top - this.$body.offset().top; // Clear out the first line so it doesn't overlap the passage.

    this.$body.text("");
  }

  render() {
    return /*#__PURE__*/React$13.createElement("div", {
      className: aphrodite.css(styles$e.measurer)
    }, /*#__PURE__*/React$13.createElement("div", null, /*#__PURE__*/React$13.createElement("div", {
      ref: e => this.$body = $$1(e),
      className: "paragraph"
    }), /*#__PURE__*/React$13.createElement("div", {
      ref: e => this.$end = $$1(e)
    })));
  }

}

var styles$e = aphrodite.StyleSheet.create({
  measurer: {
    position: "absolute",
    width: "100%",
    top: 0,
    left: 0
  }
});

class Passage extends React$13.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      nLines: null,
      startLineNumbersAfter: 0,
      stylesAreApplied: false
    });

    _defineProperty(this, "_handleSerializedHighlightsUpdate", serializedHighlights => {
      this.props.onChange({
        highlights: serializedHighlights
      });
    });
  }

  componentDidMount() {
    this._updateState();

    this._onResize = _$O.throttle(() => {
      // If we're rendering JIPT text, we won't have line numbers or a
      // line height measurer, so skip handling this resize.
      if (this.shouldRenderJipt()) {
        return;
      } // Remeasure the line height on resize, because the only line
      // height changes we expect are subpixel changes when the user
      // zooms in/out, and the only way to listen for zoom events is to
      // listen for resize events.


      this._lineHeightMeasurer.forceMeasureLineHeight();

      this._updateState();
    }, 500);
    window.addEventListener("resize", this._onResize); // Wait for Aphrodite styles (which are guaranteed to apply after one
    // tick), then set state.
    //
    // This flag is used to set the `enabled` prop of the
    // `HighlightableContent` component. That way, we only show highlights
    // once styles are ready, and they're measured with the correct
    // position.
    //
    // HACK(mdr): It's not really the Passage's Aphrodite styles that are
    //     causing bad measures, but more so the Khan Academy Test Prep
    //     app's Aphrodite styles. We would ideally instead offer the
    //     embedding application an API to signal that the app's layout has
    //     changed in a way that affects the Renderer... but, for now, just
    //     hardcode this hack into here.

    window.setTimeout(() => {
      this.setState({
        stylesAreApplied: true
      });
    }, 0);
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !_$O.isEqual(this.props, nextProps) || !_$O.isEqual(this.state, nextState);
  }

  componentDidUpdate() {
    this._updateState();
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this._onResize);
  }

  /**
   * Line numbering
   *
   * These functions support passage line numbering, which is non-trivial
   * because we manually measure lines to support resizing as well as
   * continuing line numbers from previous passages.
   */
  _updateState() {
    // If we're rendering JIPT text, we're not rendering line numbers so we
    // don't need to update this state.
    if (this.shouldRenderJipt()) {
      return;
    }

    this.setState({
      nLines: this._measureLines(),
      startLineNumbersAfter: this._getInitialLineNumber()
    });
  }

  _measureLines() {
    var $renderer = $$1(ReactDOM$c.findDOMNode(this.refs.content));
    var contentsHeight = $renderer.height();

    var lineHeight = this._getLineHeight();

    var nLines = Math.round(contentsHeight / lineHeight);
    return nLines;
  }

  _getInitialLineNumber() {
    var isPassageBeforeThisPassage = true;
    var passagesBeforeUs = this.props.findWidgets((id, widgetInfo) => {
      if (widgetInfo.type !== "passage") {
        return false;
      }

      if (id === this.props.widgetId) {
        isPassageBeforeThisPassage = false;
      }

      return isPassageBeforeThisPassage;
    });
    return passagesBeforeUs.map(passageWidget => {
      return passageWidget.getLineCount();
    }).reduce((a, b) => a + b, 0);
  }

  _getLineHeight() {
    return this._lineHeightMeasurer.measureLineHeight();
  }

  getLineCount() {
    if (this.state.nLines != null) {
      return this.state.nLines;
    } else {
      return this._measureLines();
    }
  }
  /**
   * Passage refs
   *
   * These are functions to support the passage refs inter-widgets feature
   * where other widgets can fetch the line numbers of a reference inside of
   * a passage.
   */


  _getStartRefLineNumber(referenceNumber) {
    var refRef = PassageMarkdown.START_REF_PREFIX + referenceNumber;
    var ref = this.refs[refRef];

    if (!ref) {
      return null;
    }

    var $ref = $$1(ReactDOM$c.findDOMNode(ref)); // We really care about the first text after the ref, not the
    // ref element itself:

    var $refText = $ref.next();

    if ($refText.length === 0) {
      // But if there are no elements after the ref, just
      // use the ref itself.
      $refText = $ref;
    }

    var vPos = $refText.offset().top;
    return this.state.startLineNumbersAfter + 1 + this._convertPosToLineNumber(vPos);
  }

  _getEndRefLineNumber(referenceNumber) {
    var refRef = PassageMarkdown.END_REF_PREFIX + referenceNumber;
    var ref = this.refs[refRef];

    if (!ref) {
      return null;
    }

    var $ref = $$1(ReactDOM$c.findDOMNode(ref)); // We really care about the last text before the ref, not the
    // ref element itself:

    var $refText = $ref.prev();

    if ($refText.length === 0) {
      // But if there are no elements before the ref, just
      // use the ref itself.
      $refText = $ref;
    }

    var height = $refText.height();
    var vPos = $refText.offset().top;

    var line = this._convertPosToLineNumber(vPos + height);

    if (height === 0) {
      // If the element before the end ref span was the start
      // ref span, it might have 0 height. This is obviously not
      // the intended use case, but we should handle it gracefully.
      // If this is the case, then the "bottom" of our element is
      // actually the top of the line we're on, so we need to add
      // one to the line number.
      line += 1;
    }

    return this.state.startLineNumbersAfter + line;
  }

  _convertPosToLineNumber(absoluteVPos) {
    var $content = $$1(ReactDOM$c.findDOMNode(this.refs.content));
    var relativeVPos = absoluteVPos - $content.offset().top;

    var lineHeight = this._getLineHeight();

    var line = Math.round(relativeVPos / lineHeight);
    return line;
  }

  _getRefContent(referenceNumber) {
    var refRef = PassageMarkdown.START_REF_PREFIX + referenceNumber;
    var ref = this.refs[refRef];

    if (!ref) {
      return null;
    }

    return ref.getRefContent();
  }

  getReference(referenceNumber) {
    var refStartLine = this._getStartRefLineNumber(referenceNumber);

    var refEndLine = this._getEndRefLineNumber(referenceNumber);

    if (refStartLine == null || refEndLine == null) {
      return null;
    }

    var refContent = this._getRefContent(referenceNumber);

    return {
      startLine: refStartLine,
      endLine: refEndLine,
      content: refContent
    };
  }
  /**
   * Misc functions
   *
   * These are misc widget functions used for the widget API
   */


  getUserInput() {
    return null;
  }

  simpleValidate(rubric) {
    return Passage.validate(this.getUserInput(), rubric);
  }
  /* eslint-disable react/sort-comp */


  static validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
  /* eslint-enable react/sort-comp */

  /**
   * Rendering
   *
   * Functions to render the passage widget.
   */


  _renderInstructions(parseState) {
    var firstQuestionNumber = parseState.firstQuestionRef;
    var firstSentenceRef = parseState.firstSentenceRef;
    var instructions = "";

    if (firstQuestionNumber) {
      instructions += i18n._("The symbol %(questionSymbol)s indicates that question " + "%(questionNumber)s references this portion of the " + "passage.", {
        questionSymbol: "[[" + firstQuestionNumber + "]]",
        questionNumber: firstQuestionNumber
      });
    }

    if (firstSentenceRef) {
      instructions += i18n._(" The symbol %(sentenceSymbol)s indicates that the " + "following sentence is referenced in a question.", {
        sentenceSymbol: "[" + firstSentenceRef + "]"
      });
    }

    var parsedInstructions = PassageMarkdown.parse(instructions);
    return /*#__PURE__*/React$13.createElement("div", {
      className: "perseus-widget-passage-instructions"
    }, PassageMarkdown.output(parsedInstructions));
  }

  shouldRenderJipt() {
    // Mostly copied from `renderer.jsx`. If we're doing JIPT, we want to
    // render our content differently.
    return (// $FlowFixMe KA is a global
      typeof KA !== "undefined" && KA.language === "en-pt" && this.props.passageText.indexOf("crwdns") !== -1
    );
  }

  _renderContent(parsed) {
    // Wait until Aphrodite styles are applied before enabling highlights,
    // so that we measure the correct positions.
    var enabled = this.state.stylesAreApplied; // Highlights are read-only in review mode.

    var editable = !this.props.reviewModeRubric;
    return /*#__PURE__*/React$13.createElement(HighlightableContent, {
      editable: editable,
      enabled: enabled,
      onSerializedHighlightsUpdate: this._handleSerializedHighlightsUpdate,
      serializedHighlights: this.props.highlights
    }, /*#__PURE__*/React$13.createElement("div", {
      ref: "content"
    }, /*#__PURE__*/React$13.createElement(LineHeightMeasurer, {
      ref: e => this._lineHeightMeasurer = e
    }), PassageMarkdown.output(parsed)));
  }

  _hasFootnotes() {
    var rawContent = this.props.footnotes;
    var isEmpty = /^\s*$/.test(rawContent);
    return !isEmpty;
  }

  _renderFootnotes() {
    var rawContent = this.props.footnotes;
    var parsed = PassageMarkdown.parse(rawContent);
    return PassageMarkdown.output(parsed);
  }

  render() {
    var lineNumbers;
    var nLines = this.state.nLines;

    if (this.props.showLineNumbers && nLines) {
      // lineN is the line number in the current passage;
      // the displayed line number is
      // lineN + this.state.startLineNumbersAfter, where
      // startLineNumbersAfter is the sum of all line numbers
      // in earlier passages.
      lineNumbers = _$O.range(1, nLines + 1).map(lineN => {
        if (lineN === 4 && nLines > 4) {
          return /*#__PURE__*/React$13.createElement("span", {
            key: "line-marker",
            className: "line-marker"
          }, "Line");
        } else {
          return /*#__PURE__*/React$13.createElement("span", {
            key: lineN
          }, lineN + this.state.startLineNumbersAfter);
        }
      });
    }

    var parseState = {
      firstSentenceRef: null,
      firstQuestionRef: null
    };
    var parsedContent = PassageMarkdown.parse(this.props.passageText, parseState); // Check if the title has any non-empty text in it.

    var hasTitle = /\S/.test(this.props.passageTitle);
    return /*#__PURE__*/React$13.createElement("div", null, /*#__PURE__*/React$13.createElement("div", {
      className: "perseus-widget-passage-container"
    }, this._renderInstructions(parseState), /*#__PURE__*/React$13.createElement("div", {
      className: "perseus-widget-passage"
    }, hasTitle && /*#__PURE__*/React$13.createElement("h3", {
      className: "passage-title"
    }, /*#__PURE__*/React$13.createElement(Renderer$d, {
      content: this.props.passageTitle,
      linterContext: this.props.linterContext
    })), lineNumbers && /*#__PURE__*/React$13.createElement("div", {
      className: "line-numbers",
      "aria-hidden": true
    }, lineNumbers), !hasTitle && /*#__PURE__*/React$13.createElement("h3", {
      className: "perseus-sr-only"
    }, i18n._("Beginning of reading passage.")), /*#__PURE__*/React$13.createElement("div", {
      className: "passage-text"
    }, this.shouldRenderJipt() ?
    /*#__PURE__*/
    // If we're in JIPT mode, just pass off our
    // content to a <Renderer /> which knows how
    // to handle rendering JIPT text.
    React$13.createElement(Renderer$d, {
      content: this.props.passageText
    }) : this._renderContent(parsedContent)), this._hasFootnotes() && [/*#__PURE__*/React$13.createElement("h4", {
      key: "footnote-start",
      className: "perseus-sr-only"
    }, i18n._("Beginning of reading passage footnotes.")), /*#__PURE__*/React$13.createElement("div", {
      key: "footnotes",
      className: "footnotes"
    }, this._renderFootnotes())], /*#__PURE__*/React$13.createElement("div", {
      className: "perseus-sr-only"
    }, i18n._("End of reading passage.")))));
  }

}

_defineProperty(Passage, "defaultProps", {
  passageTitle: "",
  passageText: "",
  footnotes: "",
  showLineNumbers: true,
  highlights: {},
  linterContext: linterContextDefault
});

_module_$12.exports = {
  name: "passage",
  displayName: "Passage (SAT only)",
  widget: Passage,
  transform: editorProps => {
    return _$O.pick(editorProps, "passageTitle", "passageText", "footnotes", "showLineNumbers");
  },
  isLintable: true
};
var _widgetsPassageJsx = _module_$12.exports;

var _module_$11 = {
  exports: {}
};
/* eslint-disable brace-style, comma-dangle, max-len, no-var, object-curly-spacing, one-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$12 = _react__default["default"];
var _$N = _underscore__default["default"];
var InfoTip$d = _componentsInfoTipJsx;
var TextListEditor$2 = _componentsTextListEditorJsx;
var NORMAL$1 = "normal",
    AUTO$1 = "auto",
    HORIZONTAL$1 = "horizontal",
    VERTICAL$1 = "vertical";
var OrdererEditor = createReactClass({
  displayName: "OrdererEditor",
  propTypes: {
    correctOptions: PropTypes.array,
    otherOptions: PropTypes.array,
    height: PropTypes.oneOf([NORMAL$1, AUTO$1]),
    layout: PropTypes.oneOf([HORIZONTAL$1, VERTICAL$1]),
    onChange: PropTypes.func.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return {
      correctOptions: [{
        content: "$x$"
      }],
      otherOptions: [{
        content: "$y$"
      }],
      height: NORMAL$1,
      layout: HORIZONTAL$1
    };
  },
  render: function render() {
    return /*#__PURE__*/React$12.createElement("div", {
      className: "perseus-widget-orderer"
    }, /*#__PURE__*/React$12.createElement("div", null, " ", "Correct answer:", " ", /*#__PURE__*/React$12.createElement(InfoTip$d, null, /*#__PURE__*/React$12.createElement("p", null, "Place the cards in the correct order. The same card can be used more than once in the answer but will only be displayed once at the top of a stack of identical cards."))), /*#__PURE__*/React$12.createElement(TextListEditor$2, {
      options: _$N.pluck(this.props.correctOptions, "content"),
      onChange: this.onOptionsChange.bind(this, "correctOptions"),
      layout: this.props.layout
    }), /*#__PURE__*/React$12.createElement("div", null, " ", "Other cards:", " ", /*#__PURE__*/React$12.createElement(InfoTip$d, null, /*#__PURE__*/React$12.createElement("p", null, "Create cards that are not part of the answer."))), /*#__PURE__*/React$12.createElement(TextListEditor$2, {
      options: _$N.pluck(this.props.otherOptions, "content"),
      onChange: this.onOptionsChange.bind(this, "otherOptions"),
      layout: this.props.layout
    }), /*#__PURE__*/React$12.createElement("div", null, /*#__PURE__*/React$12.createElement("label", null, " ", "Layout:", " ", /*#__PURE__*/React$12.createElement("select", {
      value: this.props.layout,
      onChange: this.onLayoutChange
    }, /*#__PURE__*/React$12.createElement("option", {
      value: HORIZONTAL$1
    }, "Horizontal"), /*#__PURE__*/React$12.createElement("option", {
      value: VERTICAL$1
    }, "Vertical"))), /*#__PURE__*/React$12.createElement(InfoTip$d, null, /*#__PURE__*/React$12.createElement("p", null, "Use the horizontal layout for short text and small images. The vertical layout is best for longer text (e.g. proofs)."))), /*#__PURE__*/React$12.createElement("div", null, /*#__PURE__*/React$12.createElement("label", null, " ", "Height:", " ", /*#__PURE__*/React$12.createElement("select", {
      value: this.props.height,
      onChange: this.onHeightChange
    }, /*#__PURE__*/React$12.createElement("option", {
      value: NORMAL$1
    }, "Normal"), /*#__PURE__*/React$12.createElement("option", {
      value: AUTO$1
    }, "Automatic"))), /*#__PURE__*/React$12.createElement(InfoTip$d, null, /*#__PURE__*/React$12.createElement("p", null, "Use \"Normal\" for text, \"Automatic\" for images."))));
  },
  onOptionsChange: function onOptionsChange(whichOptions, options, cb) {
    var props = {};
    props[whichOptions] = _$N.map(options, function (option) {
      return {
        content: option
      };
    });
    this.props.onChange(props, cb);
  },
  onLayoutChange: function onLayoutChange(e) {
    this.props.onChange({
      layout: e.target.value
    });
  },
  onHeightChange: function onHeightChange(e) {
    this.props.onChange({
      height: e.target.value
    });
  },
  serialize: function serialize() {
    // We combine the correct answer and the other cards by merging them,
    // removing duplicates and empty cards, and sorting them into
    // categories based on their content
    var options = _$N.chain(_$N.pluck(this.props.correctOptions, "content")).union(_$N.pluck(this.props.otherOptions, "content")).uniq().reject(function (content) {
      return content === "";
    }).sort().sortBy(function (content) {
      if (/\d/.test(content)) {
        return 0;
      } else if (/^\$?[a-zA-Z]+\$?$/.test(content)) {
        return 2;
      } else {
        return 1;
      }
    }).map(function (content) {
      return {
        content: content
      };
    }).value();

    return {
      options: options,
      correctOptions: this.props.correctOptions,
      otherOptions: this.props.otherOptions,
      height: this.props.height,
      layout: this.props.layout
    };
  }
});
_module_$11.exports = OrdererEditor;
var _widgetsOrdererEditorJsx = _module_$11.exports;

var _module_$10 = {
  exports: {}
};
/* eslint-disable comma-dangle, max-len, no-console, no-unused-vars, no-var, one-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$11 = _react__default["default"];
var ReactDOM$b = _reactDom__default["default"];
var _$M = _underscore__default["default"];
var Renderer$c = _rendererJsx;
var Util$8 = Util$q;
var ApiClassNames$7 = _perseusApiJsx.ClassNames;
var PlaceholderCard = createReactClass({
  displayName: "PlaceholderCard",
  propTypes: {
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired
  },
  render: function render() {
    return /*#__PURE__*/React$11.createElement("div", {
      className: "card-wrap " + ApiClassNames$7.INTERACTIVE,
      style: {
        width: this.props.width
      }
    }, /*#__PURE__*/React$11.createElement("div", {
      className: "card placeholder",
      style: {
        height: this.props.height
      }
    }));
  }
});
var DragHintCard = createReactClass({
  displayName: "DragHintCard",
  render: function render() {
    return /*#__PURE__*/React$11.createElement("div", {
      className: "card-wrap " + ApiClassNames$7.INTERACTIVE
    }, /*#__PURE__*/React$11.createElement("div", {
      className: "card drag-hint"
    }));
  }
});
var PropTypes_position = PropTypes.shape({
  left: PropTypes.number,
  top: PropTypes.number
});
var Card = createReactClass({
  displayName: "Card",
  propTypes: {
    floating: PropTypes.bool.isRequired,
    animating: PropTypes.bool,
    width: PropTypes.number,
    stack: PropTypes.bool,
    onMouseDown: PropTypes.func,
    onMouseMove: PropTypes.func,
    onMouseUp: PropTypes.func,
    // Used only for floating/animating cards
    startMouse: PropTypes_position,
    startOffset: PropTypes_position,
    animateTo: PropTypes_position,
    onAnimationEnd: PropTypes.func,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      stack: false,
      animating: false,
      linterContext: linterContextDefault
    };
  },
  render: function render() {
    var style = {};

    if (this.props.floating) {
      style = {
        position: "absolute",
        left: this.props.startOffset.left,
        top: this.props.startOffset.top
      };
    }

    if (this.props.width) {
      style.width = this.props.width;
    }

    var className = ["card"];

    if (this.props.stack) {
      className.push("stack");
    }

    if (this.props.floating && !this.props.animating) {
      className.push("dragging");
      style.left += this.props.mouse.left - this.props.startMouse.left;
      style.top += this.props.mouse.top - this.props.startMouse.top;
    } // Pull out the content to get rendered


    var rendererProps = _$M.pick(this.props, "content");

    var onMouseDown = this.props.animating ? $.noop : this.onMouseDown;
    return /*#__PURE__*/React$11.createElement("div", {
      className: "card-wrap " + ApiClassNames$7.INTERACTIVE,
      style: style,
      onMouseDown: onMouseDown,
      onTouchStart: onMouseDown,
      onTouchMove: this.onMouseMove,
      onTouchEnd: this.onMouseUp,
      onTouchCancel: this.onMouseUp
    }, /*#__PURE__*/React$11.createElement("div", {
      className: className.join(" ")
    }, /*#__PURE__*/React$11.createElement(Renderer$c, _extends({}, rendererProps, {
      linterContext: this.props.linterContext
    }))));
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    // Cards in the bank or drag list don't usually change -- they only
    // reorder themselves -- so we want to skip the update to things a
    // little faster. We also need to re-render if the content changes,
    // which happens only in the editor. (We do want to update the floating
    // card on mouse move to update its position.)
    return this.props.floating || nextProps.floating || this.props.content !== nextProps.content || // TODO(alpert): Remove ref here after fixing facebook/react#1392.
    this.props.fakeRef !== nextProps.fakeRef;
  },
  componentDidMount: function componentDidMount() {
    this.mouseMoveUpBound = false;
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    if (this.props.animating && !prevProps.animating) {
      // If we just were changed into animating, start the animation.
      // We pick the animation speed based on the distance that the card
      // needs to travel. (Why sqrt? Just because it looks nice -- with a
      // linear scale, far things take too long to come back.)
      var ms = 15 * Math.sqrt(Math.sqrt(Math.pow(this.props.animateTo.left - this.props.startOffset.left, 2) + Math.pow(this.props.animateTo.top - this.props.startOffset.top, 2)));
      $(ReactDOM$b.findDOMNode(this)).animate(this.props.animateTo, Math.max(ms, 1), this.props.onAnimationEnd);
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    // Event handlers should be unbound before component unmounting, but
    // just in case...
    if (this.mouseMoveUpBound) {
      console.warn("Removing an element with bound event handlers.");
      this.unbindMouseMoveUp();
      Util$8.resetTouchHandlers();
    }
  },
  bindMouseMoveUp: function bindMouseMoveUp() {
    this.mouseMoveUpBound = true;
    $(document).on("mousemove", this.onMouseMove);
    $(document).on("mouseup", this.onMouseUp);
  },
  unbindMouseMoveUp: function unbindMouseMoveUp() {
    this.mouseMoveUpBound = false;
    $(document).off("mousemove", this.onMouseMove);
    $(document).off("mouseup", this.onMouseUp);
  },
  onMouseDown: function onMouseDown(event) {
    event.preventDefault();
    var loc = Util$8.extractPointerLocation(event);

    if (loc) {
      this.bindMouseMoveUp();
      this.props.onMouseDown && this.props.onMouseDown(loc, this);
    }
  },
  onMouseMove: function onMouseMove(event) {
    event.preventDefault();
    var loc = Util$8.extractPointerLocation(event);

    if (loc) {
      this.props.onMouseMove && this.props.onMouseMove(loc);
    }
  },
  onMouseUp: function onMouseUp(event) {
    event.preventDefault();
    var loc = Util$8.extractPointerLocation(event);

    if (loc) {
      this.unbindMouseMoveUp();
      this.props.onMouseUp && this.props.onMouseUp(loc);
    }
  }
});
var NORMAL = "normal",
    AUTO = "auto",
    HORIZONTAL = "horizontal",
    VERTICAL = "vertical";
var Orderer = createReactClass({
  displayName: "Orderer",
  propTypes: {
    correctOptions: PropTypes.array,
    current: PropTypes.array,
    height: PropTypes.oneOf([NORMAL, AUTO]),
    layout: PropTypes.oneOf([HORIZONTAL, VERTICAL]),
    options: PropTypes.array,
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      current: [],
      options: [],
      correctOptions: [],
      height: NORMAL,
      layout: HORIZONTAL,
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      current: [],
      dragging: false,
      placeholderIndex: null
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (!_$M.isEqual(this.props.current, nextProps.current)) {
      this.setState({
        current: nextProps.current
      });
    }
  },
  render: function render() {
    // This is the card we are currently dragging
    var dragging = this.state.dragging && /*#__PURE__*/React$11.createElement(Card, {
      ref: "dragging",
      floating: true,
      content: this.state.dragContent,
      startOffset: this.state.offsetPos,
      startMouse: this.state.grabPos,
      mouse: this.state.mousePos,
      width: this.state.dragWidth,
      onMouseUp: this.onRelease,
      onMouseMove: this.onMouseMove,
      key: this.state.dragKey || "draggingCard",
      linterContext: this.props.linterContext
    }); // This is the card that is currently animating

    var animating = this.state.animating && /*#__PURE__*/React$11.createElement(Card, {
      floating: true,
      animating: true,
      content: this.state.dragContent,
      startOffset: this.state.offsetPos,
      width: this.state.dragWidth,
      animateTo: this.state.animateTo,
      onAnimationEnd: this.state.onAnimationEnd,
      key: this.state.dragKey || "draggingCard",
      linterContext: this.props.linterContext
    }); // This is the list of draggable, rearrangable cards

    var sortableCards = _$M.map(this.state.current, function (opt, i) {
      return /*#__PURE__*/React$11.createElement(Card, {
        ref: "sortable" + i,
        fakeRef: "sortable" + i,
        floating: false,
        content: opt.content,
        width: opt.width,
        key: opt.key,
        linterContext: this.props.linterContext,
        onMouseDown: this.state.animating ? $.noop : this.onClick.bind(null, "current", i)
      });
    }, this);

    if (this.state.placeholderIndex != null) {
      var placeholder = /*#__PURE__*/React$11.createElement(PlaceholderCard, {
        ref: "placeholder",
        width: this.state.dragWidth,
        height: this.state.dragHeight,
        key: "placeholder"
      });
      sortableCards.splice(this.state.placeholderIndex, 0, placeholder);
    }

    var anySortableCards = sortableCards.length > 0;
    sortableCards.push(dragging, animating); // If there are no cards in the list, then add a "hint" card

    var sortable = /*#__PURE__*/React$11.createElement("div", {
      className: "perseus-clearfix draggable-box"
    }, !anySortableCards && /*#__PURE__*/React$11.createElement(DragHintCard, null), /*#__PURE__*/React$11.createElement("div", {
      ref: "dragList"
    }, sortableCards)); // This is the bank of stacks of cards

    var bank = /*#__PURE__*/React$11.createElement("div", {
      ref: "bank",
      className: "bank perseus-clearfix"
    }, _$M.map(this.props.options, (opt, i) => {
      return /*#__PURE__*/React$11.createElement(Card, {
        ref: "bank" + i,
        floating: false,
        content: opt.content,
        stack: true,
        key: i,
        linterContext: this.props.linterContext,
        onMouseDown: this.state.animating ? $.noop : this.onClick.bind(null, "bank", i),
        onMouseMove: this.onMouseMove,
        onMouseUp: this.onRelease
      });
    }, this));
    return /*#__PURE__*/React$11.createElement("div", {
      className: "draggy-boxy-thing orderer " + "height-" + this.props.height + " " + "layout-" + this.props.layout + " " + "above-scratchpad blank-background " + "perseus-clearfix " + ApiClassNames$7.INTERACTIVE,
      ref: "orderer"
    }, bank, sortable);
  },
  onClick: function onClick(type, index, loc, draggable) {
    var $draggable = $(ReactDOM$b.findDOMNode(draggable));
    var list = this.state.current.slice();
    var opt;
    var placeholderIndex = null;

    if (type === "current") {
      // If this is coming from the original list, remove the original
      // card from the list
      list.splice(index, 1);
      opt = this.state.current[index];
      placeholderIndex = index;
    } else if (type === "bank") {
      opt = this.props.options[index];
    }

    this.setState({
      current: list,
      dragging: true,
      placeholderIndex: placeholderIndex,
      dragKey: opt.key,
      dragContent: opt.content,
      dragWidth: $draggable.width(),
      dragHeight: $draggable.height(),
      grabPos: loc,
      mousePos: loc,
      offsetPos: $draggable.position()
    });
  },
  onRelease: function onRelease(loc) {
    var draggable = this.refs.dragging;

    if (draggable == null) {
      return;
    }

    var inCardBank = this.isCardInBank(draggable);
    var index = this.state.placeholderIndex; // Here, we build a callback function for the card to call when it is
    // done animating

    var onAnimationEnd = () => {
      var list = this.state.current.slice();

      if (!inCardBank) {
        // Insert the new card into the position
        var newCard = {
          content: this.state.dragContent,
          key: _$M.uniqueId("perseus_draggable_card_"),
          width: this.state.dragWidth
        };
        list.splice(index, 0, newCard);
      }

      this.props.onChange({
        current: list
      });
      this.setState({
        current: list,
        dragging: false,
        placeholderIndex: null,
        animating: false
      });
      this.props.trackInteraction();
    }; // Find the position of the card we should animate to
    // TODO(alpert): Update mouse position once more before animating?


    var offset = $(ReactDOM$b.findDOMNode(draggable)).position();
    var finalOffset = null;

    if (inCardBank) {
      // If we're in the card bank, go through the options to find the
      // one with the same content
      _$M.each(this.props.options, function (opt, i) {
        if (opt.content === this.state.dragContent) {
          var card = ReactDOM$b.findDOMNode(this.refs["bank" + i]);
          finalOffset = $(card).position();
        }
      }, this);
    } else if (this.refs.placeholder != null) {
      // Otherwise, go to the position that the placeholder is at
      finalOffset = $(ReactDOM$b.findDOMNode(this.refs.placeholder)).position();
    }

    if (finalOffset == null) {
      // If we didn't find a card to go to, simply make the changes we
      // would have made at the end. (should only happen if we are
      // messing around with card contents, and not on the real site)
      onAnimationEnd();
    } else {
      this.setState({
        offsetPos: offset,
        animateTo: finalOffset,
        onAnimationEnd: onAnimationEnd,
        animating: true,
        dragging: false
      });
    }
  },
  onMouseMove: function onMouseMove(loc) {
    var draggable = this.refs.dragging;

    if (draggable == null) {
      return;
    }

    var index;

    if (this.isCardInBank(draggable)) {
      index = null;
    } else {
      index = this.findCorrectIndex(draggable, this.state.current);
    }

    this.setState({
      mousePos: loc,
      placeholderIndex: index
    });
  },
  findCorrectIndex: function findCorrectIndex(draggable, list) {
    // Find the correct index for a card given the current cards.
    var isHorizontal = this.props.layout === HORIZONTAL,
        $dragList = $(ReactDOM$b.findDOMNode(this.refs.dragList)),
        leftEdge = $dragList.offset().left,
        topEdge = $dragList.offset().top,
        midWidth = $(ReactDOM$b.findDOMNode(draggable)).offset().left - leftEdge,
        midHeight = $(ReactDOM$b.findDOMNode(draggable)).offset().top - topEdge,
        index = 0,
        sumWidth = 0,
        sumHeight = 0;

    if (isHorizontal) {
      _$M.each(list, function (opt, i) {
        var card = ReactDOM$b.findDOMNode(this.refs["sortable" + i]);
        var outerWidth = $(card).outerWidth(true);

        if (midWidth > sumWidth + outerWidth / 2) {
          index += 1;
        }

        sumWidth += outerWidth;
      }, this);
    } else {
      _$M.each(list, function (opt, i) {
        var card = ReactDOM$b.findDOMNode(this.refs["sortable" + i]);
        var outerHeight = $(card).outerHeight(true);

        if (midHeight > sumHeight + outerHeight / 2) {
          index += 1;
        }

        sumHeight += outerHeight;
      }, this);
    }

    return index;
  },
  isCardInBank: function isCardInBank(draggable) {
    if (draggable == null) {
      return false;
    }

    var isHorizontal = this.props.layout === HORIZONTAL,
        $draggable = $(ReactDOM$b.findDOMNode(draggable)),
        $bank = $(ReactDOM$b.findDOMNode(this.refs.bank)),
        draggableOffset = $draggable.offset(),
        bankOffset = $bank.offset(),
        draggableHeight = $draggable.outerHeight(true),
        bankHeight = $bank.outerHeight(true),
        bankWidth = $bank.outerWidth(true),
        dragList = ReactDOM$b.findDOMNode(this.refs.dragList);
        $(dragList).width();
        var draggableWidth = $draggable.outerWidth(true);

    if (isHorizontal) {
      return draggableOffset.top + draggableHeight / 2 < bankOffset.top + bankHeight;
    } else {
      return draggableOffset.left + draggableWidth / 2 < bankOffset.left + bankWidth;
    }
  },
  getUserInput: function getUserInput() {
    return {
      current: _$M.map(this.props.current, function (v) {
        return v.content;
      })
    };
  },
  simpleValidate: function simpleValidate(rubric) {
    return Orderer.validate(this.getUserInput(), rubric);
  }
});

_$M.extend(Orderer, {
  validate: function validate(state, rubric) {
    if (state.current.length === 0) {
      return {
        type: "invalid",
        message: null
      };
    }

    var correct = _$M.isEqual(state.current, _$M.pluck(rubric.correctOptions, "content"));

    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
});

_module_$10.exports = {
  name: "orderer",
  displayName: "Orderer",
  widget: Orderer,
  isLintable: true
};
var _widgetsOrdererJsx = _module_$10.exports;

var _module_$$ = {
  exports: {}
};
/* eslint-disable no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$10 = _react__default["default"];
var _$L = _underscore__default["default"];
var EditorJsonify$d = _mixinsEditorJsonifyJsx;
var ButtonGroup$6 = _reactComponentsButtonGroupJsx;
var InfoTip$c = _componentsInfoTipJsx;
var NumberInput$9 = _componentsNumberInputJsx;
var PropCheckBox$9 = _componentsPropCheckBoxJsx;
var RangeInput$3 = _componentsRangeInputJsx;
var knumber$3 = _kmath3.number;

var bound$1 = (x, gt, lt) => Math.min(Math.max(x, gt), lt);

var EN_DASH$1 = "\u2013";
var NumberLineEditor = createReactClass({
  displayName: "NumberLineEditor",
  propTypes: {
    range: PropTypes.arrayOf(PropTypes.number).isRequired,
    labelRange: PropTypes.arrayOf(PropTypes.number).isRequired,
    labelStyle: PropTypes.string.isRequired,
    labelTicks: PropTypes.bool,
    divisionRange: PropTypes.arrayOf(PropTypes.number).isRequired,
    numDivisions: PropTypes.number.isRequired,
    snapDivisions: PropTypes.number,
    tickStep: PropTypes.number,
    correctRel: PropTypes.oneOf(["lt", "gt", "le", "ge", "eq"]),
    correctX: PropTypes.number,
    initialX: PropTypes.number,
    isTickCtrl: PropTypes.bool,
    onChange: PropTypes.func.isRequired,
    static: PropTypes.bool,
    showTooltips: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      range: [0, 10],
      labelRange: [null, null],
      labelStyle: "decimal",
      labelTicks: true,
      divisionRange: [1, 12],
      numDivisions: 5,
      snapDivisions: 2,
      tickStep: null,
      correctRel: "eq",
      correctX: null,
      initialX: null,
      showTooltips: false
    };
  },
  onRangeChange: function onRangeChange(range) {
    // Changing the range constrains the initial position, as well as the
    // position of the answer and labels. Atm, it just marks them as
    // invalid and prevents the number line from showing; it was annoying
    // to change it for them, because if they're typing in fractions,
    // it registers one-at-a-time and messes things up.
    this.props.onChange({
      range: range
    });
  },
  onLabelRangeChange: function onLabelRangeChange(i, num) {
    var labelRange = this.props.labelRange.slice();
    var otherNum = labelRange[1 - i];

    if (num == null || otherNum == null) {
      labelRange[i] = num;
    } else {
      // If both labels have values, this updates the "appropriate" one.
      // It enforces that the position of the left label <= right label.
      // If left otherwise, it makes certain aspects of validation hard.
      labelRange = [Math.min(num, otherNum), Math.max(num, otherNum)];
    }

    this.props.onChange({
      labelRange: labelRange
    });
  },
  onDivisionRangeChange: function onDivisionRangeChange(divisionRange) {
    var numDivisions = this.props.numDivisions;
    numDivisions = bound$1(numDivisions, divisionRange[0], divisionRange[1]);
    this.props.onChange({
      divisionRange: divisionRange,
      numDivisions: numDivisions
    });
  },
  onNumChange: function onNumChange(key, value) {
    var opts = {};
    opts[key] = value;
    this.props.onChange(opts);
  },
  onNumDivisionsChange: function onNumDivisionsChange(numDivisions) {
    var divRange = this.props.divisionRange.slice();

    if (!_$L.isFinite(numDivisions)) {
      numDivisions = null;
    } // Don't allow a fraction for the number of divisions


    numDivisions = Math.round(numDivisions); // Don't allow negative numbers for the number of divisions

    numDivisions = numDivisions < 0 ? numDivisions * -1 : numDivisions; // If the number of divisions isn't blank, update the number line

    if (numDivisions) {
      // Constrain numDivisions to be within the allowed range
      numDivisions = Math.min(divRange[1], Math.max(divRange[0], numDivisions));
      this.props.onChange({
        tickStep: null,
        divisionRange: divRange,
        numDivisions: numDivisions
      });
    }
  },
  onTickStepChange: function onTickStepChange(tickStep) {
    this.props.onChange({
      numDivisions: null,
      tickStep: tickStep
    });
  },
  onChangeRelation: function onChangeRelation(e) {
    var value = e.target.value;
    this.props.onChange({
      correctRel: value,
      isInequality: value !== "eq"
    });
  },
  onLabelStyleChange: function onLabelStyleChange(labelStyle) {
    this.props.onChange({
      labelStyle: labelStyle
    });
  },

  serialize() {
    return EditorJsonify$d.serialize.call(this);
  },

  render: function render() {
    var range = this.props.range;
    var labelRange = this.props.labelRange;
    var divisionRange = this.props.divisionRange;
    range[0] = +range[0];
    range[1] = +range[1];
    var width = range[1] - range[0];
    var numDivisions = this.props.numDivisions;
    var snapDivisions = this.props.snapDivisions;
    var tickStep = this.props.tickStep;
    var isTickCtrl = this.props.isTickCtrl;
    var step;

    if (!isTickCtrl) {
      // this will help constrain the answer to what is reachable
      step = tickStep ? tickStep / snapDivisions : width / numDivisions / snapDivisions;
    } else {
      // but if tickCtrl is on, the range of what is reachable is
      // rather large, and it becomes obnoxious to check for this
      step = null;
    }

    var labelStyleEditorButtons = [{
      value: "decimal",
      content: "0.75",
      title: "Decimals"
    }, {
      value: "improper",
      content: "\u2077\u2044\u2084",
      title: "Improper fractions"
    }, {
      value: "mixed",
      content: "1\u00BE",
      title: "Mixed numbers"
    }, {
      value: "non-reduced",
      content: "\u2078\u2044\u2084",
      title: "Non-reduced"
    }];
    return /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-number-line-editor"
    }, /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, "Correct x", " ", /*#__PURE__*/React$10.createElement("select", {
      value: this.props.correctRel,
      onChange: this.onChangeRelation
    }, /*#__PURE__*/React$10.createElement("option", {
      value: "eq"
    }, " = "), /*#__PURE__*/React$10.createElement("option", {
      value: "lt"
    }, " < "), /*#__PURE__*/React$10.createElement("option", {
      value: "gt"
    }, " > "), /*#__PURE__*/React$10.createElement("option", {
      value: "le"
    }, " \u2264 "), /*#__PURE__*/React$10.createElement("option", {
      value: "ge"
    }, " \u2265 ")), " ", /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: this.props.correctX,
      format: this.props.labelStyle,
      onChange: this.onNumChange.bind(this, "correctX"),
      checkValidity: val => val >= range[0] && val <= range[1] && (!step || knumber$3.isInteger((val - range[0]) / step)),
      placeholder: "answer",
      size: "normal",
      useArrowKeys: true
    }), /*#__PURE__*/React$10.createElement(InfoTip$c, null, /*#__PURE__*/React$10.createElement("p", null, "This is the correct answer. The answer is validated (as right or wrong) by using only the end position of the point and the relation (=, <, >, \u2264, \u2265)."))), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, this.props.static ? /*#__PURE__*/React$10.createElement("label", null, "Range:") : /*#__PURE__*/React$10.createElement("label", null, "Position:", " ", /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: this.props.initialX,
      format: this.props.labelStyle,
      onChange: this.onNumChange.bind(this, "initialX"),
      placeholder: range[0],
      checkValidity: val => {
        return val >= range[0] && val <= range[1];
      },
      useArrowKeys: true
    }), " \u2208 "
    /* element of (little E) symbol @Nolint */
    ), /*#__PURE__*/React$10.createElement(RangeInput$3, {
      value: range,
      onChange: this.onRangeChange,
      format: this.props.labelStyle,
      useArrowKeys: true
    }), /*#__PURE__*/React$10.createElement(InfoTip$c, null, /*#__PURE__*/React$10.createElement("p", null, "This controls the initial position of the point along the number line and the", /*#__PURE__*/React$10.createElement("strong", null, "range"), ", the position of the endpoints of the number line. Setting the range constrains the position of the answer and the labels."), /*#__PURE__*/React$10.createElement("p", null, "In static mode, the initial position of the point is determined by Correct x instead of position."))), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-left-col"
    }, "Labels:", " ", /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: labelRange[0],
      placeholder: range[0],
      format: this.props.labelStyle,
      checkValidity: val => val >= range[0] && val <= range[1],
      onChange: this.onLabelRangeChange.bind(this, 0),
      useArrowKeys: true
    }), /*#__PURE__*/React$10.createElement("span", null, " & "), /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: labelRange[1],
      placeholder: range[1],
      format: this.props.labelStyle,
      checkValidity: val => val >= range[0] && val <= range[1],
      onChange: this.onLabelRangeChange.bind(this, 1),
      useArrowKeys: true
    }), /*#__PURE__*/React$10.createElement(InfoTip$c, null, /*#__PURE__*/React$10.createElement("p", null, "This controls the position of the left / right labels. By default, the labels are set by the range ", /*#__PURE__*/React$10.createElement("br", null), /*#__PURE__*/React$10.createElement("strong", null, "Note:"), " Ensure that the labels line up with the tick marks, or it may be confusing for users.")))), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, "Style:", " ", /*#__PURE__*/React$10.createElement(ButtonGroup$6, {
      allowEmpty: false,
      value: this.props.labelStyle,
      buttons: labelStyleEditorButtons,
      onChange: this.onLabelStyleChange
    }), /*#__PURE__*/React$10.createElement(InfoTip$c, null, /*#__PURE__*/React$10.createElement("p", null, "This controls the styling of the labels for the two main labels as well as all the tick mark labels, if applicable. Your choices are decimal, improper fractions, mixed fractions, and non-reduced fractions."))), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, !this.props.static && /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-left-col"
    }, /*#__PURE__*/React$10.createElement(PropCheckBox$9, {
      label: "Show tick controller",
      isTickCtrl: this.props.isTickCtrl,
      onChange: this.props.onChange
    })), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-right-col"
    }, /*#__PURE__*/React$10.createElement(PropCheckBox$9, {
      label: "Show label ticks",
      labelTicks: this.props.labelTicks,
      onChange: this.props.onChange
    }))), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, !this.props.static && /*#__PURE__*/React$10.createElement(PropCheckBox$9, {
      label: "Show tooltips",
      showTooltips: this.props.showTooltips,
      onChange: this.props.onChange
    })), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, isTickCtrl && /*#__PURE__*/React$10.createElement("span", null, /*#__PURE__*/React$10.createElement("label", null, "Start num divisions at", " ", /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: this.props.numDivisions || null,
      format: "decimal",
      onChange: this.onNumDivisionsChange,
      checkValidity: val => {
        return val >= divisionRange[0] && val <= divisionRange[1];
      },
      placeholder: width / this.props.tickStep,
      useArrowKeys: true
    })), /*#__PURE__*/React$10.createElement(InfoTip$c, null, /*#__PURE__*/React$10.createElement("p", null, "This controls the number (and position) of the tick marks. The number of divisions is constrained to", " " + divisionRange[0] + EN_DASH$1 + divisionRange[1], ".", /*#__PURE__*/React$10.createElement("br", null), /*#__PURE__*/React$10.createElement("strong", null, "Note:"), " The user will be able to specify the number of divisions in a number input."))), !isTickCtrl && /*#__PURE__*/React$10.createElement("span", null, /*#__PURE__*/React$10.createElement("label", null, "Num divisions:", " ", /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: this.props.numDivisions || null,
      format: "decimal",
      onChange: this.onNumDivisionsChange,
      checkValidity: val => {
        return val >= divisionRange[0] && val <= divisionRange[1];
      },
      placeholder: width / this.props.tickStep,
      useArrowKeys: true
    })), " ", /*#__PURE__*/React$10.createElement("label", null, "or tick step:", " ", /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: this.props.tickStep || null,
      format: this.props.labelStyle,
      onChange: this.onTickStepChange,
      checkValidity: val => {
        return val > 0 && val <= width;
      },
      placeholder: width / this.props.numDivisions,
      useArrowKeys: true
    })), /*#__PURE__*/React$10.createElement(InfoTip$c, null, /*#__PURE__*/React$10.createElement("p", null, "This controls the number (and position) of the tick marks; you can either set the number of divisions (2 divisions would split the entire range in two halves), or the tick step (the distance between ticks) and the other value will be updated accordingly.", " ", /*#__PURE__*/React$10.createElement("br", null), /*#__PURE__*/React$10.createElement("strong", null, "Note:"), " There is no check to see if labels coordinate with the tick marks, which may be confusing for users if the blue labels and black ticks are off-step.")))), /*#__PURE__*/React$10.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$10.createElement("label", null, "Snap increments per tick:", " ", /*#__PURE__*/React$10.createElement(NumberInput$9, {
      value: snapDivisions,
      checkValidity: val => val > 0,
      format: this.props.labelStyle,
      onChange: this.onNumChange.bind(this, "snapDivisions"),
      useArrowKeys: true
    })), /*#__PURE__*/React$10.createElement(InfoTip$c, null, /*#__PURE__*/React$10.createElement("p", null, "This determines the number of different places the point will snap between two adjacent tick marks.", " ", /*#__PURE__*/React$10.createElement("br", null), /*#__PURE__*/React$10.createElement("strong", null, "Note:"), "Ensure the required number of snap increments is provided to answer the question."))));
  }
});
_module_$$.exports = NumberLineEditor;
var _widgetsNumberLineEditorJsx = _module_$$.exports;

var _module_$_ = {
  exports: {}
};
/* eslint-disable brace-style, no-var */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals i18n, $_ */

var React$$ = _react__default["default"];
var ReactDOM$a = _reactDom__default["default"];
var _$K = _underscore__default["default"];
var Changeable$v = Changeable$Q;
var NumberInput$8 = _componentsNumberInputJsx;
var MathOutput$2 = _componentsMathOutputJsx;
var SimpleKeypadInput$3 = _componentsSimpleKeypadInputJsx;
var ApiOptions$i = _perseusApiJsx.Options;
var {
  keypadElementPropType: keypadElementPropType$4
} = _mathInput__default["default"].propTypes;
var Graphie$3 = _componentsGraphieJsx;
var MovablePoint$2 = Graphie$3.MovablePoint;
var Line$1 = Graphie$3.Line;
var knumber$2 = _kmath3.number;
var KhanMath$1 = _utilMathJs;
var KhanColors$4 = _utilColorsJs;

var bound = (x, gt, lt) => Math.min(Math.max(x, gt), lt);

var assert$1 = InteractiveUtil$7.assert;
var EN_DASH = "\u2013";
var horizontalPadding = 30;
var reverseRel = {
  ge: "le",
  gt: "lt",
  le: "ge",
  lt: "gt"
};
var toggleStrictRel = {
  ge: "gt",
  gt: "ge",
  le: "lt",
  lt: "le"
};

function formatImproper(n, d) {
  if (d === 1) {
    return "" + n;
  } else {
    return "\\dfrac{".concat(n, "}{").concat(d, "}");
  }
}

function formatMixed(n, d) {
  if (n < 0) {
    return "-" + formatMixed(-n, d);
  }

  var w = Math.floor(n / d);

  if (w === 0) {
    return formatImproper(n, d);
  } else if (n - w * d === 0) {
    return "" + w;
  } else {
    return w + formatImproper(n - w * d, d);
  }
}

function formatNonReduced(n, d, base) {
  var factor = Math.floor(base / d);
  return formatImproper(n * factor, base);
}

var _label = (graphie, labelStyle, pos, value, base) => {
  value = value || pos; // TODO(jack): Find out if any exercises have "decimal ticks" set,
  // and if so, re-save them and remove this check.

  if (labelStyle === "decimal" || labelStyle === "decimal ticks") {
    return graphie.label([pos, -0.53], Math.round(value * 100) / 100, "center");
  } else if (labelStyle === "improper") {
    var frac = KhanMath$1.toFraction(value);
    return graphie.label([pos, -0.17], formatImproper(frac[0], frac[1]), "below");
  } else if (labelStyle === "mixed") {
    var _frac = KhanMath$1.toFraction(value);

    return graphie.label([pos, -0.17], formatMixed(_frac[0], _frac[1]), "below");
  } else if (labelStyle === "non-reduced") {
    var _frac2 = KhanMath$1.toFraction(value);

    return graphie.label([pos, -0.17], formatNonReduced(_frac2[0], _frac2[1], base), "below");
  }
};

var TickMarks = Graphie$3.createSimpleClass((graphie, props) => {
  // Avoid infinite loop
  if (!_$K.isFinite(props.tickStep) || props.tickStep <= 0) {
    return []; // this has screwed me for the last time!
  }

  var results = []; // For convenience, extract some props into separate variables

  var range = props.range;
  var labelRange = props.labelRange;
  var leftLabel = labelRange[0] == null ? range[0] : labelRange[0];
  var rightLabel = labelRange[1] == null ? range[1] : labelRange[1]; // Find base via GCD for non-reduced fractions

  var base;

  if (props.labelStyle === "non-reduced") {
    var fractions = [leftLabel, rightLabel];

    for (var i = 0; i <= props.numDivisions; i++) {
      var x = range[0] + i * props.tickStep;
      fractions.push(x);
    }

    var getDenom = x => knumber$2.toFraction(x)[1];

    var denoms = _$K.map(fractions, getDenom);

    base = _$K.reduce(denoms, (x, y) => KhanMath$1.getLCM(x, y));
  } else {
    base = undefined;
  } // Draw and save the tick marks and tick labels


  for (var _i = 0; _i <= props.numDivisions; _i++) {
    var _x = range[0] + _i * props.tickStep;

    results.push(graphie.line([_x, -0.2], [_x, 0.2]));
    var labelTicks = props.labelTicks;

    if (labelTicks || props.labelStyle === "decimal ticks") {
      results.push(_label(graphie, props.labelStyle, _x, _x, base));
    }
  } // Render the text labels


  results.push(graphie.style(props.isMobile ? {
    color: KhanColors$4.BLUE_D
  } : {}, () => _label(graphie, props.labelStyle, leftLabel, leftLabel, base)));
  results.push(graphie.style(props.isMobile ? {
    color: KhanColors$4.BLUE_D
  } : {}, () => _label(graphie, props.labelStyle, rightLabel, rightLabel, base))); // Render the labels' lines

  graphie.style({
    stroke: props.isMobile ? KhanColors$4.BLUE_D : KhanColors$4.DYNAMIC,
    strokeWidth: 3.5
  }, () => {
    results.push(graphie.line([leftLabel, -0.2], [leftLabel, 0.2]));
    results.push(graphie.line([rightLabel, -0.2], [rightLabel, 0.2]));
  });
  return results;
});
var NumberLine = createReactClass({
  displayName: "NumberLine",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$v.propTypes), {}, {
    range: PropTypes.arrayOf(PropTypes.number).isRequired,
    labelRange: PropTypes.arrayOf(PropTypes.number).isRequired,
    labelStyle: PropTypes.string.isRequired,
    labelTicks: PropTypes.bool.isRequired,
    divisionRange: PropTypes.arrayOf(PropTypes.number).isRequired,
    numDivisions: PropTypes.number.isRequired,
    snapDivisions: PropTypes.number.isRequired,
    isTickCtrl: PropTypes.bool.isRequired,
    isInequality: PropTypes.bool.isRequired,
    numLinePosition: PropTypes.number.isRequired,
    rel: PropTypes.oneOf(["lt", "gt", "le", "ge"]),
    onFocus: PropTypes.func.isRequired,
    onBlur: PropTypes.func.isRequired,
    onChange: PropTypes.func.isRequired,
    apiOptions: ApiOptions$i.propTypes,
    keypadElement: keypadElementPropType$4,
    static: PropTypes.bool,
    showTooltips: PropTypes.bool,
    trackInteraction: PropTypes.func.isRequired
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      range: [0, 10],
      labelStyle: "decimal",
      labelRange: [null, null],
      divisionRange: [1, 12],
      labelTicks: true,
      isTickCtrl: false,
      isInequality: false,
      numLinePosition: 0,
      snapDivisions: 2,
      showTooltips: false,
      rel: "ge",
      apiOptions: ApiOptions$i.defaults
    };
  },

  getInitialState() {
    return {
      numDivisionsEmpty: false
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$v.change.apply(this, args);
  },

  isValid: function isValid() {
    var range = this.props.range;
    var initialX = this.props.numLinePosition;
    var divisionRange = this.props.divisionRange;
    initialX = initialX == null ? range[0] : initialX;
    return range[0] < range[1] && knumber$2.sign(initialX - range[0]) >= 0 && knumber$2.sign(initialX - range[1]) <= 0 && divisionRange[0] < divisionRange[1] && 0 < this.props.numDivisions && 0 < this.props.snapDivisions;
  },
  onNumDivisionsChange: function onNumDivisionsChange(numDivisions, cb) {
    var divRange = this.props.divisionRange.slice();
    var width = this.props.range[1] - this.props.range[0]; // Don't allow a fraction for the number of divisions

    numDivisions = Math.round(numDivisions); // Don't allow negative numbers for the number of divisions

    numDivisions = numDivisions < 0 ? numDivisions * -1 : numDivisions; // If the number of divisions isn't blank, update the number line

    if (numDivisions) {
      var nextProps = _$K.extend({}, this.props, {
        tickStep: width / numDivisions
      });

      var newNumLinePosition = this.snapNumLinePosition(nextProps, this.props.numLinePosition);
      this.setState({
        numDivisionsEmpty: false
      }, () => {
        this.props.onChange({
          divisionRange: divRange,
          numDivisions: numDivisions,
          numLinePosition: newNumLinePosition
        }, cb);
      });
    } else {
      this.setState({
        numDivisionsEmpty: true
      }, cb);
    }
  },
  _handleTickCtrlFocus: function _handleTickCtrlFocus() {
    this.props.onFocus(["tick-ctrl"]);
  },
  _handleTickCtrlBlur: function _handleTickCtrlBlur() {
    this.props.onBlur(["tick-ctrl"]);
  },
  focus: function focus() {
    if (this.props.isTickCtrl) {
      this.refs["tick-ctrl"].focus();
      return true;
    }
  },
  focusInputPath: function focusInputPath(path) {
    if (path.length === 1) {
      this.refs[path[0]].focus();
    }
  },
  blurInputPath: function blurInputPath(path) {
    if (path.length === 1) {
      this.refs[path[0]].blur();
    }
  },
  getInputPaths: function getInputPaths() {
    if (this.props.isTickCtrl) {
      return [["tick-ctrl"]];
    } else {
      return [];
    }
  },
  getDOMNodeForPath: function getDOMNodeForPath(inputPath) {
    if (inputPath.length === 1) {
      return ReactDOM$a.findDOMNode(this.refs[inputPath[0]]);
    }
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(inputPath) {
    if (inputPath.length === 1 && inputPath[0] === "tick-ctrl") {
      return "number";
    }
  },
  setInputValue: function setInputValue(inputPath, value, callback) {
    if (inputPath.length === 1 && inputPath[0] === "tick-ctrl") {
      this.onNumDivisionsChange(value, callback);
    }
  },
  _renderGraphie: function _renderGraphie() {
    // Position variables
    var range = this.props.range;
    var width = range[1] - range[0];

    var options = _$K.pick(this.props, ["range", "isTickCtrl"]); // TODO(aria): Maybe save this as `this.calculatedProps`?


    var props = _$K.extend({}, this.props, {
      tickStep: width / this.props.numDivisions
    });

    return /*#__PURE__*/React$$.createElement(Graphie$3, {
      ref: "graphie" // HACK(emily): We key this graphie on the label style because
      // when the label style changes we want to resize the graphie,
      // which isn't doable without throwing away the graphie and
      // making a new one.
      ,
      key: this.props.labelStyle,
      box: [this.props.apiOptions.isMobile ? 288 : 460, 80],
      options: options,
      onMouseDown: coord => {
        this.refs.graphie.movables.numberLinePoint.grab(coord);
      },
      setup: this._setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
      isMobile: this.props.apiOptions.isMobile
    }, /*#__PURE__*/React$$.createElement(TickMarks, _extends({}, _$K.pick(props, ["range", "numDivisions", "labelTicks", "labelStyle", "labelRange", "tickStep"]), {
      isMobile: this.props.apiOptions.isMobile
    })), this._renderInequality(props), this._renderNumberLinePoint(props));
  },
  snapNumLinePosition: function snapNumLinePosition(props, numLinePosition) {
    var left = props.range[0];
    var right = props.range[1];
    var snapX = props.tickStep / props.snapDivisions;
    var x = bound(numLinePosition, left, right);
    x = left + knumber$2.roundTo(x - left, snapX);
    assert$1(_$K.isFinite(x));
    return x;
  },
  _renderNumberLinePoint: function _renderNumberLinePoint(props) {
    var isOpen = ["lt", "gt"].includes(props.rel); // In static mode the point's fill and stroke is blue to signify that
    // it can't be interacted with.

    var fill;

    if (isOpen) {
      fill = KhanColors$4._BACKGROUND;
    } else if (props.static) {
      fill = KhanColors$4.DYNAMIC;
    } else {
      fill = KhanColors$4.INTERACTIVE;
    }

    var normalStyle = {
      fill: fill,
      stroke: props.static ? KhanColors$4.DYNAMIC : KhanColors$4.INTERACTIVE,
      "stroke-width": isOpen ? 3 : 1
    };
    var highlightStyle = {
      fill: isOpen ? KhanColors$4._BACKGROUND : KhanColors$4.INTERACTING,
      "stroke-width": isOpen ? 3 : 1
    };
    var mobileDotStyle = props.isInequality ? {
      stroke: KhanColors$4.INTERACTIVE,
      "fill-opacity": isOpen ? 0 : 1
    } : {};
    return /*#__PURE__*/React$$.createElement(MovablePoint$2, {
      ref: "numberLinePoint",
      pointSize: 6,
      coord: [props.numLinePosition, 0],
      constraints: [(coord, prevCoord) => {
        // constrain-y
        return [coord[0], prevCoord[1]];
      }, (coord, prevCoord) => {
        // snap X
        var x = this.snapNumLinePosition(props, coord[0]);
        return [x, coord[1]];
      }],
      normalStyle: normalStyle,
      highlightStyle: highlightStyle,
      onMove: coord => {
        this.change({
          numLinePosition: coord[0]
        });
        this.props.trackInteraction();
      },
      isMobile: this.props.apiOptions.isMobile,
      mobileStyleOverride: mobileDotStyle,
      showTooltips: this.props.showTooltips,
      xOnlyTooltip: true
    });
  },
  handleReverse: function handleReverse() {
    var newRel = reverseRel[this.props.rel];
    this.props.onChange({
      rel: newRel
    });
  },
  handleToggleStrict: function handleToggleStrict() {
    var newRel = toggleStrictRel[this.props.rel];
    this.props.onChange({
      rel: newRel
    });
  },
  _getInequalityEndpoint: function _getInequalityEndpoint(props) {
    var isGreater = ["ge", "gt"].includes(props.rel);
    var widthInPixels = 400;
    var range = props.range;
    var scale = (range[1] - range[0]) / widthInPixels;
    var buffer = horizontalPadding * scale;
    var left = range[0] - buffer;
    var right = range[1] + buffer;
    var end = isGreater ? [right, 0] : [left, 0];
    return end;
  },
  _renderInequality: function _renderInequality(props) {
    if (props.isInequality) {
      var end = this._getInequalityEndpoint(props);

      var style = {
        arrows: "->",
        stroke: this.props.apiOptions.isMobile ? KhanColors$4.INTERACTIVE : KhanColors$4.DYNAMIC,
        strokeWidth: 3.5
      };
      var isGreater = ["ge", "gt"].includes(props.rel);
      return /*#__PURE__*/React$$.createElement(Line$1 // We shift the line to either side of the dot so they don't
      // intersect
      , {
        start: [(isGreater ? 0.4 : -0.4) + props.numLinePosition, 0],
        end: end,
        style: style
      });
    } else {
      return null;
    }
  },
  _setupGraphie: function _setupGraphie(graphie, options) {
    // Ensure a sane configuration to avoid infinite loops
    if (!this.isValid()) {
      return;
    } // Position variables


    var widthInPixels = this.props.apiOptions.isMobile ? 288 - horizontalPadding * 2 : 400;
    var range = options.range;
    var scale = (range[1] - range[0]) / widthInPixels;
    var buffer = horizontalPadding * scale; // Initiate the graphie without actually drawing anything

    var left = range[0] - buffer;
    var right = range[1] + buffer;
    var hasFractionalLabels = this.props.labelStyle === "improper" || this.props.labelStyle === "mixed" || this.props.labelStyle === "non-reduced";
    var bottom = hasFractionalLabels ? -1.5 : -1;
    var top = 1;
    graphie.init({
      range: [[left, right], [bottom, top]],
      scale: [1 / scale, 40],
      isMobile: this.props.apiOptions.isMobile
    }); // Draw the number line

    var center = (range[0] + range[1]) / 2;
    graphie.line([center, 0], [right, 0], {
      arrows: "->"
    });
    graphie.line([center, 0], [left, 0], {
      arrows: "->"
    });
  },
  getUserInput: function getUserInput() {
    return {
      numLinePosition: this.props.numLinePosition,
      rel: this.props.isInequality ? this.props.rel : "eq",
      numDivisions: this.props.numDivisions,
      divisionRange: this.props.divisionRange
    };
  },
  simpleValidate: function simpleValidate(rubric) {
    return NumberLine.validate(this.getUserInput(), rubric);
  },
  render: function render() {
    var divisionRange = this.props.divisionRange;
    var divRangeString = divisionRange[0] + EN_DASH + divisionRange[1];
    var invalidNumDivisions = this.props.numDivisions < divisionRange[0] || this.props.numDivisions > divisionRange[1];
    var inequalityControls = /*#__PURE__*/React$$.createElement("div", null, /*#__PURE__*/React$$.createElement("input", {
      type: "button",
      className: "simple-button",
      value: i18n._("Switch direction"),
      onClick: this.handleReverse
    }), /*#__PURE__*/React$$.createElement("input", {
      type: "button",
      className: "simple-button",
      value: ["le", "ge"].includes(this.props.rel) ? i18n._("Make circle open") : i18n._("Make circle filled"),
      onClick: this.handleToggleStrict
    }));
    var tickCtrl;

    if (this.props.isTickCtrl) {
      var Input;

      if (this.props.apiOptions.customKeypad) {
        Input = SimpleKeypadInput$3;
      } else if (this.props.apiOptions.staticRender) {
        Input = MathOutput$2;
      } else {
        Input = NumberInput$8;
      }

      tickCtrl = /*#__PURE__*/React$$.createElement("label", null, i18n._("Number of divisions:"), " ", /*#__PURE__*/React$$.createElement(Input, {
        ref: "tick-ctrl",
        value: this.state.numDivisionsEmpty ? null : this.props.numDivisions || divisionRange[0],
        checkValidity: val => val >= divisionRange[0] && val <= divisionRange[1],
        onChange: this.onNumDivisionsChange,
        onFocus: this._handleTickCtrlFocus,
        onBlur: this._handleTickCtrlBlur,
        useArrowKeys: true,
        keypadElement: this.props.keypadElement
      }));
    }

    return /*#__PURE__*/React$$.createElement("div", {
      className: "perseus-widget " + "perseus-widget-interactive-number-line"
    }, tickCtrl, !this.isValid() ? /*#__PURE__*/React$$.createElement("div", {
      className: "perseus-error"
    }, "Invalid number line configuration.") : this.props.isTickCtrl && invalidNumDivisions ? /*#__PURE__*/React$$.createElement("div", {
      className: "perseus-error"
    }, $_({
      divRangeString: divRangeString
    }, "Please make sure the number of divisions is " + "in the range %(divRangeString)s.")) : this._renderGraphie(), !this.props.static && this.props.isInequality && inequalityControls);
  }
});

_$K.extend(NumberLine, {
  validate: function validate(state, rubric) {
    var range = rubric.range;
    var divisionRange = state.divisionRange;
    var start = rubric.initialX != null ? rubric.initialX : range[0];
    var startRel = rubric.isInequality ? "ge" : "eq";
    var correctRel = rubric.correctRel || "eq";
    var correctPos = knumber$2.equal(state.numLinePosition, rubric.correctX || 0);
    var outsideAllowedRange = state.numDivisions > divisionRange[1] || state.numDivisions < divisionRange[0];

    if (state.isTickCrtl && outsideAllowedRange) {
      return {
        type: "invalid",
        message: "Number of divisions is outside the allowed range."
      };
    } else if (correctPos && correctRel === state.rel) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    } else if (state.numLinePosition === start && state.rel === startRel) {
      // We're where we started.
      return {
        type: "invalid",
        message: null
      };
    } else {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
  }
});

var numberLineTransform = editorProps => {
  var props = _$K.pick(editorProps, ["range", "labelRange", "labelStyle", "labelTicks", "divisionRange", "snapDivisions", "isTickCtrl", "isInequality", "showTooltips"]);

  var numLinePosition = editorProps.initialX != null ? editorProps.initialX : editorProps.range[0];
  var width = editorProps.range[1] - editorProps.range[0];
  var numDivisions;

  if (editorProps.numDivisions != null) {
    numDivisions = editorProps.numDivisions;
  } else if (editorProps.tickStep != null) {
    numDivisions = width / editorProps.tickStep;
  } else {
    numDivisions = undefined; // send to getDefaultProps()
  }

  _$K.extend(props, {
    numLinePosition: numLinePosition,
    numDivisions: numDivisions,
    // Use getDefaultProps value if null
    snapDivisions: props.snapDivisions || undefined
  });

  return props;
};

var staticTransform$2 = editorProps => {
  var props = _$K.pick(editorProps, ["range", "labelRange", "labelStyle", "labelTicks", "divisionRange", "snapDivisions", // isTickCtrl is ignored since users can't interact with it anyway
  "isInequality"]); // The correct x is the initial position of the point


  var numLinePosition = editorProps.correctX != null ? editorProps.correctX : editorProps.range[0];
  var width = editorProps.range[1] - editorProps.range[0];
  var numDivisions;

  if (editorProps.numDivisions != null) {
    numDivisions = editorProps.numDivisions;
  } else if (editorProps.tickStep != null) {
    numDivisions = width / editorProps.tickStep;
  } else {
    numDivisions = undefined; // send to getDefaultProps()
  }

  _$K.extend(props, {
    numLinePosition: numLinePosition,
    numDivisions: numDivisions,
    // Render the relation in the correct answer
    rel: editorProps.isInequality ? editorProps.correctRel : null,
    // Use getDefaultProps value if null
    snapDivisions: props.snapDivisions || undefined
  });

  return props;
};

_module_$_.exports = {
  name: "number-line",
  displayName: "Number line",
  widget: NumberLine,
  transform: numberLineTransform,
  staticTransform: staticTransform$2
};
var _widgetsNumberLineJsx = _module_$_.exports;

var _module_$Z = {
  exports: {}
};
var React$_ = _react__default["default"];
var EditorJsonify$c = _mixinsEditorJsonifyJsx;
var Changeable$u = Changeable$Q;
var NumberInput$7 = _componentsNumberInputJsx;
var TextInput$7 = _componentsTextInputJsx;
var MoleculeWidgetEditor = createReactClass({
  displayName: "MoleculeWidgetEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$u.propTypes), {}, {
    rotationAngle: PropTypes.number,
    smiles: PropTypes.string
  }),

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$u.change.apply(this, args);
  },

  updateMolecule: function updateMolecule(newValue) {
    this.change({
      smiles: newValue
    });
  },
  updateRotation: function updateRotation(newValue) {
    this.change({
      rotationAngle: newValue
    });
  },

  serialize() {
    return EditorJsonify$c.serialize.call(this);
  },

  render: function render() {
    return /*#__PURE__*/React$_.createElement("div", null, /*#__PURE__*/React$_.createElement("div", null, /*#__PURE__*/React$_.createElement("label", null, "SMILES:\xA0", /*#__PURE__*/React$_.createElement(TextInput$7, {
      onChange: this.updateMolecule,
      value: this.props.smiles
    }))), /*#__PURE__*/React$_.createElement("div", null, /*#__PURE__*/React$_.createElement("label", null, "Rotation (deg):\xA0", /*#__PURE__*/React$_.createElement(NumberInput$7, {
      onChange: this.updateRotation,
      value: this.props.rotationAngle
    }))));
  }
});
_module_$Z.exports = MoleculeWidgetEditor;
var _widgetsMoleculeEditorJsx = _module_$Z.exports;

var _module_$Y = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$Z = _react__default["default"];
var _$J = _underscore__default["default"];
var Changeable$t = Changeable$Q;
var EditorJsonify$b = _mixinsEditorJsonifyJsx;
var InfoTip$b = _componentsInfoTipJsx;
var NumberInput$6 = _componentsNumberInputJsx;
var PropCheckBox$8 = _componentsPropCheckBoxJsx;
var RangeInput$2 = _componentsRangeInputJsx;
var defaultImage$1 = {
  url: null,
  top: 0,
  left: 0
};
var MeasurerEditor = createReactClass({
  displayName: "MeasurerEditor",
  className: "perseus-widget-measurer",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$t.propTypes), {}, {
    box: PropTypes.arrayOf(PropTypes.number),
    image: PropTypes.shape({
      url: PropTypes.string,
      top: PropTypes.number,
      left: PropTypes.number
    }),
    showProtractor: PropTypes.bool,
    showRuler: PropTypes.bool,
    rulerLabel: PropTypes.string,
    rulerTicks: PropTypes.number,
    rulerPixels: PropTypes.number,
    rulerLength: PropTypes.number
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      box: [480, 480],
      image: {},
      showProtractor: true,
      showRuler: false,
      rulerLabel: "",
      rulerTicks: 10,
      rulerPixels: 40,
      rulerLength: 10
    };
  },
  render: function render() {
    var image = _$J.extend({}, defaultImage$1, this.props.image);

    return /*#__PURE__*/React$Z.createElement("div", {
      className: "perseus-widget-measurer"
    }, /*#__PURE__*/React$Z.createElement("div", null, "Image displayed under protractor and/or ruler:"), /*#__PURE__*/React$Z.createElement("div", null, "URL:", " ", /*#__PURE__*/React$Z.createElement("input", {
      type: "text",
      className: "perseus-widget-measurer-url",
      ref: "image-url",
      defaultValue: image.url,
      onChange: this._changeUrl
    }), /*#__PURE__*/React$Z.createElement(InfoTip$b, null, /*#__PURE__*/React$Z.createElement("p", null, "Create an image in graphie, or use the \"Add image\" function to create a background."))), image.url && /*#__PURE__*/React$Z.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$Z.createElement("label", {
      className: "perseus-widget-left-col"
    }, "Pixels from top:", " ", /*#__PURE__*/React$Z.createElement(NumberInput$6, {
      placeholder: 0,
      onChange: this._changeTop,
      value: image.top,
      useArrowKeys: true
    })), /*#__PURE__*/React$Z.createElement("label", {
      className: "perseus-widget-right-col"
    }, "Pixels from left:", " ", /*#__PURE__*/React$Z.createElement(NumberInput$6, {
      placeholder: 0,
      onChange: this._changeLeft,
      value: image.left,
      useArrowKeys: true
    }))), /*#__PURE__*/React$Z.createElement("div", null, "Containing area [width, height]:", " ", /*#__PURE__*/React$Z.createElement(RangeInput$2, {
      onChange: this.change("box"),
      value: this.props.box,
      useArrowKeys: true
    })), /*#__PURE__*/React$Z.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$Z.createElement("div", {
      className: "perseus-widget-left-col"
    }, /*#__PURE__*/React$Z.createElement(PropCheckBox$8, {
      label: "Show ruler",
      showRuler: this.props.showRuler,
      onChange: this.props.onChange
    })), /*#__PURE__*/React$Z.createElement("div", {
      className: "perseus-widget-right-col"
    }, /*#__PURE__*/React$Z.createElement(PropCheckBox$8, {
      label: "Show protractor",
      showProtractor: this.props.showProtractor,
      onChange: this.props.onChange
    }))), this.props.showRuler && /*#__PURE__*/React$Z.createElement("div", null, /*#__PURE__*/React$Z.createElement("div", null, /*#__PURE__*/React$Z.createElement("label", null, " ", "Ruler label:", " ", /*#__PURE__*/React$Z.createElement("select", {
      onChange: e => this.change("rulerLabel", e.target.value),
      value: this.props.rulerLabel
    }, /*#__PURE__*/React$Z.createElement("option", {
      value: ""
    }, "None"), /*#__PURE__*/React$Z.createElement("optgroup", {
      label: "Metric"
    }, this.renderLabelChoices([["milimeters", "mm"], ["centimeters", "cm"], ["meters", "m"], ["kilometers", "km"]])), /*#__PURE__*/React$Z.createElement("optgroup", {
      label: "Imperial"
    }, this.renderLabelChoices([["inches", "in"], ["feet", "ft"], ["yards", "yd"], ["miles", "mi"]]))))), /*#__PURE__*/React$Z.createElement("div", null, /*#__PURE__*/React$Z.createElement("label", null, " ", "Ruler ticks:", " ", /*#__PURE__*/React$Z.createElement("select", {
      onChange: e => this.change("rulerTicks", +e.target.value),
      value: this.props.rulerTicks
    }, _$J.map([1, 2, 4, 8, 10, 16], function (n) {
      return /*#__PURE__*/React$Z.createElement("option", {
        key: n,
        value: n
      }, n);
    })))), /*#__PURE__*/React$Z.createElement("div", null, /*#__PURE__*/React$Z.createElement("label", null, "Ruler pixels per unit:", " ", /*#__PURE__*/React$Z.createElement(NumberInput$6, {
      placeholder: 40,
      onChange: this.change("rulerPixels"),
      value: this.props.rulerPixels,
      useArrowKeys: true
    }))), /*#__PURE__*/React$Z.createElement("div", null, /*#__PURE__*/React$Z.createElement("label", null, "Ruler length in units:", " ", /*#__PURE__*/React$Z.createElement(NumberInput$6, {
      placeholder: 10,
      onChange: this.change("rulerLength"),
      value: this.props.rulerLength,
      useArrowKeys: true
    })))));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$t.change.apply(this, args);
  },

  _changeUrl: function _changeUrl(e) {
    this._changeImage("url", e.target.value);
  },
  _changeTop: function _changeTop(newTop) {
    this._changeImage("top", newTop);
  },
  _changeLeft: function _changeLeft(newLeft) {
    this._changeImage("left", newLeft);
  },
  _changeImage: function _changeImage(subProp, newValue) {
    var image = _$J.clone(this.props.image);

    image[subProp] = newValue;
    this.change("image", image);
  },
  renderLabelChoices: function renderLabelChoices(choices) {
    return _$J.map(choices, function (nameAndValue) {
      var [name, value] = nameAndValue;
      return /*#__PURE__*/React$Z.createElement("option", {
        key: value,
        value: value
      }, name);
    });
  },

  serialize() {
    return EditorJsonify$b.serialize.call(this);
  }

});
_module_$Y.exports = MeasurerEditor;
var _widgetsMeasurerEditorJsx = _module_$Y.exports;

var _module_$X = {
  exports: {}
};
/* eslint-disable comma-dangle, indent, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$Y = _react__default["default"];
var ReactDOM$9 = _reactDom__default["default"];
var _2$1 = _underscore__default["default"];
var ApiOptions$h = _perseusApiJsx.Options;
var GraphUtils$1 = _utilGraphUtilsJs;
var defaultImage = {
  url: null,
  top: 0,
  left: 0
};
var Measurer = createReactClass({
  displayName: "Measurer",
  propTypes: {
    apiOptions: ApiOptions$h.propTypes,
    box: PropTypes.arrayOf(PropTypes.number),
    image: PropTypes.shape({
      url: PropTypes.string,
      top: PropTypes.number,
      left: PropTypes.number
    }),
    showProtractor: PropTypes.bool,
    protractorX: PropTypes.number,
    protractorY: PropTypes.number,
    showRuler: PropTypes.bool,
    rulerLabel: PropTypes.string,
    rulerTicks: PropTypes.number,
    rulerPixels: PropTypes.number,
    rulerLength: PropTypes.number
  },
  getDefaultProps: function getDefaultProps() {
    return {
      box: [480, 480],
      image: {},
      showProtractor: true,
      protractorX: 7.5,
      protractorY: 0.5,
      showRuler: false,
      rulerLabel: "",
      rulerTicks: 10,
      rulerPixels: 40,
      rulerLength: 10
    };
  },
  getInitialState: function getInitialState() {
    return {};
  },
  render: function render() {
    var image = _2$1.extend({}, defaultImage, this.props.image);

    return /*#__PURE__*/React$Y.createElement("div", {
      className: "perseus-widget perseus-widget-measurer " + "graphie-container above-scratchpad",
      style: {
        width: this.props.box[0],
        height: this.props.box[1]
      }
    }, image.url && /*#__PURE__*/React$Y.createElement("img", {
      src: image.url,
      style: {
        top: image.top,
        left: image.left
      }
    }), /*#__PURE__*/React$Y.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  },
  componentDidMount: function componentDidMount() {
    this.setupGraphie();
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    var shouldSetupGraphie = _2$1.any(["box", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "rulerPixels", "rulerLength"], function (prop) {
      return prevProps[prop] !== this.props[prop];
    }, this);

    if (shouldSetupGraphie) {
      this.setupGraphie();
    }
  },
  setupGraphie: function setupGraphie() {
    var graphieDiv = ReactDOM$9.findDOMNode(this.refs.graphieDiv);
    $(graphieDiv).empty();
    var graphie = this.graphie = GraphUtils$1.createGraphie(graphieDiv);
    var scale = [40, 40];
    var range = [[0, this.props.box[0] / scale[0]], [0, this.props.box[1] / scale[1]]];
    graphie.init({
      range: range,
      scale: scale
    });
    graphie.addMouseLayer({
      allowScratchpad: true,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    });

    if (this.protractor) {
      this.protractor.remove();
    }

    if (this.props.showProtractor) {
      this.protractor = graphie.protractor([this.props.protractorX, this.props.protractorY]);
    }

    if (this.ruler) {
      this.ruler.remove();
    }

    if (this.props.showRuler) {
      this.ruler = graphie.ruler({
        center: [(range[0][0] + range[0][1]) / 2, (range[1][0] + range[1][1]) / 2],
        label: this.props.rulerLabel,
        pixelsPerUnit: this.props.rulerPixels,
        ticksPerUnit: this.props.rulerTicks,
        units: this.props.rulerLength
      });
    }
  },
  getUserInput: function getUserInput() {
    return {};
  },
  simpleValidate: function simpleValidate(rubric) {
    // TODO(joel) - I don't understand how this is useful!
    return Measurer.validate(this.getUserInput(), rubric);
  },
  focus: $.noop
});

_2$1.extend(Measurer, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  }
});

var propUpgrades$2 = {
  1: v0props => {
    var v1props = _2$1.chain(v0props).omit("imageUrl", "imageTop", "imageLeft").extend({
      image: {
        url: v0props.imageUrl,
        top: v0props.imageTop,
        left: v0props.imageLeft
      }
    }).value();

    return v1props;
  }
};
_module_$X.exports = {
  name: "measurer",
  displayName: "Measurer",
  widget: Measurer,
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades$2
};
var _widgetsMeasurerJsx = _module_$X.exports;

var _module_$W = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$X = _react__default["default"];
var _$I = _underscore__default["default"];
var InfoTip$a = _componentsInfoTipJsx;
var PropCheckBox$7 = _componentsPropCheckBoxJsx;
var TextListEditor$1 = _componentsTextListEditorJsx;
var MatcherEditor = createReactClass({
  displayName: "MatcherEditor",
  propTypes: {
    left: PropTypes.array,
    right: PropTypes.array,
    labels: PropTypes.array,
    orderMatters: PropTypes.bool,
    padding: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      left: ["$x$", "$y$", "$z$"],
      right: ["$1$", "$2$", "$3$"],
      labels: ["test", "label"],
      orderMatters: false,
      padding: true
    };
  },
  render: function render() {
    return /*#__PURE__*/React$X.createElement("div", {
      className: "perseus-matcher-editor"
    }, /*#__PURE__*/React$X.createElement("div", null, " ", "Correct answer:", " ", /*#__PURE__*/React$X.createElement(InfoTip$a, null, /*#__PURE__*/React$X.createElement("p", null, "Enter the correct answers here. The preview on the right will show the cards in a randomized order, which is how the student will see them."))), /*#__PURE__*/React$X.createElement("div", {
      className: "perseus-clearfix"
    }, /*#__PURE__*/React$X.createElement(TextListEditor$1, {
      options: this.props.left,
      onChange: (options, cb) => {
        this.props.onChange({
          left: options
        }, cb);
      },
      layout: "vertical"
    }), /*#__PURE__*/React$X.createElement(TextListEditor$1, {
      options: this.props.right,
      onChange: (options, cb) => {
        this.props.onChange({
          right: options
        }, cb);
      },
      layout: "vertical"
    })), /*#__PURE__*/React$X.createElement("span", null, " ", "Labels:", " ", /*#__PURE__*/React$X.createElement(InfoTip$a, null, /*#__PURE__*/React$X.createElement("p", null, "These are entirely optional."))), /*#__PURE__*/React$X.createElement("div", null, /*#__PURE__*/React$X.createElement("input", {
      type: "text",
      defaultValue: this.props.labels[0],
      onChange: this.onLabelChange.bind(this, 0)
    }), /*#__PURE__*/React$X.createElement("input", {
      type: "text",
      defaultValue: this.props.labels[1],
      onChange: this.onLabelChange.bind(this, 1)
    })), /*#__PURE__*/React$X.createElement("div", null, /*#__PURE__*/React$X.createElement(PropCheckBox$7, {
      label: "Order of the matched pairs matters:",
      orderMatters: this.props.orderMatters,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$X.createElement(InfoTip$a, null, /*#__PURE__*/React$X.createElement("p", null, "With this option enabled, only the order provided above will be treated as correct. This is useful when ordering is significant, such as in the context of a proof."), /*#__PURE__*/React$X.createElement("p", null, "If disabled, pairwise matching is sufficient. To make this clear, the left column becomes fixed in the provided order and only the cards in the right column can be moved."))), /*#__PURE__*/React$X.createElement("div", null, /*#__PURE__*/React$X.createElement(PropCheckBox$7, {
      label: "Padding:",
      padding: this.props.padding,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$X.createElement(InfoTip$a, null, /*#__PURE__*/React$X.createElement("p", null, "Padding is good for text, but not needed for images."))));
  },
  onLabelChange: function onLabelChange(index, e) {
    var labels = _$I.clone(this.props.labels);

    labels[index] = e.target.value;
    this.props.onChange({
      labels: labels
    });
  },
  getSaveWarnings: function getSaveWarnings() {
    if (this.props.left.length !== this.props.right.length) {
      return ["The two halves of the matcher have different numbers" + " of cards."];
    }

    return [];
  },
  serialize: function serialize() {
    return _$I.pick(this.props, "left", "right", "labels", "orderMatters", "padding");
  }
});
_module_$W.exports = MatcherEditor;
var _widgetsMatcherEditorJsx = _module_$W.exports;

var _module_$V = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/forbid-prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$W = _react__default["default"];
var _$H = _underscore__default["default"];
var Renderer$b = _rendererJsx;
var Sortable = _componentsSortableJsx;
var ApiOptions$g = _perseusApiJsx.Options;
var shuffle$1 = Util$q.shuffle;
var seededRNG = Util$q.seededRNG;
var HACKY_CSS_CLASSNAME = "perseus-widget-matcher";
var Matcher = createReactClass({
  displayName: "Matcher",
  propTypes: {
    apiOptions: ApiOptions$g.propTypes,
    labels: PropTypes.array,
    left: PropTypes.array,
    onChange: PropTypes.func,
    orderMatters: PropTypes.bool,
    padding: PropTypes.bool,
    problemNum: PropTypes.number,
    right: PropTypes.array,
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      left: [],
      right: [],
      labels: ["", ""],
      orderMatters: false,
      padding: true,
      problemNum: 0,
      onChange: function onChange() {},
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      leftHeight: 0,
      rightHeight: 0
    };
  },
  render: function render() {
    // Use the same random() function to shuffle both columns sequentially
    var rng = seededRNG(this.props.problemNum);
    var left;

    if (!this.props.orderMatters) {
      // If the order doesn't matter, don't shuffle the left column
      left = this.props.left;
    } else {
      left = shuffle$1(this.props.left, rng,
      /* ensurePermuted */
      true);
    }

    var right = shuffle$1(this.props.right, rng,
    /* ensurePermuted */
    true);

    var showLabels = _$H.any(this.props.labels);

    var constraints = {
      height: _$H.max([this.state.leftHeight, this.state.rightHeight])
    };
    var cellMarginPx = this.props.apiOptions.isMobile ? 8 : 5;
    return /*#__PURE__*/React$W.createElement("table", {
      className: aphrodite.css(styles$d.widget) + " " + HACKY_CSS_CLASSNAME
    }, /*#__PURE__*/React$W.createElement("tbody", null, showLabels && /*#__PURE__*/React$W.createElement("tr", {
      className: aphrodite.css(styles$d.row)
    }, /*#__PURE__*/React$W.createElement("th", {
      className: aphrodite.css(styles$d.column, styles$d.columnLabel)
    }, /*#__PURE__*/React$W.createElement(Renderer$b, {
      content: this.props.labels[0] || "...",
      linterContext: this.props.linterContext
    })), /*#__PURE__*/React$W.createElement("th", {
      className: aphrodite.css(styles$d.column, styles$d.columnRight, styles$d.columnLabel)
    }, /*#__PURE__*/React$W.createElement(Renderer$b, {
      content: this.props.labels[1] || "...",
      linterContext: this.props.linterContext
    }))), /*#__PURE__*/React$W.createElement("tr", {
      className: aphrodite.css(styles$d.row)
    }, /*#__PURE__*/React$W.createElement("td", {
      className: aphrodite.css(styles$d.column)
    }, /*#__PURE__*/React$W.createElement(Sortable, {
      options: left,
      layout: "vertical",
      padding: this.props.padding,
      disabled: !this.props.orderMatters,
      constraints: constraints,
      onMeasure: this.onMeasureLeft,
      onChange: this.changeAndTrack,
      margin: cellMarginPx,
      linterContext: this.props.linterContext,
      ref: "left"
    })), /*#__PURE__*/React$W.createElement("td", {
      className: aphrodite.css(styles$d.column, styles$d.columnRight)
    }, /*#__PURE__*/React$W.createElement(Sortable, {
      options: right,
      layout: "vertical",
      padding: this.props.padding,
      constraints: constraints,
      onMeasure: this.onMeasureRight,
      onChange: this.changeAndTrack,
      margin: cellMarginPx,
      linterContext: this.props.linterContext,
      ref: "right"
    })))));
  },
  changeAndTrack: function changeAndTrack(e) {
    this.props.onChange(e);
    this.props.trackInteraction();
  },
  onMeasureLeft: function onMeasureLeft(dimensions) {
    var height = _$H.max(dimensions.heights);

    this.setState({
      leftHeight: height
    });
  },
  onMeasureRight: function onMeasureRight(dimensions) {
    var height = _$H.max(dimensions.heights);

    this.setState({
      rightHeight: height
    });
  },
  getUserInput: function getUserInput() {
    return {
      left: this.refs.left.getOptions(),
      right: this.refs.right.getOptions()
    };
  },
  simpleValidate: function simpleValidate(rubric) {
    return Matcher.validate(this.getUserInput(), rubric);
  }
});

_$H.extend(Matcher, {
  validate: function validate(state, rubric) {
    var correct = _$H.isEqual(state.left, rubric.left) && _$H.isEqual(state.right, rubric.right);

    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
});

var padding = 5;
var border = "1px solid #444";
var styles$d = aphrodite.StyleSheet.create({
  widget: {
    paddingTop: padding,
    maxWidth: "100%",
    // Need to override minWidth in CSS :(
    minWidth: "auto"
  },
  row: {
    // Need to override global rules in CSS :(
    border: 0
  },
  column: {
    // TODO(benkomalo): constraint to half width?
    padding: 0,
    border: 0
  },
  columnRight: {
    borderLeft: border
  },
  columnLabel: {
    fontWeight: "inherit",
    borderBottom: border,
    padding: "0 ".concat(padding, "px ").concat(padding, "px ").concat(padding, "px"),
    textAlign: "center"
  }
});
_module_$V.exports = {
  name: "matcher",
  displayName: "Two column matcher",
  widget: Matcher,
  isLintable: true
};
var _widgetsMatcherJsx = _module_$V.exports;

var _module_$U = {
  exports: {}
};
/* eslint-disable comma-dangle, max-len, no-undef, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp, space-before-function-paren */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var classNames$b = _classnames__default["default"];
var React$V = _react__default["default"];
var ReactDOM$8 = _reactDom__default["default"];
var _$G = _underscore__default["default"];
var NumberInput$5 = _componentsNumberInputJsx;
var Renderer$a = _rendererJsx;
var TextInput$6 = _componentsTextInputJsx;
var MathOutput$1 = _componentsMathOutputJsx;
var SimpleKeypadInput$2 = _componentsSimpleKeypadInputJsx;
var ApiOptions$f = _perseusApiJsx.Options;
var KhanAnswerTypes$3 = _utilAnswerTypesJs;
var {
  keypadElementPropType: keypadElementPropType$3
} = _mathInput__default["default"].propTypes;
var assert = InteractiveUtil$7.assert;
var stringArrayOfSize = Util$q.stringArrayOfSize; // We store three sets of dimensions for the brackets, for our three types of
// inputs, which vary in formatting: (1) the "static" inputs rendered for the
// mobile apps (that are being deprecated), (2) the normal inputs rendered on
// desktop, and (3) the keypad-based inputs newly rendered for the mobile apps
// and mobile web. The first two sets of dimensions come from `matrix.less`;
// the keypad-based input's dimensions are provided to the component itself,
// below.

var STATIC_INPUT_DIMENSIONS = {
  INPUT_MARGIN: 4,
  INPUT_HEIGHT: 38,
  INPUT_WIDTH: 82
};
var NORMAL_DIMENSIONS = {
  INPUT_MARGIN: 3,
  INPUT_HEIGHT: 30,
  INPUT_WIDTH: 40
};
var KEYPAD_INPUT_DIMENSIONS = {
  INPUT_MARGIN: 4,
  INPUT_HEIGHT: 36,
  INPUT_WIDTH: 64
};
/* Input handling: Maps a (row, column) pair to a unique ref used by React,
 * and extracts (row, column) pairs from input paths, used to allow outsiders
 * to focus, blur, set input values, etc. */

var getInputPath = function getInputPath(row, column) {
  return ["" + row, "" + column];
};

var getDefaultPath = function getDefaultPath() {
  return getInputPath(0, 0);
};

var getRowFromPath = function getRowFromPath(path) {
  // 'path' should be a (row, column) pair
  assert(_$G.isArray(path) && path.length === 2);
  return +path[0];
};

var getColumnFromPath = function getColumnFromPath(path) {
  // 'path' should be a (row, column) pair
  assert(_$G.isArray(path) && path.length === 2);
  return +path[1];
};

var getRefForPath = function getRefForPath(path) {
  var row = getRowFromPath(path);
  var column = getColumnFromPath(path);
  return "answer" + row + "," + column;
};

var getMatrixSize$1 = function getMatrixSize(matrix) {
  var matrixSize = [1, 1]; // We need to find the widest row and tallest column to get the correct
  // matrix size.

  _$G.each(matrix, (matrixRow, row) => {
    var rowWidth = 0;

    _$G.each(matrixRow, (matrixCol, col) => {
      if (matrixCol != null && matrixCol.toString().length) {
        rowWidth = col + 1;
      }
    }); // Matrix width:


    matrixSize[1] = Math.max(matrixSize[1], rowWidth); // Matrix height:

    if (rowWidth > 0) {
      matrixSize[0] = Math.max(matrixSize[0], row + 1);
    }
  });

  return matrixSize;
};

var Matrix$1 = createReactClass({
  displayName: "Matrix",
  propTypes: {
    answers: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number]))),
    apiOptions: ApiOptions$f.propTypes,
    cursorPosition: PropTypes.arrayOf(PropTypes.number),
    keypadElement: keypadElementPropType$3,
    matrixBoardSize: PropTypes.arrayOf(PropTypes.number).isRequired,
    prefix: PropTypes.string,
    suffix: PropTypes.string,
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      matrixBoardSize: [3, 3],
      answers: [[]],
      prefix: "",
      suffix: "",
      cursorPosition: [0, 0],
      apiOptions: ApiOptions$f.defaults,
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      enterTheMatrix: 0
    };
  },
  componentDidMount: function componentDidMount() {
    // Used in the `onBlur` and `onFocus` handlers
    this.cursorPosition = [0, 0];
  },
  render: function render() {
    // Set the input sizes through JS so we can control the size of the
    // brackets. (If we set them in CSS we won't know values until the
    // inputs are rendered.)
    var dimensions;

    if (this.props.apiOptions.customKeypad) {
      dimensions = KEYPAD_INPUT_DIMENSIONS;
    } else if (this.props.apiOptions.staticRender) {
      dimensions = STATIC_INPUT_DIMENSIONS;
    } else {
      dimensions = NORMAL_DIMENSIONS;
    }

    var {
      INPUT_MARGIN,
      INPUT_HEIGHT,
      INPUT_WIDTH
    } = dimensions;
    var matrixSize = getMatrixSize$1(this.props.answers);
    var maxRows = this.props.matrixBoardSize[0];
    var maxCols = this.props.matrixBoardSize[1];
    var cursorRow = this.props.cursorPosition[0];
    var cursorCol = this.props.cursorPosition[1];
    var highlightedRow = Math.max(cursorRow, matrixSize[0] - 1);
    var highlightedCol = Math.max(cursorCol, matrixSize[1] - 1);
    var bracketHeight = (highlightedRow + 1) * (INPUT_HEIGHT + 2 * INPUT_MARGIN);
    var bracketOffset = (highlightedCol + 1) * (INPUT_WIDTH + 2 * INPUT_MARGIN);
    var className = classNames$b({
      "perseus-matrix": true,
      "static-mode": this.props.static,
      "the-matrix": this.state.enterTheMatrix >= 5
    });
    return /*#__PURE__*/React$V.createElement("div", {
      className: className
    }, this.props.prefix && /*#__PURE__*/React$V.createElement("div", {
      className: "matrix-prefix"
    }, /*#__PURE__*/React$V.createElement(Renderer$a, {
      content: this.props.prefix,
      linterContext: this.props.linterContext
    })), /*#__PURE__*/React$V.createElement("div", {
      className: "matrix-input"
    }, /*#__PURE__*/React$V.createElement("div", {
      className: "matrix-bracket bracket-left",
      style: {
        height: bracketHeight
      }
    }), /*#__PURE__*/React$V.createElement("div", {
      className: "matrix-bracket bracket-right",
      style: {
        height: bracketHeight,
        left: bracketOffset
      }
    }), _$G.times(maxRows, row => {
      var rowVals = this.props.answers[row];
      return /*#__PURE__*/React$V.createElement("div", {
        className: "matrix-row",
        key: row
      }, _$G.times(maxCols, col => {
        var outside = row > highlightedRow || col > highlightedCol;
        var inputProps = {
          className: outside ? "outside" : "inside",
          ref: getRefForPath(getInputPath(row, col)),
          value: rowVals ? rowVals[col] : null,
          style: {
            height: INPUT_HEIGHT,
            width: INPUT_WIDTH,
            margin: INPUT_MARGIN
          },
          disabled: this.props.apiOptions.readOnly,
          onFocus: () => {
            // We store this locally so that we can use
            // the new information in the `onBlur`
            // handler, which happens before the props
            // change has time to propagate.
            // TODO(emily): Try to fix `MathOutput` so
            // it correctly sends blur events before
            // focus events.
            this.cursorPosition = [row, col];
            this.props.onChange({
              cursorPosition: [row, col]
            }, () => {
              // This isn't a user interaction, so
              // return false to signal that the
              // matrix shouldn't be focused
              return false;
            });

            this._handleFocus(row, col);
          },
          onBlur: () => {
            if (row === this.cursorPosition[0] && col === this.cursorPosition[1]) {
              this.props.onChange({
                cursorPosition: [0, 0]
              }, () => {
                // This isn't a user interaction,
                // so return false to signal that
                // the matrix shouldn't be focused
                return false;
              });
            }

            this._handleBlur(row, col);
          },
          onKeyDown: e => {
            this.handleKeyDown(row, col, e);
          },
          onChange: (value, cb) => {
            this.onValueChange(row, col, value, cb);
          }
        };
        var MatrixInput;

        if (this.props.apiOptions.customKeypad) {
          var style = {
            margin: INPUT_MARGIN,
            minWidth: INPUT_WIDTH,
            minHeight: INPUT_HEIGHT,
            // Ensure that any borders are included in
            // the provided width.
            boxSizing: "border-box",
            backgroundColor: outside ? "#f3f3f3" : "#fff"
          };
          MatrixInput = /*#__PURE__*/React$V.createElement(SimpleKeypadInput$2, _extends({}, inputProps, {
            style: style,
            scrollable: true,
            keypadElement: this.props.keypadElement
          }));
        } else if (this.props.apiOptions.staticRender) {
          MatrixInput = /*#__PURE__*/React$V.createElement(MathOutput$1, inputProps);
        } else if (this.props.numericInput) {
          MatrixInput = /*#__PURE__*/React$V.createElement(NumberInput$5, inputProps);
        } else {
          MatrixInput = /*#__PURE__*/React$V.createElement(TextInput$6, inputProps);
        }

        return /*#__PURE__*/React$V.createElement("span", {
          key: col,
          className: "matrix-input-field"
        }, MatrixInput);
      }));
    })), this.props.suffix && /*#__PURE__*/React$V.createElement("div", {
      className: "matrix-suffix"
    }, /*#__PURE__*/React$V.createElement(Renderer$a, {
      content: this.props.suffix,
      linterContext: this.props.linterContext
    })));
  },
  getInputPaths: function getInputPaths() {
    var inputPaths = [];
    var maxRows = this.props.matrixBoardSize[0];
    var maxCols = this.props.matrixBoardSize[1];

    _$G.times(maxRows, row => {
      _$G.times(maxCols, col => {
        var inputPath = getInputPath(row, col);
        inputPaths.push(inputPath);
      });
    });

    return inputPaths;
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(inputPath) {
    return "number";
  },
  _handleFocus: function _handleFocus(row, col) {
    this.props.onFocus(getInputPath(row, col));
  },
  _handleBlur: function _handleBlur(row, col) {
    this.props.onBlur(getInputPath(row, col));
  },
  focus: function focus() {
    this.focusInputPath(getDefaultPath());
    return true;
  },
  focusInputPath: function focusInputPath(path) {
    var inputID = getRefForPath(path);
    this.refs[inputID].focus();
  },
  blurInputPath: function blurInputPath(path) {
    if (path.length === 0) {
      path = getDefaultPath();
    }

    var inputID = getRefForPath(path);
    this.refs[inputID].blur();
  },
  getDOMNodeForPath: function getDOMNodeForPath(inputPath) {
    var inputID = getRefForPath(inputPath);
    return ReactDOM$8.findDOMNode(this.refs[inputID]);
  },
  setInputValue: function setInputValue(inputPath, value, callback) {
    var row = getRowFromPath(inputPath);
    var col = getColumnFromPath(inputPath);
    this.onValueChange(row, col, value, callback);
  },
  handleKeyDown: function handleKeyDown(row, col, e) {
    var maxRow = this.props.matrixBoardSize[0];
    var maxCol = this.props.matrixBoardSize[1];
    var enterTheMatrix = null;
    var curInput = this.refs[getRefForPath(getInputPath(row, col))];
    var curValueString = curInput.getStringValue();
    var cursorStartPosition = curInput.getSelectionStart();
    var cursorEndPosition = curInput.getSelectionEnd();
    var nextPath = null;

    if (e.key === "ArrowUp" && row > 0) {
      nextPath = getInputPath(row - 1, col);
    } else if (e.key === "ArrowDown" && row + 1 < maxRow) {
      nextPath = getInputPath(row + 1, col);
    } else if (e.key === "ArrowLeft" && col > 0) {
      if (cursorStartPosition === 0 && cursorEndPosition === 0) {
        // Only go to next input if we're at the *start* of the content
        nextPath = getInputPath(row, col - 1);
      }
    } else if (e.key === "ArrowRight" && col + 1 < maxCol) {
      if (cursorStartPosition === curValueString.length) {
        // Only go to next input if we're at the *end* of the content
        nextPath = getInputPath(row, col + 1);
      }
    } else if (e.key === "Enter") {
      enterTheMatrix = this.state.enterTheMatrix + 1;
    } else if (e.key === "Escape") {
      enterTheMatrix = 0;
    }

    if (nextPath) {
      // Prevent the cursor from jumping again inside the next input
      e.preventDefault(); // Focus the input and move the cursor to the end of it.

      var input = this.refs[getRefForPath(nextPath)]; // Multiply by 2 to ensure the cursor always ends up at the end;
      // Opera sometimes sees a carriage return as 2 characters.

      var inputValString = input.getStringValue();
      var valueLength = inputValString.length * 2;
      input.focus();

      if (e.key === "ArrowRight") {
        input.setSelectionRange(0, 0);
      } else {
        input.setSelectionRange(valueLength, valueLength);
      }
    }

    if (enterTheMatrix != null) {
      this.setState({
        enterTheMatrix: enterTheMatrix
      });
    }
  },
  onValueChange: function onValueChange(row, column, value, cb) {
    var answers = _$G.map(this.props.answers, _$G.clone);

    if (!answers[row]) {
      answers[row] = [];
    }

    answers[row][column] = value;
    this.props.onChange({
      answers: answers
    }, cb);
    this.props.trackInteraction();
  },
  getUserInput: function getUserInput() {
    return {
      answers: this.props.answers
    };
  },
  simpleValidate: function simpleValidate(rubric) {
    return Matrix$1.validate(this.getUserInput(), rubric);
  }
});

_$G.extend(Matrix$1, {
  validate: function validate(state, rubric) {
    var solution = rubric.answers;
    var supplied = state.answers;
    var solutionSize = getMatrixSize$1(solution);
    var suppliedSize = getMatrixSize$1(supplied);
    var incorrectSize = solutionSize[0] !== suppliedSize[0] || solutionSize[1] !== suppliedSize[1];
    var createValidator = KhanAnswerTypes$3.number.createValidatorFunctional;
    var message = null;
    var hasEmptyCell = false;
    var incorrect = false;

    _$G.times(suppliedSize[0], row => {
      _$G.times(suppliedSize[1], col => {
        if (supplied[row][col] == null || supplied[row][col].toString().length === 0) {
          hasEmptyCell = true;
        }

        var validator = createValidator(solution[row][col], {
          simplify: true
        });
        var result = validator(supplied[row][col]);

        if (result.message) {
          message = result.message;
        }

        if (!result.correct) {
          incorrect = true;
        }
      });
    });

    if (hasEmptyCell) {
      return {
        type: "invalid",
        message: i18n._("Make sure you fill in all cells in the matrix.")
      };
    }

    if (incorrectSize) {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }

    return {
      type: "points",
      earned: incorrect ? 0 : 1,
      total: 1,
      message: message
    };
  }
});

var propTransform$3 = editorProps => {
  // Remove answers before passing to widget
  var blankAnswers = _$G.times(editorProps.matrixBoardSize[0], function () {
    return stringArrayOfSize(editorProps.matrixBoardSize[1]);
  });

  editorProps = _$G.pick(editorProps, "matrixBoardSize", "prefix", "suffix");
  return _$G.extend(editorProps, {
    answers: blankAnswers
  });
};

var staticTransform$1 = editorProps => {
  var widgetProps = _$G.pick(editorProps, "matrixBoardSize", "prefix", "suffix"); // We convert matrix cells from numbers to string to match the expected
  // input into the rendered widget.


  widgetProps.answers = _$G.map(editorProps.answers, row => {
    // Replace null values with empty string
    return _$G.map(row, cell => cell != null ? String(cell) : "");
  });
  return widgetProps;
};

_module_$U.exports = {
  name: "matrix",
  displayName: "Matrix",
  widget: Matrix$1,
  transform: propTransform$3,
  staticTransform: staticTransform$1,
  isLintable: true
};
var _widgetsMatrixJsx = _module_$U.exports;

var _module_$T = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/sort-comp, space-before-function-paren */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$U = _react__default["default"];
var _$F = _underscore__default["default"];
var Changeable$s = Changeable$Q;
var EditorJsonify$a = _mixinsEditorJsonifyJsx;
var Editor$7 = _editorJsx;
var RangeInput$1 = _componentsRangeInputJsx;
var Matrix = _widgetsMatrixJsx.widget; // Really large matrices will cause issues with question formatting, so we
// have to cap it at some point.

var MAX_BOARD_SIZE = 6;

var getMatrixSize = function getMatrixSize(matrix) {
  var matrixSize = [1, 1]; // We need to find the widest row and tallest column to get the correct
  // matrix size.

  _$F.each(matrix, (matrixRow, row) => {
    var rowWidth = 0;

    _$F.each(matrixRow, (matrixCol, col) => {
      if (matrixCol != null && matrixCol.toString().length) {
        rowWidth = col + 1;
      }
    }); // Matrix width:


    matrixSize[1] = Math.max(matrixSize[1], rowWidth); // Matrix height:

    if (rowWidth > 0) {
      matrixSize[0] = Math.max(matrixSize[0], row + 1);
    }
  });

  return matrixSize;
};

var MatrixEditor = createReactClass({
  displayName: "MatrixEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$s.propTypes), {}, {
    matrixBoardSize: PropTypes.arrayOf(PropTypes.number).isRequired,
    answers: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),
    prefix: PropTypes.string,
    suffix: PropTypes.string,
    cursorPosition: PropTypes.arrayOf(PropTypes.number)
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      matrixBoardSize: [3, 3],
      answers: [[]],
      prefix: "",
      suffix: "",
      cursorPosition: [0, 0]
    };
  },
  render: function render() {
    var matrixProps = _$F.extend({
      numericInput: true,
      onBlur: () => {},
      onFocus: () => {},
      trackInteraction: () => {}
    }, this.props);

    return /*#__PURE__*/React$U.createElement("div", {
      className: "perseus-matrix-editor"
    }, /*#__PURE__*/React$U.createElement("div", {
      className: "perseus-widget-row"
    }, " ", "Max matrix size:", " ", /*#__PURE__*/React$U.createElement(RangeInput$1, {
      value: this.props.matrixBoardSize,
      onChange: this.onMatrixBoardSizeChange,
      format: this.props.labelStyle,
      useArrowKeys: true
    })), /*#__PURE__*/React$U.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$U.createElement(Matrix, matrixProps)), /*#__PURE__*/React$U.createElement("div", {
      className: "perseus-widget-row"
    }, " ", "Matrix prefix:", " ", /*#__PURE__*/React$U.createElement(Editor$7, {
      ref: "prefix",
      apiOptions: this.props.apiOptions,
      content: this.props.prefix,
      widgetEnabled: false,
      onChange: newProps => {
        this.change({
          prefix: newProps.content
        });
      }
    })), /*#__PURE__*/React$U.createElement("div", {
      className: "perseus-widget-row"
    }, " ", "Matrix suffix:", " ", /*#__PURE__*/React$U.createElement(Editor$7, {
      ref: "suffix",
      apiOptions: this.props.apiOptions,
      content: this.props.suffix,
      widgetEnabled: false,
      onChange: newProps => {
        this.change({
          suffix: newProps.content
        });
      }
    })));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$s.change.apply(this, args);
  },

  onMatrixBoardSizeChange: function onMatrixBoardSizeChange(range) {
    var matrixSize = getMatrixSize(this.props.answers);

    if (range[0] !== null && range[1] !== null) {
      range = [Math.round(Math.min(Math.max(range[0], 1), MAX_BOARD_SIZE)), Math.round(Math.min(Math.max(range[1], 1), MAX_BOARD_SIZE))];

      var answers = _$F.times(Math.min(range[0], matrixSize[0]), row => {
        return _$F.times(Math.min(range[1], matrixSize[1]), col => {
          return this.props.answers[row][col];
        });
      });

      this.props.onChange({
        matrixBoardSize: range,
        answers: answers
      });
    }
  },

  serialize() {
    return EditorJsonify$a.serialize.call(this);
  }

});
_module_$T.exports = MatrixEditor;
var _widgetsMatrixEditorJsx = _module_$T.exports;

var _module_$S = {
  exports: {}
};
/* eslint-disable array-bracket-spacing, comma-dangle, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$T = _react__default["default"];
var _$E = _underscore__default["default"];
var Changeable$r = Changeable$Q;
var EditorJsonify$9 = _mixinsEditorJsonifyJsx;
var NumberInput$4 = _componentsNumberInputJsx;
var PropCheckBox$6 = _componentsPropCheckBoxJsx;
var InfoTip$9 = _componentsInfoTipJsx;
var MAX_SIZE = 8; // styling

var CELL_PADDING$1 = 5;
var TABLE_STYLE$1 = {
  display: "table",
  tableLayout: "fixed"
};
var ROW_STYLE$1 = {
  display: "table-row"
};
var CELL_STYLE$1 = {
  display: "table-cell",
  padding: CELL_PADDING$1
};
var BASE_TILE_STYLE$1 = {
  borderRadius: 10,
  cursor: "pointer"
};
var PATTERNS$1 = {
  plus: () => [[false, true, false], [true, true, true], [false, true, false]],
  x: () => [[true, false, true], [false, true, false], [true, false, true]],
  "plus/x": iter => {
    return iter % 2 ? PATTERNS$1.x() : PATTERNS$1.plus();
  }
};
/**
 * Clamps value to an integer in the range [min, max]
 */

var clampToInt = function clampToInt(value, min, max) {
  value = Math.floor(value);
  value = Math.max(value, min);
  value = Math.min(value, max);
  return value;
}; // Returns a copy of the tiles, with tiles flipped according to
// whether or not their y, x position satisfies the predicate


var flipTilesPredicate$1 = (oldCells, predicate) => {
  return _$E.map(oldCells, (row, y) => {
    return _$E.map(row, (cell, x) => {
      return predicate(y, x) ? !cell : cell;
    });
  });
}; // A single glowy cell


var Tile$1 = createReactClass({
  displayName: "Tile",
  propTypes: {
    value: PropTypes.bool.isRequired,
    size: PropTypes.number.isRequired
  },
  render: function render() {
    var color = this.props.value ? "#55dd55" : "#115511";

    var style = _$E.extend({}, BASE_TILE_STYLE$1, {
      width: this.props.size,
      height: this.props.size,
      backgroundColor: color
    });

    return /*#__PURE__*/React$T.createElement("div", {
      style: style,
      onClick: this._flip
    });
  },
  _flip: function _flip() {
    this.props.onChange(!this.props.value);
  }
}); // A grid of glowy cells

var TileGrid$1 = createReactClass({
  displayName: "TileGrid",
  propTypes: {
    cells: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool)).isRequired,
    size: PropTypes.number.isRequired
  },
  render: function render() {
    return /*#__PURE__*/React$T.createElement("div", {
      style: TABLE_STYLE$1,
      className: "no-select"
    }, _$E.map(this.props.cells, (row, y) => {
      return /*#__PURE__*/React$T.createElement("div", {
        key: y,
        style: ROW_STYLE$1
      }, _$E.map(row, (cell, x) => {
        return /*#__PURE__*/React$T.createElement("div", {
          key: x,
          style: CELL_STYLE$1
        }, /*#__PURE__*/React$T.createElement(Tile$1, {
          value: cell,
          size: this.props.size,
          onChange: _$E.partial(this.props.onChange, y, x)
        }));
      }));
    }));
  }
}); // The widget editor

var LightsPuzzleEditor = createReactClass({
  displayName: "LightsPuzzleEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$r.propTypes), {}, {
    startCells: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool)),
    flipPattern: PropTypes.string.isRequired,
    gradeIncompleteAsWrong: PropTypes.bool.isRequired
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      startCells: [[false, false, false], [false, false, false], [false, false, false]],
      flipPattern: "plus",
      gradeIncompleteAsWrong: false
    };
  },
  _height: function _height() {
    return this.props.startCells.length;
  },
  _width: function _width() {
    if (this.props.startCells.length !== 0) {
      return this.props.startCells[0].length;
    } else {
      return 0; // default to 0
    }
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$r.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$T.createElement("div", null, /*#__PURE__*/React$T.createElement("div", null, "Width:", /*#__PURE__*/React$T.createElement(NumberInput$4, {
      value: this._width(),
      placeholder: 5,
      onChange: this._changeWidth
    }), ", ", "Height:", /*#__PURE__*/React$T.createElement(NumberInput$4, {
      value: this._height(),
      placeholder: 5,
      onChange: this._changeHeight
    })), /*#__PURE__*/React$T.createElement("div", null, "Flip pattern:", /*#__PURE__*/React$T.createElement("select", {
      value: this.props.flipPattern,
      onChange: this._handlePatternChange
    }, _$E.map(_$E.keys(PATTERNS$1), (pattern, i) => {
      return /*#__PURE__*/React$T.createElement("option", {
        value: pattern,
        key: i
      }, pattern);
    }))), /*#__PURE__*/React$T.createElement("div", null, "Grade incomplete puzzles as wrong:", " ", /*#__PURE__*/React$T.createElement(PropCheckBox$6, {
      gradeIncompleteAsWrong: this.props.gradeIncompleteAsWrong,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$T.createElement(InfoTip$9, null, "By default, incomplete puzzles are graded as empty.")), /*#__PURE__*/React$T.createElement("div", null, "Starting configuration:"), /*#__PURE__*/React$T.createElement("div", {
      style: {
        overflowX: "auto"
      }
    }, /*#__PURE__*/React$T.createElement(TileGrid$1, {
      cells: this.props.startCells,
      size: 50,
      onChange: this._switchTile
    })));
  },
  _handlePatternChange: function _handlePatternChange(e) {
    this.change("flipPattern", e.target.value);
  },
  _changeWidth: function _changeWidth(newWidth) {
    newWidth = clampToInt(newWidth, 1, MAX_SIZE);

    this._truncateCells(newWidth, this._height());
  },
  _changeHeight: function _changeHeight(newHeight) {
    newHeight = clampToInt(newHeight, 1, MAX_SIZE);

    this._truncateCells(this._width(), newHeight);
  },
  _truncateCells: function _truncateCells(newWidth, newHeight) {
    var newCells = _$E.times(newHeight, y => {
      return _$E.times(newWidth, x => {
        // explicitly cast the result to a boolean with !!
        return !!(this.props.startCells[y] && this.props.startCells[y][x]);
      });
    });

    this.change({
      startCells: newCells
    });
  },
  _switchTile: function _switchTile(tileY, tileX) {
    var newCells = flipTilesPredicate$1(this.props.startCells, (y, x) => {
      return y === tileY && x === tileX;
    });
    this.change({
      startCells: newCells
    });
  },

  serialize() {
    return EditorJsonify$9.serialize.call(this);
  }

});
_module_$S.exports = LightsPuzzleEditor;
var _widgetsLightsPuzzleEditorJsx = _module_$S.exports;

var _module_$R = {
  exports: {}
};
/* eslint-disable array-bracket-spacing, comma-dangle, no-undef, no-unused-vars, no-var, react/jsx-closing-bracket-location, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$S = _react__default["default"];
var _$D = _underscore__default["default"];
var Changeable$q = Changeable$Q;
var WidgetJsonifyDeprecated$2 = _mixinsWidgetJsonifyDeprecatedJsx;

var CELL_PADDING = 5;
var TABLE_STYLE = {
  display: "table",
  tableLayout: "fixed"
};
var ROW_STYLE = {
  display: "table-row"
};
var CELL_STYLE = {
  display: "table-cell",
  padding: CELL_PADDING
};
var BASE_TILE_STYLE = {
  borderRadius: 10,
  cursor: "pointer"
};
var MOVE_COUNT_STYLE = {
  padding: CELL_PADDING,
  display: "inline-block"
};
var RESET_BUTTON_STYLE = {
  float: "right",
  paddingRight: CELL_PADDING
};
var MAIN_TILE_SIZE = 50;

var PATTERNS = {
  plus: () => [[false, true, false], [true, true, true], [false, true, false]],
  x: () => [[true, false, true], [false, true, false], [true, false, true]],
  "plus/x": iter => {
    return iter % 2 ? PATTERNS.x() : PATTERNS.plus();
  }
};


var Tile = createReactClass({
  displayName: "Tile",
  propTypes: {
    value: PropTypes.bool.isRequired,
    size: PropTypes.number.isRequired
  },
  render: function render() {
    var color = this.props.value ? "#55dd55" : "#115511";

    var style = _$D.extend({}, BASE_TILE_STYLE, {
      width: this.props.size,
      height: this.props.size,
      backgroundColor: color
    });

    return /*#__PURE__*/React$S.createElement("div", {
      style: style,
      onClick: this._flip
    });
  },
  _flip: function _flip() {
    this.props.onChange(!this.props.value);
  }
}); // A grid of glowy cells

var TileGrid = createReactClass({
  displayName: "TileGrid",
  propTypes: {
    cells: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool)).isRequired,
    size: PropTypes.number.isRequired
  },
  render: function render() {
    return /*#__PURE__*/React$S.createElement("div", {
      style: TABLE_STYLE,
      className: "no-select"
    }, _$D.map(this.props.cells, (row, y) => {
      return /*#__PURE__*/React$S.createElement("div", {
        key: y,
        style: ROW_STYLE
      }, _$D.map(row, (cell, x) => {
        return /*#__PURE__*/React$S.createElement("div", {
          key: x,
          style: CELL_STYLE
        }, /*#__PURE__*/React$S.createElement(Tile, {
          value: cell,
          size: this.props.size,
          onChange: _$D.partial(this.props.onChange, y, x)
        }));
      }));
    }));
  }
}); // Returns a copy of the tiles, with tiles flipped according to
// whether or not their y, x position satisfies the predicate

var flipTilesPredicate = (oldCells, predicate) => {
  return _$D.map(oldCells, (row, y) => {
    return _$D.map(row, (cell, x) => {
      return predicate(y, x) ? !cell : cell;
    });
  });
};

var flipTilesPattern = (oldCells, tileY, tileX, pattern) => {
  return flipTilesPredicate(oldCells, (y, x) => {
    var offsetY = y - tileY;
    var offsetX = x - tileX;

    if (Math.abs(offsetY) <= 1 && Math.abs(offsetX) <= 1) {
      return pattern[offsetY + 1][offsetX + 1];
    } else {
      return false;
    }
  });
}; // The lights puzzle widget


var LightsPuzzle = createReactClass({
  displayName: "LightsPuzzle",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$q.propTypes), {}, {
    cells: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool)),
    startCells: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool)),
    flipPattern: PropTypes.string.isRequired,
    moveCount: PropTypes.number.isRequired
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      cells: [[false, false, false], [false, false, false], [false, false, false]],
      startCells: [[false, false, false], [false, false, false], [false, false, false]],
      flipPattern: "plus",
      moveCount: 0
    };
  },
  getUserInput: function getUserInput() {
    return WidgetJsonifyDeprecated$2.getUserInput.call(this);
  },
  render: function render() {
    var width = this._width();

    var tileSize = MAIN_TILE_SIZE;
    var pxWidth = width * (tileSize + 2 * CELL_PADDING);
    return /*#__PURE__*/React$S.createElement("div", null, /*#__PURE__*/React$S.createElement(TileGrid, {
      cells: this.props.cells,
      size: tileSize,
      onChange: this._flipTile
    }), /*#__PURE__*/React$S.createElement("div", {
      style: {
        width: pxWidth
      }
    }, /*#__PURE__*/React$S.createElement("div", {
      style: MOVE_COUNT_STYLE
    }, "Moves: ", this.props.moveCount), /*#__PURE__*/React$S.createElement("div", {
      style: RESET_BUTTON_STYLE
    }, /*#__PURE__*/React$S.createElement("input", {
      type: "button",
      value: "Reset",
      onClick: this._reset,
      className: "simple-button"
    }))), /*#__PURE__*/React$S.createElement("div", {
      className: "clearfix"
    }));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$q.change.apply(this, args);
  },

  _width: function _width() {
    if (this.props.cells.length !== 0) {
      return this.props.cells[0].length;
    } else {
      return 0; // default to 0
    }
  },
  componentDidMount: function componentDidMount() {
    this._initNextPatterns();
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    if (prevProps.flipPattern !== this.props.flipPattern) {
      this._initNextPatterns();
    }
  },
  _initNextPatterns: function _initNextPatterns() {
    this._currPattern = PATTERNS[this.props.flipPattern](0);
    this._nextPattern = PATTERNS[this.props.flipPattern](1);
    this._patternIndex = 2;
  },
  _shiftPatterns: function _shiftPatterns() {
    this._currPattern = this._nextPattern;
    this._nextPattern = PATTERNS[this.props.flipPattern](this._patternIndex);
    this._patternIndex++;
  },
  _flipTile: function _flipTile(tileY, tileX) {
    var newCells = flipTilesPattern(this.props.cells, tileY, tileX, this._currPattern);

    this._shiftPatterns();

    this.change({
      cells: newCells,
      moveCount: this.props.moveCount + 1
    });
  },
  _reset: function _reset() {
    this.change({
      cells: this.props.startCells,
      moveCount: 0
    });
  },
  simpleValidate: function simpleValidate(rubric) {
    return validate(rubric, this.getUserInput());
  }
}); // grading function

var validate = function validate(rubric, state) {
  var empty = _$D.all(state.cells, (row, y) => {
    return _$D.all(row, (cell, x) => {
      return cell === rubric.startCells[y][x];
    });
  });

  if (empty) {
    return {
      type: "invalid",
      message: i18n._("Click on the tiles to change the lights.")
    };
  }

  var correct = _$D.all(state.cells, row => {
    return _$D.all(row, cell => {
      return cell;
    });
  });

  if (correct) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  } else if (rubric.gradeIncompleteAsWrong) {
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  } else {
    return {
      type: "invalid",
      message: i18n._("You must turn on all of the lights to continue.")
    };
  }
}; // The function run on the editor props to create the widget props


var transformProps = function transformProps(editorProps) {
  return {
    cells: editorProps.startCells,
    startCells: editorProps.startCells,
    flipPattern: editorProps.flipPattern
  };
};

_module_$R.exports = {
  name: "lights-puzzle",
  displayName: "Lights Puzzle",
  hidden: true,
  widget: LightsPuzzle,
  transform: transformProps
};
var _widgetsLightsPuzzleJsx = _module_$R.exports;

var _module_$Q = {
  exports: {}
};
/* eslint-disable brace-style, comma-dangle, indent, max-lines, no-redeclare, no-undef, no-unused-vars, no-var, object-curly-spacing, one-var, prefer-spread, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$R = _react__default["default"];
var _$C = _underscore__default["default"];
var Graph = _componentsGraphJsx;
var InfoTip$8 = _componentsInfoTipJsx;
var Interactive2$1 = _interactive2Js;
var NumberInput$3 = _componentsNumberInputJsx;
var Util$7 = Util$q;
var knumber$1 = _kmath3.number;
var kpoint$2 = _kmath3.point;
var KhanColors$3 = _utilColorsJs;
var GraphUtils = _utilGraphUtilsJs;
var WrappedLine$1 = _interactive2WrappedLineJs;
var DeprecationMixin$1 = Util$7.DeprecationMixin;
var TRASH_ICON_URI = "https://ka-perseus-graphie.s3.amazonaws.com/b1452c0d79fd0f7ff4c3af9488474a0a0decb361.png";
var defaultBackgroundImage$3 = {
  url: null
};
var eq = Util$7.eq;
var deepEq = Util$7.deepEq;
var UNLIMITED = "unlimited"; // Sample background image:
// https://ka-perseus-graphie.s3.amazonaws.com/29c1b0fcd17fe63df0f148fe357044d5d5c7d0bb.png

function ccw(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
}

function collinear(a, b, c) {
  return eq(ccw(a, b, c), 0);
}

function sign(val) {
  if (eq(val, 0)) {
    return 0;
  } else {
    return val > 0 ? 1 : -1;
  }
} // default to defaultValue if actual is null or undefined


function defaultVal(actual, defaultValue) {
  return actual == null ? defaultValue : actual;
} // Given rect bounding points A and B, whether point C is inside the rect


function pointInRect(a, b, c) {
  return c[0] <= Math.max(a[0], b[0]) && c[0] >= Math.min(a[0], b[0]) && c[1] <= Math.max(a[1], b[1]) && c[1] >= Math.min(a[1], b[1]);
} // Whether line segment AB intersects line segment CD
// http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/


function intersects(ab, cd) {
  var triplets = [[ab[0], ab[1], cd[0]], [ab[0], ab[1], cd[1]], [cd[0], cd[1], ab[0]], [cd[0], cd[1], ab[1]]];

  var orientations = _$C.map(triplets, function (triplet) {
    return sign(ccw.apply(null, triplet));
  });

  if (orientations[0] !== orientations[1] && orientations[2] !== orientations[3]) {
    return true;
  }

  for (var i = 0; i < 4; i++) {
    if (orientations[i] === 0 && pointInRect.apply(null, triplets[i])) {
      return true;
    }
  }

  return false;
}

function vector(a, b) {
  return _$C.map(_$C.zip(a, b), function (pair) {
    return pair[0] - pair[1];
  });
}

function magnitude(v) {
  return Math.sqrt(_$C.reduce(v, function (memo, el) {
    return memo + Math.pow(el, 2);
  }, 0));
}

function dotProduct(a, b) {
  return _$C.reduce(_$C.zip(a, b), function (memo, pair) {
    return memo + pair[0] * pair[1];
  }, 0);
}

function sideLengths(coords) {
  var segments = _$C.zip(coords, rotate(coords));

  return _$C.map(segments, function (segment) {
    return magnitude(vector.apply(null, segment));
  });
} // Based on http://math.stackexchange.com/a/151149


function angleMeasures(coords) {
  var triplets = _$C.zip(rotate(coords, -1), coords, rotate(coords, 1));

  var offsets = _$C.map(triplets, function (triplet) {
    var p = vector(triplet[1], triplet[0]);
    var q = vector(triplet[2], triplet[1]);
    var raw = Math.acos(dotProduct(p, q) / (magnitude(p) * magnitude(q)));
    return sign(ccw.apply(null, triplet)) > 0 ? raw : -raw;
  });

  var sum = _$C.reduce(offsets, function (memo, arg) {
    return memo + arg;
  }, 0);

  return _$C.map(offsets, function (offset) {
    return sum > 0 ? Math.PI - offset : Math.PI + offset;
  });
} // Whether two polygons are similar (or if specified, congruent)


function similar(coords1, coords2, tolerance) {
  if (coords1.length !== coords2.length) {
    return false;
  }

  var n = coords1.length;
  var angles1 = angleMeasures(coords1);
  var angles2 = angleMeasures(coords2);
  var sides1 = sideLengths(coords1);
  var sides2 = sideLengths(coords2);

  for (var i = 0; i < 2 * n; i++) {
    var angles = angles2.slice();
    var sides = sides2.slice(); // Reverse angles and sides to allow matching reflected polygons

    if (i >= n) {
      angles.reverse();
      sides.reverse(); // Since sides are calculated from two coordinates,
      // simply reversing results in an off by one error

      sides = rotate(sides, 1);
    }

    angles = rotate(angles, i);
    sides = rotate(sides, i);

    if (deepEq(angles1, angles)) {
      var sidePairs = _$C.zip(sides1, sides);

      var factors = _$C.map(sidePairs, function (pair) {
        return pair[0] / pair[1];
      });

      var same = _$C.all(factors, function (factor) {
        return eq(factors[0], factor);
      });

      var congruentEnough = _$C.all(sidePairs, function (pair) {
        return knumber$1.equal(pair[0], pair[1], tolerance);
      });

      if (same && congruentEnough) {
        return true;
      }
    }
  }

  return false;
} // Less than or approximately equal


function leq(a, b) {
  return a < b || eq(a, b);
} // Given triangle with sides ABC return angle opposite side C in degrees


function lawOfCosines(a, b, c) {
  return Math.acos((a * a + b * b - c * c) / (2 * a * b)) * 180 / Math.PI;
}

function canonicalSineCoefficients$1(coeffs) {
  // For a curve of the form f(x) = a * Sin(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  var amplitude = coeffs[0];
  var angularFrequency = coeffs[1];
  var phase = coeffs[2];
  var verticalOffset = coeffs[3]; // Guarantee a > 0

  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }

  var period = 2 * Math.PI; // Guarantee b > 0

  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  } // Guarantee c is smallest possible positive value


  while (phase > 0) {
    phase -= period;
  }

  while (phase < 0) {
    phase += period;
  }

  return [amplitude, angularFrequency, phase, verticalOffset];
} // e.g. rotate([1, 2, 3]) -> [2, 3, 1]


function rotate(array, n) {
  n = typeof n === "undefined" ? 1 : n % array.length;
  return array.slice(n).concat(array.slice(0, n));
}

function capitalize(str) {
  return str.replace(/(?:^|-)(.)/g, function (match, letter) {
    return letter.toUpperCase();
  });
}

function getLineEquation(first, second) {
  if (eq(first[0], second[0])) {
    return "x = " + first[0].toFixed(3);
  } else {
    var m = (second[1] - first[1]) / (second[0] - first[0]);
    var b = first[1] - m * first[0];
    return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
  }
} // Stolen from the wikipedia article
// http://en.wikipedia.org/wiki/Line-line_intersection


function getLineIntersection(firstPoints, secondPoints) {
  var x1 = firstPoints[0][0],
      y1 = firstPoints[0][1],
      x2 = firstPoints[1][0],
      y2 = firstPoints[1][1],
      x3 = secondPoints[0][0],
      y3 = secondPoints[0][1],
      x4 = secondPoints[1][0],
      y4 = secondPoints[1][1];
  var determinant = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (Math.abs(determinant) < 1e-9) {
    return "Lines are parallel";
  } else {
    var x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / determinant;
    var y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / determinant;
    return "Intersection: (" + x.toFixed(3) + ", " + y.toFixed(3) + ")";
  }
}

function numSteps(range, step) {
  return Math.floor((range[1] - range[0]) / step);
}

var deprecatedProps$1 = {
  showGraph: function showGraph(props) {
    return {
      markings: props.showGraph ? "graph" : "none"
    };
  }
};
var InteractiveGraph$1 = createReactClass({
  displayName: "InteractiveGraph",
  propTypes: {
    containerSizeClass: containerSizeClassPropType.isRequired,
    trackInteraction: PropTypes.func.isRequired
  },
  getInitialState: function getInitialState() {
    return {
      shouldShowInstructions: this._getShouldShowInstructions()
    };
  },
  getDefaultProps: function getDefaultProps() {
    return {
      labels: ["x", "y"],
      range: [[-10, 10], [-10, 10]],
      step: [1, 1],
      backgroundImage: defaultBackgroundImage$3,
      markings: "graph",
      showTooltips: false,
      showProtractor: false,
      showRuler: false,
      rulerLabel: "",
      rulerTicks: 10,
      graph: {
        type: "linear"
      }
    };
  },
  deprecatedProps: deprecatedProps$1,

  componentWillMount() {
    DeprecationMixin$1.componentWillMount.call(this);
  },

  _getShouldShowInstructions: function _getShouldShowInstructions(props) {
    props = props || this.props;
    return this.isClickToAddPoints(props) && (props.graph.coords == null || props.graph.coords.length === 0);
  },
  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
    var oldType = prevProps.graph.type;
    var newType = this.props.graph.type;

    if (oldType !== newType || prevProps.graph.allowReflexAngles !== this.props.graph.allowReflexAngles || prevProps.graph.angleOffsetDeg !== this.props.graph.angleOffsetDeg || prevProps.graph.numPoints !== this.props.graph.numPoints || prevProps.graph.numSides !== this.props.graph.numSides || prevProps.graph.numSegments !== this.props.graph.numSegments || prevProps.graph.showAngles !== this.props.graph.showAngles || prevProps.graph.showSides !== this.props.graph.showSides || prevProps.graph.snapTo !== this.props.graph.snapTo || prevProps.graph.snapDegrees !== this.props.graph.snapDegrees) {
      this["remove" + capitalize(oldType) + "Controls"]();
      this["add" + capitalize(newType) + "Controls"]();
    }

    if (this.shouldResetGraphie) {
      this.resetGraphie();
    }
  },
  render: function render() {
    var typeSelect;
    var extraOptions;

    if (this.props.flexibleType) {
      typeSelect = /*#__PURE__*/React$R.createElement("select", {
        value: this.props.graph.type,
        onChange: e => {
          var type = e.target.value;
          this.onChange({
            graph: {
              type: type
            }
          });
        }
      }, /*#__PURE__*/React$R.createElement("option", {
        value: "linear"
      }, "Linear function"), /*#__PURE__*/React$R.createElement("option", {
        value: "quadratic"
      }, "Quadratic function"), /*#__PURE__*/React$R.createElement("option", {
        value: "sinusoid"
      }, "Sinusoid function"), /*#__PURE__*/React$R.createElement("option", {
        value: "circle"
      }, "Circle"), /*#__PURE__*/React$R.createElement("option", {
        value: "point"
      }, "Point(s)"), /*#__PURE__*/React$R.createElement("option", {
        value: "linear-system"
      }, "Linear System"), /*#__PURE__*/React$R.createElement("option", {
        value: "polygon"
      }, "Polygon"), /*#__PURE__*/React$R.createElement("option", {
        value: "segment"
      }, "Line Segment(s)"), /*#__PURE__*/React$R.createElement("option", {
        value: "ray"
      }, "Ray"), /*#__PURE__*/React$R.createElement("option", {
        value: "angle"
      }, "Angle"));

      if (this.props.graph.type === "point") {
        extraOptions = /*#__PURE__*/React$R.createElement("select", {
          key: "point-select",
          value: this.props.graph.numPoints || 1,
          onChange: e => {
            // Convert numbers, leave UNLIMITED intact:
            var num = +e.target.value || e.target.value;
            this.onChange({
              graph: {
                type: "point",
                numPoints: num,
                coords: null
              }
            });
          }
        }, _$C.map(_$C.range(1, 7), function (n) {
          return /*#__PURE__*/React$R.createElement("option", {
            value: n
          }, n, " point", n > 1 && "s");
        }), /*#__PURE__*/React$R.createElement("option", {
          value: UNLIMITED
        }, "unlimited"));
      } else if (this.props.graph.type === "polygon") {
        extraOptions = /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("select", {
          key: "polygon-select",
          value: this.props.graph.numSides || 3,
          onChange: e => {
            // Convert numbers, leave UNLIMITED intact:
            var num = +e.target.value || e.target.value;

            var graph = _$C.extend({}, this.props.graph, {
              numSides: num,
              coords: null,
              snapTo: "grid" // reset the snap for
              // UNLIMITED, which only
              // supports "grid"

            });

            this.onChange({
              graph: graph
            });
          }
        }, _$C.map(_$C.range(3, 13), function (n) {
          return /*#__PURE__*/React$R.createElement("option", {
            value: n
          }, n, " sides");
        }), /*#__PURE__*/React$R.createElement("option", {
          value: UNLIMITED
        }, "unlimited sides"))), /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("label", null, " ", "Snap to", " ", /*#__PURE__*/React$R.createElement("select", {
          key: "polygon-snap",
          value: this.props.graph.snapTo,
          onChange: e => {
            var graph = _$C.extend({}, this.props.graph, {
              snapTo: e.target.value,
              coords: null
            });

            this.onChange({
              graph: graph
            });
          }
        }, /*#__PURE__*/React$R.createElement("option", {
          value: "grid"
        }, "grid"), this.props.graph.numSides !== UNLIMITED && [/*#__PURE__*/React$R.createElement("option", {
          value: "angles"
        }, " ", "interior angles", " "), /*#__PURE__*/React$R.createElement("option", {
          value: "sides"
        }, " ", "side measures", " ")])), /*#__PURE__*/React$R.createElement(InfoTip$8, null, /*#__PURE__*/React$R.createElement("p", null, "These options affect the movement of the vertex points. The grid option will guide the points to the nearest half step along the grid."), /*#__PURE__*/React$R.createElement("p", null, "The interior angle and side measure options guide the points to the nearest whole angle or side"), " ", "measure respectively.", " ")), /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("label", null, "Show angle measures:", " ", /*#__PURE__*/React$R.createElement("input", {
          type: "checkbox",
          checked: this.props.graph.showAngles,
          onChange: this.toggleShowAngles
        })), /*#__PURE__*/React$R.createElement(InfoTip$8, null, /*#__PURE__*/React$R.createElement("p", null, "Displays the interior angle measures."))), /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("label", null, "Show side measures:", " ", /*#__PURE__*/React$R.createElement("input", {
          type: "checkbox",
          checked: this.props.graph.showSides,
          onChange: this.toggleShowSides
        })), /*#__PURE__*/React$R.createElement(InfoTip$8, null, /*#__PURE__*/React$R.createElement("p", null, "Displays the side lengths."))));
      } else if (this.props.graph.type === "segment") {
        extraOptions = /*#__PURE__*/React$R.createElement("select", {
          key: "segment-select",
          value: this.props.graph.numSegments || 1,
          onChange: e => {
            var num = +e.target.value;
            this.onChange({
              graph: {
                type: "segment",
                numSegments: num,
                coords: null
              }
            });
          }
        }, _$C.map(_$C.range(1, 7), function (n) {
          return /*#__PURE__*/React$R.createElement("option", {
            value: n
          }, n, " segment", n > 1 && "s");
        }));
      } else if (this.props.graph.type === "angle") {
        var allowReflexAngles = defaultVal(this.props.graph.allowReflexAngles, true);
        extraOptions = /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("label", null, "Show angle measure:", " ", /*#__PURE__*/React$R.createElement("input", {
          type: "checkbox",
          checked: this.props.graph.showAngles,
          onChange: this.toggleShowAngles
        }))), /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("label", null, "Allow reflex angles:", " ", /*#__PURE__*/React$R.createElement("input", {
          type: "checkbox",
          checked: allowReflexAngles,
          onChange: newVal => {
            this.onChange({
              graph: _$C.extend({}, this.props.graph, {
                allowReflexAngles: !allowReflexAngles,
                // eslint-disable-line max-len
                coords: null
              })
            });
          }
        })), /*#__PURE__*/React$R.createElement(InfoTip$8, null, /*#__PURE__*/React$R.createElement("p", null, "Reflex angles are angles with a measure greater than 180 degrees."), /*#__PURE__*/React$R.createElement("p", null, "By default, these should remain enabled."))), /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("label", null, "Snap to increments of", " ", /*#__PURE__*/React$R.createElement(NumberInput$3, {
          key: "degree-snap",
          placeholder: 1,
          value: this.props.graph.snapDegrees,
          onChange: newVal => {
            this.onChange({
              graph: _$C.extend({}, this.props.graph, {
                snapDegrees: Math.abs(newVal),
                coords: null
              })
            });
          }
        }), " ", "degrees", " ")), /*#__PURE__*/React$R.createElement("div", null, /*#__PURE__*/React$R.createElement("label", null, " ", "With an offset of", " ", /*#__PURE__*/React$R.createElement(NumberInput$3, {
          key: "angle-offset",
          placeholder: 0,
          value: this.props.graph.angleOffsetDeg,
          onChange: newVal => {
            this.onChange({
              graph: _$C.extend({}, this.props.graph, {
                angleOffsetDeg: newVal,
                coords: null
              })
            });
          }
        }), " ", "degrees", " ")));
      }
    }

    var box = getInteractiveBoxFromSizeClass(this.props.containerSizeClass);
    var instructions;

    if (this.isClickToAddPoints() && this.state.shouldShowInstructions) {
      if (this.props.graph.type === "point") {
        instructions = i18n._("Click to add points");
      } else if (this.props.graph.type === "polygon") {
        instructions = i18n._("Click to add vertices");
      }
    } else {
      instructions = undefined;
    }

    var onMouseDown = this.isClickToAddPoints() ? this.handleAddPointsMouseDown : null;
    var gridStep = this.props.gridStep || Util$7.getGridStep(this.props.range, this.props.step, box[0]);
    var snapStep = this.props.snapStep || Util$7.snapStepFromGridStep(gridStep);
    var isMobile = this.props.apiOptions.isMobile;
    return /*#__PURE__*/React$R.createElement("div", {
      className: "perseus-widget " + "perseus-widget-interactive-graph",
      style: {
        width: box[0],
        height: this.props.flexibleType ? "auto" : box[1]
      }
    }, /*#__PURE__*/React$R.createElement(Graph, {
      instructions: instructions,
      ref: "graph",
      box: box,
      labels: this.props.labels,
      range: this.props.range,
      step: isMobile ? Util$7.constrainedTickStepsFromTickSteps(this.props.step, this.props.range) : this.props.step,
      gridStep: gridStep,
      snapStep: snapStep,
      markings: this.props.markings,
      backgroundImage: this.props.backgroundImage,
      showProtractor: this.props.showProtractor,
      showRuler: this.props.showRuler,
      rulerLabel: this.props.rulerLabel,
      rulerTicks: this.props.rulerTicks,
      onMouseDown: onMouseDown,
      onGraphieUpdated: this.setGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
      isMobile: isMobile
    }), typeSelect, extraOptions);
  },
  componentDidMount: function componentDidMount() {
    this.setGraphie(this.refs.graph.graphie());
  },
  setGraphie: function setGraphie(newGraphie) {
    this.graphie = newGraphie;
    this.setupGraphie();
  },
  handleAddPointsMouseDown: function handleAddPointsMouseDown(coord) {
    // This function should only be called when this.isClickToAddPoints()
    // is true
    if (!this.isClickToAddPoints()) {
      throw new Error("handleAddPointsClick should not be registered" + "when isClickToAddPoints() is false");
    }

    if (!this.isCoordInTrash(coord)) {
      var point;

      if (this.props.graph.type === "point") {
        point = this.createPointForPointsType(coord, this.points.length);

        if (!point.constrain()) {
          point.remove();
          return;
        }

        this.points.push(point); // interactive2 allows us to grab the point

        var idx = this.points.length - 1;
        this.points[idx].grab(coord);
        this.updateCoordsFromPoints();
      } else if (this.props.graph.type === "polygon") {
        if (this.polygon.closed()) {
          return;
        }

        point = this.createPointForPolygonType(coord, this.points.length);
        this.points.push(point);
        var idx = this.points.length - 1;
        this.points[idx].grab(coord); // We don't call updateCoordsFromPoints for
        // polygons, since the polygon won't be
        // closed yet.

        this.updatePolygon();
      }

      this.setState({
        shouldShowInstructions: false
      });
    }
  },
  resetGraphie: function resetGraphie() {
    this.shouldResetGraphie = false;
    this.parabola = null;
    this.sinusoid = null;
    this.refs.graph.reset();
  },
  setupGraphie: function setupGraphie() {
    this.setTrashCanVisibility(0);

    if (this.isClickToAddPoints()) {
      this.setTrashCanVisibility(0.5);
    }

    if (this.props.apiOptions.isMobile) {
      this.horizHairline = new WrappedLine$1(this.graphie, [0, 0], [0, 0], {
        normalStyle: {
          strokeWidth: 1
        }
      });
      this.horizHairline.attr({
        stroke: KhanColors$3.INTERACTIVE
      });
      this.horizHairline.hide();
      this.vertHairline = new WrappedLine$1(this.graphie, [0, 0], [0, 0], {
        normalStyle: {
          strokeWidth: 1
        }
      });
      this.vertHairline.attr({
        stroke: KhanColors$3.INTERACTIVE
      });
      this.vertHairline.hide();
    }

    var type = this.props.graph.type;
    this["add" + capitalize(type) + "Controls"]();
  },
  showHairlines: function showHairlines(point) {
    if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
      // Hairlines are already initialized when the graph is loaded, so
      // here we just move them to the updated location and make them
      // visible.
      this.horizHairline.moveTo([this.props.range[0][0], point[1]], [this.props.range[0][1], point[1]]);
      this.horizHairline.show();
      this.vertHairline.moveTo([point[0], this.props.range[1][0]], [point[0], this.props.range[1][1]]);
      this.vertHairline.show();
    }
  },
  hideHairlines: function hideHairlines() {
    if (this.props.apiOptions.isMobile) {
      this.horizHairline.hide();
      this.vertHairline.hide();
    }
  },
  setTrashCanVisibility: function setTrashCanVisibility(opacity) {
    var graphie = this.graphie;

    if (knumber$1.equal(opacity, 0)) {
      if (this.trashCan) {
        this.trashCan.remove();
        this.trashCan = null;
      }
    } else if (!this.props.apiOptions.isMobile) {
      // Only if trash tooltips are not being used, we initialize the old
      // trash can area.
      if (!this.trashCan) {
        this.trashCan = graphie.raphael.image(TRASH_ICON_URI, graphie.xpixels - 40, graphie.ypixels - 40, 40, 40);
      }

      this.trashCan.attr({
        opacity: opacity
      });
    }
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (this.isClickToAddPoints() !== this.isClickToAddPoints(nextProps)) {
      this.shouldResetGraphie = true;
      this.setState({
        shouldShowInstructions: this._getShouldShowInstructions(nextProps)
      });
    }

    if (this.props.backgroundImage.url !== nextProps.backgroundImage.url || this.props.backgroundImage !== nextProps.backgroundImage || this.props.containerSizeClass !== nextProps.containerSizeClass) {
      // @Nolint
      this.shouldResetGraphie = true;
    }
  },
  isClickToAddPoints: function isClickToAddPoints(props) {
    props = props || this.props;
    return props.graph.type === "point" && props.graph.numPoints === UNLIMITED || props.graph.type === "polygon" && props.graph.numSides === UNLIMITED;
  },
  _lineStroke: function _lineStroke() {
    return this.props.isMobile ? {
      "stroke-width": 3
    } : {};
  },
  addLine: function addLine(type) {
    var self = this;
    var graphie = self.graphie;
    var coords = InteractiveGraph$1.getLineCoords(self.props.graph, self.props);

    var points = self.points = _$C.map(coords, coord => {
      return Interactive2$1.addMaybeMobileMovablePoint(this, {
        coord: coord,
        constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap()],
        onMove: () => {
          var graph = _$C.extend({}, self.props.graph, {
            coords: _$C.invoke(points, "coord")
          });

          self.onChange({
            graph: graph
          });
        }
      });
    });

    var lineConfig = {
      points: points,
      static: true,
      normalStyle: _objectSpread2({
        stroke: this.props.apiOptions.isMobile ? KhanColors$3.BLUE_C : KhanColors$3.INTERACTIVE
      }, this._lineStroke())
    };

    if (type === "line") {
      lineConfig.extendLine = true;
    } else if (type === "ray") {
      lineConfig.extendRay = true;
    }

    self.line = Interactive2$1.addMovableLine(graphie, lineConfig); // A and B can't be in the same place

    points[0].listen("constraints", "isLine", coord => {
      return !kpoint$2.equal(coord, points[1].coord());
    });
    points[1].listen("constraints", "isLine", coord => {
      return !kpoint$2.equal(coord, points[0].coord());
    });
  },
  removeLine: function removeLine() {
    _$C.invoke(this.points, "remove");

    this.line.remove();
  },
  addLinearControls: function addLinearControls() {
    this.addLine("line");
  },
  removeLinearControls: function removeLinearControls() {
    this.removeLine();
  },
  addQuadraticControls: function addQuadraticControls() {
    this.graphie;
    var coords = this.props.graph.coords;

    if (!coords) {
      coords = InteractiveGraph$1.defaultQuadraticCoords(this.props);
    }

    var pointA;
    var pointB;
    var pointC;

    var onMoveHandler = () => {
      var graph = _$C.extend({}, this.props.graph, {
        coords: [pointA.coord(), pointB.coord(), pointC.coord()]
      });

      this.onChange({
        graph: graph
      });
      this.updateQuadratic();
    };

    pointA = this.pointA = Interactive2$1.addMaybeMobileMovablePoint(this, {
      coord: coords[0],
      constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), coord => {
        return !pointA || coord[0] !== pointB.coord()[0] && coord[0] !== pointC.coord()[0];
      }],
      onMove: onMoveHandler
    });
    pointB = this.pointB = Interactive2$1.addMaybeMobileMovablePoint(this, {
      coord: coords[1],
      constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), coord => {
        return !pointB || coord[0] !== pointA.coord()[0] && coord[0] !== pointC.coord()[0];
      }],
      onMove: onMoveHandler
    });
    pointC = this.pointC = Interactive2$1.addMaybeMobileMovablePoint(this, {
      coord: coords[2],
      constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), coord => {
        return !pointC || coord[0] !== pointA.coord()[0] && coord[0] !== pointB.coord()[0];
      }],
      onMove: onMoveHandler
    });
    this.updateQuadratic();
  },
  updateQuadratic: function updateQuadratic() {
    var coeffs = InteractiveGraph$1.getCurrentQuadraticCoefficients(this.props);

    if (!coeffs) {
      return;
    } // Extract coefficients the parabola


    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2]; // Plot and style

    if (this.parabola) {
      var path = this.graphie.svgParabolaPath(a, b, c);
      this.parabola.attr({
        path: path
      });
    } else {
      this.parabola = this.graphie.parabola(a, b, c);
      this.parabola.attr(_objectSpread2({
        stroke: this.props.apiOptions.isMobile ? KhanColors$3.BLUE_C : KhanColors$3.DYNAMIC
      }, this._lineStroke()));
      this.parabola.toBack();
    }
  },
  removeQuadraticControls: function removeQuadraticControls() {
    this.pointA.remove();
    this.pointB.remove();
    this.pointC.remove();

    if (this.parabola) {
      this.parabola.remove();
      this.parabola = null;
    }
  },
  addSinusoidControls: function addSinusoidControls() {
    this.graphie;
    var coords = this.props.graph.coords;

    if (!coords) {
      coords = InteractiveGraph$1.defaultSinusoidCoords(this.props);
    }

    var pointA;
    var pointB;

    var onMoveHandler = () => {
      var graph = _$C.extend({}, this.props.graph, {
        coords: [pointA.coord(), pointB.coord()]
      });

      this.onChange({
        graph: graph
      });
      this.updateSinusoid();
    };

    pointA = this.pointA = Interactive2$1.addMaybeMobileMovablePoint(this, {
      coord: coords[0],
      constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), coord => {
        return !pointA || coord[0] !== pointB.coord()[0];
      }],
      onMove: onMoveHandler
    });
    pointB = this.pointB = Interactive2$1.addMaybeMobileMovablePoint(this, {
      coord: coords[1],
      constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), coord => {
        return !pointA || coord[0] !== pointA.coord()[0];
      }],
      onMove: onMoveHandler
    });
    this.updateSinusoid();
  },
  updateSinusoid: function updateSinusoid() {
    var coeffs = InteractiveGraph$1.getCurrentSinusoidCoefficients(this.props);

    if (!coeffs) {
      return;
    }

    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2],
        d = coeffs[3]; // Plot and style

    if (this.sinusoid) {
      var path = this.graphie.svgSinusoidPath(a, b, c, d);
      this.sinusoid.attr({
        path: path
      });
    } else {
      this.sinusoid = this.graphie.sinusoid(a, b, c, d);
      this.sinusoid.attr(_objectSpread2({
        stroke: this.props.apiOptions.isMobile ? KhanColors$3.BLUE_C : KhanColors$3.DYNAMIC
      }, this._lineStroke()));
      this.sinusoid.toBack();
    }
  },
  removeSinusoidControls: function removeSinusoidControls() {
    this.pointA.remove();
    this.pointB.remove();

    if (this.sinusoid) {
      this.sinusoid.remove();
      this.sinusoid = null;
    }
  },
  addCircleControls: function addCircleControls() {
    var graphie = this.graphie;

    var minSnap = _$C.min(graphie.snap);

    var circle = this.circle = graphie.addCircleGraph({
      center: this.props.graph.center || [0, 0],
      radius: this.props.graph.radius || _$C.min(this.props.step),
      snapX: graphie.snap[0],
      snapY: graphie.snap[1],
      minRadius: minSnap,
      snapRadius: minSnap
    });
    $(circle).on("move", () => {
      var graph = _$C.extend({}, this.props.graph, {
        center: circle.center,
        radius: circle.radius
      });

      this.onChange({
        graph: graph
      });
    });
  },
  removeCircleControls: function removeCircleControls() {
    this.circle.remove();
  },
  addLinearSystemControls: function addLinearSystemControls() {
    var graphie = this.graphie;
    var coords = InteractiveGraph$1.getLinearSystemCoords(this.props.graph, this.props);
    var segmentColors = [KhanColors$3.INTERACTIVE, KhanColors$3.GREEN];

    var points = this.points = _$C.map(coords, (segmentCoords, segmentIndex) => {
      var segmentPoints = _$C.map(segmentCoords, (coord, i) => {
        return Interactive2$1.addMaybeMobileMovablePoint(this, {
          coord: coord,
          constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), coord => {
            if (!segmentPoints) {
              // points hasn't been defined yet because
              // we're still creating them
              return;
            }

            return !kpoint$2.equal(coord, segmentPoints[1 - i].coord());
          }],
          onMove: () => {
            var graph = _$C.extend({}, this.props.graph, {
              coords: _$C.map(this.points, segment => _$C.invoke(segment, "coord"))
            });

            this.onChange({
              graph: graph
            });
          },
          normalStyle: {
            fill: segmentColors[segmentIndex]
          },
          highlightStyle: {
            fill: segmentColors[segmentIndex]
          }
        });
      });

      return segmentPoints;
    });

    this.lines = _$C.map(points, (segmentPoints, segmentIndex) => {
      return Interactive2$1.addMovableLine(graphie, {
        points: segmentPoints,
        static: true,
        extendLine: true,
        normalStyle: {
          stroke: segmentColors[segmentIndex]
        }
      });
    });
  },
  removeLinearSystemControls: function removeLinearSystemControls() {
    _$C.invoke(this.lines, "remove");

    _$C.map(this.points, segment => _$C.invoke(segment, "remove"));
  },
  isCoordInTrash: function isCoordInTrash(coord) {
    if (this.props.apiOptions.isMobile) {
      return false;
    }

    var graphie = this.graphie;
    var screenPoint = graphie.scalePoint(coord);
    return screenPoint[0] >= graphie.xpixels - 40 && screenPoint[1] >= graphie.ypixels - 40;
  },
  createPointForPointsType: function createPointForPointsType(coord, i) {
    var self = this;
    self.graphie;

    var remove = () => {
      self.points = _$C.filter(self.points, function (pt) {
        return pt !== point;
      }); // update the correct answer box

      self.updateCoordsFromPoints(); // remove this movablePoint from graphie.
      // we wait to do this until we're not inside of
      // said point's onMoveEnd method so its state is
      // consistent throughout this method call

      setTimeout(point.remove.bind(point), 0);
    };

    var point = Interactive2$1.addMaybeMobileMovablePoint(this, _objectSpread2({
      coord: coord,
      constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), function (coord) {
        // TODO(jack): There ought to be a
        // MovablePoint.constraints.avoid
        // default that lets you do things like this
        return _$C.all(self.points, function (pt) {
          return point === pt || !kpoint$2.equal(coord, pt.coord());
        });
      }],
      onMoveStart: function onMoveStart() {
        if (self.isClickToAddPoints()) {
          self.setTrashCanVisibility(1);
        }
      },
      onMove: self.updateCoordsFromPoints,
      onMoveEnd: function onMoveEnd(coord) {
        if (self.isClickToAddPoints()) {
          if (self.isCoordInTrash(coord)) {
            remove();
          } // In case we mouseup'd off the graphie and that
          // stopped the move (in which case, we might not
          // be in isCoordInTrash()


          self.setTrashCanVisibility(0.5);
        }
      }
    }, this.props.apiOptions.isMobile && self.isClickToAddPoints() ? {
      onRemove: remove
    } : {}));
    return point;
  },
  removePoint: function removePoint(point) {
    var index = null;
    this.points = _$C.filter(this.points, function (pt, i) {
      if (pt === point) {
        index = i;
        return false;
      } else {
        return true;
      }
    });
    return index;
  },
  createPointForPolygonType: function createPointForPolygonType(coord, i) {
    this.graphie; // TODO(alex): check against "grid" instead, use constants

    var snapToGrid = !_$C.contains(["angles", "sides"], this.props.graph.snapTo); // Index relative to current point -> absolute index
    // NOTE: This does not work when isClickToAddPoints() == true,
    // as `i` can be changed by dragging a point to the trash
    // Currently this function is only called when !isClickToAddPoints()

    var rel = j => {
      return (i + j + this.points.length) % this.points.length;
    };

    var remove = () => {
      // remove this point from points
      var index = this.removePoint(point);

      if (this.polygon.closed()) {
        this.points = rotate(this.points, index);
        this.polygon.update({
          closed: false
        });
      }

      this.updatePolygon(); // the polygon is now unclosed, so we need to
      // remove any points props

      this.clearCoords(); // remove this movablePoint from graphie.
      // wait to do this until we're not inside of
      // said point's onMoveEnd method so state is
      // consistent throughout the method call

      setTimeout(point.remove.bind(point), 0);
    };

    var onMoveEndHandler = coord => {
      if (this.isClickToAddPoints()) {
        if (this.isCoordInTrash(coord)) {
          remove();
        } else if (this.points.length > 1 && (point === this.points[0] && kpoint$2.equal(coord, _$C.last(this.points).coord()) || point === _$C.last(this.points) && kpoint$2.equal(coord, this.points[0].coord()))) {
          // If the user clicked and dragged a point over endpoint,
          // join the them
          var pointToRemove = this.points.pop();

          if (this.points.length > 2) {
            this.polygon.update({
              closed: true
            });
            this.updateCoordsFromPoints();
          } else {
            this.polygon.update({
              closed: false
            });
            this.clearCoords();
          }

          this.updatePolygon(); // remove this movablePoint from graphie.
          // wait to do this until we're not inside of
          // said point's onMoveEnd method so state is
          // consistent throughout the method call

          setTimeout(pointToRemove.remove.bind(pointToRemove), 0);
        } else {
          // If the user clicked and dragged a point over any other
          // existing point, fix shape
          var shouldRemove = _$C.any(this.points, function (pt) {
            return pt !== point && kpoint$2.equal(pt.coord(), coord);
          });

          if (shouldRemove) {
            this.removePoint(point);

            if (this.points.length < 3) {
              this.polygon.update({
                closed: false
              });
              this.clearCoords();
            } else if (this.polygon.closed()) {
              this.updateCoordsFromPoints();
            }

            this.updatePolygon(); // remove this movablePoint from graphie.
            // wait to do this until we're not inside
            // said point's onMoveEnd method so state
            // is consistent throughout the method call

            setTimeout(point.remove.bind(point), 0);
          } else {
            // If this was
            //  * not a deletion
            //  * and a click on the first or last point
            //  * and not a drag,
            //  * and not a creation of a new point
            //    (see !point.state.isInitialMove, below),
            //  * and our polygon is not closed,
            //  * and we can close it (we need at least 3 points),
            // then close it
            if ((point === this.points[0] || point === _$C.last(this.points)) && !point.hasMoved() && !point.state.isInitialMove && !this.polygon.closed() && this.points.length > 2) {
              this.polygon.update({
                closed: true
              });
              this.updatePolygon(); // We finally have a closed polygon, so save our
              // points to props

              this.updateCoordsFromPoints();
            }
          }
        } // In case we mouseup'd off the graphie and that
        // stopped the move


        this.setTrashCanVisibility(0.5);
      }

      point.state.isInitialMove = false;
    };

    var graphConstraint = coord => {
      // These constraints are all relative to the other points, so if
      // we're creating the initial points and haven't added any others
      // to the graph, we can't enforce them.
      if (this.points == null || this.points.length === 0) {
        return true;
      }

      var coords = _$C.invoke(this.points, "coord");

      coords[i] = coord; // Check for invalid positioning, but only if we aren't adding
      // points one click at a time, since those added points could
      // have already violated these constraints

      if (!this.isClickToAddPoints()) {
        // Polygons can't have consecutive collinear points
        if (collinear(coords[rel(-2)], coords[rel(-1)], coords[i]) || collinear(coords[rel(-1)], coords[i], coords[rel(1)]) || collinear(coords[i], coords[rel(1)], coords[rel(2)])) {
          return false;
        }

        var segments = _$C.zip(coords, rotate(coords));

        if (this.points.length > 3) {
          // Constrain to simple (non self-intersecting) polygon by
          // testing whether adjacent segments intersect any others
          for (var j = -1; j <= 0; j++) {
            var segment = segments[rel(j)];

            var others = _$C.without(segments, segment, segments[rel(j - 1)], segments[rel(j + 1)]);

            for (var k = 0; k < others.length; k++) {
              var other = others[k];

              if (intersects(segment, other)) {
                return false;
              }
            }
          }
        }
      }

      if (this.props.graph.snapTo === "angles" && this.points.length > 2) {
        // Snap to whole degree interior angles
        var angles = _$C.map(angleMeasures(coords), function (rad) {
          return rad * 180 / Math.PI;
        });

        _$C.each([-1, 1], function (j) {
          angles[rel(j)] = Math.round(angles[rel(j)]);
        });

        var getAngle = function getAngle(a, vertex, b) {
          var angle = GraphUtils.findAngle(coords[rel(a)], coords[rel(b)], coords[rel(vertex)]);
          return (angle + 360) % 360;
        };

        var innerAngles = [angles[rel(-1)] - getAngle(-2, -1, 1), angles[rel(1)] - getAngle(-1, 1, 2)];
        innerAngles[2] = 180 - (innerAngles[0] + innerAngles[1]); // Avoid degenerate triangles

        if (_$C.any(innerAngles, function (angle) {
          return leq(angle, 1);
        })) {
          return false;
        }

        var knownSide = magnitude(vector(coords[rel(-1)], coords[rel(1)]));
        var onLeft = sign(ccw(coords[rel(-1)], coords[rel(1)], coords[i])) === 1; // Solve for side by using the law of sines

        var side = Math.sin(innerAngles[1] * Math.PI / 180) / Math.sin(innerAngles[2] * Math.PI / 180) * knownSide;
        var outerAngle = GraphUtils.findAngle(coords[rel(1)], coords[rel(-1)]);
        var offset = this.graphie.polar(side, outerAngle + (onLeft ? 1 : -1) * innerAngles[0]);
        return this.graphie.addPoints(coords[rel(-1)], offset);
      } else if (this.props.graph.snapTo === "sides" && this.points.length > 1) {
        // Snap to whole unit side measures
        var sides = _$C.map([[coords[rel(-1)], coords[i]], [coords[i], coords[rel(1)]], [coords[rel(-1)], coords[rel(1)]]], function (coords) {
          return magnitude(vector.apply(null, coords));
        });

        _$C.each([0, 1], function (j) {
          sides[j] = Math.round(sides[j]);
        }); // Avoid degenerate triangles


        if (leq(sides[1] + sides[2], sides[0]) || leq(sides[0] + sides[2], sides[1]) || leq(sides[0] + sides[1], sides[2])) {
          return false;
        } // Solve for angle by using the law of cosines


        var innerAngle = lawOfCosines(sides[0], sides[2], sides[1]);
        var outerAngle = GraphUtils.findAngle(coords[rel(1)], coords[rel(-1)]);
        var onLeft = sign(ccw(coords[rel(-1)], coords[rel(1)], coords[i])) === 1;
        var offset = this.graphie.polar(sides[0], outerAngle + (onLeft ? 1 : -1) * innerAngle);
        return this.graphie.addPoints(coords[rel(-1)], offset);
      } else {
        // Snap to grid (already done)
        return true;
      }
    };

    var point = Interactive2$1.addMaybeMobileMovablePoint(this, _objectSpread2({
      coord: coord,
      constraints: [Interactive2$1.MovablePoint.constraints.bound(), snapToGrid ? Interactive2$1.MovablePoint.constraints.snap() : null, graphConstraint],
      onMoveStart: () => {
        if (this.isClickToAddPoints()) {
          this.setTrashCanVisibility(1);
        }
      },
      onMove: () => {
        if (this.polygon.closed()) {
          this.updateCoordsFromPoints();
        }
      },
      onMoveEnd: onMoveEndHandler
    }, this.props.apiOptions.isMobile && this.isClickToAddPoints() ? {
      onRemove: remove
    } : {}));
    point.state.isInitialMove = true;
    return point;
  },
  updateCoordsFromPoints: function updateCoordsFromPoints() {
    var graph = _$C.extend({}, this.props.graph, {
      // Handle old movable points with .coord, or
      // Interactive2.MovablePoint's with .coord()
      coords: _$C.map(this.points, function (point) {
        return _$C.result(point, "coord");
      })
    });

    this.onChange({
      graph: graph
    });
  },
  clearCoords: function clearCoords() {
    var graph = _$C.extend({}, this.props.graph, {
      coords: null
    });

    this.onChange({
      graph: graph
    });
  },
  onChange: function onChange(data) {
    this.props.onChange(data);
    this.props.trackInteraction();
  },
  addPointControls: function addPointControls() {
    var coords = InteractiveGraph$1.getPointCoords(this.props.graph, this.props); // Clear out our old points so that newly added points don't
    // "collide" with them and reposition when being added
    // Without this, when added, each point checks whether it is on top
    // of a point in this.points, which (a) shouldn't matter since
    // we're clearing out this.points anyways, and (b) can cause problems
    // if each of this.points is a MovablePoint instead of an
    // Interactive2.MovablePoint, since one has a .coord and the other
    // has .coord()
    // TODO(jack): Figure out a better way to do this

    this.points = [];
    this.points = _$C.map(coords, this.createPointForPointsType, this);
  },
  removePointControls: function removePointControls() {
    _$C.invoke(this.points, "remove");
  },
  addSegmentControls: function addSegmentControls() {
    var self = this;
    var graphie = this.graphie;
    var coords = InteractiveGraph$1.getSegmentCoords(this.props.graph, this.props);

    var createPoint = options => Interactive2$1.addMaybeMobileMovablePoint(this, options);

    this.points = [];
    this.lines = _$C.map(coords, function (segment, i) {
      var updateCoordProps = function updateCoordProps() {
        var graph = _$C.extend({}, self.props.graph, {
          coords: _$C.invoke(self.lines, "coords")
        });

        self.onChange({
          graph: graph
        });
      };

      var points = _$C.map(segment, function (coord, i) {
        return createPoint({
          coord: coord,
          constraints: [Interactive2$1.MovablePoint.constraints.bound(), Interactive2$1.MovablePoint.constraints.snap(), coord => {
            if (!points) {
              // points hasn't been defined yet because
              // we're still creating them
              return;
            }

            return !kpoint$2.equal(coord, points[1 - i].coord());
          }],
          onMove: updateCoordProps
        });
      });

      self.points = self.points.concat(points);
      var line = Interactive2$1.addMovableLine(graphie, {
        points: points,
        static: false,
        constraints: [Interactive2$1.MovableLine.constraints.bound(), Interactive2$1.MovableLine.constraints.snap()],
        onMove: [Interactive2$1.MovableLine.onMove.updatePoints, updateCoordProps],
        normalStyle: _objectSpread2({
          stroke: this.props.apiOptions.isMobile ? KhanColors$3.BLUE_C : KhanColors$3.INTERACTIVE
        }, this._lineStroke()),
        highlightStyle: _objectSpread2({
          stroke: this.props.apiOptions.isMobile ? KhanColors$3.BLUE_C : KhanColors$3.INTERACTING
        }, this._lineStroke())
      });

      _$C.invoke(points, "toFront");

      return line;
    }, this);
  },
  removeSegmentControls: function removeSegmentControls() {
    _$C.invoke(this.points, "remove");

    _$C.invoke(this.lines, "remove");
  },
  addRayControls: function addRayControls() {
    this.addLine("ray");
  },
  removeRayControls: function removeRayControls() {
    this.removeLine();
  },
  addPolygonControls: function addPolygonControls() {
    this.polygon = null;
    var coords = InteractiveGraph$1.getPolygonCoords(this.props.graph, this.props); // Clear out our old points so that newly added points don't
    // "collide", as in `addPointControls`

    this.points = [];
    this.points = _$C.map(coords, this.createPointForPolygonType, this);
    this.updatePolygon();
  },
  updatePolygon: function updatePolygon() {
    var closed;

    if (this.polygon) {
      closed = this.polygon.closed();
    } else if (this.points.length >= 3) {
      closed = true;
    } else {
      // There will only be fewer than 3 points in click-to-add-vertices
      // mode, so we don't need to explicitly check for that here.
      closed = false;
    }

    var graphie = this.graphie;
    var n = this.points.length; // TODO(alex): check against "grid" instead, use constants

    var snapToGrid = !_$C.contains(["angles", "sides"], this.props.graph.snapTo);

    var angleLabels = _$C.times(n, function (i) {
      if (!this.props.graph.showAngles || !closed && (i === 0 || i === n - 1)) {
        return "";
      } else if (this.props.graph.snapTo === "angles") {
        return "$deg0";
      } else {
        return "$deg1";
      }
    }, this);

    var showRightAngleMarkers = _$C.times(n, function (i) {
      return closed || i !== 0 && i !== n - 1;
    }, this);

    var numArcs = _$C.times(n, function (i) {
      if (this.props.graph.showAngles && (closed || i !== 0 && i !== n - 1)) {
        return 1;
      } else {
        return 0;
      }
    }, this);

    var sideLabels = _$C.times(n, function (i) {
      if (!this.props.graph.showSides || !closed && i === n - 1) {
        return "";
      } else if (this.props.graph.snapTo === "sides") {
        return "$len0";
      } else {
        return "$len1";
      }
    }, this);

    if (this.polygon == null) {
      var self = this;
      self.polygon = Interactive2$1.addMovablePolygon(graphie, {
        constraints: [Interactive2$1.MovablePolygon.constraints.bound(), snapToGrid ? Interactive2$1.MovablePolygon.constraints.snap() : null],
        closed: closed,
        points: self.points,
        angleLabels: angleLabels,
        showRightAngleMarkers: showRightAngleMarkers,
        numArcs: numArcs,
        sideLabels: sideLabels,
        onMove: [Interactive2$1.MovablePolygon.onMove.updatePoints, function () {
          if (this.closed()) {
            self.updateCoordsFromPoints();
          }
        }],
        normalStyle: _objectSpread2({
          stroke: this.props.apiOptions.isMobile ? KhanColors$3.BLUE_C : KhanColors$3.INTERACTIVE
        }, this._lineStroke())
      });
    } else {
      // We only need to pass in the properties that might've changed
      this.polygon.update({
        closed: closed,
        points: this.points,
        angleLabels: angleLabels,
        showRightAngleMarkers: showRightAngleMarkers,
        numArcs: numArcs,
        sideLabels: sideLabels
      });
    }
  },
  removePolygonControls: function removePolygonControls() {
    _$C.invoke(this.points, "remove");

    this.polygon.remove();
  },
  addAngleControls: function addAngleControls() {
    var graphie = this.graphie;
    var coords = InteractiveGraph$1.getAngleCoords(this.props.graph, this.props); // The vertex snaps to the grid, but the rays don't...

    this.points = _$C.map(coords, function (coord, i) {
      return graphie.addMovablePoint(_$C.extend({
        coord: coord,
        normalStyle: {
          stroke: KhanColors$3.INTERACTIVE,
          fill: KhanColors$3.INTERACTIVE
        }
      }, i === 1 ? {
        snapX: graphie.snap[0],
        snapY: graphie.snap[1]
      } : {}));
    }); // ...they snap to whole-degree angles from the vertex.

    this.angle = graphie.addMovableAngle({
      points: this.points,
      snapDegrees: this.props.graph.snapDegrees || 1,
      snapOffsetDeg: this.props.graph.angleOffsetDeg || 0,
      angleLabel: this.props.graph.showAngles ? "$deg0" : "",
      pushOut: 2,
      allowReflex: defaultVal(this.props.graph.allowReflexAngles, true)
    });
    $(this.angle).on("move", () => {
      var graph = _$C.extend({}, this.props.graph, {
        coords: this.angle.getClockwiseCoords()
      });

      this.onChange({
        graph: graph
      });
    });
  },
  removeAngleControls: function removeAngleControls() {
    _$C.invoke(this.points, "remove");

    this.angle.remove();
  },
  toggleShowAngles: function toggleShowAngles() {
    var graph = _$C.extend({}, this.props.graph, {
      showAngles: !this.props.graph.showAngles
    });

    this.onChange({
      graph: graph
    });
  },
  toggleShowSides: function toggleShowSides() {
    var graph = _$C.extend({}, this.props.graph, {
      showSides: !this.props.graph.showSides
    });

    this.onChange({
      graph: graph
    });
  },
  getUserInput: function getUserInput() {
    return this.props.graph;
  },
  simpleValidate: function simpleValidate(rubric) {
    return InteractiveGraph$1.validate(this.getUserInput(), rubric, this);
  },
  focus: $.noop
});

_$C.extend(InteractiveGraph$1, {
  getQuadraticCoefficients: function getQuadraticCoefficients(coords) {
    var p1 = coords[0];
    var p2 = coords[1];
    var p3 = coords[2];
    var denom = (p1[0] - p2[0]) * (p1[0] - p3[0]) * (p2[0] - p3[0]);

    if (denom === 0) {
      return;
    }

    var a = (p3[0] * (p2[1] - p1[1]) + p2[0] * (p1[1] - p3[1]) + p1[0] * (p3[1] - p2[1])) / denom;
    var b = (p3[0] * p3[0] * (p1[1] - p2[1]) + p2[0] * p2[0] * (p3[1] - p1[1]) + p1[0] * p1[0] * (p2[1] - p3[1])) / denom;
    var c = (p2[0] * p3[0] * (p2[0] - p3[0]) * p1[1] + p3[0] * p1[0] * (p3[0] - p1[0]) * p2[1] + p1[0] * p2[0] * (p1[0] - p2[0]) * p3[1]) / denom;
    return [a, b, c];
  },
  getSinusoidCoefficients: function getSinusoidCoefficients(coords) {
    // It's assumed that p1 is the root and p2 is the first peak
    var p1 = coords[0];
    var p2 = coords[1]; // Resulting coefficients are canonical for this sine curve

    var amplitude = p2[1] - p1[1];
    var angularFrequency = Math.PI / (2 * (p2[0] - p1[0]));
    var phase = p1[0] * angularFrequency;
    var verticalOffset = p1[1];
    return [amplitude, angularFrequency, phase, verticalOffset];
  },

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  getLineCoords: function getLineCoords(graph, props) {
    return graph.coords || InteractiveGraph$1.pointsFromNormalized(props, [[0.25, 0.75], [0.75, 0.75]]);
  },

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  getPointCoords: function getPointCoords(graph, props) {
    var numPoints = graph.numPoints || 1;
    var coords = graph.coords;

    if (coords) {
      return coords;
    } else {
      switch (numPoints) {
        case 1:
          // Back in the day, one point's coords were in graph.coord
          coords = [graph.coord || [0, 0]];
          break;

        case 2:
          coords = [[-5, 0], [5, 0]];
          break;

        case 3:
          coords = [[-5, 0], [0, 0], [5, 0]];
          break;

        case 4:
          coords = [[-6, 0], [-2, 0], [2, 0], [6, 0]];
          break;

        case 5:
          coords = [[-6, 0], [-3, 0], [0, 0], [3, 0], [6, 0]];
          break;

        case 6:
          coords = [[-5, 0], [-3, 0], [-1, 0], [1, 0], [3, 0], [5, 0]];
          break;

        case UNLIMITED:
          coords = [];
          break;
      } // Transform coords from their -10 to 10 space to 0 to 1
      // because of the old graph.coord, and also it's easier.


      var range = [[-10, 10], [-10, 10]];
      coords = InteractiveGraph$1.normalizeCoords(coords, range);
      var coords = InteractiveGraph$1.pointsFromNormalized(props, coords);
      return coords;
    }
  },

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  getLinearSystemCoords: function getLinearSystemCoords(graph, props) {
    return graph.coords || _$C.map([[[0.25, 0.75], [0.75, 0.75]], [[0.25, 0.25], [0.75, 0.25]]], coords => {
      return InteractiveGraph$1.pointsFromNormalized(props, coords);
    });
  },

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  getPolygonCoords: function getPolygonCoords(graph, props) {
    var coords = graph.coords;

    if (coords) {
      return coords;
    }

    var n = graph.numSides || 3;

    if (n === UNLIMITED) {
      coords = [];
    } else {
      var angle = 2 * Math.PI / n;
      var offset = (1 / n - 1 / 2) * Math.PI; // TODO(alex): Generalize this to more than just triangles so that
      // all polygons have whole number side lengths if snapping to sides

      var radius = graph.snapTo === "sides" ? Math.sqrt(3) / 3 * 7 : 4; // Generate coords of a regular polygon with n sides

      coords = _$C.times(n, function (i) {
        return [radius * Math.cos(i * angle + offset), radius * Math.sin(i * angle + offset)];
      });
    }

    var range = [[-10, 10], [-10, 10]];
    coords = InteractiveGraph$1.normalizeCoords(coords, range);
    var snapToGrid = !_$C.contains(["angles", "sides"], graph.snapTo);
    coords = InteractiveGraph$1.pointsFromNormalized(props, coords,
    /* noSnap */
    !snapToGrid);
    return coords;
  },

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  getSegmentCoords: function getSegmentCoords(graph, props) {
    var coords = graph.coords;

    if (coords) {
      return coords;
    }

    var n = graph.numSegments || 1;
    var ys = {
      1: [5],
      2: [5, -5],
      3: [5, 0, -5],
      4: [6, 2, -2, -6],
      5: [6, 3, 0, -3, -6],
      6: [5, 3, 1, -1, -3, -5]
    }[n];
    var range = [[-10, 10], [-10, 10]];
    return _$C.map(ys, function (y) {
      var segment = [[-5, y], [5, y]];
      segment = InteractiveGraph$1.normalizeCoords(segment, range);
      segment = InteractiveGraph$1.pointsFromNormalized(props, segment);
      return segment;
    });
  },

  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */
  getAngleCoords: function getAngleCoords(graph, props) {
    var coords = graph.coords;

    if (coords) {
      return coords;
    }

    var snap = graph.snapDegrees || 1;
    var angle = snap;

    while (angle < 20) {
      angle += snap;
    }

    angle = angle * Math.PI / 180;
    var offset = (graph.angleOffsetDeg || 0) * Math.PI / 180;
    coords = InteractiveGraph$1.pointsFromNormalized(props, [[0.85, 0.5], [0.5, 0.5]]);
    var radius = magnitude(vector.apply(null, coords)); // Adjust the lower point by angleOffsetDeg degrees

    coords[0] = [coords[1][0] + radius * Math.cos(offset), coords[1][1] + radius * Math.sin(offset)]; // Position the upper point angle radians from the
    // lower point

    coords[2] = [coords[1][0] + radius * Math.cos(angle + offset), coords[1][1] + radius * Math.sin(angle + offset)];
    return coords;
  },
  normalizeCoords: function normalizeCoords(coordsList, range) {
    return _$C.map(coordsList, function (coords) {
      return _$C.map(coords, function (coord, i) {
        var extent = range[i][1] - range[i][0];
        return (coord + range[i][1]) / extent;
      });
    });
  },
  getEquationString: function getEquationString(props) {
    var type = props.graph.type;
    var funcName = "get" + capitalize(type) + "EquationString";
    return InteractiveGraph$1[funcName](props);
  },
  pointsFromNormalized: function pointsFromNormalized(props, coordsList, noSnap) {
    return _$C.map(coordsList, function (coords) {
      return _$C.map(coords, function (coord, i) {
        var range = props.range[i];

        if (noSnap) {
          return range[0] + (range[1] - range[0]) * coord;
        } else {
          var step = props.step[i];
          var nSteps = numSteps(range, step);
          var tick = Math.round(coord * nSteps);
          return range[0] + step * tick;
        }
      });
    });
  },
  getLinearEquationString: function getLinearEquationString(props) {
    var coords = InteractiveGraph$1.getLineCoords(props.graph, props);

    if (eq(coords[0][0], coords[1][0])) {
      return "x = " + coords[0][0].toFixed(3);
    } else {
      var m = (coords[1][1] - coords[0][1]) / (coords[1][0] - coords[0][0]);
      var b = coords[0][1] - m * coords[0][0];

      if (eq(m, 0)) {
        return "y = " + b.toFixed(3);
      } else {
        return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
      }
    }
  },
  getCurrentQuadraticCoefficients: function getCurrentQuadraticCoefficients(props) {
    // TODO(alpert): Don't duplicate
    var coords = props.graph.coords || InteractiveGraph$1.defaultQuadraticCoords(props);
    return InteractiveGraph$1.getQuadraticCoefficients(coords);
  },
  defaultQuadraticCoords: function defaultQuadraticCoords(props) {
    var coords = [[0.25, 0.75], [0.5, 0.25], [0.75, 0.75]];
    return InteractiveGraph$1.pointsFromNormalized(props, coords);
  },
  getQuadraticEquationString: function getQuadraticEquationString(props) {
    var coeffs = InteractiveGraph$1.getCurrentQuadraticCoefficients(props);
    return "y = " + coeffs[0].toFixed(3) + "x^2 + " + coeffs[1].toFixed(3) + "x + " + coeffs[2].toFixed(3);
  },
  getCurrentSinusoidCoefficients: function getCurrentSinusoidCoefficients(props) {
    var coords = props.graph.coords || InteractiveGraph$1.defaultSinusoidCoords(props);
    return InteractiveGraph$1.getSinusoidCoefficients(coords);
  },
  defaultSinusoidCoords: function defaultSinusoidCoords(props) {
    var coords = [[0.5, 0.5], [0.65, 0.6]];
    return InteractiveGraph$1.pointsFromNormalized(props, coords);
  },
  getSinusoidEquationString: function getSinusoidEquationString(props) {
    var coeffs = InteractiveGraph$1.getCurrentSinusoidCoefficients(props);
    return "y = " + coeffs[0].toFixed(3) + "sin(" + coeffs[1].toFixed(3) + "x - " + coeffs[2].toFixed(3) + ") + " + coeffs[3].toFixed(3);
  },
  getCircleEquationString: function getCircleEquationString(props) {
    var graph = props.graph; // TODO(alpert): Don't duplicate

    var center = graph.center || [0, 0];
    var radius = graph.radius || 2;
    return "center (" + center[0] + ", " + center[1] + "), radius " + radius;
  },
  getLinearSystemEquationString: function getLinearSystemEquationString(props) {
    var coords = InteractiveGraph$1.getLinearSystemCoords(props.graph, props);
    return "\n" + getLineEquation(coords[0][0], coords[0][1]) + "\n" + getLineEquation(coords[1][0], coords[1][1]) + "\n" + getLineIntersection(coords[0], coords[1]);
  },
  getPointEquationString: function getPointEquationString(props) {
    var coords = InteractiveGraph$1.getPointCoords(props.graph, props);
    return coords.map(function (coord) {
      return "(" + coord[0] + ", " + coord[1] + ")";
    }).join(", ");
  },
  getSegmentEquationString: function getSegmentEquationString(props) {
    var segments = InteractiveGraph$1.getSegmentCoords(props.graph, props);
    return _$C.map(segments, function (segment) {
      return "[" + _$C.map(segment, function (coord) {
        return "(" + coord.join(", ") + ")";
      }).join(" ") + "]";
    }).join(" ");
  },
  getRayEquationString: function getRayEquationString(props) {
    var coords = InteractiveGraph$1.getLineCoords(props.graph, props);
    var a = coords[0];
    var b = coords[1];
    var eq = InteractiveGraph$1.getLinearEquationString(props);

    if (a[0] > b[0]) {
      eq += " (for x <= " + a[0].toFixed(3) + ")";
    } else if (a[0] < b[0]) {
      eq += " (for x >= " + a[0].toFixed(3) + ")";
    } else if (a[1] > b[1]) {
      eq += " (for y <= " + a[1].toFixed(3) + ")";
    } else {
      eq += " (for y >= " + a[1].toFixed(3) + ")";
    }

    return eq;
  },
  getPolygonEquationString: function getPolygonEquationString(props) {
    var coords = InteractiveGraph$1.getPolygonCoords(props.graph, props);
    return _$C.map(coords, function (coord) {
      return "(" + coord.join(", ") + ")";
    }).join(" ");
  },
  getAngleEquationString: function getAngleEquationString(props) {
    var coords = InteractiveGraph$1.getAngleCoords(props.graph, props);
    var angle = GraphUtils.findAngle(coords[2], coords[0], coords[1]);
    return angle.toFixed(0) + "\u00B0 angle" + " at (" + coords[1].join(", ") + ")";
  },
  validate: function validate(state, rubric, component) {
    // When nothing has moved, there will neither be coords nor the
    // circle's center/radius fields. When those fields are absent, skip
    // all these checks; just go mark the answer as empty.
    var hasValue = !!(state.coords || state.center && state.radius);

    if (state.type === rubric.correct.type && hasValue) {
      if (state.type === "linear") {
        var guess = state.coords;
        var correct = rubric.correct.coords; // If both of the guess points are on the correct line, it's
        // correct.

        if (collinear(correct[0], correct[1], guess[0]) && collinear(correct[0], correct[1], guess[1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "linear-system") {
        var guess = state.coords;
        var correct = rubric.correct.coords;

        if (collinear(correct[0][0], correct[0][1], guess[0][0]) && collinear(correct[0][0], correct[0][1], guess[0][1]) && collinear(correct[1][0], correct[1][1], guess[1][0]) && collinear(correct[1][0], correct[1][1], guess[1][1]) || collinear(correct[0][0], correct[0][1], guess[1][0]) && collinear(correct[0][0], correct[0][1], guess[1][1]) && collinear(correct[1][0], correct[1][1], guess[0][0]) && collinear(correct[1][0], correct[1][1], guess[0][1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "quadratic") {
        // If the parabola coefficients match, it's correct.
        var guessCoeffs = this.getQuadraticCoefficients(state.coords);
        var correctCoeffs = this.getQuadraticCoefficients(rubric.correct.coords);

        if (deepEq(guessCoeffs, correctCoeffs)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "sinusoid") {
        var guessCoeffs = this.getSinusoidCoefficients(state.coords);
        var correctCoeffs = this.getSinusoidCoefficients(rubric.correct.coords);
        var canonicalGuessCoeffs = canonicalSineCoefficients$1(guessCoeffs);
        var canonicalCorrectCoeffs = canonicalSineCoefficients$1(correctCoeffs); // If the canonical coefficients match, it's correct.

        if (deepEq(canonicalGuessCoeffs, canonicalCorrectCoeffs)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "circle") {
        if (deepEq(state.center, rubric.correct.center) && eq(state.radius, rubric.correct.radius)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "point") {
        var guess = state.coords;
        var correct = InteractiveGraph$1.getPointCoords(rubric.correct, component);
        guess = guess.slice();
        correct = correct.slice(); // Everything's already rounded so we shouldn't need to do an
        // eq() comparison but _.isEqual(0, -0) is false, so we'll use
        // eq() anyway. The sort should be fine because it'll stringify
        // it and -0 converted to a string is "0"

        guess.sort();
        correct.sort();

        if (deepEq(guess, correct)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "polygon") {
        var guess = state.coords.slice();
        var correct = rubric.correct.coords.slice();
        var match;

        if (rubric.correct.match === "similar") {
          match = similar(guess, correct, Number.POSITIVE_INFINITY);
        } else if (rubric.correct.match === "congruent") {
          match = similar(guess, correct, knumber$1.DEFAULT_TOLERANCE);
        } else if (rubric.correct.match === "approx") {
          match = similar(guess, correct, 0.1);
        } else {
          /* exact */
          guess.sort();
          correct.sort();
          match = deepEq(guess, correct);
        }

        if (match) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "segment") {
        var guess = state.coords.slice();
        var correct = rubric.correct.coords.slice();
        guess = _$C.invoke(guess, "sort").sort();
        correct = _$C.invoke(correct, "sort").sort();

        if (deepEq(guess, correct)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "ray") {
        var guess = state.coords;
        var correct = rubric.correct.coords;

        if (deepEq(guess[0], correct[0]) && collinear(correct[0], correct[1], guess[1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "angle") {
        var guess = state.coords;
        var correct = rubric.correct.coords;
        var match;

        if (rubric.correct.match === "congruent") {
          var angles = _$C.map([guess, correct], function (coords) {
            var angle = GraphUtils.findAngle(coords[2], coords[0], coords[1]);
            return (angle + 360) % 360;
          });

          match = eq.apply(null, angles);
        } else {
          /* exact */
          match = deepEq(guess[1], correct[1]) && collinear(correct[1], correct[0], guess[0]) && collinear(correct[1], correct[2], guess[2]);
        }

        if (match) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      }
    } // The input wasn't correct, so check if it's a blank input or if it's
    // actually just wrong


    if (!hasValue || _$C.isEqual(state, rubric.graph)) {
      // We're where we started.
      return {
        type: "invalid",
        message: null
      };
    } else {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
  }
});

_module_$Q.exports = {
  name: "interactive-graph",
  displayName: "Interactive graph",
  widget: InteractiveGraph$1
};
var _widgetsInteractiveGraphJsx = _module_$Q.exports;

var _module_$P = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$Q = _react__default["default"];
var _$B = _underscore__default["default"];
var Util$6 = Util$q;
var DeprecationMixin = Util$6.DeprecationMixin;
var GraphSettings$2 = _componentsGraphSettingsJsx;
var InfoTip$7 = _componentsInfoTipJsx;
var InteractiveGraph = _widgetsInteractiveGraphJsx.widget;
var defaultBackgroundImage$2 = {
  url: null
};
var deprecatedProps = {
  showGraph: function showGraph(props) {
    return {
      markings: props.showGraph ? "graph" : "none"
    };
  }
};
var InteractiveGraphEditor = createReactClass({
  displayName: "InteractiveGraphEditor",
  className: "perseus-widget-interactive-graph",
  getDefaultProps: function getDefaultProps() {
    return {
      labels: ["x", "y"],
      range: [[-10, 10], [-10, 10]],
      step: [1, 1],
      valid: true,
      backgroundImage: defaultBackgroundImage$2,
      markings: "graph",
      showProtractor: false,
      showRuler: false,
      showTooltips: false,
      rulerLabel: "",
      rulerTicks: 10,
      correct: {
        type: "linear",
        coords: null
      }
    };
  },
  // TODO(jack): Use versioning instead of DeprecationMixin
  deprecatedProps: deprecatedProps,

  componentWillMount() {
    DeprecationMixin.componentWillMount.call(this);
  },

  render: function render() {
    var graph;
    var equationString;
    var gridStep = this.props.gridStep || Util$6.getGridStep(this.props.range, this.props.step, interactiveSizes.defaultBoxSize);
    var snapStep = this.props.snapStep || Util$6.snapStepFromGridStep(gridStep);
    var sizeClass = containerSizeClass.SMALL;

    if (this.props.valid === true) {
      // TODO(aria): send these down all at once
      var graphProps = {
        ref: "graph",
        box: this.props.box,
        range: this.props.range,
        labels: this.props.labels,
        step: this.props.step,
        gridStep: gridStep,
        snapStep: snapStep,
        graph: this.props.correct,
        backgroundImage: this.props.backgroundImage,
        markings: this.props.markings,
        showProtractor: this.props.showProtractor,
        showRuler: this.props.showRuler,
        rulerLabel: this.props.rulerLabel,
        rulerTicks: this.props.rulerTicks,
        trackInteraction: function trackInteraction() {},
        flexibleType: true,
        onChange: newProps => {
          var correct = this.props.correct;

          if (correct.type === newProps.graph.type) {
            correct = _$B.extend({}, correct, newProps.graph);
          } else {
            // Clear options from previous graph
            correct = newProps.graph;
          }

          this.props.onChange({
            correct: correct
          });
        }
      };
      graph = /*#__PURE__*/React$Q.createElement(InteractiveGraph, _extends({}, graphProps, {
        containerSizeClass: sizeClass,
        apiOptions: _objectSpread2(_objectSpread2({}, this.props.apiOptions), {}, {
          isMobile: false
        })
      }));
      equationString = InteractiveGraph.getEquationString(graphProps);
    } else {
      graph = /*#__PURE__*/React$Q.createElement("div", {
        className: "perseus-error"
      }, this.props.valid);
    }

    return /*#__PURE__*/React$Q.createElement("div", {
      className: "perseus-widget-interactive-graph"
    }, /*#__PURE__*/React$Q.createElement("div", null, "Correct answer", " ", /*#__PURE__*/React$Q.createElement(InfoTip$7, null, /*#__PURE__*/React$Q.createElement("p", null, "Graph the correct answer in the graph below and ensure the equation or point coordinates displayed represent the correct answer.")), " ", ": ", equationString), /*#__PURE__*/React$Q.createElement(GraphSettings$2, {
      box: getInteractiveBoxFromSizeClass(sizeClass),
      range: this.props.range,
      labels: this.props.labels,
      step: this.props.step,
      gridStep: gridStep,
      snapStep: snapStep,
      valid: this.props.valid,
      backgroundImage: this.props.backgroundImage,
      markings: this.props.markings,
      showProtractor: this.props.showProtractor,
      showRuler: this.props.showRuler,
      showTooltips: this.props.showTooltips,
      rulerLabel: this.props.rulerLabel,
      rulerTicks: this.props.rulerTicks,
      onChange: this.props.onChange
    }), this.props.correct.type === "polygon" && /*#__PURE__*/React$Q.createElement("div", {
      className: "type-settings"
    }, /*#__PURE__*/React$Q.createElement("label", null, " ", "Student answer must", " ", /*#__PURE__*/React$Q.createElement("select", {
      value: this.props.correct.match,
      onChange: this.changeMatchType
    }, /*#__PURE__*/React$Q.createElement("option", {
      value: "exact"
    }, "match exactly"), /*#__PURE__*/React$Q.createElement("option", {
      value: "congruent"
    }, "be congruent"), /*#__PURE__*/React$Q.createElement("option", {
      value: "approx"
    }, "be approximately congruent"), /*#__PURE__*/React$Q.createElement("option", {
      value: "similar"
    }, "be similar"))), /*#__PURE__*/React$Q.createElement(InfoTip$7, null, /*#__PURE__*/React$Q.createElement("ul", null, /*#__PURE__*/React$Q.createElement("li", null, /*#__PURE__*/React$Q.createElement("p", null, /*#__PURE__*/React$Q.createElement("b", null, "Match Exactly:"), " Match exactly in size, orientation, and location on the grid even if it is not shown in the background.")), /*#__PURE__*/React$Q.createElement("li", null, /*#__PURE__*/React$Q.createElement("p", null, /*#__PURE__*/React$Q.createElement("b", null, "Be Congruent:"), " Be congruent in size and shape, but can be located anywhere on the grid.")), /*#__PURE__*/React$Q.createElement("li", null, /*#__PURE__*/React$Q.createElement("p", null, /*#__PURE__*/React$Q.createElement("b", null, "Be Approximately Congruent:"), " Be exactly similar, and congruent in size and shape to within 0.1 units, but can be located anywhere on the grid.", " ", /*#__PURE__*/React$Q.createElement("em", null, "Use this with snapping to angle measure."))), /*#__PURE__*/React$Q.createElement("li", null, /*#__PURE__*/React$Q.createElement("p", null, /*#__PURE__*/React$Q.createElement("b", null, "Be Similar:"), " Be similar with matching interior angles, and side measures that are matching or a multiple of the correct side measures. The figure can be located anywhere on the grid."))))), this.props.correct.type === "angle" && /*#__PURE__*/React$Q.createElement("div", {
      className: "type-settings"
    }, /*#__PURE__*/React$Q.createElement("div", null, /*#__PURE__*/React$Q.createElement("label", null, " ", "Student answer must", " ", /*#__PURE__*/React$Q.createElement("select", {
      value: this.props.correct.match,
      onChange: this.changeMatchType
    }, /*#__PURE__*/React$Q.createElement("option", {
      value: "exact"
    }, "match exactly"), /*#__PURE__*/React$Q.createElement("option", {
      value: "congruent"
    }, "be congruent"))), /*#__PURE__*/React$Q.createElement(InfoTip$7, null, /*#__PURE__*/React$Q.createElement("p", null, "Congruency requires only that the angle measures are the same. An exact match implies congruency, but also requires that the angles have the same orientation and that the vertices are in the same position.")))), graph);
  },
  changeMatchType: function changeMatchType(e) {
    var correct = _$B.extend({}, this.props.correct, {
      match: e.target.value
    });

    this.props.onChange({
      correct: correct
    });
  },
  serialize: function serialize() {
    var json = _$B.pick(this.props, "step", "backgroundImage", "markings", "labels", "showProtractor", "showRuler", "showTooltips", "rulerLabel", "rulerTicks", "range", "gridStep", "snapStep");

    var graph = this.refs.graph;

    if (graph) {
      var correct = graph && graph.getUserInput();

      _$B.extend(json, {
        // TODO(alpert): Allow specifying flexibleType (whether the
        // graph type should be a choice or not)
        graph: {
          type: correct.type
        },
        correct: correct
      });

      _$B.each(["allowReflexAngles", "angleOffsetDeg", "numPoints", "numSides", "numSegments", "showAngles", "showSides", "snapTo", "snapDegrees"], function (key) {
        if (_$B.has(correct, key)) {
          json.graph[key] = correct[key];
        }
      });
    }

    return json;
  }
});
_module_$P.exports = InteractiveGraphEditor;
var _widgetsInteractiveGraphEditorJsx = _module_$P.exports;

var _module_$O = {
  exports: {}
};
/* eslint-disable react/prop-types, react/sort-comp */

var React$P = _react__default["default"];
var _$A = _underscore__default["default"];
var TeX$3 = _reactComponentsTexJsx;
var prettyBig = {
  fontSize: "150%"
};
var slightlyBig = {
  fontSize: "120%"
};
var symbStyle = {
  fontSize: "130%"
}; // These are functions because we want to generate a new component for each use
// on the page rather than reusing an instance (which will cause an error).
// Also, it's useful for things which might look different depending on the
// props.

var basic = [() => [/*#__PURE__*/React$P.createElement("span", {
  key: "plus",
  style: slightlyBig
}, "+"), "+"], () => [/*#__PURE__*/React$P.createElement("span", {
  key: "minus",
  style: prettyBig
}, "-"), "-"], // TODO(joel) - display as \cdot when appropriate
props => {
  if (props.convertDotToTimes) {
    return [/*#__PURE__*/React$P.createElement(TeX$3, {
      key: "times",
      style: prettyBig
    }, "\\times"), "\\times"];
  } else {
    return [/*#__PURE__*/React$P.createElement(TeX$3, {
      key: "times",
      style: prettyBig
    }, "\\cdot"), "\\cdot"];
  }
}, () => [/*#__PURE__*/React$P.createElement(TeX$3, {
  key: "frac",
  style: prettyBig
}, "\\frac{□}{□}"), // If there's something in the input that can become part of a
// fraction, typing "/" puts it in the numerator. If not, typing
// "/" does nothing. In that case, enter a \frac.
input => {
  var contents = input.latex();
  input.typedText("/");

  if (input.latex() === contents) {
    input.cmd("\\frac");
  }
}]];
var buttonSets = {
  basic,
  "basic+div": basic.concat([() => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "div"
  }, "\\div"), "\\div"]]),
  trig: [() => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "sin"
  }, "\\sin"), "\\sin"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "cos"
  }, "\\cos"), "\\cos"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "tan"
  }, "\\tan"), "\\tan"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "theta",
    style: symbStyle
  }, "\\theta"), "\\theta"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "pi",
    style: symbStyle
  }, "\\phi"), "\\phi"]],
  prealgebra: [() => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "sqrt"
  }, "\\sqrt{x}"), "\\sqrt"], // TODO(joel) - how does desmos do this?
  () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "nthroot"
  }, "\\sqrt[3]{x}"), input => {
    input.typedText("nthroot3");
    input.keystroke("Right");
  }], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "pow",
    style: slightlyBig
  }, "\u25A1^a"), input => {
    var contents = input.latex();
    input.typedText("^"); // If the input hasn't changed (for example, if we're
    // attempting to add an exponent on an empty input or an empty
    // denominator), insert our own "a^b"

    if (input.latex() === contents) {
      input.typedText("a^b");
    }
  }], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "pi",
    style: slightlyBig
  }, "\\pi"), "\\pi"]],
  logarithms: [() => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "log"
  }, "\\log"), "\\log"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "ln"
  }, "\\ln"), "\\ln"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "log_b"
  }, "\\log_b"), input => {
    input.typedText("log_");
    input.keystroke("Right");
    input.typedText("(");
    input.keystroke("Left");
    input.keystroke("Left");
  }]],
  "basic relations": [() => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "eq"
  }, "="), "="], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "lt"
  }, "\\lt"), "\\lt"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "gt"
  }, "\\gt"), "\\gt"]],
  "advanced relations": [() => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "neq"
  }, "\\neq"), "\\neq"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "leq"
  }, "\\leq"), "\\leq"], () => [/*#__PURE__*/React$P.createElement(TeX$3, {
    key: "geq"
  }, "\\geq"), "\\geq"]]
};
var buttonSetsType = PropTypes.arrayOf(PropTypes.oneOf(Object.keys(buttonSets)));
var TexButtons$3 = createReactClass({
  displayName: "TexButtons",
  propTypes: {
    sets: buttonSetsType.isRequired,
    onInsert: PropTypes.func.isRequired
  },
  render: function render() {
    // Always show buttonSets in the same order. Note: Technically it's ok
    // for _.keys() to return the keys in an arbitrary order, but in
    // practice, they will be ordered as listed above.
    var sortedButtonSets = _$A.sortBy(this.props.sets, setName => _$A.keys(buttonSets).indexOf(setName));

    var buttons = sortedButtonSets.map(setName => buttonSets[setName]);
    var buttonRows = buttons.map(row => row.map(symbGen => {
      // create a (component, thing we should send to mathquill) pair
      var symbol = symbGen(this.props);
      return /*#__PURE__*/React$P.createElement("button", {
        onClick: () => this.props.onInsert(symbol[1]),
        className: "tex-button",
        key: symbol[0].key,
        tabIndex: -1,
        type: "button"
      }, symbol[0]);
    }));
    var buttonPopup = buttonRows.map((row, i) => {
      return /*#__PURE__*/React$P.createElement("div", {
        className: "clearfix tex-button-row",
        key: this.props.sets[i]
      }, row);
    });
    return /*#__PURE__*/React$P.createElement("div", {
      className: "".concat(this.props.className, " preview-measure")
    }, buttonPopup);
  },
  statics: {
    buttonSets,
    buttonSetsType
  }
});
_module_$O.exports = TexButtons$3;
var _componentsTexButtonsJsx = _module_$O.exports;

var _module_$N = {
  exports: {}
};
/* eslint-disable react/prop-types, react/sort-comp */

var classNames$a = _classnames__default["default"];
var React$O = _react__default["default"];
var ReactDOM$7 = _reactDom__default["default"];
var _$z = _underscore__default["default"];
var TexButtons$2 = _componentsTexButtonsJsx; // TODO(alex): Package MathQuill

var MathQuill = window.MathQuill;
var PT$1 = PropTypes; // A WYSIWYG math input that calls `onChange(LaTeX-string)`

var MathInput$4 = createReactClass({
  displayName: "MathInput",
  propTypes: {
    value: PT$1.string,
    onChange: PT$1.func.isRequired,
    convertDotToTimes: PT$1.bool,
    buttonsVisible: PT$1.oneOf(["always", "never", "focused"]),
    buttonSets: TexButtons$2.buttonSetsType.isRequired,
    labelText: PropTypes.string,
    onFocus: PT$1.func,
    onBlur: PT$1.func
  },
  render: function render() {
    var className = classNames$a({
      "perseus-math-input": true,
      // mathquill usually adds these itself but react removes them when
      // updating the component.
      "mq-editable-field": true,
      "mq-math-mode": true
    });

    if (this.props.className) {
      className = className + " " + this.props.className;
    }

    var buttons = null;

    if (this._shouldShowButtons()) {
      buttons = /*#__PURE__*/React$O.createElement(TexButtons$2, {
        sets: this.props.buttonSets,
        className: "math-input-buttons absolute",
        convertDotToTimes: this.props.convertDotToTimes,
        onInsert: this.insert
      });
    }

    return /*#__PURE__*/React$O.createElement("div", {
      style: {
        display: "inline-block"
      }
    }, /*#__PURE__*/React$O.createElement("div", {
      style: {
        display: "inline-block"
      }
    }, /*#__PURE__*/React$O.createElement("span", {
      className: className,
      ref: "mathinput",
      "aria-label": this.props.labelText,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    })), /*#__PURE__*/React$O.createElement("div", {
      style: {
        position: "relative"
      }
    }, buttons));
  },
  // handlers:
  // keep track of two related bits of state:
  // * this.state.focused - whether the buttons are currently shown
  // * this.mouseDown - whether a mouse click is active that started in the
  //   buttons div
  handleFocus: function handleFocus() {
    this.setState({
      focused: true
    }); // TODO(joel) fix properly - we should probably allow onFocus handlers
    // to this property, but we need to work correctly with them.
    // if (this.props.onFocus) {
    //     this.props.onFocus();
    // }
  },
  handleMouseDown: function handleMouseDown(event) {
    var focused = ReactDOM$7.findDOMNode(this).contains(event.target);
    this.mouseDown = focused;

    if (!focused) {
      this.setState({
        focused: false
      });
    }
  },
  handleMouseUp: function handleMouseUp() {
    // this mouse click started in the buttons div so we should focus the
    // input
    if (this.mouseDown) {
      this.focus();
    }

    this.mouseDown = false;
  },
  handleBlur: function handleBlur() {
    if (!this.mouseDown) {
      this.setState({
        focused: false
      });
    }
  },
  _shouldShowButtons: function _shouldShowButtons() {
    if (this.props.buttonsVisible === "always") {
      return true;
    } else if (this.props.buttonsVisible === "never") {
      return false;
    } else {
      return this.state.focused;
    }
  },
  getDefaultProps: function getDefaultProps() {
    return {
      value: "",
      convertDotToTimes: false,
      buttonsVisible: "focused"
    };
  },
  getInitialState: function getInitialState() {
    return {
      focused: false
    };
  },
  insert: function insert(value) {
    var input = this.mathField();

    if (_$z.isFunction(value)) {
      value(input);
    } else if (value[0] === "\\") {
      input.cmd(value).focus();
    } else {
      input.write(value).focus();
    }

    input.focus();
  },
  mathField: function mathField(options) {
    // The MathQuill API is now "versioned" through its own "InterVer"
    // system.
    // See: https://github.com/mathquill/mathquill/pull/459
    var MQ = MathQuill.getInterface(2); // MathQuill.MathField takes a DOM node, MathQuill-ifies it if it's
    // seeing that node for the first time, then returns the associated
    // MathQuill object for that node. It is stable - will always return
    // the same object when called on the same DOM node.

    return MQ.MathField(ReactDOM$7.findDOMNode(this.refs.mathinput), options);
  },
  componentWillUnmount: function componentWillUnmount() {
    window.removeEventListener("mousedown", this.handleMouseDown);
    window.removeEventListener("mouseup", this.handleMouseUp);
  },
  componentDidMount: function componentDidMount() {
    window.addEventListener("mousedown", this.handleMouseDown);
    window.addEventListener("mouseup", this.handleMouseUp);
    var initialized = false; // Initialize MathQuill.MathField instance

    this.mathField({
      // LaTeX commands that, when typed, are immediately replaced by the
      // appropriate symbol. This does not include ln, log, or any of the
      // trig functions; those are always interpreted as commands.
      autoCommands: "pi theta phi sqrt nthroot",
      // Pop the cursor out of super/subscripts on arithmetic operators
      // or (in)equalities.
      charsThatBreakOutOfSupSub: "+-*/=<>≠≤≥",
      // Prevent excessive super/subscripts or fractions from being
      // created without operands, e.g. when somebody holds down a key
      supSubsRequireOperand: true,
      // The name of this option is somewhat misleading, as tabbing in
      // MathQuill breaks you out of a nested context (fraction/script)
      // if you're in one, but moves focus to the next input if you're
      // not. Spaces (with this option enabled) are just ignored in the
      // latter case.
      //
      // TODO(alex): In order to allow inputting mixed numbers, we will
      // have to accept spaces in certain cases. The desired behavior is
      // still to escape nested contexts if currently in one, but to
      // insert a space if not (we don't expect mixed numbers in nested
      // contexts). We should also limit to one consecutive space.
      spaceBehavesLikeTab: true,
      handlers: {
        edited: mathField => {
          // This handler is guaranteed to be called on change, but
          // unlike React it sometimes generates false positives.
          // One of these is on initialization (with an empty string
          // value), so we have to guard against that below.
          var value = mathField.latex(); // Provide a MathQuill-compatible way to generate the
          // not-equals sign without pasting unicode or typing TeX

          value = value.replace(/<>/g, "\\ne"); // Use the specified symbol to represent multiplication
          // TODO(alex): Add an option to disallow variables, in
          // which case 'x' should get converted to '\\times'

          if (this.props.convertDotToTimes) {
            value = value.replace(/\\cdot/g, "\\times"); // Preserve cursor position in the common case:
            // typing '*' to insert a multiplication sign.
            // We do this by modifying internal MathQuill state
            // directly, instead of waiting for `.latex()` to be
            // called in `componentDidUpdate()`.

            var left = mathField.__controller.cursor[MathQuill.L];

            if (left && left.ctrlSeq === "\\cdot ") {
              mathField.__controller.backspace();

              mathField.cmd("\\times");
            }
          } else {
            value = value.replace(/\\times/g, "\\cdot");
          }

          if (initialized && this.props.value !== value) {
            this.props.onChange(value);
          }
        },
        enter: () => {
          // This handler is called when the user presses the enter
          // key. Since this isn't an actual <input> element, we have
          // to manually trigger the usually automatic form submit.
          $__default["default"](ReactDOM$7.findDOMNode(this.refs.mathinput)).submit();
        },
        upOutOf: mathField => {
          // This handler is called when the user presses the up
          // arrow key, but there is nowhere in the expression to go
          // up to (no numerator or exponent). For ease of use,
          // interpret this as an attempt to create an exponent.
          mathField.typedText("^");
        }
      }
    }); // Ideally, we would be able to pass an initial value directly into
    // the constructor above

    this.mathField().latex(this.props.value);
    initialized = true;
  },
  componentDidUpdate: function componentDidUpdate() {
    if (!_$z.isEqual(this.mathField().latex(), this.props.value)) {
      this.mathField().latex(this.props.value);
    }
  },
  focus: function focus() {
    this.mathField().focus();
    this.setState({
      focused: true
    });
  },
  blur: function blur() {
    this.mathField().blur();
    this.setState({
      focused: false
    });
  }
});
_module_$N.exports = MathInput$4;
var _componentsMathInputJsx = _module_$N.exports;

var _module_$M = {
  exports: {}
};
/* eslint-disable react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$N = _react__default["default"];
var InlineIcon$c = _componentsInlineIconJsx;

class ElementContainer$1 extends React$N.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "toggle", e => {
      e.preventDefault();
      this.setState({
        show: !this.state.show
      });
    });

    this.state = {
      show: props.initiallyVisible
    };
  }

  render() {
    return /*#__PURE__*/React$N.createElement("div", {
      className: "perseus-interaction-element"
    }, /*#__PURE__*/React$N.createElement("a", {
      href: "#",
      className: "perseus-interaction-element-title " + (this.state.show ? "open" : "closed"),
      onClick: this.toggle
    }, this.state.show ? /*#__PURE__*/React$N.createElement(InlineIcon$c, iconChevronDown) : /*#__PURE__*/React$N.createElement(InlineIcon$c, iconChevronRight), this.props.title), /*#__PURE__*/React$N.createElement("div", {
      className: "perseus-interaction-element-content " + (this.state.show ? "enter" : "leave")
    }, this.props.children, (this.props.onUp != null || this.props.onDown != null || this.props.onDelete != null) && /*#__PURE__*/React$N.createElement("div", {
      className: "edit-controls"
    }, this.props.onUp != null && /*#__PURE__*/React$N.createElement("button", {
      onClick: this.props.onUp
    }, /*#__PURE__*/React$N.createElement(InlineIcon$c, iconCircleArrowUp)), this.props.onDown != null && /*#__PURE__*/React$N.createElement("button", {
      onClick: this.props.onDown
    }, /*#__PURE__*/React$N.createElement(InlineIcon$c, iconCircleArrowDown)), this.props.onDelete != null && /*#__PURE__*/React$N.createElement("button", {
      onClick: this.props.onDelete
    }, /*#__PURE__*/React$N.createElement(InlineIcon$c, iconTrash)))));
  }

}

_defineProperty(ElementContainer$1, "defaultProps", {
  initiallyVisible: false,
  title: "More"
});

_module_$M.exports = ElementContainer$1;
var _interactionElementContainerJsx = _module_$M.exports;

var _module_$L = {
  exports: {}
};
/* eslint-disable react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var ButtonGroup$5 = _reactComponentsButtonGroupJsx;
var React$M = _react__default["default"];

class DashPicker$1 extends React$M.Component {
  render() {
    return /*#__PURE__*/React$M.createElement(ButtonGroup$5, {
      value: this.props.value,
      allowEmpty: false,
      buttons: [{
        value: "",
        content: /*#__PURE__*/React$M.createElement("span", null, "\u2014")
      }, {
        value: "-",
        content: /*#__PURE__*/React$M.createElement("span", null, "\u2013\u2013\u2013")
      }, {
        value: "- ",
        content: /*#__PURE__*/React$M.createElement("span", null, "\u2013\xA0\xA0\u2013")
      }, {
        value: ".",
        content: /*#__PURE__*/React$M.createElement("span", null, "\xB7\xB7\xB7\xB7")
      }, {
        value: ". ",
        content: /*#__PURE__*/React$M.createElement("span", null, "\xB7 \xB7 \xB7")
      }],
      onChange: this.props.onChange
    });
  }

}

_defineProperty(DashPicker$1, "defaultProps", {
  value: ""
});

_module_$L.exports = DashPicker$1;
var _interactionDashPickerJsx = _module_$L.exports;

var _module_$K = {
  exports: {}
};
/* eslint-disable react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$L = _react__default["default"];
var TeX$2 = _reactComponentsTexJsx;
var ButtonGroup$4 = _reactComponentsButtonGroupJsx;
var MathInput$3 = _componentsMathInputJsx;
var NumberInput$2 = _componentsNumberInputJsx;

class ConstraintEditor$1 extends React$L.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });
  }

  render() {
    return /*#__PURE__*/React$L.createElement("div", null, /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, "Constraint:", " ", /*#__PURE__*/React$L.createElement(ButtonGroup$4, {
      value: this.props.constraint,
      allowEmpty: false,
      buttons: [{
        value: "none",
        content: "None"
      }, {
        value: "snap",
        content: "Snap"
      }, {
        value: "x",
        content: "x="
      }, {
        value: "y",
        content: "y="
      }],
      onChange: this.change("constraint")
    })), this.props.constraint === "snap" && /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, "Snap:", " ", /*#__PURE__*/React$L.createElement(NumberInput$2, {
      value: this.props.snap,
      placeholder: 0,
      onChange: this.change("snap")
    })), this.props.constraint === "x" && /*#__PURE__*/React$L.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$L.createElement(TeX$2, null, "x="), " ", /*#__PURE__*/React$L.createElement(MathInput$3, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.constraintFn,
      onChange: this.change("constraintFn")
    }))), this.props.constraint === "y" && /*#__PURE__*/React$L.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$L.createElement(TeX$2, null, "y="), " ", /*#__PURE__*/React$L.createElement(MathInput$3, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.constraintFn,
      onChange: this.change("constraintFn")
    }))), "Ensure these are set so nothing can be dragged off the canvas:", /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$L.createElement(TeX$2, null, "x \\in \\Large["), " ", /*#__PURE__*/React$L.createElement(MathInput$3, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.constraintXMin,
      onChange: this.change("constraintXMin")
    }), /*#__PURE__*/React$L.createElement(TeX$2, null, ", "), " ", /*#__PURE__*/React$L.createElement(MathInput$3, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.constraintXMax,
      onChange: this.change("constraintXMax")
    }), " ", /*#__PURE__*/React$L.createElement(TeX$2, null, "\\Large]"))), /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$L.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$L.createElement(TeX$2, null, "y \\in \\Large["), " ", /*#__PURE__*/React$L.createElement(MathInput$3, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.constraintYMin,
      onChange: this.change("constraintYMin")
    }), /*#__PURE__*/React$L.createElement(TeX$2, null, ", "), " ", /*#__PURE__*/React$L.createElement(MathInput$3, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.constraintYMax,
      onChange: this.change("constraintYMax")
    }), " ", /*#__PURE__*/React$L.createElement(TeX$2, null, "\\Large]"))));
  }

}

_defineProperty(ConstraintEditor$1, "defaultProps", {
  constraint: "none",
  snap: 0.5,
  constraintFn: "0",
  constraintXMin: "-10",
  constraintXMax: "10",
  constraintYMin: "-10",
  constraintYMax: "10"
});

_module_$K.exports = ConstraintEditor$1;
var _interactionConstraintEditorJsx = _module_$K.exports;

var _module_$J = {
  exports: {}
};
/* eslint-disable react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var ButtonGroup$3 = _reactComponentsButtonGroupJsx;
var React$K = _react__default["default"];
var _$y = _underscore__default["default"];
var KhanColors$2 = _utilColorsJs;
var COLORS = [KhanColors$2.BLACK, KhanColors$2.BLUE, KhanColors$2.GREEN, KhanColors$2.PINK, KhanColors$2.PURPLE, KhanColors$2.RED, KhanColors$2.GRAY];
var LIGHT_COLORS = [KhanColors$2.LIGHT_BLUE, KhanColors$2.LIGHT_ORANGE, KhanColors$2.LIGHT_PINK, KhanColors$2.LIGHT_GREEN, KhanColors$2.LIGHT_PURPLE, KhanColors$2.LIGHT_RED, "#fff"];

class ColorPicker$1 extends React$K.Component {
  render() {
    var colors = this.props.lightColors ? LIGHT_COLORS : COLORS;
    return /*#__PURE__*/React$K.createElement(ButtonGroup$3, {
      value: this.props.value,
      allowEmpty: false,
      buttons: _$y.map(colors, color => {
        return {
          value: color,
          content: /*#__PURE__*/React$K.createElement("span", null, /*#__PURE__*/React$K.createElement("span", {
            className: "colorpicker-circle",
            style: {
              background: color
            }
          }), "\xA0")
        };
      }),
      onChange: this.props.onChange
    });
  }

}

_defineProperty(ColorPicker$1, "defaultProps", {
  value: KhanColors$2.BLACK,
  lightColors: false
});

_module_$J.exports = ColorPicker$1;
var _interactionColorPickerJsx = _module_$J.exports;

var _module_$I = {
  exports: {}
};
/* eslint-disable react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var ButtonGroup$2 = _reactComponentsButtonGroupJsx;
var React$J = _react__default["default"];

class ArrowPicker$1 extends React$J.Component {
  render() {
    return /*#__PURE__*/React$J.createElement(ButtonGroup$2, {
      value: this.props.value,
      allowEmpty: false,
      buttons: [{
        value: "",
        content: /*#__PURE__*/React$J.createElement("span", null, "\u2014")
      }, {
        value: "->",
        content: /*#__PURE__*/React$J.createElement("span", null, "\u2192")
      }
      /*
      TODO(eater): fix khan-exercises so these are supported
      {value: "<-", content: <span>&#x2190;</span>},
      {value: "<->", content: <span>&#x2194;</span>}
      */
      ],
      onChange: this.props.onChange
    });
  }

}

_defineProperty(ArrowPicker$1, "defaultProps", {
  value: ""
});

_module_$I.exports = ArrowPicker$1;
var _interactionArrowPickerJsx = _module_$I.exports;

var _module_$H = {
  exports: {}
};
/* eslint-disable max-lines, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$I = _react__default["default"];
var _$x = _underscore__default["default"];
var Changeable$p = Changeable$Q;
var EditorJsonify$8 = _mixinsEditorJsonifyJsx;
var ArrowPicker = _interactionArrowPickerJsx;
var ColorPicker = _interactionColorPickerJsx;
var ConstraintEditor = _interactionConstraintEditorJsx;
var DashPicker = _interactionDashPickerJsx;
var ElementContainer = _interactionElementContainerJsx;
var GraphSettings$1 = _componentsGraphSettingsJsx;
var MathInput$2 = _componentsMathInputJsx;
var NumberInput$1 = _componentsNumberInputJsx;
var TeX$1 = _reactComponentsTexJsx;
var TextInput$5 = _componentsTextInputJsx;
var KhanColors$1 = _utilColorsJs;
var defaultInteractionProps$1 = {
  graph: {
    box: [400, 400],
    labels: ["x", "y"],
    range: [[-10, 10], [-10, 10]],
    tickStep: [1, 1],
    gridStep: [1, 1],
    markings: "graph"
  },
  elements: []
}; //
// Editor for non-interactive points
//
// TODO(eater): Factor this out
//

var PointEditor = createReactClass({
  displayName: "PointEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    coordX: PropTypes.string,
    coordY: PropTypes.string,
    color: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      coordX: "0",
      coordY: "0",
      color: KhanColors$1.BLACK
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Coordinate: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.coordX,
      onChange: this.change("coordX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.coordY,
      onChange: this.change("coordY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(ColorPicker, {
      value: this.props.color,
      onChange: this.change("color")
    })));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

}); //
// Editor for non-interactive line segments
//
// TODO(eater): Factor this out
//

var LineEditor = createReactClass({
  displayName: "LineEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    startX: PropTypes.string,
    startY: PropTypes.string,
    endX: PropTypes.string,
    endY: PropTypes.string,
    color: PropTypes.string,
    strokeDasharray: PropTypes.string,
    arrows: PropTypes.string,
    strokeWidth: PropTypes.number
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      startX: "-5",
      startY: "5",
      endX: "5",
      endY: "5",
      color: KhanColors$1.BLACK,
      strokeDasharray: "",
      arrows: "",
      strokeWidth: 2
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Start: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.startX,
      onChange: this.change("startX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.startY,
      onChange: this.change("startY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "End: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.endX,
      onChange: this.change("endX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.endY,
      onChange: this.change("endY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(ColorPicker, {
      value: this.props.color,
      onChange: this.change("color")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(DashPicker, {
      value: this.props.strokeDasharray,
      onChange: this.change("strokeDasharray")
    }), "\xA0 \xA0", /*#__PURE__*/React$I.createElement(ArrowPicker, {
      value: this.props.arrows,
      onChange: this.change("arrows")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-left-col"
    }, "Width:", " ", /*#__PURE__*/React$I.createElement(NumberInput$1, {
      value: this.props.strokeWidth,
      placeholder: 2,
      onChange: this.change("strokeWidth")
    }))));
  },

  change() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

}); //
// Editor for interactive movable points
//
// TODO(eater): Factor this out
// TODO(eater): Rethink how constraints are represented
//

var MovablePointEditor = createReactClass({
  displayName: "MovablePointEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    startX: PropTypes.string,
    startY: PropTypes.string,
    constraint: PropTypes.string,
    snap: PropTypes.number,
    constraintFn: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      startX: "0",
      startY: "0",
      constraint: "none",
      snap: 0.5,
      constraintFn: "0",
      constraintXMin: "-10",
      constraintXMax: "10",
      constraintYMin: "-10",
      constraintYMax: "10"
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Start: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.startX,
      onChange: this.change("startX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.startY,
      onChange: this.change("startY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Update ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(x_n, y_n)"), " for ", /*#__PURE__*/React$I.createElement(TeX$1, null, "n ="), " ", /*#__PURE__*/React$I.createElement(NumberInput$1, {
      value: this.props.varSubscript,
      placeholder: 0,
      onChange: this.change("varSubscript")
    })), /*#__PURE__*/React$I.createElement(ConstraintEditor, this.props));
  },

  change() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

}); //
// Editor for interactive movable line segments
//
// TODO(eater): Factor this out
// TODO(eater): Rethink how constraints are represented
//

var MovableLineEditor = createReactClass({
  displayName: "MovableLineEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    startX: PropTypes.string,
    startY: PropTypes.string,
    endX: PropTypes.string,
    endY: PropTypes.string,
    constraint: PropTypes.string,
    snap: PropTypes.number,
    constraintFn: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      startX: "-5",
      startY: "5",
      endX: "5",
      endY: "5",
      constraint: "none",
      snap: 0.5,
      constraintFn: "0",
      constraintXMin: "-10",
      constraintXMax: "10",
      constraintYMin: "-10",
      constraintYMax: "10"
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, "Initial position:", /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Start: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.startX,
      onChange: this.change("startX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.startY,
      onChange: this.change("startY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "End: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.endX,
      onChange: this.change("endX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.endY,
      onChange: this.change("endY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Start updates ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(x_n, y_n)"), " for ", /*#__PURE__*/React$I.createElement(TeX$1, null, "n ="), /*#__PURE__*/React$I.createElement(NumberInput$1, {
      value: this.props.startSubscript,
      placeholder: 0,
      onChange: this.change("startSubscript")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "End updates ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(x_m, y_m)"), " for ", /*#__PURE__*/React$I.createElement(TeX$1, null, "m ="), /*#__PURE__*/React$I.createElement(NumberInput$1, {
      value: this.props.endSubscript,
      placeholder: 0,
      onChange: this.change("endSubscript")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "All constraints are applied to the start point."), /*#__PURE__*/React$I.createElement(ConstraintEditor, this.props));
  },

  change() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

}); //
// Editor for function plots
//
// TODO(eater): Factor this out
//

var FunctionEditor = createReactClass({
  displayName: "FunctionEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    value: PropTypes.string,
    rangeMin: PropTypes.string,
    rangeMax: PropTypes.string,
    color: PropTypes.string,
    strokeDashArray: PropTypes.string,
    strokeWidth: PropTypes.number
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      value: "x",
      rangeMin: "-10",
      rangeMax: "10",
      color: KhanColors$1.BLUE,
      strokeDasharray: "",
      strokeWidth: 2
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(TeX$1, null, this.props.funcName + "(x)="), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.value,
      onChange: this.change("value")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Range: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.rangeMin,
      onChange: this.change("rangeMin")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.rangeMax,
      onChange: this.change("rangeMax")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(ColorPicker, {
      value: this.props.color,
      onChange: this.change("color")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(DashPicker, {
      value: this.props.strokeDasharray,
      onChange: this.change("strokeDasharray")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-left-col"
    }, "Width:", " ", /*#__PURE__*/React$I.createElement(NumberInput$1, {
      value: this.props.strokeWidth,
      placeholder: 2,
      onChange: this.change("strokeWidth")
    }))));
  },

  change() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

}); //
// Editor for parametric plots
//
// TODO(eater): Factor this out
//

var ParametricEditor = createReactClass({
  displayName: "ParametricEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    x: PropTypes.string,
    y: PropTypes.string,
    rangeMin: PropTypes.string,
    rangeMax: PropTypes.string,
    color: PropTypes.string,
    strokeDashArray: PropTypes.string,
    strokeWidth: PropTypes.number
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      x: "cos(t)",
      y: "sin(t)",
      rangeMin: "0",
      rangeMax: "2\\pi",
      color: KhanColors$1.BLUE,
      strokeDasharray: "",
      strokeWidth: 2
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(TeX$1, null, "X(t) ="), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.x,
      onChange: this.change("x")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(TeX$1, null, "Y(t) ="), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.y,
      onChange: this.change("y")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Range: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.rangeMin,
      onChange: this.change("rangeMin")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.rangeMax,
      onChange: this.change("rangeMax")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(ColorPicker, {
      value: this.props.color,
      onChange: this.change("color")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(DashPicker, {
      value: this.props.strokeDasharray,
      onChange: this.change("strokeDasharray")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-left-col"
    }, "Width:", " ", /*#__PURE__*/React$I.createElement(NumberInput$1, {
      value: this.props.strokeWidth,
      placeholder: 2,
      onChange: this.change("strokeWidth")
    }))));
  },

  change() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

}); //
// Editor for labels
//
// TODO(eater): Factor this out maybe?
// TODO(eater): Add text direction
//

var LabelEditor = createReactClass({
  displayName: "LabelEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    color: PropTypes.string,
    coordX: PropTypes.string,
    coordY: PropTypes.string,
    label: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      coordX: "0",
      coordY: "0",
      color: KhanColors$1.BLACK,
      label: "\\phi"
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(TextInput$5, {
      value: this.props.label,
      onChange: this.change("label"),
      style: {
        width: "100%"
      }
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Location: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.coordX,
      onChange: this.change("coordX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.coordY,
      onChange: this.change("coordY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(ColorPicker, {
      value: this.props.color,
      onChange: this.change("color")
    })));
  },

  change() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

}); //
// Editor for rectangles
//
// TODO(eater): Factor this out maybe?
//

var RectangleEditor = createReactClass({
  displayName: "RectangleEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    color: PropTypes.string,
    coordX: PropTypes.string,
    coordY: PropTypes.string,
    height: PropTypes.string,
    width: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      coordX: "-5",
      coordY: "5",
      width: "2",
      height: "3",
      color: KhanColors$1.LIGHT_BLUE
    };
  },
  render: function render() {
    return /*#__PURE__*/React$I.createElement("div", {
      className: "graph-settings"
    }, /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Bottom left: ", /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large("), /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.coordX,
      onChange: this.change("coordX")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, ","), " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.coordY,
      onChange: this.change("coordY")
    }), /*#__PURE__*/React$I.createElement(TeX$1, null, "\\Large)")), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Width:", " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.width,
      onChange: this.change("width")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "Height:", " ", /*#__PURE__*/React$I.createElement(MathInput$2, {
      buttonSets: [],
      buttonsVisible: "never",
      value: this.props.height,
      onChange: this.change("height")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$I.createElement(ColorPicker, {
      value: this.props.color,
      lightColors: true,
      onChange: this.change("color")
    })), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-row"
    }, "You want a border? Sorry, draw your own."));
  },

  change() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    return Changeable$p.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

});
var InteractionEditor = createReactClass({
  displayName: "InteractionEditor",
  // TODO(eater): Make more better
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$p.propTypes), {}, {
    elements: PropTypes.arrayOf(PropTypes.object),
    graph: PropTypes.objectOf(PropTypes.any)
  }),
  getDefaultProps: function getDefaultProps() {
    return defaultInteractionProps$1;
  },
  getInitialState: function getInitialState() {
    return {
      usedVarSubscripts: this._getAllVarSubscripts(this.props.elements),
      usedFunctionNames: this._getAllFunctionNames(this.props.elements)
    };
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      usedVarSubscripts: this._getAllVarSubscripts(nextProps.elements),
      usedFunctionNames: this._getAllFunctionNames(nextProps.elements)
    });
  },
  _getAllVarSubscripts: function _getAllVarSubscripts(elements) {
    return _$x.map(_$x.where(elements, {
      type: "movable-point"
    }), element => element.options.varSubscript).concat(_$x.map(_$x.where(elements, {
      type: "movable-line"
    }), element => element.options.startSubscript)).concat(_$x.map(_$x.where(elements, {
      type: "movable-line"
    }), element => element.options.endSubscript));
  },
  _getAllFunctionNames: function _getAllFunctionNames(elements) {
    return _$x.map(_$x.where(elements, {
      type: "function"
    }), element => element.options.funcName);
  },
  _updateGraphProps: function _updateGraphProps(newProps) {
    // TODO(eater): GraphSettings should name this tickStep instead
    // of step. Grr..
    this.change({
      graph: _$x.extend(_$x.omit(newProps, "step"), {
        tickStep: newProps.step
      })
    });
  },
  _addNewElement: function _addNewElement(e) {
    var elementType = e.target.value;

    if (elementType === "") {
      return;
    }

    e.target.value = "";
    var newElement = {
      type: elementType,
      key: elementType + "-" + (Math.random() * 0xffffff << 0).toString(16),
      options: elementType === "point" ? _$x.clone(PointEditor.defaultProps) : elementType === "line" ? _$x.clone(LineEditor.defaultProps) : elementType === "movable-point" ? _$x.clone(MovablePointEditor.defaultProps) : elementType === "movable-line" ? _$x.clone(MovableLineEditor.defaultProps) : elementType === "function" ? _$x.clone(FunctionEditor.defaultProps) : elementType === "parametric" ? _$x.clone(ParametricEditor.defaultProps) : elementType === "label" ? _$x.clone(LabelEditor.defaultProps) : elementType === "rectangle" ? _$x.clone(RectangleEditor.defaultProps) : {}
    };
    var nextSubscript;

    if (elementType === "movable-point") {
      nextSubscript = _$x.max([_$x.max(this.state.usedVarSubscripts), -1]) + 1;
      newElement.options.varSubscript = nextSubscript;
    } else if (elementType === "movable-line") {
      nextSubscript = _$x.max([_$x.max(this.state.usedVarSubscripts), -1]) + 1;
      newElement.options.startSubscript = nextSubscript;
      newElement.options.endSubscript = nextSubscript + 1;
    } else if (elementType === "function") {
      // TODO(eater): The 22nd function added will be {(x) since '{'
      // comes after 'z'
      var nextLetter = String.fromCharCode(_$x.max([_$x.max(_$x.map(this.state.usedFunctionNames, function (c) {
        return c.charCodeAt(0);
      })), "e".charCodeAt(0)]) + 1);
      newElement.options.funcName = nextLetter;
    }

    this.change({
      elements: this.props.elements.concat(newElement)
    });
  },
  _deleteElement: function _deleteElement(index) {
    var element = this.props.elements[index];
    this.change({
      elements: _$x.without(this.props.elements, element)
    });
  },
  _moveElementUp: function _moveElementUp(index) {
    var element = this.props.elements[index];

    var newElements = _$x.without(this.props.elements, element);

    newElements.splice(index - 1, 0, element);
    this.change({
      elements: newElements
    });
  },
  _moveElementDown: function _moveElementDown(index) {
    var element = this.props.elements[index];

    var newElements = _$x.without(this.props.elements, element);

    newElements.splice(index + 1, 0, element);
    this.change({
      elements: newElements
    });
  },

  change() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    return Changeable$p.change.apply(this, args);
  },

  render: function render() {
    /* eslint-disable max-len */
    return /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-interaction-editor"
    }, /*#__PURE__*/React$I.createElement(ElementContainer, {
      title: "Grid settings"
    }, /*#__PURE__*/React$I.createElement(GraphSettings$1, {
      editableSettings: ["canvas", "graph"],
      box: this.props.graph.box,
      labels: this.props.graph.labels,
      range: this.props.graph.range,
      step: this.props.graph.tickStep,
      gridStep: this.props.graph.gridStep,
      markings: this.props.graph.markings,
      onChange: this._updateGraphProps
    }), this.props.graph.valid !== true && /*#__PURE__*/React$I.createElement("div", null, this.props.graph.valid)), _$x.map(this.props.elements, function (element, n) {
      if (element.type === "movable-point") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Movable point", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(x_{" + element.options.varSubscript + "}, y_{" + element.options.varSubscript + "})")),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement.bind(this, n),
          key: element.key
        }, /*#__PURE__*/React$I.createElement(MovablePointEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      } else if (element.type === "movable-line") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Movable line", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(x_{" + element.options.startSubscript + "}, y_{" + element.options.startSubscript + "})"), " ", "to", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(x_{" + element.options.endSubscript + "}, y_{" + element.options.endSubscript + "})")),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement.bind(this, n),
          key: element.key
        }, /*#__PURE__*/React$I.createElement(MovableLineEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      } else if (element.type === "point") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Point", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(" + element.options.coordX + ", " + element.options.coordY + ")")),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement.bind(this, n),
          key: element.key
        }, /*#__PURE__*/React$I.createElement(PointEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      } else if (element.type === "line") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Line", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(" + element.options.startX + ", " + element.options.startY + ")"), " ", "to", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(" + element.options.endX + ", " + element.options.endY + ")")),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement.bind(this, n),
          key: element.key
        }, /*#__PURE__*/React$I.createElement(LineEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      } else if (element.type === "function") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Function", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, element.options.funcName + "(x) = " + element.options.value)),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement,
          key: element.key
        }, /*#__PURE__*/React$I.createElement(FunctionEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      } else if (element.type === "parametric") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Parametric"),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement,
          key: element.key
        }, /*#__PURE__*/React$I.createElement(ParametricEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      } else if (element.type === "label") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Label", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, element.options.label), " "),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement,
          key: element.key
        }, /*#__PURE__*/React$I.createElement(LabelEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      } else if (element.type === "rectangle") {
        return /*#__PURE__*/React$I.createElement(ElementContainer, {
          title: /*#__PURE__*/React$I.createElement("span", null, "Rectangle", " ", /*#__PURE__*/React$I.createElement(TeX$1, null, "(" + element.options.coordX + ", " + element.options.coordY + ")"), "\xA0\u2014\xA0", /*#__PURE__*/React$I.createElement(TeX$1, null, element.options.width + " \\times " + element.options.height)),
          onUp: n === 0 ? null : this._moveElementUp.bind(this, n),
          onDown: n === this.props.elements.length - 1 ? null : this._moveElementDown.bind(this, n),
          onDelete: this._deleteElement,
          key: element.key
        }, /*#__PURE__*/React$I.createElement(RectangleEditor, _extends({}, element.options, {
          onChange: newProps => {
            var elements = JSON.parse(JSON.stringify(this.props.elements));

            _$x.extend(elements[n].options, newProps);

            this.change({
              elements: elements
            });
          }
        })));
      }
    }, this), /*#__PURE__*/React$I.createElement("div", {
      className: "perseus-widget-interaction-editor-select-element"
    }, /*#__PURE__*/React$I.createElement("select", {
      onChange: this._addNewElement
    }, /*#__PURE__*/React$I.createElement("option", {
      value: ""
    }, "Add an element", "\u2026"), /*#__PURE__*/React$I.createElement("option", {
      disabled: true
    }, "--"), /*#__PURE__*/React$I.createElement("option", {
      value: "point"
    }, "Point"), /*#__PURE__*/React$I.createElement("option", {
      value: "line"
    }, "Line segment"), /*#__PURE__*/React$I.createElement("option", {
      value: "function"
    }, "Function plot"), /*#__PURE__*/React$I.createElement("option", {
      value: "parametric"
    }, "Parametric plot"), /*#__PURE__*/React$I.createElement("option", {
      value: "label"
    }, "Label"), /*#__PURE__*/React$I.createElement("option", {
      value: "rectangle"
    }, "Rectangle"), /*#__PURE__*/React$I.createElement("option", {
      value: "movable-point"
    }, "\u2605 Movable point"), /*#__PURE__*/React$I.createElement("option", {
      value: "movable-line"
    }, "\u2605 Movable line segment"))));
    /* eslint-enable max-len */
  },

  serialize() {
    return EditorJsonify$8.serialize.call(this);
  }

});
_module_$H.exports = InteractionEditor;
var _widgetsInteractionEditorJsx = _module_$H.exports;

var _module_$G = {
  exports: {}
};
/* eslint-disable brace-style, no-redeclare, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/sort-comp, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$H = _react__default["default"];
var _$w = _underscore__default["default"];
var Changeable$o = Changeable$Q;
var Graphie$2 = _componentsGraphieJsx;
var Label = Graphie$2.Label;
var Line = Graphie$2.Line;
var MovablePoint$1 = Graphie$2.MovablePoint;
var MovableLine$1 = Graphie$2.MovableLine;
var Plot$1 = Graphie$2.Plot;
var PlotParametric = Graphie$2.PlotParametric;
var Point = Graphie$2.Point;
var Rect = Graphie$2.Rect;
var kvector$1 = _kmath3.vector; // Memoize KAS parsing

var KAShashFunc = (expr, options) => {
  options = options || {};
  var result = expr + "||" + options.decimal_separatpr + "||";
  var functions = options.functions;
  var functionsLength = functions ? functions.length : 0;

  for (var i = 0; i < functionsLength; i++) {
    result += functions[i] + "|";
  }

  return result;
};

var _parseCache = Object.create(null);

var KASparse = (expr, options) => {
  var hash = KAShashFunc(expr, options);
  var cached = _parseCache[hash];

  if (cached) {
    return cached;
  }

  cached = KAS.parse(expr, options);
  _parseCache[hash] = cached;
  return cached;
};

var _compileCache = Object.create(null);

var KAScompile = (expr, options) => {
  var hash = KAShashFunc(expr, options);
  var cached = _compileCache[hash];

  if (cached) {
    return cached;
  }

  var parsed = KAS.parse(expr, options).expr;
  cached = parsed ? parsed.compile() : function () {
    return 0;
  };
  _compileCache[hash] = cached;
  return cached;
};

var defaultInteractionProps = {
  graph: {
    box: [400, 400],
    labels: ["x", "y"],
    range: [[-10, 10], [-10, 10]],
    tickStep: [1, 1],
    gridStep: [1, 1],
    markings: "graph"
  },
  elements: []
};
var Interaction = createReactClass({
  displayName: "Interaction",
  // TODO(eater): Make more better
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$o.propTypes), {}, {
    graph: PropTypes.object,
    elements: PropTypes.arrayOf(PropTypes.object)
  }),
  getDefaultProps: function getDefaultProps() {
    return defaultInteractionProps;
  },
  getInitialState: function getInitialState() {
    return {
      variables: this._getInitialVariables(this.props.elements),
      functions: this._getInitialFunctions(this.props.elements)
    };
  },
  _getInitialVariables: function _getInitialVariables(elements) {
    var variables = {}; // TODO(eater): look at all this copypasta! refactor this!

    _$w.each(_$w.where(elements, {
      type: "movable-point"
    }), function (element) {
      var subscript = element.options.varSubscript;
      var startXExpr = KASparse(element.options.startX || "0").expr;
      var startYExpr = KASparse(element.options.startY || "0").expr;
      var startX = 0;
      var startY = 0;

      if (startXExpr) {
        startX = startXExpr.eval({}) || 0;
      }

      if (startYExpr) {
        startY = startYExpr.eval({}) || 0;
      }

      variables["x_" + subscript] = startX;
      variables["y_" + subscript] = startY;
    }, this);

    _$w.each(_$w.where(elements, {
      type: "movable-line"
    }), function (element) {
      var startSubscript = element.options.startSubscript;
      var endSubscript = element.options.endSubscript;
      var startXExpr = KASparse(element.options.startX || "0").expr;
      var startYExpr = KASparse(element.options.startY || "0").expr;
      var endXExpr = KASparse(element.options.endX || "0").expr;
      var endYExpr = KASparse(element.options.endY || "0").expr;
      var startX = 0;
      var startY = 0;
      var endX = 0;
      var endY = 0;

      if (startXExpr) {
        startX = startXExpr.eval({}) || 0;
      }

      if (startYExpr) {
        startY = startYExpr.eval({}) || 0;
      }

      if (endXExpr) {
        endX = endXExpr.eval({}) || 0;
      }

      if (endYExpr) {
        endY = endYExpr.eval({}) || 0;
      }

      variables["x_" + startSubscript] = startX;
      variables["y_" + startSubscript] = startY;
      variables["x_" + endSubscript] = endX;
      variables["y_" + endSubscript] = endY;
    }, this);

    _$w.each(_$w.where(elements, {
      type: "function"
    }), function (element) {
      variables[element.options.funcName] = element.options.value;
    });

    return variables;
  },
  _getInitialFunctions: function _getInitialFunctions(elements) {
    return _$w.map(_$w.where(elements, {
      type: "function"
    }), element => element.options.funcName);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      variables: this._getInitialVariables(nextProps.elements),
      functions: this._getInitialFunctions(nextProps.elements)
    });
  },
  _setupGraphie: function _setupGraphie(graphie, options) {
    graphie.graphInit(_$w.extend({}, options, {
      grid: _$w.contains(["graph", "grid"], this.props.graph.markings),
      axes: _$w.contains(["graph"], this.props.graph.markings),
      ticks: _$w.contains(["graph"], this.props.graph.markings),
      labels: _$w.contains(["graph"], this.props.graph.markings),
      labelFormat: function labelFormat(s) {
        return "\\small{" + s + "}";
      },
      axisArrows: "<->",
      unityLabels: false
    }));

    if (this.props.graph.markings === "graph") {
      var labels = this.props.graph.labels;
      var range = this.props.graph.range;
      graphie.label([0, range[1][1]], labels[1], "above");
      graphie.label([range[0][1], 0], labels[0], "right");
    }
  },
  _updatePointLocation: function _updatePointLocation(subscript, coord) {
    var variables = _$w.clone(this.state.variables);

    variables["x_" + subscript] = coord[0];
    variables["y_" + subscript] = coord[1];
    this.setState({
      variables: variables
    });
    this.props.trackInteraction();
  },
  _updateLineLocation: function _updateLineLocation(options, startCoord) {
    var xDiff = this._eval("(" + options.endX + ")-(" + options.startX + ")");

    var yDiff = this._eval("(" + options.endY + ")-(" + options.startY + ")");

    var endCoord = kvector$1.add(startCoord, [xDiff, yDiff]);

    var variables = _$w.clone(this.state.variables);

    variables["x_" + options.startSubscript] = startCoord[0];
    variables["y_" + options.startSubscript] = startCoord[1];
    variables["x_" + options.endSubscript] = endCoord[0];
    variables["y_" + options.endSubscript] = endCoord[1];
    this.setState({
      variables: variables
    });
    this.props.trackInteraction();
  },
  _eval: function _eval(expression, variables) {
    var func = KAScompile(expression, {
      functions: this.state.functions
    });

    var compiledVars = _$w.extend({}, this.state.variables, variables);

    _$w.each(_$w.keys(compiledVars), name => {
      if (_$w.isString(compiledVars[name])) {
        var func = KAScompile(compiledVars[name], {
          functions: this.state.functions
        });

        compiledVars[name] = function (x) {
          return func(_$w.extend({}, compiledVars, {
            x: x
          }));
        };
      }
    }); // Default to 0 if the expression couldn't be parsed


    return func(compiledVars) || 0;
  },
  // Return an array of all the variables in an expression
  _extractVars: function _extractVars(expr) {
    if (expr == null) {
      return [];
    }

    var vars = [];

    _$w.each(expr.args(), function (arg) {
      if (arg && arg.constructor.name === "Expr") {
        vars = vars.concat(this._extractVars(arg));
      }
    }, this);

    if (expr.name() === "Var") {
      vars.push(expr.prettyPrint());
    }

    return vars;
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$o.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$H.createElement(Graphie$2, {
      box: this.props.graph.box,
      range: this.props.graph.range,
      options: this.props.graph,
      setup: this._setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }, _$w.map(this.props.elements, function (element, n) {
      if (element.type === "point") {
        return /*#__PURE__*/React$H.createElement(Point, {
          key: element.key,
          coord: [this._eval(element.options.coordX), this._eval(element.options.coordY)],
          color: element.options.color
        });
      } else if (element.type === "line") {
        var start = [this._eval(element.options.startX), this._eval(element.options.startY)];
        var end = [this._eval(element.options.endX), this._eval(element.options.endY)];
        return /*#__PURE__*/React$H.createElement(Line, {
          key: element.key,
          start: start,
          end: end,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            arrows: element.options.arrows
          }
        });
      } else if (element.type === "movable-point") {
        // TODO(eater): Would be nice if the constraint
        // system were more flexible.
        var constraints = [coord => {
          var coordX = Math.max(this._eval(element.options.constraintXMin), Math.min(this._eval(element.options.constraintXMax), coord[0]));
          var coordY = Math.max(this._eval(element.options.constraintYMin), Math.min(this._eval(element.options.constraintYMax), coord[1]));
          return [coordX, coordY];
        }];

        if (element.options.constraint === "snap") {
          constraints.push(MovablePoint$1.constraints.snap(element.options.snap));
        } else if (element.options.constraint === "x") {
          constraints.push(coord => {
            return [this._eval(element.options.constraintFn, {
              y: coord[1]
            }), coord[1]];
          });
        } else if (element.options.constraint === "y") {
          constraints.push(coord => {
            return [coord[0], this._eval(element.options.constraintFn, {
              x: coord[0]
            })];
          });
        } // TODO(eater): foo_[xyz] are hacky non-props to
        // get the component to update when constraints
        // change


        return /*#__PURE__*/React$H.createElement(MovablePoint$1, {
          key: element.key,
          coord: [this.state.variables["x_" + element.options.varSubscript], this.state.variables["y_" + element.options.varSubscript]],
          constraints: constraints,
          foo_x: element.options.constraint,
          foo_y: element.options.constraintFn,
          foo_z: element.options.snap,
          onMove: _$w.partial(this._updatePointLocation, element.options.varSubscript)
        });
      } else if (element.type === "movable-line") {
        // TODO(eater): Would be nice if the constraint
        // system were more flexible.
        // TODO(eater): Don't duplicate this code from
        // movable-point above
        var constraints = [coord => {
          var coordX = Math.max(this._eval(element.options.constraintXMin), Math.min(this._eval(element.options.constraintXMax), coord[0]));
          var coordY = Math.max(this._eval(element.options.constraintYMin), Math.min(this._eval(element.options.constraintYMax), coord[1]));
          return [coordX, coordY];
        }];

        if (element.options.constraint === "snap") {
          constraints.push(MovablePoint$1.constraints.snap(element.options.snap));
        } else if (element.options.constraint === "x") {
          constraints.push(coord => {
            return [this._eval(element.options.constraintFn, {
              y: coord[1]
            }), coord[1]];
          });
        } else if (element.options.constraint === "y") {
          constraints.push(coord => {
            return [coord[0], this._eval(element.options.constraintFn, {
              x: coord[0]
            })];
          });
        }

        var start = [this.state.variables["x_" + element.options.startSubscript], this.state.variables["y_" + element.options.startSubscript]];
        var end = [this.state.variables["x_" + element.options.endSubscript], this.state.variables["y_" + element.options.endSubscript]];
        return /*#__PURE__*/React$H.createElement(MovableLine$1, {
          key: element.key,
          constraints: constraints,
          onMove: _$w.bind(this._updateLineLocation, this, element.options),
          foo_x: element.options.constraint,
          foo_y: element.options.constraintFn,
          foo_z: element.options.snap
        }, /*#__PURE__*/React$H.createElement(MovablePoint$1, {
          coord: start,
          static: true,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        }), /*#__PURE__*/React$H.createElement(MovablePoint$1, {
          coord: end,
          static: true,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        }));
      } else if (element.type === "function") {
        var fn = x => {
          return this._eval(element.options.value, {
            x: x
          });
        }; // find all the variables referenced by this
        // function


        var vars = _$w.without(this._extractVars(KASparse(element.options.value).expr), "x"); // and find their values, so we redraw if any
        // change


        var varValues = _$w.object(vars, _$w.map(vars, v => this.state.variables[v]));

        var range = [this._eval(element.options.rangeMin, this.state.variables), this._eval(element.options.rangeMax, this.state.variables)];
        return /*#__PURE__*/React$H.createElement(Plot$1, {
          key: element.key,
          fn: fn,
          foo_fn: element.options.value,
          foo_varvalues: varValues,
          range: range,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            plotPoints: 100 // TODO(eater): why
            // so slow?

          }
        });
      } else if (element.type === "parametric") {
        var fn = t => {
          return [this._eval(element.options.x, {
            t: t
          }), this._eval(element.options.y, {
            t: t
          })];
        }; // find all the variables referenced by this
        // function


        var vars = _$w.without(this._extractVars(KASparse(element.options.x).expr).concat(this._extractVars(KASparse(element.options.y).expr)), "t"); // and find their values, so we redraw if any change


        var varValues = _$w.object(vars, _$w.map(vars, v => this.state.variables[v]));

        var range = [this._eval(element.options.rangeMin, this.state.variables), this._eval(element.options.rangeMax, this.state.variables)];
        return /*#__PURE__*/React$H.createElement(PlotParametric, {
          key: element.key,
          fn: fn,
          foo_fnx: element.options.x,
          foo_fny: element.options.y,
          foo_varvalues: varValues,
          range: range,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            plotPoints: 100 // TODO(eater): why
            // so slow?

          }
        });
      } else if (element.type === "label") {
        var coord = [this._eval(element.options.coordX), this._eval(element.options.coordY)];
        return /*#__PURE__*/React$H.createElement(Label, {
          key: n + 1,
          coord: coord,
          text: element.options.label,
          style: {
            color: element.options.color
          }
        });
      } else if (element.type === "rectangle") {
        return /*#__PURE__*/React$H.createElement(Rect, {
          key: n + 1,
          x: this._eval(element.options.coordX),
          y: this._eval(element.options.coordY),
          width: _$w.max([this._eval(element.options.width), 0]),
          height: _$w.max([this._eval(element.options.height), 0]),
          style: {
            stroke: "none",
            fill: element.options.color
          }
        });
      }
    }, this));
  },
  getUserInput: function getUserInput() {
    // TODO(eater): Perhaps we want to be able to record the state of the
    // user's interaction. Unfortunately sending all the props will
    // probably make the attempt payload too large. So for now, don't send
    // anything.
    return {};
  },
  simpleValidate: function simpleValidate(rubric) {
    return Interaction.validate(this.getUserInput(), rubric);
  }
});

_$w.extend(Interaction, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

_module_$G.exports = {
  name: "interaction",
  displayName: "Interaction",
  widget: Interaction,
  transform: _$w.identity,
  hidden: true
};
var _widgetsInteractionJsx = _module_$G.exports;

var _module_$F = {
  exports: {}
};
/* eslint-disable no-var, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$G = _react__default["default"];
var _$v = _underscore__default["default"];
var Util$5 = Util$q;
var Changeable$n = Changeable$Q;
var EditorJsonify$7 = _mixinsEditorJsonifyJsx;
var BlurInput$3 = _reactComponentsBlurInputJsx;
var Editor$6 = _editorJsx;
var InfoTip$6 = _componentsInfoTipJsx;
var InlineIcon$b = _componentsInlineIconJsx;
var RangeInput = _componentsRangeInputJsx;
var defaultBoxSize$1 = 400;
var defaultRange$1 = [0, 10];
var defaultBackgroundImage$1 = {
  url: null,
  width: 0,
  height: 0
}; // Match any image URL (including "web+graphie" links) that is hosted by KA.
// We're somewhat generous in our AWS URL matching
// ("ka-<something>.s3.amazonaws.com") so that we don't have to update Perseus
// every time we add a new proxied AWS bucket.

var INTERNALLY_HOSTED_DOMAINS = "(" + "ka-.*.s3.amazonaws.com|" + "(fastly|cdn).kastatic.org|" + "khanacademy.org|" + "kasandbox.org" + ")";
var INTERNALLY_HOSTED_URL_RE = new RegExp("^(https?|web\\+graphie)://[^/]*" + INTERNALLY_HOSTED_DOMAINS);
/**
 * Alignment option for captions, relative to specified coordinates.
 */

var captionAlignments = ["center", "above", "above right", "right", "below right", "below", "below left", "left", "above left"];
var ImageEditor = createReactClass({
  displayName: "ImageEditor",
  propTypes: _objectSpread2({}, Changeable$n.propTypes),
  componentDidMount: function componentDidMount() {
    // defer this because it can call a change handler synchronously
    _$v.defer(() => {
      var url = this.props.backgroundImage.url;
      this.onUrlChange(url, true);
    });
  },
  getDefaultProps: function getDefaultProps() {
    return {
      title: "",
      range: [defaultRange$1, defaultRange$1],
      box: [defaultBoxSize$1, defaultBoxSize$1],
      backgroundImage: defaultBackgroundImage$1,
      labels: [],
      alt: "",
      caption: ""
    };
  },
  getInitialState: function getInitialState() {
    return {
      backgroundImageError: ""
    };
  },
  render: function render() {
    var backgroundImage = this.props.backgroundImage;
    var imageSettings = /*#__PURE__*/React$G.createElement("div", {
      className: "image-settings"
    }, /*#__PURE__*/React$G.createElement("div", null, /*#__PURE__*/React$G.createElement("label", null, /*#__PURE__*/React$G.createElement("div", null, "Alt text:", /*#__PURE__*/React$G.createElement(InfoTip$6, null, "This is important for screenreaders. The content of this alt text will be formatted as markdown (tables, emphasis, etc. are supported).")), /*#__PURE__*/React$G.createElement(Editor$6, {
      apiOptions: this.props.apiOptions,
      content: this.props.alt,
      onChange: props => {
        if (props.content != null) {
          this.change("alt", props.content);
        }
      },
      widgetEnabled: false
    }))), /*#__PURE__*/React$G.createElement("div", null, /*#__PURE__*/React$G.createElement("label", null, /*#__PURE__*/React$G.createElement("div", null, "Caption:"), /*#__PURE__*/React$G.createElement(Editor$6, {
      apiOptions: this.props.apiOptions,
      content: this.props.caption,
      onChange: props => {
        if (props.content != null) {
          this.change("caption", props.content);
        }
      },
      widgetEnabled: false
    }))));
    var backgroundImageErrorText = /*#__PURE__*/React$G.createElement("div", {
      className: "renderer-widget-error"
    }, this.state.backgroundImageError);
    return /*#__PURE__*/React$G.createElement("div", {
      className: "perseus-image-editor"
    }, /*#__PURE__*/React$G.createElement("label", null, "Image url:", /*#__PURE__*/React$G.createElement(InfoTip$6, null, "Paste an image or graphie image URL."), this.state.backgroundImageError && backgroundImageErrorText, /*#__PURE__*/React$G.createElement(BlurInput$3, {
      value: backgroundImage.url || "",
      style: {
        width: 332
      },
      onChange: url => this.onUrlChange(url, false)
    })), backgroundImage.url && imageSettings);
  },
  _renderRowForLabel: function _renderRowForLabel(label, i) {
    return /*#__PURE__*/React$G.createElement("tr", {
      key: i
    }, /*#__PURE__*/React$G.createElement("td", null, /*#__PURE__*/React$G.createElement(RangeInput, {
      value: label.coordinates,
      onChange: this.onCoordinateChange.bind(this, i)
    })), /*#__PURE__*/React$G.createElement("td", {
      style: {
        verticalAlign: "bottom",
        width: "5px"
      }
    }, /*#__PURE__*/React$G.createElement("input", {
      type: "text",
      className: "graph-settings-axis-label",
      value: label.content,
      onChange: this.onContentChange.bind(this, i)
    })), /*#__PURE__*/React$G.createElement("td", null, /*#__PURE__*/React$G.createElement("select", {
      className: "perseus-widget-dropdown",
      value: label.alignment,
      onChange: this.onAlignmentChange.bind(this, i)
    }, captionAlignments.map(function (alignment, i) {
      return /*#__PURE__*/React$G.createElement("option", {
        key: "" + i,
        value: alignment
      }, alignment);
    }, this))), /*#__PURE__*/React$G.createElement("td", null, /*#__PURE__*/React$G.createElement("a", {
      href: "#",
      className: "simple-button orange delete-label",
      title: "Remove this label",
      onClick: this.removeLabel.bind(this, i)
    }, /*#__PURE__*/React$G.createElement(InlineIcon$b, iconTrash))));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$n.change.apply(this, args);
  },

  removeLabel: function removeLabel(labelIndex, e) {
    e.preventDefault();

    var labels = _$v.clone(this.props.labels);

    labels.splice(labelIndex, 1);
    this.props.onChange({
      labels: labels
    });
  },
  onCoordinateChange: function onCoordinateChange(labelIndex, newCoordinates) {
    var labels = this.props.labels.slice();
    labels[labelIndex] = _$v.extend({}, labels[labelIndex], {
      coordinates: newCoordinates
    });
    this.props.onChange({
      labels: labels
    });
  },
  onContentChange: function onContentChange(labelIndex, e) {
    var newContent = e.target.value;
    var labels = this.props.labels.slice();
    labels[labelIndex] = _$v.extend({}, labels[labelIndex], {
      content: newContent
    });
    this.props.onChange({
      labels: labels
    });
  },
  onAlignmentChange: function onAlignmentChange(labelIndex, e) {
    var newAlignment = e.target.value;
    var labels = this.props.labels.slice();
    labels[labelIndex] = _$v.extend({}, labels[labelIndex], {
      alignment: newAlignment
    });
    this.props.onChange({
      labels: labels
    });
  },
  setUrl: function setUrl(url, width, height, silent) {
    // Because this calls into WidgetEditor._handleWidgetChange, which
    // checks for this widget's ref to serialize it.
    //
    // Errors if you switch items before the `Image` from `onUrlChange`
    // loads.
    if (!this.isMounted()) {
      return;
    }

    var image = _$v.clone(this.props.backgroundImage);

    image.url = url;
    image.width = width;
    image.height = height;
    var box = [image.width, image.height];
    this.props.onChange({
      backgroundImage: image,
      box: box
    }, null, silent);
  },
  // silently load the image when the component mounts
  // silently update url and sizes when the image loads
  // noisily load the image in response to the author changing it
  onUrlChange: function onUrlChange(url, silent) {
    // All article content must be KA-owned!
    if (!INTERNALLY_HOSTED_URL_RE.test(url)) {
      this.setState({
        backgroundImageError: "Images must be from sites hosted by Khan Academy. " + "Please input a Khan Academy-owned address, or use the " + "Add Image tool to rehost an existing image"
      });
      return;
    } else {
      this.setState({
        backgroundImageError: ""
      });
    } // We update our background image prop after the image loads below. To
    // avoid weirdness when we change to a very slow URL, then a much
    // faster URL, we keep track of the URL we're trying to change to.


    this._leadingUrl = url;

    if (!url) {
      this.setUrl(url, 0, 0, silent);
      return;
    }

    Util$5.getImageSize(url, (width, height) => {
      if (this._leadingUrl !== url) {
        return;
      }

      this.setUrl(url, width, height, true);
    });
  },
  onRangeChange: function onRangeChange(type, newRange) {
    var range = this.props.range.slice();
    range[type] = newRange;
    this.props.onChange({
      range: range
    });
  },

  serialize() {
    return EditorJsonify$7.serialize.call(this);
  }

});
_module_$F.exports = ImageEditor;
var _widgetsImageEditorJsx = _module_$F.exports;

var _module_$E = {
  exports: {}
};
/* eslint-disable no-var, object-curly-spacing */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */
// TODO(kevindangoor) fix these lint errors

/*eslint-disable react/sort-comp, react/jsx-indent-props, react/prop-types,
    react/jsx-closing-bracket-location
*/

var classNames$9 = _classnames__default["default"];
var React$F = _react__default["default"];
var _$u = _underscore__default["default"];
var ApiOptions$e = _perseusApiJsx.Options;
var Changeable$m = Changeable$Q;
var mediaQueries$5 = _stylesMediaQueriesJs;
var Renderer$9 = _rendererJsx;
var SvgImage$1 = _componentsSvgImageJsx;
var defaultBoxSize = 400;
var defaultRange = [0, 10];
var defaultBackgroundImage = {
  url: null,
  width: 0,
  height: 0
}; // NOTE(david): 2016-07-20: This widget supports the 4 alignments specified
//     below, but we want to phase out the floating alignments in the next few
//     weeks. So, we remove the float options from the editor interface.

var supportedAlignments = ["block", "float-left", "float-right", "full-width"];
var editorAlignments = ["block", "full-width"];
var DEFAULT_ALIGNMENT = "block";
var ImageWidget = createReactClass({
  displayName: "ImageWidget",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$m.propTypes), {}, {
    alignment: PropTypes.oneOf(supportedAlignments),
    alt: PropTypes.string,
    apiOptions: ApiOptions$e.propTypes,
    // TODO(alex): Rename to something else, e.g. "image", perhaps flatten
    backgroundImage: PropTypes.shape({
      url: PropTypes.string,
      width: PropTypes.number,
      height: PropTypes.number
    }),
    box: PropTypes.arrayOf(PropTypes.number),
    caption: PropTypes.string,
    // TODO(alex): Convert uses of this widget's labeling functionality to
    // SvgImage wherever possible (almost certainly requires a backfill)
    labels: PropTypes.arrayOf(PropTypes.shape({
      content: PropTypes.string,
      coordinates: PropTypes.arrayOf(PropTypes.number),
      alignment: PropTypes.string
    })),
    range: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number)),
    title: PropTypes.string,
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  }),
  statics: {
    styles: aphrodite.StyleSheet.create({
      caption: {
        display: "inline-block",
        marginTop: baseUnitPx,
        maxWidth: 640,
        [mediaQueries$5.lgOrSmaller]: {
          // TODO(david): This maxWidth is not being used because
          //     it's overriden by the 512px max-width we have on
          //     paragraphs.
          maxWidth: 540
        },
        [mediaQueries$5.smOrSmaller]: {
          maxWidth: 450
        }
      }
    })
  },
  getDefaultProps: function getDefaultProps() {
    return {
      alignment: DEFAULT_ALIGNMENT,
      title: "",
      range: [defaultRange, defaultRange],
      box: [defaultBoxSize, defaultBoxSize],
      backgroundImage: defaultBackgroundImage,
      labels: [],
      alt: "",
      caption: "",
      linterContext: linterContextDefault
    };
  },
  render: function render() {
    var image;
    var alt;
    var {
      apiOptions
    } = this.props;
    var backgroundImage = this.props.backgroundImage;

    if (backgroundImage.url) {
      image = /*#__PURE__*/React$F.createElement(SvgImage$1, {
        src: backgroundImage.url,
        alt:
        /* alt text is formatted in a sr-only
               div next to the image, so we make
               this empty here.
               If there is no alt text at all,
               we don't put an alt attribute on
               the image, so that screen readers
               know there's something they can't
               read there :(.
               NOTE: React <=0.13 (maybe later)
               has a bug where it won't ever
               remove an attribute, so if this
               alt node is ever defined it's
               not removed. This is sort of
               dangerous, but we usually re-key
               new renderers so that they're
               rendered from scratch anyways,
               so this shouldn't be a problem
               in practice right now, although
               it will exhibit weird behaviour
               while editing. */
        this.props.alt ? "" : undefined,
        width: backgroundImage.width,
        height: backgroundImage.height,
        preloader: apiOptions.imagePreloader,
        extraGraphie: {
          box: this.props.box,
          range: this.props.range,
          labels: this.props.labels
        },
        trackInteraction: this.props.trackInteraction,
        zoomToFullSizeOnMobile: apiOptions.isMobile,
        constrainHeight: apiOptions.isMobile,
        allowFullBleed: apiOptions.isMobile
      });
    }

    if (this.props.alt) {
      alt = /*#__PURE__*/React$F.createElement("span", {
        className: "perseus-sr-only"
      }, /*#__PURE__*/React$F.createElement(Renderer$9, {
        content: this.props.alt,
        apiOptions: apiOptions,
        linterContext: this.props.linterContext
      }));
    } // For mobile we combine an image's title and caption.


    if (apiOptions.isMobile) {
      var titleAndCaption;

      if (this.props.title || this.props.caption) {
        var _title = this.props.title; // Bold the title, and make it the first sentence of the
        // caption.

        if (_title) {
          // We add a period to separate the title from the caption
          // (if it exists), unless the title already ends with a
          // punctuation symbol (whitespace ignored). Copied from
          // webapp: https://github.com/Khan/webapp/blob/6e930637edb65696d0749ea0f7558214aee32b4e/javascript/tutorial-shared-package/components/content-description.jsx#L80
          // TODO(charlie): Internationalize this check, and the
          // delimiter that is being inserted.
          if (this.props.caption && !/[.?!"']\s*$/.test(_title)) {
            _title += ".";
          }

          _title = "**".concat(_title, "** ");
        }

        var className = classNames$9({
          "perseus-image-caption": true,
          "has-title": !!_title
        }); // Caption is left-aligned within a container that's centered
        // below the image, with these width constraints:
        //
        // 1. Size caption to width of the image on-screen.
        // 2. ... but constrain its width to a range based on the
        //    device to optimize readability - e.g. [320px, 450px] for
        //    phones.
        // 3. ... unless the image is floated, in which case we don't
        //    want the caption to overflow the image size.
        //
        // TODO(david): If caption is only 1 line long, center-align
        //     the text.

        var alignment = this.props.alignment;
        var isImageFullWidth = alignment === "block" || alignment === "full-width"; // This minWidth takes precedence over minWidth applied via
        // Aphrodite.

        var minWidth = isImageFullWidth ? null : "0 !important";
        titleAndCaption = /*#__PURE__*/React$F.createElement("div", {
          className: className
        }, /*#__PURE__*/React$F.createElement("div", {
          className: aphrodite.css(ImageWidget.styles.caption),
          style: {
            minWidth: minWidth
          }
        }, /*#__PURE__*/React$F.createElement(Renderer$9, {
          content: _title + this.props.caption,
          apiOptions: apiOptions,
          linterContext: this.props.linterContext
        })));
      }

      return /*#__PURE__*/React$F.createElement("div", {
        className: "perseus-image-widget"
      }, image, alt, titleAndCaption);
    } else {
      var title;
      var caption;

      if (this.props.title) {
        title = /*#__PURE__*/React$F.createElement("div", {
          className: "perseus-image-title"
        }, /*#__PURE__*/React$F.createElement(Renderer$9, {
          content: this.props.title,
          apiOptions: apiOptions,
          linterContext: this.props.linterContext
        }));
      }

      if (this.props.caption) {
        caption = /*#__PURE__*/React$F.createElement("div", {
          className: "perseus-image-caption"
        }, /*#__PURE__*/React$F.createElement(Renderer$9, {
          content: this.props.caption,
          apiOptions: apiOptions,
          linterContext: this.props.linterContext
        }));
      }

      return /*#__PURE__*/React$F.createElement("div", {
        className: "perseus-image-widget"
      }, title, image, alt, caption);
    }
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$m.change.apply(this, args);
  },

  getUserInput: function getUserInput() {
    return null;
  },
  simpleValidate: function simpleValidate(rubric) {
    return ImageWidget.validate(this.getUserInput(), rubric);
  },
  focus: $.noop
});

_$u.extend(ImageWidget, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

_module_$E.exports = {
  name: "image",
  // This widget's accessibility depends on its contents: if the image has
  // has a background but no alt text, it is not accessible
  accessible: props => {
    var bgImage = props.backgroundImage;
    return !(bgImage && bgImage.url && !props.alt);
  },
  defaultAlignment: DEFAULT_ALIGNMENT,
  supportedAlignments: editorAlignments,
  displayName: "Image",
  widget: ImageWidget,
  isLintable: true
};
var _widgetsImageJsx = _module_$E.exports;

var _module_$D = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$E = _react__default["default"];
var _$t = _underscore__default["default"];
var Changeable$l = Changeable$Q;
var EditorJsonify$6 = _mixinsEditorJsonifyJsx;
var BlurInput$2 = _reactComponentsBlurInputJsx;
var PropCheckBox$5 = _componentsPropCheckBoxJsx;
/**
 * This is used for editing a name/value pair.
 */

var PairEditor$1 = createReactClass({
  displayName: "PairEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$l.propTypes), {}, {
    name: PropTypes.string,
    value: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      name: "",
      value: ""
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$l.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$E.createElement("fieldset", null, /*#__PURE__*/React$E.createElement("label", null, "Name:", /*#__PURE__*/React$E.createElement(BlurInput$2, {
      value: this.props.name,
      onChange: this.change("name")
    })), /*#__PURE__*/React$E.createElement("label", null, "Value:", /*#__PURE__*/React$E.createElement(BlurInput$2, {
      value: this.props.value,
      onChange: this.change("value")
    })));
  },

  serialize() {
    return EditorJsonify$6.serialize.call(this);
  }

});
/**
 * This is used for editing a set of name/value pairs.
 */

var PairsEditor$1 = createReactClass({
  displayName: "PairsEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$l.propTypes), {}, {
    pairs: PropTypes.arrayOf(PropTypes.shape({
      name: PropTypes.string,
      value: PropTypes.string
    })).isRequired
  }),
  render: function render() {
    var editors = _$t.map(this.props.pairs, (pair, i) => {
      return /*#__PURE__*/React$E.createElement(PairEditor$1, {
        key: i,
        name: pair.name,
        value: pair.value,
        onChange: this.handlePairChange.bind(this, i)
      });
    });

    return /*#__PURE__*/React$E.createElement("div", null, editors);
  },

  change() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return Changeable$l.change.apply(this, args);
  },

  handlePairChange: function handlePairChange(pairIndex, pair) {
    // If they're both non empty, add a new one
    var pairs = this.props.pairs.slice();
    pairs[pairIndex] = pair;
    var lastPair = pairs[pairs.length - 1];

    if (lastPair.name && lastPair.value) {
      pairs.push({
        name: "",
        value: ""
      });
    }

    this.change("pairs", pairs);
  },

  serialize() {
    return EditorJsonify$6.serialize.call(this);
  }

});
/**
 * This is the main editor for this widget, to specify all the options.
 */

var IframeEditor = createReactClass({
  displayName: "IframeEditor",
  propTypes: _objectSpread2({}, Changeable$l.propTypes),
  getDefaultProps: function getDefaultProps() {
    return {
      url: "",
      settings: [{
        name: "",
        value: ""
      }],
      width: "400",
      height: "400",
      allowFullScreen: false,
      allowTopNavigation: false
    };
  },

  change() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return Changeable$l.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$E.createElement("div", null, /*#__PURE__*/React$E.createElement("div", {
      style: {
        fontWeight: "bold",
        textAlign: "center"
      }
    }, "This widget is deprecated! ", /*#__PURE__*/React$E.createElement("br", null), "Try using the Video or CS Program widgets instead."), /*#__PURE__*/React$E.createElement("label", null, "Url or Program ID:", /*#__PURE__*/React$E.createElement(BlurInput$2, {
      name: "url",
      value: this.props.url,
      onChange: this.change("url")
    })), /*#__PURE__*/React$E.createElement("br", null), /*#__PURE__*/React$E.createElement("label", null, "Settings:", /*#__PURE__*/React$E.createElement(PairsEditor$1, {
      name: "settings",
      pairs: this.props.settings,
      onChange: this.handleSettingsChange
    })), /*#__PURE__*/React$E.createElement("br", null), /*#__PURE__*/React$E.createElement("label", null, "Width:", /*#__PURE__*/React$E.createElement(BlurInput$2, {
      name: "width",
      value: this.props.width,
      onChange: this.change("width")
    })), /*#__PURE__*/React$E.createElement("label", null, "Height:", /*#__PURE__*/React$E.createElement(BlurInput$2, {
      name: "height",
      value: this.props.height,
      onChange: this.change("height")
    })), /*#__PURE__*/React$E.createElement(PropCheckBox$5, {
      label: "Allow full screen",
      allowFullScreen: this.props.allowFullScreen,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$E.createElement("br", null), /*#__PURE__*/React$E.createElement(PropCheckBox$5, {
      label: "Allow iframe content to redirect the page",
      allowTopNavigation: this.props.allowTopNavigation,
      onChange: this.props.onChange
    }));
  },
  handleSettingsChange: function handleSettingsChange(settings) {
    this.change({
      settings: settings.pairs
    });
  },

  serialize() {
    return EditorJsonify$6.serialize.call(this);
  }

});
_module_$D.exports = IframeEditor;
var _widgetsIframeEditorJsx = _module_$D.exports;

var _module_$C = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * This is an iframe widget. It is used for rendering an iframe that
 *  then communicates its state via window.postMessage
 * This is useful for embedding arbitrary visualizations/simulations with
 *  completed conditions, such as the mazes and games in Algorithms.
 * It's particularly well suited for embedding our ProcessingJS programs,
 *  but could also be used for embedding viz's hosted elsewhere.
 */

/* globals KA */

var React$D = _react__default["default"];
var _$s = _underscore__default["default"];
var Changeable$k = Changeable$Q;
var WidgetJsonifyDeprecated$1 = _mixinsWidgetJsonifyDeprecatedJsx;
var updateQueryString$1 = Util$q.updateQueryString;
/* This renders the iframe and handles validation via window.postMessage */

var Iframe = createReactClass({
  displayName: "Iframe",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$k.propTypes), {}, {
    width: PropTypes.string,
    height: PropTypes.string,
    url: PropTypes.string,
    settings: PropTypes.array,
    status: PropTypes.oneOf(["incomplete", "incorrect", "correct"]),
    message: PropTypes.string,
    allowFullScreen: PropTypes.bool,
    allowTopNavigation: PropTypes.bool
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      status: "incomplete",
      // optional message
      message: null,
      allowFullScreen: false,
      allowTopNavigation: false
    };
  },
  getUserInput: function getUserInput() {
    return WidgetJsonifyDeprecated$1.getUserInput.call(this);
  },
  handleMessageEvent: function handleMessageEvent(e) {
    // We receive data from the iframe that contains {passed: true/false}
    //  and use that to set the status
    // It could also contain an optional message
    var data = {};

    try {
      data = JSON.parse(e.originalEvent.data);
    } catch (err) {
      return;
    }

    if (_$s.isUndefined(data.testsPassed)) {
      return;
    }

    var status = data.testsPassed ? "correct" : "incorrect";
    this.change({
      status: status,
      message: data.message
    });
  },
  componentDidMount: function componentDidMount() {
    $(window).on("message", this.handleMessageEvent);
  },
  componentWillUnmount: function componentWillUnmount() {
    $(window).off("message", this.handleMessageEvent);
  },
  render: function render() {
    var style = {
      width: this.props.width,
      height: this.props.height
    };
    var url = this.props.url; // If the URL doesnt start with http, it must be a program ID

    if (url && url.length && url.indexOf("http") !== 0) {
      url = "https://www.khanacademy.org/computer-programming/program/" + url + "/embedded?buttons=no&embed=yes&editor=no&author=no";
      url = updateQueryString$1(url, "width", this.props.width);
      url = updateQueryString$1(url, "height", this.props.height); // Origin is used by output.js in deciding to send messages

      url = updateQueryString$1(url, "origin", window.location.origin);
    } // Zero-rated users may incur data charges for viewing non-zero.ka.org
    // resources, so we need to warn them first.


    if (typeof KA !== "undefined" && KA.isZeroRated) {
      if (url.match(/https?:\/\/[^\/]*khanacademy.org/)) {
        // Internal URLs should be rewritten to point at zero.ka.org,
        // unless they already do so
        if (!url.match(/zero.khanacademy.org/)) {
          url = url.replace("khanacademy.org", "zero.khanacademy.org");
        }
      } else {
        // External URLs should be rewritten to point at a warning
        // interstitial
        url = "/zero/external-link?context=iframe&url=" + encodeURIComponent(url);
      }
    } // Turn array of [{name: "", value: ""}] into object


    if (this.props.settings) {
      var settings = {};

      _$s.each(this.props.settings, function (setting) {
        if (setting.name && setting.value) {
          settings[setting.name] = setting.value;
        }
      }); // This becomes available to programs as Program.settings()


      url = updateQueryString$1(url, "settings", JSON.stringify(settings));
    }

    var sandboxProperties = "allow-same-origin allow-scripts"; // TODO(scottgrant): This line is an intentional hack to retain the
    // allow-top-navigation sandbox property. Once our LearnStorm articles
    // have this value checked and published, this line should be removed
    // and replaced with the conditional check below that is commented out.
    // We don't want to break LearnStorm badges, so this will be a two-part
    // deploy.

    sandboxProperties += " allow-top-navigation"; // if (this.props.allowTopNavigation === true) {
    //     sandboxProperties += " allow-top-navigation";
    // }
    // We sandbox the iframe so that we whitelist only the functionality
    //  that we need. This makes it a bit safer in case some content
    //  creator "went wild".
    // http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/

    return /*#__PURE__*/React$D.createElement("iframe", {
      sandbox: sandboxProperties,
      style: style,
      src: url,
      allowFullScreen: this.props.allowFullScreen
    });
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$k.change.apply(this, args);
  },

  simpleValidate: function simpleValidate(rubric) {
    return Iframe.validate(this.getUserInput(), rubric);
  }
});
/**
 * This is the widget's grading function
 */

_$s.extend(Iframe, {
  validate: function validate(state, rubric) {
    // The iframe can tell us whether it's correct or incorrect,
    //  and pass an optional message
    if (state.status === "correct") {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: state.message || null
      };
    } else if (state.status === "incorrect") {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: state.message || null
      };
    } else {
      return {
        type: "invalid",
        message: "Keep going, you're not there yet!"
      };
    }
  }
});

_module_$C.exports = {
  name: "iframe",
  displayName: "Iframe",
  widget: Iframe,
  // Let's not expose it to all content creators yet
  hidden: true
};
var _widgetsIframeJsx = _module_$C.exports;

var _module_$B = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$C = _react__default["default"];
var _$r = _underscore__default["default"];
var ApiOptions$d = _perseusApiJsx.Options;
var Changeable$j = Changeable$Q;
var Editor$5 = _editorJsx;
var GroupEditor = createReactClass({
  displayName: "GroupEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$j.propTypes), {}, {
    content: PropTypes.string,
    widgets: PropTypes.object,
    images: PropTypes.object,
    metadata: PropTypes.any,
    apiOptions: ApiOptions$d.propTypes
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      content: "",
      widgets: {},
      images: {},
      // `undefined` instead of `null` so that getDefaultProps works for
      // `the GroupMetadataEditor`
      metadata: undefined
    };
  },
  render: function render() {
    return /*#__PURE__*/React$C.createElement("div", {
      className: "perseus-group-editor"
    }, /*#__PURE__*/React$C.createElement("div", null, this._renderMetadataEditor()), /*#__PURE__*/React$C.createElement(Editor$5, {
      ref: "editor",
      content: this.props.content,
      widgets: this.props.widgets,
      apiOptions: this.props.apiOptions,
      images: this.props.images,
      widgetEnabled: true,
      immutableWidgets: false,
      onChange: this.props.onChange
    }));
  },
  _renderMetadataEditor: function _renderMetadataEditor() {
    var GroupMetadataEditor = this.props.apiOptions.GroupMetadataEditor;
    return /*#__PURE__*/React$C.createElement(GroupMetadataEditor, {
      value: this.props.metadata,
      onChange: this.change("metadata")
    });
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$j.change.apply(this, args);
  },

  getSaveWarnings: function getSaveWarnings() {
    return this.refs.editor.getSaveWarnings();
  },
  serialize: function serialize() {
    return _$r.extend({}, this.refs.editor.serialize(), {
      metadata: this.props.metadata
    });
  }
});
_module_$B.exports = GroupEditor;
var _widgetsGroupEditorJsx = _module_$B.exports;

var _module_$A = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var classNames$8 = _classnames__default["default"];
var React$B = _react__default["default"];
var _$q = _underscore__default["default"];
var ApiOptions$c = _perseusApiJsx.Options;
var Changeable$i = Changeable$Q;
var Renderer$8 = _rendererJsx;
var Group = createReactClass({
  displayName: "Group",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$i.propTypes), {}, {
    content: PropTypes.string,
    widgets: PropTypes.object,
    images: PropTypes.object,
    icon: PropTypes.object,
    reviewModeRubric: PropTypes.object,
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      content: "",
      widgets: {},
      images: {},
      icon: null,
      linterContext: linterContextDefault
    };
  },
  componentDidMount: function componentDidMount() {
    // TODO(marcia): See comment in render method about our cyclical
    // numbering scheme. We force another render so that we can annotate
    // the group with the correct number.
    this.forceUpdate();
  },
  render: function render() {
    var apiOptions = _$q.extend({}, ApiOptions$c.defaults, this.props.apiOptions, {
      // Api Rewriting to support correct onFocus/onBlur
      // events for the mobile API
      onFocusChange: (newFocus, oldFocus) => {
        if (oldFocus) {
          this.props.onBlur(oldFocus);
        }

        if (newFocus) {
          this.props.onFocus(newFocus);
        }
      }
    }); // Allow a problem number annotation to be added.
    // This is cyclical and should probably be reconsidered. In order to
    // render the annotation ("Question 3 of 10"), we call findWidgets to
    // figure out our index in the list of all fellow group widgets. On
    // first render, though, we don't exist yet in this list, and so we
    // give ourselves number -1. To combat this, we forceUpdate in
    // componentDidMount so that we can number ourselves properly. But,
    // really we should have a more unidirectional flow. TODO(marcia): fix.


    var number = _$q.indexOf(this.props.findWidgets("group"), this);

    var problemNumComponent = this.props.apiOptions.groupAnnotator(number, this.props.widgetId); // This is a little strange because the id of the widget that actually
    // changed is going to be lost in favor of the group widget's id. The
    // widgets prop also wasn't actually changed, and this only serves to
    // alert our renderer (our parent) of the fact that some interaction
    // has occurred.

    var onInteractWithWidget = id => {
      if (this.refs.renderer) {
        this.change("widgets", this.refs.renderer.props.widgets);
      }
    };

    var score = this.refs.renderer && this.refs.renderer.score();
    var isValid = score && score.type !== "invalid";
    var isInvalid = score && score.type === "invalid"; // TODO(mdr): Widgets inside this Renderer are not discoverable through
    //     the parent Renderer's `findWidgets` function.

    return /*#__PURE__*/React$B.createElement("div", {
      className: classNames$8({
        "perseus-group": true,
        "perseus-group-valid-answer": isValid,
        "perseus-group-invalid-answer": isInvalid
      })
    }, problemNumComponent, /*#__PURE__*/React$B.createElement(Renderer$8, _extends({}, this.props, {
      ref: "renderer",
      apiOptions: apiOptions,
      findExternalWidgets: this.props.findWidgets,
      reviewMode: !!this.props.reviewModeRubric,
      onInteractWithWidget: onInteractWithWidget,
      linterContext: this.props.linterContext
    })), this.props.icon && /*#__PURE__*/React$B.createElement("div", {
      className: "group-icon"
    }, this.props.icon));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$i.change.apply(this, args);
  },

  getUserInput: function getUserInput() {
    return this.refs.renderer.getUserInput();
  },
  getSerializedState: function getSerializedState() {
    return this.refs.renderer.getSerializedState();
  },
  restoreSerializedState: function restoreSerializedState(state, callback) {
    this.refs.renderer.restoreSerializedState(state, callback); // Tell our renderer that we have no props to change
    // (all our changes were in state):

    return null;
  },
  simpleValidate: function simpleValidate(rubric) {
    return this.refs.renderer.score();
  },
  // Mobile API:
  getInputPaths: function getInputPaths() {
    return this.refs.renderer.getInputPaths();
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    return this.refs.renderer.setInputValue(path, newValue, cb);
  },
  getAcceptableFormatsForInputPath: function getAcceptableFormatsForInputPath(path) {
    return this.refs.renderer.getAcceptableFormatsForInputPath(path);
  },

  /**
   * WARNING: This is an experimental/temporary API and should not be relied
   *     upon in production code. This function may change its behavior or
   *     disappear without notice.
   *
   * This function was created to allow Renderer.getAllWidgetIds to descend
   * into our renderer.
   */
  getRenderer: function getRenderer() {
    return this.refs.renderer;
  },
  focus: function focus() {
    return this.refs.renderer.focus();
  },
  focusInputPath: function focusInputPath(path) {
    this.refs.renderer.focusPath(path);
  },
  blurInputPath: function blurInputPath(path) {
    this.refs.renderer.blurPath(path);
  },

  showRationalesForCurrentlySelectedChoices() {
    this.refs.renderer.showRationalesForCurrentlySelectedChoices();
  }

});

var traverseChildWidgets$2 = function traverseChildWidgets(props, traverseRenderer) {
  return _$q.extend({}, props, traverseRenderer(props));
};

_module_$A.exports = {
  name: "group",
  displayName: "Group (SAT only)",
  widget: Group,
  traverseChildWidgets: traverseChildWidgets$2,
  hidden: false,
  isLintable: true
};
var _widgetsGroupJsx = _module_$A.exports;

var _module_$z = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$A = _react__default["default"];
var ApiOptions$b = _perseusApiJsx.Options;
var Changeable$h = Changeable$Q;
var Editor$4 = _editorJsx;
var TextInput$4 = _componentsTextInputJsx;
var InlineIcon$a = _componentsInlineIconJsx;
var GradedGroupEditor$1 = createReactClass({
  displayName: "GradedGroupEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$h.propTypes), {}, {
    title: PropTypes.string,
    content: PropTypes.string,
    widgets: PropTypes.object,
    images: PropTypes.object,
    apiOptions: ApiOptions$b.propTypes
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      title: "",
      content: "",
      widgets: {},
      images: {},
      hint: null
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$h.change.apply(this, args);
  },

  handleAddHint: function handleAddHint() {
    var hint = {
      content: ""
    };
    this.props.onChange({
      hint
    }, () => {
      this.refs["hint-editor"].focus();
    });
  },
  handleRemoveHint: function handleRemoveHint(i) {
    this.props.onChange({
      hint: null
    });
  },
  render: function render() {
    return /*#__PURE__*/React$A.createElement("div", {
      className: "perseus-group-editor"
    }, /*#__PURE__*/React$A.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$A.createElement("label", {
      className: aphrodite.css(styles$c.title)
    }, "Title:", " ", /*#__PURE__*/React$A.createElement(TextInput$4, {
      value: this.props.title,
      className: aphrodite.css(styles$c.input),
      onChange: this.change("title")
    }))), /*#__PURE__*/React$A.createElement(Editor$4, {
      ref: "editor",
      content: this.props.content,
      widgets: this.props.widgets,
      apiOptions: this.props.apiOptions,
      images: this.props.images,
      widgetEnabled: true,
      immutableWidgets: false,
      onChange: this.props.onChange,
      warnNoPrompt: true,
      warnNoWidgets: true
    }), !this.props.hint && /*#__PURE__*/React$A.createElement("button", {
      type: "button",
      style: {
        marginTop: 10
      },
      className: "add-hint simple-button orange",
      onClick: this.handleAddHint
    }, /*#__PURE__*/React$A.createElement(InlineIcon$a, iconPlus), " Add a hint"), this.props.hint && /*#__PURE__*/React$A.createElement("div", {
      className: "perseus-hint-editor"
    }, /*#__PURE__*/React$A.createElement("div", {
      className: aphrodite.css(styles$c.hintsTitle)
    }, "Hint"), /*#__PURE__*/React$A.createElement(Editor$4, {
      ref: "hint-editor",
      content: this.props.hint ? this.props.hint.content : "",
      widgets: this.props.hint ? this.props.hint.widgets : {},
      apiOptions: this.props.apiOptions,
      images: this.props.hint && this.props.hint.images,
      widgetEnabled: true,
      immutableWidgets: false,
      onChange: props => {
        // Copy all props over from the existing hint
        // and then add new props.
        this.change("hint", Object.assign({}, this.props.hint, props));
      }
    }), /*#__PURE__*/React$A.createElement("button", {
      type: "button",
      className: "remove-hint simple-button orange",
      onClick: this.handleRemoveHint
    }, /*#__PURE__*/React$A.createElement(InlineIcon$a, iconTrash), " Remove this hint")));
  },
  getSaveWarnings: function getSaveWarnings() {
    return this.refs.editor.getSaveWarnings();
  },
  serialize: function serialize() {
    return _objectSpread2(_objectSpread2({
      title: this.props.title
    }, this.refs.editor.serialize()), {}, {
      hint: this.refs["hint-editor"] && this.refs["hint-editor"].serialize()
    });
  }
});
var styles$c = aphrodite.StyleSheet.create({
  title: {
    fontSize: 18,
    fontWeight: "bold"
  },
  input: {
    fontSize: 18
  },
  hintsTitle: {
    marginTop: 10,
    fontSize: "110%",
    fontWeight: "bold"
  }
});
_module_$z.exports = GradedGroupEditor$1;
var _widgetsGradedGroupEditorJsx = _module_$z.exports;

var _module_$y = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$z = _react__default["default"];
var ApiOptions$a = _perseusApiJsx.Options;
var Changeable$g = Changeable$Q;
var GradedGroupEditor = _widgetsGradedGroupEditorJsx;
var GradedGroupSetEditor = createReactClass({
  displayName: "GradedGroupSetEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$g.propTypes), {}, {
    apiOptions: ApiOptions$a.propTypes,
    gradedGroups: PropTypes.array,
    onChange: PropTypes.func.isRequired
  }),

  getDefaultProps() {
    return {
      gradedGroups: []
    };
  },

  componentWillMount() {
    this._editors = [];
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$g.change.apply(this, args);
  },

  getSaveWarnings() {
    return [].concat(...this._editors.map(editor => editor.getSaveWarnings()));
  },

  serialize() {
    return {
      gradedGroups: this.props.gradedGroups
    };
  },

  renderGroups() {
    if (!this.props.gradedGroups) {
      return null;
    }

    return this.props.gradedGroups.map((group, i) => /*#__PURE__*/React$z.createElement(GradedGroupEditor, _extends({
      key: i,
      ref: el => this._editors[i] = el
    }, group, {
      apiOptions: this.props.apiOptions,
      widgetEnabled: true,
      immutableWidgets: false,
      onChange: data => this.change("gradedGroups", setArrayItem(this.props.gradedGroups, i, _objectSpread2(_objectSpread2({}, this.props.gradedGroups[i]), data)))
    })));
  },

  addGroup() {
    var groups = this.props.gradedGroups || [];
    this.change("gradedGroups", groups.concat([GradedGroupEditor.getDefaultProps()]));
  },

  render() {
    return /*#__PURE__*/React$z.createElement("div", {
      className: "perseus-group-editor"
    }, this.renderGroups(), /*#__PURE__*/React$z.createElement("button", {
      onClick: this.addGroup
    }, "Add group"));
  }

});

var setArrayItem = (list, i, value) => [...list.slice(0, i), value, ...list.slice(i + 1)];

_module_$y.exports = GradedGroupSetEditor;
var _widgetsGradedGroupSetEditorJsx = _module_$y.exports;

var _module_$x = {
  exports: {}
};
/* globals i18n */

/**
 * Renders answer bar for mobile graded groups. [STATELESS]
 */

var React$y = _react__default["default"];
var ApiOptions$9 = _perseusApiJsx.Options;
var InlineIcon$9 = _componentsInlineIconJsx;
var ANSWER_BAR_STATES$1 = {
  // Initial state before the question is answerable.  The user must complete
  // each of the widgets before the answer bar becomes visible.
  HIDDEN: Symbol("HIDDEN"),
  // The 'Check' button is active whenever the question is answerable or any
  // of the input widgets have been modified after getting the answer wrong.
  ACTIVE: Symbol("ACTIVE"),
  // The 'Check' button is disabled and there is no message.  This occurs when
  // some of the widgets haven't been filled in after the has already become
  // visible.
  INACTIVE: Symbol("INACTIVE"),
  // This happens immediately after clicking 'Check' with a wrong answer.
  // The 'Check' button is disabled and the 'Try Again' message is displayed.
  INCORRECT: Symbol("INCORRECT"),
  // Final state.  This occurs after the user submits the correct answer.
  // The widgets in this grade-group are disabled.
  CORRECT: Symbol("CORRECT")
};
var GradedGroupAnswerBar$1 = createReactClass({
  displayName: "GradedGroupAnswerBar",
  propTypes: {
    // TODO(kevinb) update to oneOf once we update to 15.2
    answerBarState: PropTypes.any.isRequired,
    apiOptions: ApiOptions$9.propTypes,
    onCheckAnswer: PropTypes.func.isRequired,
    // The function to call when clicking "Next question" after correctly
    // answering one graded group out of a set. If this is null, the
    // "Next question" button will not appear.
    onNextQuestion: PropTypes.func
  },

  render() {
    var {
      apiOptions,
      answerBarState,
      onCheckAnswer,
      onNextQuestion
    } = this.props;

    var answerBarStyle = _objectSpread2(_objectSpread2({}, styles$b.answerBar), {}, {
      backgroundColor: answerBarState === ANSWER_BAR_STATES$1.CORRECT ? gray95 : "white",
      // Center the "Correct!" message only when there's no next question
      justifyContent: answerBarState === ANSWER_BAR_STATES$1.CORRECT && !onNextQuestion ? "center" : "space-between"
    });

    var buttonStyle = _objectSpread2(_objectSpread2({}, styles$b.button), {}, {
      // "Check" and "Next question" buttons should both be green
      backgroundColor: answerBarState === ANSWER_BAR_STATES$1.ACTIVE || answerBarState === ANSWER_BAR_STATES$1.CORRECT ? kaGreen : gray85
    });

    var textStyle = _objectSpread2(_objectSpread2({}, styles$b.text), {}, {
      color: answerBarState === ANSWER_BAR_STATES$1.CORRECT ? kaGreen : gray68
    });

    var message = answerBarState === ANSWER_BAR_STATES$1.INCORRECT ? /*#__PURE__*/React$y.createElement("span", {
      style: textStyle
    }, /*#__PURE__*/React$y.createElement("span", {
      style: styles$b.tryAgainIcon
    }, /*#__PURE__*/React$y.createElement(InlineIcon$9, iconTryAgain)), /*#__PURE__*/React$y.createElement("span", {
      style: {
        marginLeft: 8
      }
    }, i18n._("Keep trying"))) : /*#__PURE__*/React$y.createElement("span", null); // empty span keeps the button on the right side

    if (answerBarState !== ANSWER_BAR_STATES$1.CORRECT) {
      var buttonLabel = answerBarState === ANSWER_BAR_STATES$1.INCORRECT ? i18n._("Try again") : i18n._("Check"); // Use <button> instead of <input> b/c iOS 9.3 on iPhone 6 renders
      // the <input> as a faded out green button instead of using our
      // styles.

      return /*#__PURE__*/React$y.createElement("div", {
        style: answerBarStyle
      }, message, /*#__PURE__*/React$y.createElement("button", {
        style: buttonStyle,
        disabled: apiOptions.readOnly || answerBarState !== ANSWER_BAR_STATES$1.ACTIVE,
        onClick: onCheckAnswer
      }, buttonLabel));
    } else {
      return /*#__PURE__*/React$y.createElement("div", {
        style: answerBarStyle
      }, /*#__PURE__*/React$y.createElement("span", {
        style: textStyle
      }, /*#__PURE__*/React$y.createElement("span", {
        style: {
          fontSize: 28,
          color: "#FFB300"
        }
      }, /*#__PURE__*/React$y.createElement(InlineIcon$9, _extends({}, iconStar, {
        style: {
          marginBottom: 5
        }
      }))), /*#__PURE__*/React$y.createElement("span", {
        style: {
          marginLeft: 8
        }
      }, i18n._("Correct!"))), onNextQuestion && /*#__PURE__*/React$y.createElement("button", {
        style: buttonStyle,
        onClick: onNextQuestion
      }, i18n._("Next question")));
    }
  }

});
var fontSize = 17;
var styles$b = {
  answerBar: {
    display: "flex",
    alignItems: "center",
    height: 68,
    // so that we don't have calculate the vertical padding
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    marginBottom: negativePhoneMargin,
    marginTop: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: 10,
    borderTop: "1px solid ".concat(gray76)
  },
  // TODO(kevinb) figure out a way inject styles/components from webapp
  button: {
    height: 48,
    width: 143,
    borderRadius: 4,
    color: "white",
    fontFamily: boldFontFamily,
    fontSize: fontSize,
    border: "none"
  },
  tryAgainIcon: {
    fontSize: 28,
    color: "#63D9EA",
    transform: "scale(-1,1) rotate(-268deg)"
  },
  text: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    fontFamily: boldFontFamily,
    fontSize: fontSize
  }
};
GradedGroupAnswerBar$1.ANSWER_BAR_STATES = ANSWER_BAR_STATES$1;
_module_$x.exports = GradedGroupAnswerBar$1;
var _gradedGroupAnswerBarJsx = _module_$x.exports;

var _module_$w = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/* globals i18n */

var classNames$7 = _classnames__default["default"];
var React$x = _react__default["default"];
var _$p = _underscore__default["default"];
var ApiOptions$8 = _perseusApiJsx.Options;
var Changeable$f = Changeable$Q;
var InlineIcon$8 = _componentsInlineIconJsx;
var Renderer$7 = _rendererJsx;
var GradedGroupAnswerBar = _gradedGroupAnswerBarJsx; // A Graded Group is more or less a Group widget that displays a check
// answer button below the rendered content. When clicked, the widget grades
// the stuff inside and displays feedback about whether the inputted answer was
// correct or not.

var GRADING_STATUSES = {
  ungraded: "ungraded",
  correct: "correct",
  incorrect: "incorrect",
  invalid: "invalid"
};
var ANSWER_BAR_STATES = GradedGroupAnswerBar.ANSWER_BAR_STATES; // Update answer bar state based on current state and whether the question is
// answerable (all parts have been filled out) or not.

var getNextState = (currentState, answerable) => {
  switch (currentState) {
    case ANSWER_BAR_STATES.HIDDEN:
      return answerable ? ANSWER_BAR_STATES.ACTIVE : currentState;

    case ANSWER_BAR_STATES.ACTIVE:
      return !answerable ? ANSWER_BAR_STATES.INACTIVE : currentState;

    case ANSWER_BAR_STATES.INACTIVE:
      return answerable ? ANSWER_BAR_STATES.ACTIVE : currentState;

    case ANSWER_BAR_STATES.INCORRECT:
      return answerable ? ANSWER_BAR_STATES.ACTIVE : ANSWER_BAR_STATES.INACTIVE;

    default:
      return currentState;
  }
}; // Prepended to all invalid messages to make the widget messages a bit clearer


var INVALID_MESSAGE_PREFIX = "We couldn't grade your answer.";
var DEFAULT_INVALID_MESSAGE = "It looks like you left something blank or " + "entered in an invalid answer.";
var GradedGroup$1 = createReactClass({
  displayName: "GradedGroup",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$f.propTypes), {}, {
    apiOptions: ApiOptions$8.propTypes,
    content: PropTypes.string,
    hasHint: PropTypes.bool,
    hint: PropTypes.object,
    images: PropTypes.object,
    inGradedGroupSet: PropTypes.bool,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func,
    // The function to call when clicking "Next question" after correctly
    // answering one graded group out of a set. If this is null, the
    // "Next question" button will not appear.
    onNextQuestion: PropTypes.func,
    title: PropTypes.string,
    trackInteraction: PropTypes.func.isRequired,
    widgets: PropTypes.object,
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      title: "",
      content: "",
      widgets: {},
      images: {},
      hint: null,
      hasHint: false,
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      status: GRADING_STATUSES.ungraded,
      showHint: false,
      message: "",
      answerBarState: ANSWER_BAR_STATES.HIDDEN
    };
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$f.change.apply(this, args);
  },

  // This is a little strange because the id of the widget that actually
  // changed is going to be lost in favor of the group widget's id. The
  // widgets prop also wasn't actually changed, and this only serves to
  // alert our renderer (our parent) of the fact that some interaction
  // has occurred.
  _onInteractWithWidget: function _onInteractWithWidget(id) {
    // Reset grading display when user changes answer
    this.setState({
      status: GRADING_STATUSES.ungraded,
      message: ""
    });

    if (this.refs.renderer) {
      this.change("widgets", this.props.widgets);
      var emptyWidgets = this.refs.renderer.emptyWidgets();
      var answerable = emptyWidgets.length === 0;
      var answerBarState = this.state.answerBarState;
      this.setState({
        answerBarState: getNextState(answerBarState, answerable)
      });
    }
  },
  _checkAnswer: function _checkAnswer() {
    this.refs.renderer.showRationalesForCurrentlySelectedChoices();
    var score = this.refs.renderer.score();
    var status;
    var message;

    if (score.type === "points") {
      status = score.total === score.earned ? GRADING_STATUSES.correct : GRADING_STATUSES.incorrect;
      message = score.message || "";
    } else {
      // score.type is "invalid"
      status = GRADING_STATUSES.invalid;
      message = score.message ? "".concat(INVALID_MESSAGE_PREFIX, " ").concat(score.message) : "".concat(INVALID_MESSAGE_PREFIX, " ").concat(DEFAULT_INVALID_MESSAGE);
    }

    this.setState({
      status: status,
      message: message,
      // TODO(kevinb) handle 'invalid' status
      answerBarState: status === "correct" ? ANSWER_BAR_STATES.CORRECT : ANSWER_BAR_STATES.INCORRECT
    });
    this.props.trackInteraction({
      status: status
    });
  },
  // Mobile API
  getInputPaths: function getInputPaths() {
    return this.refs.renderer.getInputPaths();
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    return this.refs.renderer.setInputValue(path, newValue, cb);
  },
  getAcceptableFormatsForInputPath: function getAcceptableFormatsForInputPath(path) {
    return this.refs.renderer.getAcceptableFormatsForInputPath(path);
  },
  focus: function focus() {
    return this.refs.renderer.focus();
  },
  focusInputPath: function focusInputPath(path) {
    this.refs.renderer.focusPath(path);
  },
  blurInputPath: function blurInputPath(path) {
    this.refs.renderer.blurPath(path);
  },
  render: function render() {
    var apiOptions = _$p.extend({}, ApiOptions$8.defaults, this.props.apiOptions, {
      // Api Rewriting to support correct onFocus/onBlur
      // events for the mobile API
      onFocusChange: (newFocus, oldFocus) => {
        if (oldFocus) {
          this.props.onBlur(oldFocus);
        }

        if (newFocus) {
          this.props.onFocus(newFocus);
        }
      }
    });

    var icon = null; // Colors are 10% darker than the colors in graded-group.less

    if (this.state.status === GRADING_STATUSES.correct) {
      icon = /*#__PURE__*/React$x.createElement(InlineIcon$8, _extends({}, iconOk, {
        style: {
          color: "#526f03"
        }
      }));
    } else if (this.state.status === GRADING_STATUSES.incorrect) {
      icon = /*#__PURE__*/React$x.createElement(InlineIcon$8, _extends({}, iconRemove, {
        style: {
          color: "#ff5454"
        }
      }));
    }

    var mobileClass = this.props.inGradedGroupSet ? aphrodite.css(styles$a.gradedGroupInSet) : aphrodite.css(styles$a.gradedGroup);
    var classes = classNames$7({
      [mobileClass]: apiOptions.isMobile,
      "perseus-graded-group": true,
      "answer-correct": apiOptions.isMobile ? false : this.state.status === GRADING_STATUSES.correct,
      "answer-incorrect": apiOptions.isMobile ? false : this.state.status === GRADING_STATUSES.incorrect
    });
    var {
      answerBarState
    } = this.state; // Disabled widgets after the answer has been answered correctly to
    // prevent a situation where the answer has been marked correct but
    // looks incorrect because a user has modified it afterwards.

    var isCorrect = answerBarState === ANSWER_BAR_STATES.CORRECT;
    var readOnly = apiOptions.readOnly || apiOptions.isMobile && isCorrect;
    return /*#__PURE__*/React$x.createElement("div", {
      className: classes
    }, !!this.props.title && /*#__PURE__*/React$x.createElement("div", {
      className: aphrodite.css(styles$a.title)
    }, this.props.title), /*#__PURE__*/React$x.createElement(Renderer$7, _extends({}, this.props, {
      ref: "renderer",
      apiOptions: _objectSpread2(_objectSpread2({}, apiOptions), {}, {
        readOnly
      }),
      onInteractWithWidget: this._onInteractWithWidget,
      linterContext: this.props.linterContext
    })), !apiOptions.isMobile && icon && /*#__PURE__*/React$x.createElement("div", {
      className: "group-icon"
    }, icon), !apiOptions.isMobile && /*#__PURE__*/React$x.createElement("p", null, this.state.message), !apiOptions.isMobile && /*#__PURE__*/React$x.createElement("input", {
      type: "button",
      value: i18n._("Check"),
      className: "simple-button",
      disabled: this.props.apiOptions.readOnly,
      onClick: this._checkAnswer
    }), !apiOptions.isMobile && isCorrect && this.props.onNextQuestion && /*#__PURE__*/React$x.createElement("input", {
      type: "button",
      value: i18n._("Next question"),
      className: "simple-button",
      disabled: this.props.apiOptions.readOnly,
      onClick: this.props.onNextQuestion,
      style: {
        marginLeft: 5
      }
    }), this.props.hint && this.props.hint.content && (this.state.showHint ? /*#__PURE__*/React$x.createElement("div", null, /*#__PURE__*/React$x.createElement("div", {
      className: aphrodite.css(styles$a.explanationTitle),
      onClick: () => this.setState({
        showHint: false
      })
    }, i18n._("Hide explanation")), /*#__PURE__*/React$x.createElement(Renderer$7, _extends({}, this.props.hint, {
      ref: "hints-renderer",
      apiOptions: apiOptions,
      linterContext: this.props.linterContext
    }))) : /*#__PURE__*/React$x.createElement("div", {
      onClick: () => this.setState({
        showHint: true
      }),
      className: aphrodite.css(styles$a.showHintLink)
    }, i18n._("Explain"))), apiOptions.isMobile && answerBarState !== ANSWER_BAR_STATES.HIDDEN && /*#__PURE__*/React$x.createElement(GradedGroupAnswerBar, {
      apiOptions: apiOptions,
      answerBarState: answerBarState,
      onCheckAnswer: this._checkAnswer,
      onNextQuestion: this.props.onNextQuestion
    }));
  }
});

var traverseChildWidgets$1 = function traverseChildWidgets(props, traverseRenderer) {
  return _$p.extend({}, props, traverseRenderer(props));
};

_module_$w.exports = {
  name: "graded-group",
  displayName: "Graded group (articles only)",
  widget: GradedGroup$1,
  traverseChildWidgets: traverseChildWidgets$1,
  // TODO(aasmund): This widget should be available for articles only
  hidden: false,
  tracking: "all",
  isLintable: true
};
var styles$a = aphrodite.StyleSheet.create({
  gradedGroupInSet: {
    // Reset a few desktop-only styles that come from graded-group.less
    marginLeft: 0,
    paddingLeft: 0
  },
  gradedGroup: {
    borderTop: "1px solid ".concat(gray76),
    borderBottom: "1px solid ".concat(gray76),
    backgroundColor: tableBackgroundAccent,
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingBottom: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin,
    paddingTop: 10,
    width: "auto"
  },
  showHintLink: {
    marginTop: 20,
    color: kaGreen,
    cursor: "pointer"
  },
  explanationTitle: {
    marginTop: 20,
    color: kaGreen,
    marginBottom: 10,
    cursor: "pointer"
  },
  title: {
    fontSize: 12,
    color: gray76,
    textTransform: "uppercase",
    marginBottom: 11,
    letterSpacing: 0.8
  }
});
var _widgetsGradedGroupJsx = _module_$w.exports;

var _module_$v = {
  exports: {}
};
/* eslint-disable react/forbid-prop-types */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$w = _react__default["default"];
var ApiOptions$7 = _perseusApiJsx.Options;
var Changeable$e = Changeable$Q;
var GradedGroup = _widgetsGradedGroupJsx.widget;
var Indicators = createReactClass({
  displayName: "Indicators",
  propTypes: {
    currentGroup: PropTypes.number.isRequired,
    numGroups: PropTypes.number.isRequired,
    onChangeCurrentGroup: PropTypes.func.isRequired
  },

  render() {
    var _this = this;

    var items = [];

    var _loop = function _loop(i) {
      items.push( /*#__PURE__*/React$w.createElement("div", {
        key: i,
        className: aphrodite.css(styles$9.indicator, i === _this.props.currentGroup && styles$9.selectedIndicator),
        onClick: () => _this.props.onChangeCurrentGroup(i)
      }));
    };

    for (var i = 0; i < this.props.numGroups; i++) {
      _loop(i);
    }

    return /*#__PURE__*/React$w.createElement("div", {
      className: aphrodite.css(styles$9.indicatorContainer)
    }, items);
  }

}); // TODO(jared): find a better name for this :) and for GradedGroup; the names
// are currently a little confusing.

var GradedGroupSet = createReactClass({
  displayName: "GradedGroupSet",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$e.propTypes), {}, {
    apiOptions: ApiOptions$7.propTypes,
    gradedGroups: PropTypes.array,
    trackInteraction: PropTypes.func.isRequired,
    linterContext: linterContextProps
  }),

  getDefaultProps() {
    return {
      gradedGroups: [],
      linterContext: linterContextDefault
    };
  },

  getInitialState() {
    return {
      currentGroup: 0
    };
  },

  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$e.change.apply(this, args);
  },

  // Mobile API
  getInputPaths() {
    return this._childGroup.getInputPaths();
  },

  setInputValue(path, newValue, cb) {
    return this._childGroup.setInputValue(path, newValue, cb);
  },

  getAcceptableFormatsForInputPath(path) {
    return this._childGroup.getAcceptableFormatsForInputPath(path);
  },

  focus() {
    return this._childGroup.focus();
  },

  focusInputPath(path) {
    this._childGroup.focusInputPath(path);
  },

  blurInputPath(path) {
    this._childGroup.blurInputPath(path);
  },

  handleNextQuestion() {
    var {
      currentGroup
    } = this.state;
    var numGroups = this.props.gradedGroups.length;

    if (currentGroup < numGroups - 1) {
      this.setState({
        currentGroup: currentGroup + 1
      });
    }
  },

  render() {
    var currentGroup = this.props.gradedGroups[this.state.currentGroup];

    if (!currentGroup) {
      return /*#__PURE__*/React$w.createElement("span", null, "No current group...");
    }

    var numGroups = this.props.gradedGroups.length;
    var handleNextQuestion = this.state.currentGroup < numGroups - 1 ? this.handleNextQuestion : null;
    return /*#__PURE__*/React$w.createElement("div", {
      className: aphrodite.css(styles$9.container)
    }, /*#__PURE__*/React$w.createElement("div", {
      className: aphrodite.css(styles$9.top)
    }, /*#__PURE__*/React$w.createElement("div", {
      className: aphrodite.css(styles$9.title)
    }, currentGroup.title), /*#__PURE__*/React$w.createElement("div", {
      className: aphrodite.css(styles$9.spacer)
    }), /*#__PURE__*/React$w.createElement(Indicators, {
      numGroups: numGroups,
      currentGroup: this.state.currentGroup,
      onChangeCurrentGroup: currentGroup => this.setState({
        currentGroup
      })
    })), /*#__PURE__*/React$w.createElement(GradedGroup, _extends({
      key: this.state.currentGroup,
      ref: comp => this._childGroup = comp
    }, this.props, currentGroup, {
      inGradedGroupSet: true,
      title: null,
      onNextQuestion: handleNextQuestion,
      linterContext: this.props.linterContext
    })));
  }

});

var traverseChildWidgets = function traverseChildWidgets(props, traverseRenderer) {
  // NOTE(jared): I have no idea how this works
  return {
    groups: props.gradedGroups.map(traverseRenderer)
  };
};

_module_$v.exports = {
  name: "graded-group-set",
  displayName: "Graded group set (articles only)",
  widget: GradedGroupSet,
  traverseChildWidgets: traverseChildWidgets,
  // TODO(michaelpolyak): This widget should be available for articles only
  hidden: false,
  tracking: "all",
  isLintable: true
};
var styles$9 = aphrodite.StyleSheet.create({
  top: {
    display: "flex",
    flexDirection: "row"
  },
  spacer: {
    flex: 1
  },
  title: {
    fontSize: 12,
    color: gray76,
    textTransform: "uppercase",
    marginBottom: 11,
    letterSpacing: 0.8
  },
  indicatorContainer: {
    display: "flex",
    flexDirection: "row"
  },
  indicator: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: grayLight,
    marginLeft: 5,
    cursor: "pointer"
  },
  selectedIndicator: {
    backgroundColor: kaGreen
  },
  container: {
    borderTop: "1px solid ".concat(gray76),
    borderBottom: "1px solid ".concat(gray76),
    backgroundColor: tableBackgroundAccent,
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingBottom: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin,
    paddingTop: 10,
    width: "auto"
  }
});
var _widgetsGradedGroupSetJsx = _module_$v.exports;

/* eslint-disable brace-style, comma-dangle, no-var, one-var, space-unary-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var _$o = _underscore__default["default"];
var Util$4 = Util$q;
var Graphie$1 = _componentsGraphieJsx;
var Plot = Graphie$1.Plot;
var kpoint$1 = _kmath3.point;
var DEFAULT_BACKGROUND_IMAGE = {
  url: null
}; // TODO(charlie): These really need to go into a utility file as they're being
// used by both interactive-graph and now grapher.

function canonicalSineCoefficients(coeffs) {
  // For a curve of the form f(x) = a * Sin(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  var amplitude = coeffs[0];
  var angularFrequency = coeffs[1];
  var phase = coeffs[2];
  var verticalOffset = coeffs[3]; // Guarantee a > 0

  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }

  var period = 2 * Math.PI; // Guarantee b > 0

  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  } // Guarantee c is smallest possible positive value


  while (phase > 0) {
    phase -= period;
  }

  while (phase < 0) {
    phase += period;
  }

  return [amplitude, angularFrequency, phase, verticalOffset];
}

function canonicalTangentCoefficients(coeffs) {
  // For a curve of the form f(x) = a * Tan(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  var amplitude = coeffs[0];
  var angularFrequency = coeffs[1];
  var phase = coeffs[2];
  var verticalOffset = coeffs[3]; // Guarantee a > 0

  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }

  var period = Math.PI; // Guarantee b > 0

  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  } // Guarantee c is smallest possible positive value


  while (phase > 0) {
    phase -= period;
  }

  while (phase < 0) {
    phase += period;
  }

  return [amplitude, angularFrequency, phase, verticalOffset];
}

var PlotDefaults = {
  areEqual: function areEqual(coeffs1, coeffs2) {
    return Util$4.deepEq(coeffs1, coeffs2);
  },
  Movable: Plot,
  getPropsForCoeffs: function getPropsForCoeffs(coeffs) {
    return {
      fn: _$o.partial(this.getFunctionForCoeffs, coeffs)
    };
  }
};

var Linear = _$o.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/67aaf581e6d9ef9038c10558a1f70ac21c11c9f8.png",
  defaultCoords: [[0.25, 0.75], [0.75, 0.75]],
  getCoefficients: function getCoefficients(coords) {
    var p1 = coords[0];
    var p2 = coords[1];
    var denom = p2[0] - p1[0];
    var num = p2[1] - p1[1];

    if (denom === 0) {
      return;
    }

    var m = num / denom;
    var b = p2[1] - m * p2[0];
    return [m, b];
  },
  getFunctionForCoeffs: function getFunctionForCoeffs(coeffs, x) {
    var m = coeffs[0],
        b = coeffs[1];
    return m * x + b;
  },
  getEquationString: function getEquationString(coords) {
    var coeffs = this.getCoefficients(coords);
    var m = coeffs[0],
        b = coeffs[1];
    return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
  }
});

var Quadratic = _$o.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/e23d36e6fc29ee37174e92c9daba2a66677128ab.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  Movable: Graphie$1.Parabola,
  getCoefficients: function getCoefficients(coords) {
    var p1 = coords[0];
    var p2 = coords[1]; // Parabola with vertex (h, k) has form: y = a * (h - k)^2 + k

    var h = p1[0];
    var k = p1[1]; // Use these to calculate familiar a, b, c

    var a = (p2[1] - k) / ((p2[0] - h) * (p2[0] - h));
    var b = -2 * h * a;
    var c = a * h * h + k;
    return [a, b, c];
  },
  getFunctionForCoeffs: function getFunctionForCoeffs(coeffs, x) {
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2];
    return (a * x + b) * x + c;
  },
  getPropsForCoeffs: function getPropsForCoeffs(coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2]
    };
  },
  getEquationString: function getEquationString(coords) {
    var coeffs = this.getCoefficients(coords);
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2];
    return "y = " + a.toFixed(3) + "x^2 + " + b.toFixed(3) + "x + " + c.toFixed(3);
  }
});

var Sinusoid = _$o.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/3d68e7718498475f53b206c2ab285626baf8857e.png",
  defaultCoords: [[0.5, 0.5], [0.6, 0.6]],
  Movable: Graphie$1.Sinusoid,
  getCoefficients: function getCoefficients(coords) {
    var p1 = coords[0];
    var p2 = coords[1];
    var a = p2[1] - p1[1];
    var b = Math.PI / (2 * (p2[0] - p1[0]));
    var c = p1[0] * b;
    var d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function getFunctionForCoeffs(coeffs, x) {
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2],
        d = coeffs[3];
    return a * Math.sin(b * x - c) + d;
  },
  getPropsForCoeffs: function getPropsForCoeffs(coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2],
      d: coeffs[3]
    };
  },
  getEquationString: function getEquationString(coords) {
    var coeffs = this.getCoefficients(coords);
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2],
        d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function areEqual(coeffs1, coeffs2) {
    return Util$4.deepEq(canonicalSineCoefficients(coeffs1), canonicalSineCoefficients(coeffs2));
  }
});

var Tangent = _$o.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/7db80d23c35214f98659fe1cf0765811c1bbfbba.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function getCoefficients(coords) {
    var p1 = coords[0];
    var p2 = coords[1];
    var a = p2[1] - p1[1];
    var b = Math.PI / (4 * (p2[0] - p1[0]));
    var c = p1[0] * b;
    var d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function getFunctionForCoeffs(coeffs, x) {
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2],
        d = coeffs[3];
    return a * Math.tan(b * x - c) + d;
  },
  getEquationString: function getEquationString(coords) {
    var coeffs = this.getCoefficients(coords);
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2],
        d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function areEqual(coeffs1, coeffs2) {
    return Util$4.deepEq(canonicalTangentCoefficients(coeffs1), canonicalTangentCoefficients(coeffs2));
  }
});

var Exponential = _$o.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/9cbfad55525e3ce755a31a631b074670a5dad611.png",
  defaultCoords: [[0.5, 0.55], [0.75, 0.75]],
  defaultAsymptote: [[0, 0.5], [1.0, 0.5]],

  /**
   * Add extra constraints for movement of the points or asymptote (below):
   *   newCoord: [x, y]
   *     The end position of the point or asymptote endpoint
   *   oldCoord: [x, y]
   *     The old position of the point or asymptote endpoint
   *   coords:
   *     An array of coordinates representing the proposed end configuration
   *     of the plot coordinates.
   *   asymptote:
   *     An array of coordinates representing the proposed end configuration
   *     of the asymptote.
   *
   * Return: either a coordinate (to be used as the resulting coordinate of
   * the move) or a boolean, where `true` uses newCoord as the resulting
   * coordinate, and `false` uses oldCoord as the resulting coordinate.
   */
  extraCoordConstraint: function extraCoordConstraint(newCoord, oldCoord, coords, asymptote, graph) {
    var y = _$o.head(asymptote)[1];

    return _$o.all(coords, coord => coord[1] !== y);
  },
  extraAsymptoteConstraint: function extraAsymptoteConstraint(newCoord, oldCoord, coords, asymptote, graph) {
    var y = newCoord[1];

    var isValid = _$o.all(coords, coord => coord[1] > y) || _$o.all(coords, coord => coord[1] < y);

    if (isValid) {
      return [oldCoord[0], y];
    } else {
      // Snap the asymptote as close as possible, i.e., if the user moves
      // the mouse really quickly into an invalid region
      var oldY = oldCoord[1];

      var wasBelow = _$o.all(coords, coord => coord[1] > oldY);

      if (wasBelow) {
        var bottomMost = _$o.min(_$o.map(coords, coord => coord[1]));

        return [oldCoord[0], bottomMost - graph.snapStep[1]];
      } else {
        var topMost = _$o.max(_$o.map(coords, coord => coord[1]));

        return [oldCoord[0], topMost + graph.snapStep[1]];
      }
    }
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function getCoefficients(coords, asymptote) {
    var p1 = coords[0];
    var p2 = coords[1];

    var c = _$o.head(asymptote)[1];

    var b = Math.log((p1[1] - c) / (p2[1] - c)) / (p1[0] - p2[0]);
    var a = (p1[1] - c) / Math.exp(b * p1[0]);
    return [a, b, c];
  },
  getFunctionForCoeffs: function getFunctionForCoeffs(coeffs, x) {
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2];
    return a * Math.exp(b * x) + c;
  },
  getEquationString: function getEquationString(coords, asymptote) {
    if (!asymptote) {
      return null;
    }

    var coeffs = this.getCoefficients(coords, asymptote);
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2];
    return "y = " + a.toFixed(3) + "e^(" + b.toFixed(3) + "x) + " + c.toFixed(3);
  }
});

var Logarithm = _$o.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/f6491e99d34af34d924bfe0231728ad912068dc3.png",
  defaultCoords: [[0.55, 0.5], [0.75, 0.75]],
  defaultAsymptote: [[0.5, 0], [0.5, 1.0]],
  extraCoordConstraint: function extraCoordConstraint(newCoord, oldCoord, coords, asymptote, graph) {
    var x = _$o.head(asymptote)[0];

    return _$o.all(coords, coord => coord[0] !== x) && coords[0][1] !== coords[1][1];
  },
  extraAsymptoteConstraint: function extraAsymptoteConstraint(newCoord, oldCoord, coords, asymptote, graph) {
    var x = newCoord[0];

    var isValid = _$o.all(coords, coord => coord[0] > x) || _$o.all(coords, coord => coord[0] < x);

    if (isValid) {
      return [x, oldCoord[1]];
    } else {
      // Snap the asymptote as close as possible, i.e., if the user moves
      // the mouse really quickly into an invalid region
      var oldX = oldCoord[0];

      var wasLeft = _$o.all(coords, coord => coord[0] > oldX);

      if (wasLeft) {
        var leftMost = _$o.min(_$o.map(coords, coord => coord[0]));

        return [leftMost - graph.snapStep[0], oldCoord[1]];
      } else {
        var rightMost = _$o.max(_$o.map(coords, coord => coord[0]));

        return [rightMost + graph.snapStep[0], oldCoord[1]];
      }
    }
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function getCoefficients(coords, asymptote) {
    // It's easiest to calculate the logarithm's coefficients by thinking
    // about it as the inverse of the exponential, so we flip x and y and
    // perform some algebra on the coefficients. This also unifies the
    // logic between the two 'models'.
    var flip = coord => [coord[1], coord[0]];

    var inverseCoeffs = Exponential.getCoefficients(_$o.map(coords, flip), _$o.map(asymptote, flip));
    var c = -inverseCoeffs[2] / inverseCoeffs[0];
    var b = 1 / inverseCoeffs[0];
    var a = 1 / inverseCoeffs[1];
    return [a, b, c];
  },
  getFunctionForCoeffs: function getFunctionForCoeffs(coeffs, x, asymptote) {
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2];
    return a * Math.log(b * x + c);
  },
  getEquationString: function getEquationString(coords, asymptote) {
    if (!asymptote) {
      return null;
    }

    var coeffs = this.getCoefficients(coords, asymptote);
    var a = coeffs[0],
        b = coeffs[1],
        c = coeffs[2];
    return "y = ln(" + a.toFixed(3) + "x + " + b.toFixed(3) + ") + " + c.toFixed(3);
  }
});

var AbsoluteValue = _$o.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/8256a630175a0cb1d11de223d6de0266daf98721.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function getCoefficients(coords) {
    var p1 = coords[0];
    var p2 = coords[1];
    var denom = p2[0] - p1[0];
    var num = p2[1] - p1[1];

    if (denom === 0) {
      return;
    }

    var m = Math.abs(num / denom);

    if (p2[1] < p1[1]) {
      m *= -1;
    }

    var horizontalOffset = p1[0];
    var verticalOffset = p1[1];
    return [m, horizontalOffset, verticalOffset];
  },
  getFunctionForCoeffs: function getFunctionForCoeffs(coeffs, x) {
    var m = coeffs[0],
        horizontalOffset = coeffs[1],
        verticalOffset = coeffs[2];
    return m * Math.abs(x - horizontalOffset) + verticalOffset;
  },
  getEquationString: function getEquationString(coords) {
    var coeffs = this.getCoefficients(coords);
    var m = coeffs[0],
        horizontalOffset = coeffs[1],
        verticalOffset = coeffs[2];
    return "y = " + m.toFixed(3) + "| x - " + horizontalOffset.toFixed(3) + "| + " + verticalOffset.toFixed(3);
  }
});
/* Utility functions for dealing with graphing interfaces. */


var functionTypeMapping = {
  linear: Linear,
  quadratic: Quadratic,
  sinusoid: Sinusoid,
  tangent: Tangent,
  exponential: Exponential,
  logarithm: Logarithm,
  absolute_value: AbsoluteValue
};

var allTypes = _$o.keys(functionTypeMapping);

function functionForType(type) {
  return functionTypeMapping[type];
}

var GrapherUtil = {
  validate: function validate(state, rubric) {
    if (state.type !== rubric.correct.type) {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    } // We haven't moved the coords


    if (state.coords == null) {
      return {
        type: "invalid",
        message: null
      };
    } // Get new function handler for grading


    var grader = functionForType(state.type);
    var guessCoeffs = grader.getCoefficients(state.coords, state.asymptote);
    var correctCoeffs = grader.getCoefficients(rubric.correct.coords, rubric.correct.asymptote);

    if (guessCoeffs == null || correctCoeffs == null) {
      return {
        type: "invalid",
        message: null
      };
    } else if (grader.areEqual(guessCoeffs, correctCoeffs)) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    } else {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }
  },
  getEquationString: function getEquationString(props) {
    var plot = props.plot;

    if (plot.type && plot.coords) {
      var handler = functionForType(plot.type);
      var result = handler.getEquationString(plot.coords, plot.asymptote);
      return result || "";
    } else {
      return "";
    }
  },
  pointsFromNormalized: function pointsFromNormalized(coordsList, range, step, snapStep) {
    var numSteps = function numSteps(range, step) {
      return Math.floor((range[1] - range[0]) / step);
    };

    return _$o.map(coordsList, function (coords) {
      var unsnappedPoint = _$o.map(coords, function (coord, i) {
        var currRange = range[i];
        var currStep = step[i];
        var nSteps = numSteps(currRange, currStep);
        var tick = Math.round(coord * nSteps);
        return currRange[0] + currStep * tick;
      }); // In some graphing widgets, e.g. interactive-graph, you can rely
      // on the Graphie to handle snapping. Here, we need the points
      // returned to already be snapped so that the plot that goes
      // through them is correct.


      return kpoint$1.roundTo(unsnappedPoint, snapStep);
    });
  },
  maybePointsFromNormalized: function maybePointsFromNormalized(coordsList, range, step, snapStep) {
    if (coordsList) {
      return this.pointsFromNormalized(coordsList, range, step, snapStep);
    } else {
      return coordsList;
    }
  },

  /* Given a plot type, return the appropriate default value for a grapher
   * widget's plot props: type, default coords, default asymptote. */
  defaultPlotProps: function defaultPlotProps(type, graph) {
    // The coords are null by default, to indicate that the user has not
    // moved them from the default position, and that this widget should
    // therefore be considered empty and ineligible for grading. The user
    // *can* move the coords from the default position and then back if
    // they really want to submit the default coords as their answer, but
    // we currently don't write questions that require this.
    //
    // We *do* write questions in which the asymptote should be left in
    // the default position. For this reason, we fill in the default
    // asymptote rather than leaving it null; if the user moves the coords
    // but not the asymptote, the widget is non-empty and eligible for
    // grading.
    //
    // TODO(mattdr): Consider an updated scoring function that marks the
    // default coords as empty *unless* they're the correct coords. This
    // would remove this default-coords-are-always-wrong constraints on
    // the questions we write, while still maintaining our kind behavior
    // when users forget to update a widget... but we'd also be revealing
    // extra information. It would be valid to always submit the default
    // widget before even reading the question; you can't lose, but you
    // might get a free win.
    var model = functionForType(type);
    var gridStep = [1, 1];
    var snapStep = Util$4.snapStepFromGridStep(gridStep);
    return {
      type,
      asymptote: this.maybePointsFromNormalized(model.defaultAsymptote, graph.range, graph.step, snapStep),
      coords: null
    };
  },

  /* Given a list of available types, choose which to use. */
  chooseType: _$o.first,
  getGridAndSnapSteps: function getGridAndSnapSteps(options, boxSize) {
    var gridStep = options.gridStep || Util$4.getGridStep(options.range, options.step, boxSize);
    var snapStep = options.snapStep || Util$4.snapStepFromGridStep(gridStep);
    return {
      gridStep: gridStep,
      snapStep: snapStep
    };
  }
};
var DEFAULT_GRAPHER_PROPS = {};
DEFAULT_GRAPHER_PROPS.graph = {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  backgroundImage: DEFAULT_BACKGROUND_IMAGE,
  markings: "graph",
  rulerLabel: "",
  rulerTicks: 10,
  valid: true,
  showTooltips: false
};
DEFAULT_GRAPHER_PROPS.plot = GrapherUtil.defaultPlotProps("linear", DEFAULT_GRAPHER_PROPS.graph);
DEFAULT_GRAPHER_PROPS.availableTypes = [DEFAULT_GRAPHER_PROPS.plot.type];

function typeToButton(type) {
  var capitalized = type.charAt(0).toUpperCase() + type.substring(1);
  return {
    value: type,
    title: capitalized,
    content: /*#__PURE__*/React.createElement("img", {
      src: functionForType(type).url,
      alt: capitalized
    })
  };
}

var _module_$u = {
  exports: {}
};
/* eslint-disable brace-style, comma-dangle, indent, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$v = _react__default["default"];
var _$n = _underscore__default["default"];
var Interactive2 = _interactive2Js;
var SvgImage = _componentsSvgImageJsx;
var Util$3 = Util$q;
var ButtonGroup$1 = _reactComponentsButtonGroupJsx;
/* Graphie and relevant components. */

var Graphie = _componentsGraphieJsx;
var MovablePoint = Graphie.MovablePoint;
var MovableLine = Graphie.MovableLine;
var WrappedLine = _interactive2WrappedLineJs;
var knumber = _kmath3.number;
var kvector = _kmath3.vector;
var kpoint = _kmath3.point;
var KhanColors = _utilColorsJs;
/* Mixins. */

var Changeable$d = Changeable$Q;

function isFlipped(newCoord, oldCoord, line) {
  var CCW = (a, b, c) => {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
  };

  return CCW(line[0], line[1], oldCoord) > 0 !== CCW(line[0], line[1], newCoord) > 0;
}
/* Styles */


var typeSelectorStyle = {
  padding: "5px 5px"
};
/* Graphing interface. */

var FunctionGrapher = createReactClass({
  displayName: "FunctionGrapher",
  _coords: function _coords(props) {
    // Coords are usually based on props, but should fall back to the
    // model's default whenever they're not provided (if there's a model)
    props = props || this.props;
    var graph = props.graph;
    var defaultModelCoords = props.model && GrapherUtil.maybePointsFromNormalized(props.model.defaultCoords, graph.range, graph.step, graph.snapStep);
    return props.coords || defaultModelCoords || null;
  },
  _asymptote: function _asymptote(props) {
    // Unlike coords, asymptotes are never null; see defaultPlotProps.
    props = props || this.props;
    return props.asymptote;
  },
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$d.propTypes), {}, {
    flexibleType: PropTypes.bool,
    graph: PropTypes.any,
    hideHairlines: PropTypes.func,
    isMobile: PropTypes.bool,
    model: PropTypes.any,
    onChange: PropTypes.func,
    setDrawingAreaAvailable: PropTypes.func,
    showHairlines: PropTypes.func,
    showTooltips: PropTypes.bool,
    static: PropTypes.bool
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      graph: {
        range: [[-10, 10], [-10, 10]],
        step: [1, 1]
      },
      coords: null,
      asymptote: null,
      isMobile: false
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$d.change.apply(this, args);
  },

  render: function render() {
    var pointForCoord = (coord, i) => {
      return /*#__PURE__*/React$v.createElement(MovablePoint, {
        key: i,
        coord: coord,
        static: this.props.static,
        constraints: [Interactive2.MovablePoint.constraints.bound(), Interactive2.MovablePoint.constraints.snap(), coord => {
          // Always enforce that this is a function
          var isFunction = _$n.all(this._coords(), (otherCoord, j) => {
            return i === j || !otherCoord || !knumber.equal(coord[0], otherCoord[0]);
          }); // Evaluate this criteria before per-point
          // constraints


          if (!isFunction) {
            return false;
          } // Specific functions have extra per-point
          // constraints


          if (this.props.model && this.props.model.extraCoordConstraint) {
            var extraConstraint = this.props.model.extraCoordConstraint; // Calculat resulting coords and verify that
            // they're valid for this graph

            var proposedCoords = _$n.clone(this._coords());

            var oldCoord = _$n.clone(proposedCoords[i]);

            proposedCoords[i] = coord;
            return extraConstraint(coord, oldCoord, proposedCoords, this._asymptote(), this.props.graph);
          }

          return isFunction;
        }],
        onMove: (newCoord, oldCoord) => {
          var coords; // Reflect over asymptote, if allowed

          var asymptote = this._asymptote();

          if (asymptote && this.props.model.allowReflectOverAsymptote && isFlipped(newCoord, oldCoord, asymptote)) {
            coords = _$n.map(this._coords(), coord => {
              return kpoint.reflectOverLine(coord, asymptote);
            });
          } else {
            coords = _$n.clone(this._coords());
          }

          coords[i] = newCoord;
          this.props.onChange({
            coords: coords
          });
        },
        showHairlines: this.props.showHairlines,
        hideHairlines: this.props.hideHairlines,
        showTooltips: this.props.showTooltips,
        isMobile: this.props.isMobile
      });
    };

    var points = _$n.map(this._coords(), pointForCoord);

    var box = this.props.graph.box;
    var imageDescription = this.props.graph.backgroundImage;
    var image = null;

    if (imageDescription.url) {
      var scale = box[0] / interactiveSizes.defaultBoxSize;
      image = /*#__PURE__*/React$v.createElement(SvgImage, {
        src: imageDescription.url,
        width: imageDescription.width,
        height: imageDescription.height,
        scale: scale
      });
    }

    return /*#__PURE__*/React$v.createElement("div", {
      className: "perseus-widget " + "perseus-widget-grapher",
      style: {
        width: box[0],
        height: this.props.flexibleType ? "auto" : box[1],
        boxSizing: "initial"
      }
    }, /*#__PURE__*/React$v.createElement("div", {
      className: "graphie-container above-scratchpad",
      style: {
        width: box[0],
        height: box[1]
      }
    }, image, /*#__PURE__*/React$v.createElement(Graphie, _extends({}, this.props.graph, {
      setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
    }), this.props.model && this.renderPlot(), this.props.model && this.renderAsymptote(), this.props.model && points)));
  },
  renderPlot: function renderPlot() {
    var model = this.props.model;
    var xRange = this.props.graph.range[0];

    var style = _objectSpread2({
      stroke: this.props.isMobile ? KhanColors.BLUE_C : KhanColors.DYNAMIC
    }, this.props.isMobile ? {
      "stroke-width": 3
    } : {});

    var coeffs = model.getCoefficients(this._coords(), this._asymptote());

    if (!coeffs) {
      return;
    }

    var functionProps = model.getPropsForCoeffs(coeffs, xRange);
    return /*#__PURE__*/React$v.createElement(model.Movable, _extends({}, functionProps, {
      key: this.props.model.url,
      range: xRange,
      style: style
    }));
  },
  renderAsymptote: function renderAsymptote() {
    var model = this.props.model;
    var graph = this.props.graph;

    var asymptote = this._asymptote();

    var dashed = {
      strokeDasharray: "- "
    };
    return asymptote && /*#__PURE__*/React$v.createElement(MovableLine, {
      onMove: (newCoord, oldCoord) => {
        // Calculate and apply displacement
        var delta = kvector.subtract(newCoord, oldCoord);

        var newAsymptote = _$n.map(this._asymptote(), coord => kvector.add(coord, delta));

        this.props.onChange({
          asymptote: newAsymptote
        });
      },
      constraints: [Interactive2.MovableLine.constraints.bound(), Interactive2.MovableLine.constraints.snap(), (newCoord, oldCoord) => {
        // Calculate and apply proposed displacement
        var delta = kvector.subtract(newCoord, oldCoord);

        var proposedAsymptote = _$n.map(this._asymptote(), coord => kvector.add(coord, delta)); // Verify that resulting asymptote is valid for graph


        if (model.extraAsymptoteConstraint) {
          return model.extraAsymptoteConstraint(newCoord, oldCoord, this._coords(), proposedAsymptote, graph);
        }

        return true;
      }],
      normalStyle: dashed,
      highlightStyle: dashed
    }, _$n.map(asymptote, (coord, i) => /*#__PURE__*/React$v.createElement(MovablePoint, {
      key: "asymptoteCoord-".concat(i),
      coord: coord,
      static: true,
      draw: null,
      extendLine: true,
      showHairlines: this.props.showHairlines,
      hideHairlines: this.props.hideHairlines,
      showTooltips: this.props.showTooltips,
      isMobile: this.props.isMobile
    })));
  }
});
/* Widget and editor. */

var Grapher$1 = createReactClass({
  displayName: "Grapher",
  propTypes: {
    apiOptions: PropTypes.any,
    availableTypes: PropTypes.arrayOf(PropTypes.any),
    containerSizeClass: containerSizeClassPropType.isRequired,
    graph: PropTypes.any,
    markings: PropTypes.string,
    onChange: PropTypes.func,
    plot: PropTypes.any,
    static: PropTypes.bool,
    trackInteraction: PropTypes.func.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return DEFAULT_GRAPHER_PROPS;
  },
  render: function render() {
    var type = this.props.plot.type;
    var coords = this.props.plot.coords;
    var asymptote = this.props.plot.asymptote;
    var typeSelector = /*#__PURE__*/React$v.createElement("div", {
      style: typeSelectorStyle,
      className: "above-scratchpad"
    }, /*#__PURE__*/React$v.createElement(ButtonGroup$1, {
      value: type,
      allowEmpty: true,
      buttons: _$n.map(this.props.availableTypes, typeToButton),
      onChange: this.handleActiveTypeChange
    }));
    var box = getInteractiveBoxFromSizeClass(this.props.containerSizeClass); // Calculate additional graph properties so that the same values are
    // passed in to both FunctionGrapher and Graphie.

    var options = _objectSpread2(_objectSpread2(_objectSpread2({}, this.props.graph), GrapherUtil.getGridAndSnapSteps(this.props.graph, box[0])), {}, {
      gridConfig: this._getGridConfig(_objectSpread2(_objectSpread2({}, this.props.graph), {}, {
        box: box
      }, GrapherUtil.getGridAndSnapSteps(this.props.graph, box[0])))
    }); // The `graph` prop will eventually be passed to the <Graphie>
    // component. In fact, if model is `null`, this is functionalliy
    // identical to a <Graphie>. Otherwise, some points and a plot will be
    // overlayed.


    var grapherProps = {
      graph: {
        box: box,
        range: options.range,
        step: options.step,
        snapStep: options.snapStep,
        backgroundImage: options.backgroundImage,
        options: options,
        setup: this._setupGraphie
      },
      onChange: this.handlePlotChanges,
      model: type && functionForType(type),
      coords: coords,
      asymptote: asymptote,
      static: this.props.static,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
      isMobile: this.props.apiOptions.isMobile,
      showTooltips: this.props.graph.showTooltips,
      showHairlines: this.showHairlines,
      hideHairlines: this.hideHairlines
    };
    return /*#__PURE__*/React$v.createElement("div", null, /*#__PURE__*/React$v.createElement(FunctionGrapher, grapherProps), this.props.availableTypes.length > 1 && typeSelector);
  },
  handlePlotChanges: function handlePlotChanges(newPlot) {
    var plot = _$n.extend({}, this.props.plot, newPlot);

    this.props.onChange({
      plot: plot
    });
    this.props.trackInteraction();
  },
  handleActiveTypeChange: function handleActiveTypeChange(newType) {
    var graph = this.props.graph;

    var plot = _$n.extend({}, this.props.plot, GrapherUtil.defaultPlotProps(newType, graph));

    this.props.onChange({
      plot: plot
    });
  },
  _getGridConfig: function _getGridConfig(options) {
    return _$n.map(options.step, function (step, i) {
      return Util$3.gridDimensionConfig(step, options.range[i], options.box[i], options.gridStep[i]);
    });
  },

  _calculateMobileTickStep(gridStep, step, ranges) {
    var tickStep = Util$3.constrainedTickStepsFromTickSteps(step, ranges); // According to the graphInit documentation in graphie.js, tickStep is
    // relative to the grid units so we need to adjust all values by the
    // grid step.

    tickStep[0] = tickStep[0] / gridStep[0];
    tickStep[1] = tickStep[1] / gridStep[1];
    return tickStep;
  },

  _setupGraphie: function _setupGraphie(graphie, options) {
    var isMobile = this.props.apiOptions.isMobile;

    if (options.markings === "graph") {
      graphie.graphInit({
        range: options.range,
        scale: _$n.pluck(options.gridConfig, "scale"),
        axisArrows: "<->",
        labelFormat: function labelFormat(s) {
          return "\\small{" + s + "}";
        },
        gridStep: options.gridStep,
        snapStep: options.snapStep,
        tickStep: isMobile ? this._calculateMobileTickStep(options.gridStep, options.step, options.range) : _$n.pluck(options.gridConfig, "tickStep"),
        labelStep: 1,
        unityLabels: _$n.pluck(options.gridConfig, "unityLabel"),
        isMobile: isMobile
      });
      graphie.label([0, options.range[1][1]], options.labels[1], isMobile ? "below right" : "above");
      graphie.label([options.range[0][1], 0], options.labels[0], isMobile ? "above left" : "right");
    } else if (options.markings === "grid") {
      graphie.graphInit({
        range: options.range,
        scale: _$n.pluck(options.gridConfig, "scale"),
        gridStep: options.gridStep,
        axes: false,
        ticks: false,
        labels: false,
        isMobile: isMobile
      });
    } else if (options.markings === "none") {
      graphie.init({
        range: options.range,
        scale: _$n.pluck(options.gridConfig, "scale")
      });
    }

    if (this.props.apiOptions.isMobile) {
      var hairlineStyle = {
        normalStyle: {
          strokeWidth: 1
        }
      };
      this.horizHairline = new WrappedLine(graphie, [0, 0], [0, 0], hairlineStyle);
      this.horizHairline.attr({
        stroke: KhanColors.INTERACTIVE
      });
      this.horizHairline.hide();
      this.vertHairline = new WrappedLine(graphie, [0, 0], [0, 0], hairlineStyle);
      this.vertHairline.attr({
        stroke: KhanColors.INTERACTIVE
      });
      this.vertHairline.hide();
    }
  },
  showHairlines: function showHairlines(point) {
    if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
      // Hairlines are already initialized when the graph is loaded, so
      // here we just move them to the updated location and make them
      // visible.
      this.horizHairline.moveTo([this.props.graph.range[0][0], point[1]], [this.props.graph.range[0][1], point[1]]);
      this.horizHairline.show();
      this.vertHairline.moveTo([point[0], this.props.graph.range[1][0]], [point[0], this.props.graph.range[1][1]]);
      this.vertHairline.show();
    }
  },
  hideHairlines: function hideHairlines() {
    if (this.props.apiOptions.isMobile) {
      this.horizHairline.hide();
      this.vertHairline.hide();
    }
  },
  simpleValidate: function simpleValidate(rubric) {
    return GrapherUtil.validate(this.getUserInput(), rubric);
  },
  getUserInput: function getUserInput() {
    return this.props.plot;
  },
  focus: $.noop
});

var propTransform$2 = editorProps => {
  var widgetProps = {
    availableTypes: editorProps.availableTypes,
    graph: editorProps.graph
  }; // If there's only one type, the graph type is deterministic

  if (widgetProps.availableTypes.length === 1) {
    var graph = widgetProps.graph;
    var type = GrapherUtil.chooseType(widgetProps.availableTypes);
    widgetProps.plot = GrapherUtil.defaultPlotProps(type, graph);
  }

  return widgetProps;
}; // Note that in addition to the standard staticTransform, in static
// mode we set static=true for the graph's handles in FunctionGrapher.


var staticTransform = editorProps => {
  return _$n.extend({}, propTransform$2(editorProps), {
    // Don't display graph type choices if we're in static mode
    availableTypes: [editorProps.correct.type],
    // Display the same graph marked as correct in the widget editor.
    plot: editorProps.correct
  });
};

_module_$u.exports = {
  name: "grapher",
  displayName: "Grapher",
  widget: Grapher$1,
  transform: propTransform$2,
  staticTransform: staticTransform
};
var _widgetsGrapherJsx = _module_$u.exports;

var module$3 = {
  exports: {}
};
/* MultiButtonGroup is an aesthetically pleasing group of buttons,
 * which allows multiple buttons to be selected at the same time.
 *
 * The class requires these properties:
 *   buttons - an array of objects with keys:
 *     "value": this is the value returned when the button is selected
 *     "content": this is the JSX shown within the button, typically a string
 *         that gets rendered as the button's display text
 *     "title": this is the title-text shown on hover
 *   onChange - a function that is provided with an array of the updated
 *     values (which it then is responsible for updating)
 *
 * The class has these optional properties:
 *   values - an array of the initial values of the buttons selected.
 *
 * Requires stylesheets/perseus-admin-package/editor.less to look nice.
 */

var React$u = _react__default["default"];
var ReactDOM$6 = _reactDom__default["default"];
var createReactClass$3 = _createReactClass__default["default"];
var PropTypes$3 = _propTypes__default["default"];
var styles$8 = _stylesJs;
var MultiButtonGroup$2 = createReactClass$3({
  displayName: "MultiButtonGroup",
  propTypes: {
    values: PropTypes$3.arrayOf(PropTypes$3.any),
    buttons: PropTypes$3.arrayOf(PropTypes$3.shape({
      value: PropTypes$3.any.isRequired,
      content: PropTypes$3.node,
      title: PropTypes$3.string
    })).isRequired,
    onChange: PropTypes$3.func.isRequired,
    allowEmpty: PropTypes$3.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      values: [],
      allowEmpty: true
    };
  },
  focus: function focus() {
    ReactDOM$6.findDOMNode(this).focus();
    return true;
  },
  toggleSelect: function toggleSelect(newValue) {
    var values = (this.props.values || []).slice(0);
    var allowEmpty = this.props.allowEmpty;

    if (values.indexOf(newValue) >= 0 && (values.length > 1 || allowEmpty)) {
      // If the value is already selected, unselect it
      values.splice(values.indexOf(newValue), 1);
    } else {
      // Otherwise merge with other values and return
      if (values.indexOf(newValue) < 0) {
        values.push(newValue);
      }
    }

    this.props.onChange(values);
  },
  render: function render() {
    var values = this.props.values || [];
    var buttons = this.props.buttons.map((button, i) => {
      var selected = values.indexOf(button.value) >= 0;
      return /*#__PURE__*/React$u.createElement("button", {
        title: button.title,
        type: "button",
        id: "" + i,
        key: "" + i,
        ref: "button" + i,
        className: aphrodite.css(styles$8.button.buttonStyle, selected && styles$8.button.selectedStyle),
        onClick: this.toggleSelect.bind(this, button.value)
      }, button.content || "" + button.value);
    });
    var outerStyle = {
      display: 'inline-block'
    };
    return /*#__PURE__*/React$u.createElement("div", {
      style: outerStyle
    }, buttons);
  }
});
module$3.exports = MultiButtonGroup$2;
var _reactComponentsMultiButtonGroupJsx = module$3.exports;

var _module_$t = {
  exports: {}
};
/* eslint-disable comma-dangle, no-redeclare, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$t = _react__default["default"];
var _$m = _underscore__default["default"];
var Changeable$c = Changeable$Q;
var GraphSettings = _componentsGraphSettingsJsx;
var InfoTip$5 = _componentsInfoTipJsx;
var MultiButtonGroup$1 = _reactComponentsMultiButtonGroupJsx;
var Grapher = _widgetsGrapherJsx.widget;
var GrapherEditor = createReactClass({
  displayName: "GrapherEditor",
  propTypes: _objectSpread2({}, Changeable$c.propTypes),
  getDefaultProps: function getDefaultProps() {
    return {
      correct: DEFAULT_GRAPHER_PROPS.plot,
      graph: DEFAULT_GRAPHER_PROPS.graph,
      availableTypes: DEFAULT_GRAPHER_PROPS.availableTypes
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$c.change.apply(this, args);
  },

  render: function render() {
    var sizeClass = containerSizeClass.SMALL;
    var equationString;
    var graph;

    if (this.props.graph.valid === true) {
      var graphProps = {
        graph: this.props.graph,
        plot: this.props.correct,
        availableTypes: this.props.availableTypes,
        onChange: (newProps, cb) => {
          var correct = this.props.correct;

          if (correct.type === newProps.plot.type) {
            correct = _$m.extend({}, correct, newProps.plot);
          } else {
            // Clear options from previous graph
            correct = newProps.plot;
          }

          this.props.onChange({
            correct: correct
          }, cb);
        },
        trackInteraction: function trackInteraction() {}
      };
      graph = /*#__PURE__*/React$t.createElement(Grapher, _extends({}, graphProps, {
        apiOptions: this.props.apiOptions,
        containerSizeClass: sizeClass
      }));
      equationString = GrapherUtil.getEquationString(graphProps);
    } else {
      graph = /*#__PURE__*/React$t.createElement("div", {
        className: "perseus-error"
      }, this.props.graph.valid);
    }

    return /*#__PURE__*/React$t.createElement("div", null, /*#__PURE__*/React$t.createElement("div", null, "Correct answer", " ", /*#__PURE__*/React$t.createElement(InfoTip$5, null, /*#__PURE__*/React$t.createElement("p", null, "Graph the correct answer in the graph below and ensure the equation or point coordinates displayed represent the correct answer.")), " ", ": ", equationString), /*#__PURE__*/React$t.createElement(GraphSettings, {
      editableSettings: ["graph", "snap", "image"],
      box: getInteractiveBoxFromSizeClass(sizeClass),
      range: this.props.graph.range,
      labels: this.props.graph.labels,
      step: this.props.graph.step,
      gridStep: this.props.graph.gridStep,
      snapStep: this.props.graph.snapStep,
      valid: this.props.graph.valid,
      backgroundImage: this.props.graph.backgroundImage,
      markings: this.props.graph.markings,
      rulerLabel: this.props.graph.rulerLabel,
      rulerTicks: this.props.graph.rulerTicks,
      showTooltips: this.props.graph.showTooltips,
      onChange: this.change("graph")
    }), /*#__PURE__*/React$t.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$t.createElement("label", null, "Available functions:  "), /*#__PURE__*/React$t.createElement(MultiButtonGroup$1, {
      allowEmpty: false,
      values: this.props.availableTypes,
      buttons: _$m.map(allTypes, typeToButton),
      onChange: this.handleAvailableTypesChange
    })), graph);
  },
  handleAvailableTypesChange: function handleAvailableTypesChange(newAvailableTypes) {
    var correct = this.props.correct; // If the currently 'correct' type is removed from the list of types,
    // we need to change it to avoid impossible questions.

    if (!_$m.contains(newAvailableTypes, this.props.correct.type)) {
      var graph = this.props.graph;
      var newType = GrapherUtil.chooseType(newAvailableTypes);
      var correct = GrapherUtil.defaultPlotProps(newType, graph);
    }

    this.props.onChange({
      availableTypes: newAvailableTypes,
      correct: correct
    });
  },
  serialize: function serialize() {
    return _$m.chain(this.props).pick("correct", "availableTypes").extend({
      graph: _$m.omit(this.props.graph, "box")
    }).value();
  }
});
_module_$t.exports = GrapherEditor;
var _widgetsGrapherEditorJsx = _module_$t.exports;

var _module_$s = {
  exports: {}
};
var React$s = _react__default["default"];
var _$l = _underscore__default["default"];
var Changeable$b = Changeable$Q;
var EditorJsonify$5 = _mixinsEditorJsonifyJsx;
var Editor$3 = _editorJsx;
var TextInput$3 = _componentsTextInputJsx;
var DefinitionEditor = createReactClass({
  displayName: "DefinitionEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$b.propTypes), {}, {
    togglePrompt: PropTypes.string,
    definition: PropTypes.string,
    apiOptions: PropTypes.any
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      togglePrompt: "",
      definition: ""
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$b.change.apply(this, args);
  },

  serialize() {
    return EditorJsonify$5.serialize.call(this);
  },

  render: function render() {
    return /*#__PURE__*/React$s.createElement("div", {
      className: "perseus-widget-definition-editor"
    }, /*#__PURE__*/React$s.createElement("a", {
      href: "https://docs.google.com/document/d/1udaPef4imOfTMhmLDlWq4SM0mxL0r3YHFZE-5J1uGfo",
      target: "_blank"
    }, "Definition style guide"), /*#__PURE__*/React$s.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$s.createElement("label", null, "Word to be defined:", " ", /*#__PURE__*/React$s.createElement(TextInput$3, {
      value: this.props.togglePrompt,
      onChange: this.change("togglePrompt"),
      placeholder: "define me"
    }))), /*#__PURE__*/React$s.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$s.createElement(Editor$3, {
      apiOptions: this.props.apiOptions,
      content: this.props.definition,
      widgetEnabled: false,
      placeholder: "definition goes here",
      onChange: props => {
        var newProps = {};

        if (_$l.has(props, "content")) {
          newProps.definition = props.content;
        }

        this.change(newProps);
      }
    })));
  }
});
_module_$s.exports = DefinitionEditor;
var _widgetsDefinitionEditorJsx = _module_$s.exports;

var _module_$r = {
  exports: {}
};
var React$r = _react__default["default"];
var _$k = _underscore__default["default"];
var Changeable$a = Changeable$Q;
var PerseusApi$1 = _perseusApiJsx;
var Renderer$6 = _rendererJsx;
var mediaQueries$4 = _stylesMediaQueriesJs;
var Definition = createReactClass({
  displayName: "Definition",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$a.propTypes), {}, {
    apiOptions: PerseusApi$1.Options.propTypes,
    definition: PropTypes.string,
    togglePrompt: PropTypes.string,
    trackInteraction: PropTypes.func.isRequired
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      togglePrompt: "define me",
      definition: "definition goes here"
    };
  },
  getInitialState: function getInitialState() {
    return {
      expanded: false,
      belowScreen: false,
      contentOffsetLeft: 0,
      contentOffsetLeftMobile: 0,
      contentWidth: 0,
      contentWidthMobile: 0,
      contentMarginTop: arrowHeight$1
    };
  },
  componentDidMount: function componentDidMount() {
    document.addEventListener("click", this.handleClick);
  },
  componentWillUnmount: function componentWillUnmount() {
    document.removeEventListener("click", this.handleClick);
  },
  handleClick: function handleClick(event) {
    var elem = event.target;
    var shouldClose = true;

    while (elem) {
      // If the clicked element is outside the definition box
      // close the definition box
      if (elem === this.content || elem === this.container) {
        shouldClose = false;
        break;
      }

      elem = elem.parentNode;
    }

    if (shouldClose) {
      this.close();
    }
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$a.change.apply(this, args);
  },

  close: function close() {
    this.setState({
      expanded: false
    });
  },
  getUserInput: function getUserInput() {
    return {};
  },
  simpleValidate: function simpleValidate(rubric) {
    return Definition.validate(this.getUserInput(), rubric);
  },
  // check if the definition is fully visible on the bottom
  _definitionBelowScreen: function _definitionBelowScreen() {
    var windowBottom = window.innerHeight;
    var bottom = this.container.getBoundingClientRect().bottom;
    return bottom > windowBottom - this.content.offsetHeight;
  },
  // TODO(audrey): think of a better way to have the definition always appear
  // on screen. Currently, the marginTop and absolute positions of the arrow
  // and the definition div are adjusted. Could also consider having
  // dynamic flipping.
  _checkDefinitionPosition: function _checkDefinitionPosition() {
    // need to wait for aphrodite styles to be rendered
    // so they can accessed for measurements in positionContent
    setTimeout(() => {
      this._positionContentHorizontally();

      if (this._definitionBelowScreen()) {
        this.setState({
          belowScreen: true
        }, this._positionContentVertically);
      } else {
        this.setState({
          belowScreen: false
        }, this._positionContentVertically);
      }
    }, 0);
  },

  /**
  * This function sets the definition boxes' vertical positions depending
  * on whether the definition should appear above or below. The positions
  * are affected by how long the definition is.
  */
  _positionContentVertically: function _positionContentVertically() {
    if (this.state.belowScreen) {
      var contentHeight = this.content.offsetHeight; // slight hack to better align the bottom of the arrow
      // with the rest of the definition box

      var contentMarginTop = -contentHeight - 2 * arrowHeight$1 - 4;
      this.setState({
        contentMarginTop: contentMarginTop
      });
    } else {
      this.setState({
        contentMarginTop: arrowHeight$1
      });
    }
  },
  _onClick: function _onClick() {
    // close all other open definitions if opening definition
    if (!this.state.expanded) {
      var definitionWidgets = this.props.findWidgets("definition");

      for (var widget of definitionWidgets) {
        if (widget !== this) {
          widget.close();
        }
      }
    }

    this.setState({
      expanded: !this.state.expanded
    }, this._checkDefinitionPosition);
    this.props.trackInteraction();
  },
  _onMouseOver: function _onMouseOver() {
    this.setState({
      expanded: true
    }, this._checkDefinitionPosition);
    this.props.trackInteraction();
  },
  _onMouseOut: function _onMouseOut() {
    this.setState({
      expanded: false
    });
    this.props.trackInteraction();
  },

  /**
  * This function sets the definition boxes' widths so that the complete box
  * is visible on the screen and spans the entire width. It also makes sure
  * the content is centered correctly.
  */
  _positionContentHorizontally: function _positionContentHorizontally() {
    // container is the word to be defined
    // content is the actual definition
    var documentWidth = document.body.clientWidth;
    var marginWidth = this.container.parentElement.parentElement.offsetLeft;
    var contentWidth = documentWidth - 2 * marginWidth;
    var contentWidthMobile = documentWidth - marginWidth;
    var contentOffsetLeft = this.container.offsetLeft - marginWidth;
    var contentOffsetLeftMobile = this.container.offsetLeft;
    this.setState({
      contentWidth: contentWidth,
      contentWidthMobile: contentWidthMobile,
      contentOffsetLeft: -contentOffsetLeft,
      contentOffsetLeftMobile: -contentOffsetLeftMobile
    });
  },
  render: function render() {
    var {
      readOnly,
      isMobile
    } = this.props.apiOptions;
    var linkAnchor = this.props.togglePrompt;
    var link;
    var href = readOnly ? null : "javascript:void(0)";
    var onClick = readOnly ? null : this._onClick;
    var onMouseOver = this._onMouseOver;
    var onMouseOut = this._onMouseOut;

    if (isMobile) {
      link = /*#__PURE__*/React$r.createElement("a", {
        className: aphrodite.css(styles$7.mobileDefinitionLink),
        href: href,
        onClick: onClick
      }, linkAnchor);
    } else {
      link = /*#__PURE__*/React$r.createElement("a", {
        className: aphrodite.css(styles$7.definitionLink),
        href: href,
        onMouseOver: onMouseOver,
        onMouseOut: onMouseOut
      }, linkAnchor);
    }

    var expandedStyle = isMobile ? styles$7.contentExpandedMobile : styles$7.contentExpanded;
    var arrowTransform = this.state.belowScreen ? "scale(1, -1)" : "scale(1, 1)";
    return /*#__PURE__*/React$r.createElement("div", {
      className: aphrodite.css(styles$7.container),
      ref: e => this.container = e
    }, /*#__PURE__*/React$r.createElement("div", {
      className: aphrodite.css(styles$7.linkContainer)
    }, link, this.state.expanded && /*#__PURE__*/React$r.createElement("svg", {
      className: aphrodite.css(styles$7.disclosureArrow),
      ref: e => this.arrow = e,
      transform: arrowTransform,
      style: {
        bottom: this.state.expanded && this.state.belowScreen ? "18px" : "-18px"
      }
    }, /*#__PURE__*/React$r.createElement("filter", {
      id: "definition-widget-dropshadow",
      height: "150%"
    }, /*#__PURE__*/React$r.createElement("feOffset", {
      dx: dropShadowXOffset,
      dy: dropShadowYOffset,
      result: "offsetblur"
    }), /*#__PURE__*/React$r.createElement("feGaussianBlur", {
      in: "SourceAlpha",
      stdDeviation: dropShadowRadius / 2
    }), /*#__PURE__*/React$r.createElement("feComponentTransfer", null, /*#__PURE__*/React$r.createElement("feFuncA", {
      type: "linear",
      slope: dropShadowOpacity
    })), /*#__PURE__*/React$r.createElement("feMerge", null, /*#__PURE__*/React$r.createElement("feMergeNode", null), /*#__PURE__*/React$r.createElement("feMergeNode", {
      in: "SourceGraphic"
    }))), /*#__PURE__*/React$r.createElement("polyline", {
      fill: "white",
      filter: "url(#definition-widget-dropshadow)",
      points: "0,".concat(arrowHeight$1, " ") + "".concat(arrowWidth$1, ",").concat(arrowHeight$1, " ") + "".concat(arrowWidth$1 / 2, ",0")
    }))), /*#__PURE__*/React$r.createElement("div", {
      className: aphrodite.css(styles$7.content, isMobile && styles$7.contentMobile, this.state.expanded && expandedStyle),
      style: {
        height: this.state.expanded ? "auto" : 0,
        overflow: this.state.expanded ? "visible" : "hidden",
        left: isMobile ? this.state.contentOffsetLeftMobile : this.state.contentOffsetLeft,
        width: isMobile ? this.state.contentWidthMobile : this.state.contentWidth,
        marginTop: this.state.contentMarginTop
      },
      ref: e => this.content = e
    }, /*#__PURE__*/React$r.createElement(Renderer$6, {
      apiOptions: this.props.apiOptions,
      content: this.props.definition,
      widgets: this.props.widgets
    })));
  }
});
var dropShadowXOffset = 0;
var dropShadowYOffset = 1;
var dropShadowOpacity = 0.35;
var dropShadowRadius = 4;
var arrowWidth$1 = 20;
var arrowHeight$1 = 14;
var backgroundColor$1 = white;
var styles$7 = aphrodite.StyleSheet.create({
  container: {
    display: "inline",
    position: "relative"
  },
  linkContainer: {
    display: "inline-block"
  },
  definitionLink: {
    color: blue,
    borderBottom: "dashed 1px ".concat(blue),
    textDecoration: "none"
  },
  mobileDefinitionLink: {
    color: kaGreen,
    borderBottom: "dashed 1px ".concat(kaGreen),
    textDecoration: "none",
    // TODO(benkomalo): these should be pulled in from common typography
    // shared files so we have a single place where the type hierarchy is
    // defined; one off font sizes for individual components should be
    // avoided.
    [mediaQueries$4.xl]: {
      fontSize: 22,
      lineHeight: 1.4
    },
    [mediaQueries$4.lgOrSmaller]: {
      fontSize: 20,
      lineHeight: 1.5
    },
    [mediaQueries$4.smOrSmaller]: {
      fontSize: 18,
      lineHeight: 1.2
    }
  },
  content: {
    background: backgroundColor$1,
    opacity: 0.95,
    borderRadius: 1,
    position: "absolute",
    transition: "margin-top 0.1s",
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin,
    zIndex: 2
  },
  contentExpanded: {
    boxShadow: "0px 0px 4px ".concat(gray85),
    border: "solid 0.5px ".concat(gray85)
  },
  contentExpandedMobile: {
    paddingTop: 32,
    paddingBottom: 32,
    boxShadow: "0px 0px 4px ".concat(gray85),
    border: "solid 0.5px ".concat(gray85)
  },
  disclosureArrow: {
    // HACK - positioning at "bottom: 0", doesn't actually position it to
    // the real bottom, because the container is `inline-block`, and it
    // seems to position it to the baseline? We put in a generous
    // fudge factor to position it down to be flush with the content box
    // below it.
    height: arrowHeight$1,
    left: "50%",
    marginLeft: -(arrowWidth$1 / 2),
    position: "absolute",
    width: arrowWidth$1,
    zIndex: 4 // so popovers appear on top

  }
});

_$k.extend(Definition, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

_module_$r.exports = {
  name: "definition",
  displayName: "Definition",
  defaultAlignment: "inline",
  widget: Definition,
  transform: _$k.identity
};
var _widgetsDefinitionJsx = _module_$r.exports;

var _module_$q = {
  exports: {}
};
/* eslint-disable no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$q = _react__default["default"];
var _$j = _underscore__default["default"];
var Changeable$9 = Changeable$Q;
var EditorJsonify$4 = _mixinsEditorJsonifyJsx;
var Editor$2 = _editorJsx;
var TextInput$2 = _componentsTextInputJsx;
var defaultExplanationProps$1 = {
  showPrompt: "Explain",
  hidePrompt: "Hide explanation",
  explanation: "explanation goes here\n\nmore explanation",
  widgets: {}
};
var ExplanationEditor = createReactClass({
  displayName: "ExplanationEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$9.propTypes), {}, {
    showPrompt: PropTypes.string,
    hidePrompt: PropTypes.string,
    explanation: PropTypes.string,
    widgets: PropTypes.object,
    apiOptions: PropTypes.any
  }),
  getDefaultProps: function getDefaultProps() {
    return defaultExplanationProps$1;
  },
  getInitialState: function getInitialState() {
    return {};
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$9.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$q.createElement("div", {
      className: "perseus-widget-explanation-editor"
    }, /*#__PURE__*/React$q.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$q.createElement("label", null, "Prompt to show explanation:", " ", /*#__PURE__*/React$q.createElement(TextInput$2, {
      value: this.props.showPrompt,
      onChange: this.change("showPrompt")
    }))), /*#__PURE__*/React$q.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$q.createElement("label", null, "Prompt to hide explanation:", " ", /*#__PURE__*/React$q.createElement(TextInput$2, {
      value: this.props.hidePrompt,
      onChange: this.change("hidePrompt")
    }))), /*#__PURE__*/React$q.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$q.createElement(Editor$2, {
      apiOptions: this.props.apiOptions,
      content: this.props.explanation,
      widgets: this.props.widgets,
      widgetEnabled: true,
      immutableWidgets: false,
      onChange: props => {
        var newProps = {};

        if (_$j.has(props, "content")) {
          newProps.explanation = props.content;
        }

        if (_$j.has(props, "widgets")) {
          newProps.widgets = props.widgets;
        }

        this.change(newProps);
      }
    })));
  },

  serialize() {
    return EditorJsonify$4.serialize.call(this);
  }

});
_module_$q.exports = ExplanationEditor;
var _widgetsExplanationEditorJsx = _module_$q.exports;

var _module_$p = {
  exports: {}
};
var React$p = _react__default["default"];
var _$i = _underscore__default["default"];
var Changeable$8 = Changeable$Q;
var PerseusApi = _perseusApiJsx;
var Renderer$5 = _rendererJsx;
var mediaQueries$3 = _stylesMediaQueriesJs;
var defaultExplanationProps = {
  showPrompt: "Explain",
  hidePrompt: "Hide explanation",
  explanation: "explanation goes here\n\nmore explanation",
  widgets: {},
  linterContext: linterContextDefault
};
var Explanation = createReactClass({
  displayName: "Explanation",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$8.propTypes), {}, {
    apiOptions: PerseusApi.Options.propTypes,
    explanation: PropTypes.string,
    hidePrompt: PropTypes.string,
    showPrompt: PropTypes.string,
    trackInteraction: PropTypes.func.isRequired,
    widgets: PropTypes.object,
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return defaultExplanationProps;
  },
  getInitialState: function getInitialState() {
    return {
      expanded: false
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$8.change.apply(this, args);
  },

  _onClick: function _onClick() {
    this.setState({
      expanded: !this.state.expanded
    });
    this.props.trackInteraction();
  },
  render: function render() {
    var {
      Link
    } = this.props.apiOptions.baseElements;
    var {
      readOnly,
      isMobile
    } = this.props.apiOptions;
    var linkAnchor = this.state.expanded ? this.props.hidePrompt : this.props.showPrompt;
    var linkContainer;
    var href = readOnly ? null : "javascript:void(0)";
    var onClick = readOnly ? null : this._onClick;

    if (isMobile) {
      linkContainer = /*#__PURE__*/React$p.createElement("div", {
        className: aphrodite.css(styles$6.linkContainer)
      }, /*#__PURE__*/React$p.createElement("a", {
        className: aphrodite.css(styles$6.mobileExplanationLink),
        href: href,
        onClick: onClick
      }, linkAnchor), this.state.expanded && /*#__PURE__*/React$p.createElement("svg", {
        className: aphrodite.css(styles$6.disclosureArrow)
      }, /*#__PURE__*/React$p.createElement("polygon", {
        style: {
          fill: backgroundColor
        },
        points: "0,".concat(arrowHeight, " ") + "".concat(arrowWidth, ",").concat(arrowHeight, " ") + "".concat(arrowWidth / 2, ",0")
      })));
    } else {
      linkContainer = /*#__PURE__*/React$p.createElement("div", {
        className: aphrodite.css(styles$6.linkContainer)
      }, /*#__PURE__*/React$p.createElement(Link, {
        className: aphrodite.css(styles$6.explanationLink),
        href: href,
        onClick: onClick
      }, "[".concat(linkAnchor, "]")));
    }

    var expandedStyle = isMobile ? styles$6.contentExpandedMobile : styles$6.contentExpanded;
    return /*#__PURE__*/React$p.createElement("div", {
      className: aphrodite.css(styles$6.container)
    }, linkContainer, /*#__PURE__*/React$p.createElement("div", {
      className: aphrodite.css(styles$6.content, isMobile && styles$6.contentMobile, this.state.expanded && expandedStyle),
      style: {
        height: this.state.expanded ? "auto" : 0,
        overflow: this.state.expanded ? "visible" : "hidden"
      },
      ref: "content"
    }, /*#__PURE__*/React$p.createElement(Renderer$5, {
      apiOptions: this.props.apiOptions,
      content: this.props.explanation,
      widgets: this.props.widgets,
      linterContext: this.props.linterContext
    })));
  },
  getUserInput: function getUserInput() {
    return {};
  },
  simpleValidate: function simpleValidate(rubric) {
    return Explanation.validate(this.getUserInput(), rubric);
  }
});
var leftBorderSpacing = 23;
var verticalContentPadding = 10;
var arrowWidth = 30;
var arrowHeight = 14;
var backgroundColor = gray95;
var styles$6 = aphrodite.StyleSheet.create({
  container: {
    display: "inline",
    position: "relative"
  },
  linkContainer: {
    display: "inline-block"
  },
  explanationLink: {
    fontStyle: "italic",
    color: "#007d96",
    [mediaQueries$3.xl]: {
      fontSize: 20,
      lineHeight: 1.1
    },
    [mediaQueries$3.lgOrSmaller]: {
      fontSize: 17,
      lineHeight: 1.4
    },
    [mediaQueries$3.smOrSmaller]: {
      fontSize: 14,
      lineHeight: 1.3
    }
  },
  mobileExplanationLink: {
    color: kaGreen,
    borderBottom: "dashed 1px ".concat(kaGreen),
    textDecoration: "none",
    // TODO(benkomalo): these should be pulled in from common typography
    // shared files so we have a single place where the type hierarchy is
    // defined; one off font sizes for individual components should be
    // avoided.
    [mediaQueries$3.xl]: {
      fontSize: 22,
      lineHeight: 1.4
    },
    [mediaQueries$3.lgOrSmaller]: {
      fontSize: 20,
      lineHeight: 1.5
    },
    [mediaQueries$3.smOrSmaller]: {
      fontSize: 18,
      lineHeight: 1.2
    }
  },
  content: {
    position: "relative",
    transition: "margin-top 0.1s"
  },
  contentExpanded: {
    borderLeft: "5px solid #ccc",
    marginLeft: -leftBorderSpacing,
    paddingLeft: leftBorderSpacing,
    paddingBottom: verticalContentPadding,
    // Note: we still use arrow height as the vertical margin, even on
    // desktop when there is no arrow, but it's good enough.
    marginBottom: arrowHeight,
    marginTop: arrowHeight
  },
  contentExpandedMobile: {
    boxSizing: "content-box",
    paddingTop: 32,
    paddingBottom: 32,
    marginTop: arrowHeight
  },
  contentMobile: {
    background: backgroundColor,
    // TODO(benkomalo): this is to "full bleed" the background.
    // The actual content padding differs depending on the host
    // container, so this needs to be fixed eventually.
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin
  },
  disclosureArrow: {
    // HACK - positioning at "bottom: 0", doesn't actually position it to
    // the real bottom, because the container is `inline-block`, and it
    // seems to position it to the baseline? We put in a generous
    // fudge factor to position it down to be flush with the content box
    // below it.
    bottom: -(arrowHeight + 5),
    height: arrowHeight,
    left: "50%",
    marginLeft: -(arrowWidth / 2),
    position: "absolute",
    width: arrowWidth
  }
});

_$i.extend(Explanation, {
  validate: function validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

_module_$p.exports = {
  name: "explanation",
  displayName: "Explanation",
  defaultAlignment: "inline",
  widget: Explanation,
  transform: _$i.identity,
  isLintable: true
};
var _widgetsExplanationJsx = _module_$p.exports;

var _module_$o = {
  exports: {}
};
/* eslint-disable comma-dangle, max-len, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp, semi, space-before-function-paren */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$o = _react__default["default"];
var ReactDOM$5 = _reactDom__default["default"];
var _$h = _underscore__default["default"];
var InfoTip$4 = _componentsInfoTipJsx;
var InlineIcon$7 = _componentsInlineIconJsx;
var EditorJsonify$3 = _mixinsEditorJsonifyJsx;
var DropdownEditor = createReactClass({
  displayName: "DropdownEditor",
  propTypes: {
    choices: PropTypes.arrayOf(PropTypes.shape({
      content: PropTypes.string,
      correct: PropTypes.bool
    })),
    placeholder: PropTypes.string
  },
  getDefaultProps: function getDefaultProps() {
    return {
      placeholder: "",
      choices: [{
        content: "",
        correct: false
      }]
    };
  },
  render: function render() {
    var dropdownGroupName = _$h.uniqueId("perseus_dropdown_");

    return /*#__PURE__*/React$o.createElement("div", {
      className: "perseus-widget-dropdown"
    }, /*#__PURE__*/React$o.createElement("div", {
      className: "dropdown-info"
    }, "Dropdown", /*#__PURE__*/React$o.createElement(InfoTip$4, null, /*#__PURE__*/React$o.createElement("p", null, "The drop down is useful for making inequalities in a custom format. We normally use the symbols ", "<", ",", " ", ">", ", \u2264, \u2265 (in that order) which you can copy into the choices. When possible, use the \"multiple choice\" answer type instead."))), /*#__PURE__*/React$o.createElement("div", {
      className: "dropdown-placeholder"
    }, /*#__PURE__*/React$o.createElement("input", {
      type: "text",
      placeholder: "Placeholder value",
      value: this.props.placeholder,
      onChange: this.onPlaceholderChange
    }), /*#__PURE__*/React$o.createElement(InfoTip$4, null, /*#__PURE__*/React$o.createElement("p", null, "This value will appear as the drop down default. It should give the user some indication of the values available in the drop down itself, e.g., Yes/No/Maybe."))), /*#__PURE__*/React$o.createElement("div", {
      className: "clearfix"
    }), /*#__PURE__*/React$o.createElement("ul", {
      className: "dropdown-choices"
    }, this.props.choices.map(function (choice, i) {
      var checkedClass = choice.correct ? "correct" : "incorrect";
      return /*#__PURE__*/React$o.createElement("li", {
        key: "" + i
      }, /*#__PURE__*/React$o.createElement("div", null, /*#__PURE__*/React$o.createElement("input", {
        ref: "radio" + i,
        type: "radio",
        name: dropdownGroupName,
        checked: choice.correct ? "checked" : "",
        onChange: this.onCorrectChange.bind(this, i),
        value: i
      }), /*#__PURE__*/React$o.createElement("input", {
        type: "text",
        ref: "editor" + i,
        onChange: this.onContentChange.bind(this, i),
        className: checkedClass,
        value: choice.content
      }), /*#__PURE__*/React$o.createElement("a", {
        href: "#",
        className: "simple-button orange",
        onClick: this.removeChoice.bind(this, i)
      }, /*#__PURE__*/React$o.createElement("span", {
        className: "remove-choice"
      }, /*#__PURE__*/React$o.createElement(InlineIcon$7, iconTrash)))));
    }, this)), /*#__PURE__*/React$o.createElement("div", {
      className: "add-choice-container"
    }, /*#__PURE__*/React$o.createElement("a", {
      href: "#",
      className: "simple-button orange",
      onClick: this.addChoice
    }, /*#__PURE__*/React$o.createElement(InlineIcon$7, iconPlus), " Add a choice", " ")));
  },
  onPlaceholderChange: function onPlaceholderChange(e) {
    var placeholder = e.target.value;
    this.props.onChange({
      placeholder: placeholder
    });
  },
  onCorrectChange: function onCorrectChange(choiceIndex) {
    var choices = _$h.map(this.props.choices, function (choice, i) {
      return _$h.extend({}, choice, {
        correct: i === choiceIndex
      });
    });

    this.props.onChange({
      choices: choices
    });
  },
  onContentChange: function onContentChange(choiceIndex, e) {
    var choices = this.props.choices.slice();

    var choice = _$h.clone(choices[choiceIndex]);

    choice.content = e.target.value;
    choices[choiceIndex] = choice;
    this.props.onChange({
      choices: choices
    });
  },
  addChoice: function addChoice(e) {
    e.preventDefault();
    var choices = this.props.choices;
    var blankChoice = {
      content: "",
      correct: false
    };
    this.props.onChange({
      choices: choices.concat([blankChoice])
    }, this.focus.bind(this, choices.length));
  },
  removeChoice: function removeChoice(choiceIndex, e) {
    e.preventDefault();

    var choices = _$h.clone(this.props.choices);

    choices.splice(choiceIndex, 1);
    this.props.onChange({
      choices: choices
    });
  },
  focus: function focus(i) {
    ReactDOM$5.findDOMNode(this.refs["editor" + i]).focus();
    return true;
  },

  serialize() {
    return EditorJsonify$3.serialize.call(this);
  }

});
_module_$o.exports = DropdownEditor;
var _widgetsDropdownEditorJsx = _module_$o.exports;

var _module_$n = {
  exports: {}
};
var classNames$6 = _classnames__default["default"];
var React$n = _react__default["default"];
var ReactDOM$4 = _reactDom__default["default"];
var _$g = _underscore__default["default"];
var ApiClassNames$6 = _perseusApiJsx.ClassNames;
var ApiOptions$6 = _perseusApiJsx.Options;
var InlineIcon$6 = _componentsInlineIconJsx;
var dropdownArrowSize = 24;
var Dropdown = createReactClass({
  displayName: "Dropdown",
  propTypes: {
    apiOptions: ApiOptions$6.propTypes,
    choices: PropTypes.arrayOf(PropTypes.string),
    onChange: PropTypes.func.isRequired,
    placeholder: PropTypes.string,
    selected: PropTypes.number,
    trackInteraction: PropTypes.func.isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return {
      choices: [],
      selected: 0,
      placeholder: "",
      apiOptions: ApiOptions$6.defaults
    };
  },
  render: function render() {
    var choices = this.props.choices.slice();
    var selectClasses = classNames$6({
      "perseus-widget-dropdown": true
    });
    return /*#__PURE__*/React$n.createElement("div", null, /*#__PURE__*/React$n.createElement("select", {
      onChange: this._handleChangeEvent,
      onClick: e => {
        e.stopPropagation();
        e.target.focus();
      },
      onTouchStart: e => {
        e.stopPropagation();
        e.target.focus();
      },
      className: selectClasses + // This makes it so that mobile's fastclick doesn't
      // interfere & call `.focus` when we're inside of a
      // zoomable table.
      " nofastclick " + aphrodite.css(styles$5.dropdown) + " " + ApiClassNames$6.INTERACTIVE,
      disabled: this.props.apiOptions.readOnly,
      value: this.props.selected
    }, /*#__PURE__*/React$n.createElement("option", {
      value: 0,
      disabled: true
    }, this.props.placeholder), choices.map((choice, i) => {
      return /*#__PURE__*/React$n.createElement("option", {
        key: "" + (i + 1),
        value: i + 1
      }, choice);
    })), /*#__PURE__*/React$n.createElement(InlineIcon$6, _extends({}, iconDropdownArrow, {
      style: {
        marginLeft: "-".concat(dropdownArrowSize, "px"),
        height: dropdownArrowSize,
        width: dropdownArrowSize
      }
    })));
  },
  focus: function focus() {
    ReactDOM$4.findDOMNode(this).focus();
    return true;
  },
  _handleChangeEvent: function _handleChangeEvent(e) {
    this._handleChange(parseInt(e.target.value));
  },
  _handleChange: function _handleChange(selected) {
    this.props.trackInteraction();
    this.props.onChange({
      selected: selected
    });
  },
  getUserInput: function getUserInput() {
    return {
      value: this.props.selected
    };
  },
  simpleValidate: function simpleValidate(rubric) {
    return Dropdown.validate(this.getUserInput(), rubric);
  }
});

_$g.extend(Dropdown, {
  validate: function validate(state, rubric) {
    var selected = state.value;

    if (selected === 0) {
      return {
        type: "invalid",
        message: null
      };
    } else {
      var correct = rubric.choices[selected - 1].correct;
      return {
        type: "points",
        earned: correct ? 1 : 0,
        total: 1,
        message: null
      };
    }
  }
});

var propTransform$1 = editorProps => {
  return {
    placeholder: editorProps.placeholder,
    choices: _$g.map(editorProps.choices, choice => choice.content)
  };
};

var styles$5 = aphrodite.StyleSheet.create({
  dropdown: {
    appearance: "none",
    backgroundColor: "transparent",
    border: "1px solid ".concat(gray76),
    borderRadius: 4,
    boxShadow: "none",
    fontFamily: baseFontFamily,
    padding: "9px ".concat(dropdownArrowSize + 1, "px 9px 9px"),
    ":focus": {
      outline: "none",
      border: "2px solid ".concat(kaGreen),
      padding: "8px ".concat(dropdownArrowSize, "px 8px 8px")
    },
    ":focus + svg": {
      color: "".concat(kaGreen)
    },
    ":disabled": {
      color: gray68
    },
    ":disabled + svg": {
      color: gray68
    }
  }
});
_module_$n.exports = {
  name: "dropdown",
  displayName: "Drop down",
  defaultAlignment: "inline-block",
  accessible: true,
  widget: Dropdown,
  transform: propTransform$1
};
var _widgetsDropdownJsx = _module_$n.exports;

var _module_$m = {
  exports: {}
};
/* eslint-disable comma-dangle, no-console, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp, space-before-function-paren, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$m = _react__default["default"];
var _$f = _underscore__default["default"];
var Changeable$7 = Changeable$Q;
var EditorJsonify$2 = _mixinsEditorJsonifyJsx;
var BlurInput$1 = _reactComponentsBlurInputJsx;
var InfoTip$3 = _componentsInfoTipJsx;
var PropCheckBox$4 = _componentsPropCheckBoxJsx;
var DEFAULT_WIDTH = 400;
var DEFAULT_HEIGHT = 400;
/**
 * This is used for editing a name/value pair.
 */

var PairEditor = createReactClass({
  displayName: "PairEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$7.propTypes), {}, {
    name: PropTypes.string,
    value: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      name: "",
      value: ""
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$7.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$m.createElement("fieldset", {
      className: "pair-editor"
    }, /*#__PURE__*/React$m.createElement("label", null, "Name:", " ", /*#__PURE__*/React$m.createElement(BlurInput$1, {
      value: this.props.name,
      onChange: this.change("name")
    })), /*#__PURE__*/React$m.createElement("label", null, " ", "Value:", " ", /*#__PURE__*/React$m.createElement(BlurInput$1, {
      value: this.props.value,
      onChange: this.change("value")
    })));
  },

  serialize() {
    return EditorJsonify$2.serialize.call(this);
  }

});
/**
 * This is used for editing a set of name/value pairs.
 */

var PairsEditor = createReactClass({
  displayName: "PairsEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$7.propTypes), {}, {
    pairs: PropTypes.arrayOf(PropTypes.shape({
      name: PropTypes.string,
      value: PropTypes.string
    })).isRequired
  }),
  render: function render() {
    var editors = _$f.map(this.props.pairs, (pair, i) => {
      return /*#__PURE__*/React$m.createElement(PairEditor, {
        key: i,
        name: pair.name,
        value: pair.value,
        onChange: this.handlePairChange.bind(this, i)
      });
    });

    return /*#__PURE__*/React$m.createElement("div", null, editors);
  },

  change() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return Changeable$7.change.apply(this, args);
  },

  handlePairChange: function handlePairChange(pairIndex, pair) {
    // If they're both non empty, add a new one
    var pairs = this.props.pairs.slice();
    pairs[pairIndex] = pair;
    var lastPair = pairs[pairs.length - 1];

    if (lastPair.name && lastPair.value) {
      pairs.push({
        name: "",
        value: ""
      });
    }

    this.change("pairs", pairs);
  },

  serialize() {
    return EditorJsonify$2.serialize.call(this);
  }

});
var KA_PROGRAM_URL = /khanacademy\.org\/computer-programming\/[^\/]+\/(\d+)/;
/**
 * Given a program URL from the site, extract its program ID.
 * If the input does not match the known URL patterns, it is assumed to be
 * a program ID.
 */

function isolateProgramID(programUrl) {
  var match = KA_PROGRAM_URL.exec(programUrl);

  if (match) {
    programUrl = match[1];
  }

  return programUrl;
}
/**
 * This is the main editor for this widget, to specify all the options.
 */


var CSProgramEditor = createReactClass({
  displayName: "CSProgramEditor",
  propTypes: _objectSpread2({}, Changeable$7.propTypes),
  getDefaultProps: function getDefaultProps() {
    return {
      programID: "",
      settings: [{
        name: "",
        value: ""
      }],
      showEditor: false,
      showButtons: false,
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT
    };
  },
  render: function render() {
    return /*#__PURE__*/React$m.createElement("div", null, /*#__PURE__*/React$m.createElement("label", null, "Url or Program ID:", " ", /*#__PURE__*/React$m.createElement(BlurInput$1, {
      name: "programID",
      value: this.props.programID,
      onChange: this._handleProgramIDChange
    })), /*#__PURE__*/React$m.createElement("br", null), /*#__PURE__*/React$m.createElement(PropCheckBox$4, {
      label: "Show Editor",
      showEditor: this.props.showEditor,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$m.createElement(InfoTip$3, null, "If you show the editor, you should use the \"full-width\" alignment to make room for the width of the editor."), /*#__PURE__*/React$m.createElement("br", null), /*#__PURE__*/React$m.createElement(PropCheckBox$4, {
      label: "Show Buttons",
      showButtons: this.props.showButtons,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$m.createElement("br", null), /*#__PURE__*/React$m.createElement("label", null, "Settings:", /*#__PURE__*/React$m.createElement(PairsEditor, {
      name: "settings",
      pairs: this.props.settings,
      onChange: this._handleSettingsChange
    }), /*#__PURE__*/React$m.createElement(InfoTip$3, null, "Settings that you add here are available to the program as an object returned by ", /*#__PURE__*/React$m.createElement("code", null, "Program.settings()"))));
  },

  change() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return Changeable$7.change.apply(this, args);
  },

  _handleSettingsChange: function _handleSettingsChange(settings) {
    this.change({
      settings: settings.pairs
    });
  },
  _handleProgramIDChange: function _handleProgramIDChange(programID) {
    programID = isolateProgramID(programID);
    $.getJSON("https://www.khanacademy.org/api/internal/scratchpads/" + programID).done(programInfo => {
      this.change({
        width: programInfo.width,
        height: programInfo.height,
        programID: programID
      });
    }).fail((jqxhr, textStatus, error) => {
      console.error("Error retrieving scratchpad info for " + "program ID ", programID);
      console.error(textStatus + ", " + error);
      this.change({
        width: DEFAULT_WIDTH,
        height: DEFAULT_HEIGHT,
        programID: programID
      });
    });
  },

  serialize() {
    return EditorJsonify$2.serialize.call(this);
  }

});
_module_$m.exports = CSProgramEditor;
var _widgetsCsProgramEditorJsx = _module_$m.exports;

var _module_$l = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

/**
 * This widget is for embedding Khan Academy CS programs.
 */

var React$l = _react__default["default"];
var _$e = _underscore__default["default"];
var Changeable$6 = Changeable$Q;
var updateQueryString = Util$q.updateQueryString;
var PADDING_WIDTH = 2;
var IS_KA_SITE = /khanacademy\.org/;
var KA_EMBED_URL = "https://{hostname}/computer-programming/program/" + "{programID}/embedded?embed=yes&author=no";

function getUrlFromProgramID(programID) {
  var url = KA_EMBED_URL.replace("{programID}", programID);
  var currentHostname = document.location.hostname;
  var embedHostname = "www.khanacademy.org";

  if (IS_KA_SITE.test(currentHostname)) {
    embedHostname = currentHostname;
  }

  return url.replace("{hostname}", embedHostname);
}
/* This renders the scratchpad in an iframe and handles validation via
 * window.postMessage */


var CSProgram = createReactClass({
  displayName: "CSProgram",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$6.propTypes), {}, {
    programID: PropTypes.string,
    width: PropTypes.number,
    height: PropTypes.number,
    settings: PropTypes.array,
    showEditor: PropTypes.bool,
    showButtons: PropTypes.bool,
    status: PropTypes.oneOf(["incomplete", "incorrect", "correct"]),
    message: PropTypes.string
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      showEditor: false,
      showButtons: false,
      status: "incomplete",
      // optional message
      message: null
    };
  },
  handleMessageEvent: function handleMessageEvent(e) {
    // We receive data from the iframe that contains {passed: true/false}
    //  and use that to set the status
    // It could also contain an optional message
    var data = {};

    try {
      data = JSON.parse(e.originalEvent.data);
    } catch (err) {
      return;
    }

    if (_$e.isUndefined(data.testsPassed)) {
      return;
    }

    var status = data.testsPassed ? "correct" : "incorrect";
    this.change({
      status: status,
      message: data.message
    });
  },
  componentDidMount: function componentDidMount() {
    $(window).on("message", this.handleMessageEvent);
  },
  componentWillUnmount: function componentWillUnmount() {
    $(window).off("message", this.handleMessageEvent);
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$6.change.apply(this, args);
  },

  render: function render() {
    if (!this.props.programID) {
      return /*#__PURE__*/React$l.createElement("div", null);
    }

    var url = getUrlFromProgramID(this.props.programID);
    var className;
    var style = {
      height: this.props.height
    };

    if (this.props.showEditor) {
      url += "&editor=yes";
      style.width = "100%";
      className = "perseus-scratchpad-editor";
    } else {
      url += "&editor=no";
      style.width = this.props.width + PADDING_WIDTH;
      className = "perseus-scratchpad";
    }

    if (this.props.showButtons) {
      url += "&buttons=yes";
      style.height += 50;
    } else {
      url += "&buttons=no";
    } // Turn array of [{name: "", value: ""}] into object


    if (this.props.settings) {
      var settings = {};

      _$e.each(this.props.settings, function (setting) {
        if (setting.name && setting.value) {
          settings[setting.name] = setting.value;
        }
      }); // This becomes available to programs as Program.settings()


      url = updateQueryString(url, "settings", JSON.stringify(settings));
    }

    var sandboxOptions = ["allow-popups", "allow-same-origin", "allow-scripts", "allow-top-navigation"].join(' '); // We sandbox the iframe so that we whitelist only the functionality
    //  that we need. This makes it a bit safer in case some content
    //  creator "went wild".
    // http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/

    return /*#__PURE__*/React$l.createElement("iframe", {
      sandbox: sandboxOptions,
      src: url,
      style: style,
      className: className,
      allowFullScreen: true
    });
  },
  simpleValidate: function simpleValidate(rubric) {
    return CSProgram.validate({
      status: this.props.status,
      message: this.props.message
    }, rubric);
  },
  statics: {
    // The widget's grading function
    validate: function validate(state, rubric) {
      // The iframe can tell us whether it's correct or incorrect,
      //  and pass an optional message
      if (state.status === "correct") {
        return {
          type: "points",
          earned: 1,
          total: 1,
          message: state.message || null
        };
      } else if (state.status === "incorrect") {
        return {
          type: "points",
          earned: 0,
          total: 1,
          message: state.message || null
        };
      } else {
        return {
          type: "invalid",
          message: "Keep going, you're not there yet!"
        };
      }
    }
  }
});
_module_$l.exports = {
  name: "cs-program",
  displayName: "CS Program",
  supportedAlignments: ["block", "full-width"],
  widget: CSProgram,
  hidden: true
};
var _widgetsCsProgramJsx = _module_$l.exports;

var _module_$k = {
  exports: {}
};
var React$k = _react__default["default"];
var classNames$5 = _classnames__default["default"];
var Changeable$5 = Changeable$Q;
var WidgetJsonifyDeprecated = _mixinsWidgetJsonifyDeprecatedJsx;
var _$d = _underscore__default["default"];
var ApiClassNames$5 = _perseusApiJsx.ClassNames;
var ApiOptions$5 = _perseusApiJsx.Options;
var InlineIcon$5 = _componentsInlineIconJsx;
var Renderer$4 = _rendererJsx;
var Util$2 = Util$q;
var mediaQueries$2 = _stylesMediaQueriesJs;
var sharedStyles$2 = _stylesSharedJs;
var Categorizer$1 = createReactClass({
  displayName: "Categorizer",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$5.propTypes), {}, {
    apiOptions: ApiOptions$5.propTypes,
    // List of categories (across the top)
    categories: PropTypes.arrayOf(PropTypes.string),
    // List of items that are being categorized (along the left side)
    items: PropTypes.arrayOf(PropTypes.string),
    trackInteraction: PropTypes.func.isRequired,
    // Ordered list of correct answers, mapping items to categories thusly:
    //   values[<items_index>] == <categories_index>
    values: PropTypes.arrayOf(PropTypes.number),
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      items: [],
      categories: [],
      values: [],
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      uniqueId: _$d.uniqueId("perseus_radio_")
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$5.change.apply(this, args);
  },

  getUserInput: function getUserInput() {
    return WidgetJsonifyDeprecated.getUserInput.call(this);
  },
  render: function render() {
    var self = this; // In this context, isMobile is used to differentiate mobile from
    // desktop.

    var isMobile = this.props.apiOptions.isMobile;
    var indexedItems = this.props.items.map((item, n) => [item, n]);

    if (this.props.randomizeItems) {
      indexedItems = Util$2.shuffle(indexedItems, this.props.problemNum);
    }

    var table = /*#__PURE__*/React$k.createElement("table", {
      className: "categorizer-table"
    }, /*#__PURE__*/React$k.createElement("thead", null, /*#__PURE__*/React$k.createElement("tr", null, /*#__PURE__*/React$k.createElement("th", null, "\xA0"), this.props.categories.map((category, i) => {
      // Array index is the correct key here, as that's
      // how category grading actually works -- no way
      // to add or remove categories or items in the
      // middle. (If we later add that, this should be
      // fixed.)
      return /*#__PURE__*/React$k.createElement("th", {
        className: aphrodite.css(styles$4.header),
        key: i
      }, /*#__PURE__*/React$k.createElement(Renderer$4, {
        content: category,
        linterContext: this.props.linterContext
      }));
    }))), /*#__PURE__*/React$k.createElement("tbody", null, indexedItems.map(indexedItem => {
      var item = indexedItem[0];
      var itemNum = indexedItem[1];
      var uniqueId = self.state.uniqueId + "_" + itemNum;
      /* eslint-disable max-len */

      return /*#__PURE__*/React$k.createElement("tr", {
        key: itemNum
      }, /*#__PURE__*/React$k.createElement("td", null, /*#__PURE__*/React$k.createElement(Renderer$4, {
        content: item,
        linterContext: this.props.linterContext
      })), _$d.range(self.props.categories.length).map(catNum => {
        var selected = self.props.values[itemNum] === catNum;
        return /*#__PURE__*/React$k.createElement("td", {
          className: "category " + aphrodite.css(styles$4.cell, styles$4.responsiveCell),
          key: catNum
        }, /*#__PURE__*/React$k.createElement("div", {
          className: ApiClassNames$5.INTERACTIVE,
          onClick: this.onChange.bind(this, itemNum, catNum)
        }, isMobile && /*#__PURE__*/React$k.createElement("input", {
          type: "radio",
          name: uniqueId,
          className: aphrodite.css(sharedStyles$2.responsiveInput, sharedStyles$2.responsiveRadioInput),
          checked: selected,
          onChange: this.onChange.bind(this, itemNum, catNum),
          onClick: e => e.stopPropagation()
        }), !isMobile && /*#__PURE__*/React$k.createElement("span", {
          className: aphrodite.css(styles$4.responsiveSpan, styles$4.radioSpan, selected && styles$4.checkedRadioSpan, this.props.static && selected && styles$4.staticCheckedRadioSpan)
        }, selected ? /*#__PURE__*/React$k.createElement(InlineIcon$5, iconCircle) : /*#__PURE__*/React$k.createElement(InlineIcon$5, iconCircleThin))));
      }));
      /* eslint-enable max-len */
    }))); // TODO(benkomalo): kill CSS-based styling and move everything to
    // aphrodite.

    var extraClassNames = classNames$5({
      "categorizer-container": true,
      "static-mode": this.props.static
    });
    var inlineStyles = this.props.apiOptions.isMobile ? [styles$4.fullBleedContainer] : [];
    return /*#__PURE__*/React$k.createElement("div", {
      className: extraClassNames + " " + aphrodite.css(...inlineStyles)
    }, table);
  },
  onChange: function onChange(itemNum, catNum) {
    var values = _$d.clone(this.props.values);

    values[itemNum] = catNum;
    this.change("values", values);
    this.props.trackInteraction();
  },
  simpleValidate: function simpleValidate(rubric) {
    return Categorizer$1.validate(this.getUserInput(), rubric);
  }
});

_$d.extend(Categorizer$1, {
  validate: function validate(state, rubric) {
    var completed = true;
    var allCorrect = true;

    _$d.each(rubric.values, function (value, i) {
      if (state.values[i] == null) {
        completed = false;
      }

      if (state.values[i] !== value) {
        allCorrect = false;
      }
    });

    if (!completed) {
      return {
        type: "invalid",
        message: i18n._("Make sure you select something for every row.")
      };
    }

    return {
      type: "points",
      earned: allCorrect ? 1 : 0,
      total: 1,
      message: null
    };
  }
}); // TODO(benkomalo): inject page-margin into Perseus instead of hardcoding.


var pageMargin = 16;
var styles$4 = aphrodite.StyleSheet.create({
  fullBleedContainer: {
    [mediaQueries$2.mdOrSmaller]: {
      marginLeft: -pageMargin,
      marginRight: -pageMargin,
      overflowX: "auto"
    }
  },
  header: {
    textAlign: "center",
    verticalAlign: "bottom"
  },
  cell: {
    textAlign: "center",
    padding: 0,
    color: "#ccc",
    verticalAlign: "middle"
  },
  radioSpan: {
    fontSize: 30,
    paddingRight: 3,
    ":hover": {
      color: "#999"
    }
  },
  checkedRadioSpan: {
    color: "#333"
  },
  // .static-mode is applied by the Categorizer when the rendered
  // widget is static; in this case we gray out the choices to show
  // the user that the widget can't be interacted with.
  staticCheckedRadioSpan: {
    color: "#888"
  }
});
_module_$k.exports = {
  name: "categorizer",
  displayName: "Categorizer",
  widget: Categorizer$1,
  transform: editorProps => {
    return _$d.pick(editorProps, "items", "categories", "randomizeItems");
  },
  staticTransform: editorProps => {
    return _$d.pick(editorProps, "items", "categories", "values", "randomizeItems");
  },
  isLintable: true
};
var _widgetsCategorizerJsx = _module_$k.exports;

var _module_$j = {
  exports: {}
};
/* eslint-disable brace-style, comma-dangle, indent, react/jsx-closing-bracket-location, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$j = _react__default["default"];
var Changeable$4 = Changeable$Q;
var _$c = _underscore__default["default"];
var ApiOptions$4 = _perseusApiJsx.Options;
var EditorJsonify$1 = _mixinsEditorJsonifyJsx;
var PropCheckBox$3 = _componentsPropCheckBoxJsx;
var TextListEditor = _componentsTextListEditorJsx;
var Categorizer = _widgetsCategorizerJsx.widget;
var CategorizerEditor = createReactClass({
  displayName: "CategorizerEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$4.propTypes), {}, {
    apiOptions: ApiOptions$4.propTypes,
    items: PropTypes.arrayOf(PropTypes.string),
    categories: PropTypes.arrayOf(PropTypes.string),
    values: PropTypes.arrayOf(PropTypes.number),
    randomizeItems: PropTypes.bool
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      items: [],
      categories: [],
      values: [],
      randomizeItems: false
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$4.change.apply(this, args);
  },

  render: function render() {
    return /*#__PURE__*/React$j.createElement("div", null, /*#__PURE__*/React$j.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$j.createElement(PropCheckBox$3, {
      label: "Randomize item order",
      labelAlignment: "right",
      randomizeItems: this.props.randomizeItems,
      onChange: this.props.onChange
    })), "Categories:", /*#__PURE__*/React$j.createElement(TextListEditor, {
      options: this.props.categories,
      onChange: cat => {
        this.change("categories", cat);
      },
      layout: "horizontal"
    }), "Items:", /*#__PURE__*/React$j.createElement(TextListEditor, {
      options: this.props.items,
      onChange: items => {
        this.change({
          items: items,
          // TODO(eater): This truncates props.values so there
          // are never more correct answers than items,
          // ensuring the widget is possible to answer
          // correctly. It doesn't necessarly keep each
          // answer with its corresponding item if an item
          // is deleted from the middle. Inconvenient, but
          // it's at least possible for content creators to
          // catch and fix.
          values: _$c.first(this.props.values, items.length)
        });
      },
      layout: "vertical"
    }), /*#__PURE__*/React$j.createElement(Categorizer, {
      apiOptions: this.props.apiOptions,
      items: this.props.items,
      categories: this.props.categories,
      values: this.props.values,
      onChange: newProps => {
        this.props.onChange(newProps);
      },
      trackInteraction: function trackInteraction() {}
    }));
  },

  serialize() {
    return EditorJsonify$1.serialize.call(this);
  }

});
_module_$j.exports = CategorizerEditor;
var _widgetsCategorizerEditorJsx = _module_$j.exports;

// webapp perseus/traversal.py so they can be properly translated.

var allWidgets = [[_widgetsCategorizerJsx, _widgetsCategorizerEditorJsx], [_widgetsCsProgramJsx, _widgetsCsProgramEditorJsx], [_widgetsDropdownJsx, _widgetsDropdownEditorJsx], [_widgetsExplanationJsx, _widgetsExplanationEditorJsx], [_widgetsDefinitionJsx, _widgetsDefinitionEditorJsx], [_widgetsGrapherJsx, _widgetsGrapherEditorJsx], [_widgetsGradedGroupJsx, _widgetsGradedGroupEditorJsx], [_widgetsGradedGroupSetJsx, _widgetsGradedGroupSetEditorJsx], [_widgetsGroupJsx, _widgetsGroupEditorJsx], [_widgetsIframeJsx, _widgetsIframeEditorJsx], [_widgetsImageJsx, _widgetsImageEditorJsx], [_widgetsInteractionJsx, _widgetsInteractionEditorJsx], [_widgetsInteractiveGraphJsx, _widgetsInteractiveGraphEditorJsx], [_widgetsLightsPuzzleJsx, _widgetsLightsPuzzleEditorJsx], [_widgetsMatrixJsx, _widgetsMatrixEditorJsx], [_widgetsMatcherJsx, _widgetsMatcherEditorJsx], [_widgetsMeasurerJsx, _widgetsMeasurerEditorJsx], [_widgetsMoleculeJsx, _widgetsMoleculeEditorJsx], [_widgetsNumberLineJsx, _widgetsNumberLineEditorJsx], [_widgetsOrdererJsx, _widgetsOrdererEditorJsx], [_widgetsPassageJsx, _widgetsPassageEditorJsx], [_passageRefJsx, _widgetsPassageRefEditorJsx], [_widgetsPassageRefTargetJsx, _widgetsPassageRefTargetEditorJsx], [_widgetsPlotterJsx, _widgetsPlotterEditorJsx], [_widgetsReactionDiagramJsx, _widgetsReactionDiagramEditorJsx], [_widgetsSequenceJsx, _widgetsSequenceEditorJsx], [_widgetsSimulatorJsx, _widgetsSimulatorEditorJsx], [_widgetsSorterJsx, _widgetsSorterEditorJsx], [_widgetsTableJsx, _widgetsTableEditorJsx], [_widgetsTransformerJsx, _widgetsTransformerEditorJsx], [_widgetsUnitJsx, _widgetsUnitEditorJsx], [_widgetsVideoJsx, _widgetsVideoEditorJsx] // These widgets are only used when testing things, so remove them in the
// non-editor bundle.
//__EDITOR__ && [
//    _widgetsExampleGraphieWidgetJsx,
//    _widgetsExampleGraphieWidgetEditorJsx,
//],
//__EDITOR__ && [
//    _widgetsExampleWidgetJsx,
//    _widgetsExampleWidgetEditorJsx,
//],
//__EDITOR__ && [
//    _widgetsSimpleMarkdownTesterJsx,
//    _widgetsSimpleMarkdownTesterEditorJsx,
//],
];

var _module_$i = {
  exports: {}
};
/**
 * This should be called by all clients, specifying whether extra widgets are
 * needed via `loadExtraWidgets`. It is idempotent, so it's not a problem to
 * call it multiple times.
 *
 * skipMathJax:
 *   if false/undefined, MathJax will be configured, and the
 *   promise will wait for MathJax to load (if it hasn't already).
 * loadExtraWidgets:
 *   if true, `extra-widgets` will be required. The client must have already
 *   loaded the file, either by using the full perseus bundle
 *   `/build/perseus.js`, or by loading `/build/perseus-extras.js` prior to
 *   calling `Perseus.init()`.
 */

var init$1 = function init(options) {
  // Pass skipMathJax: true if MathJax is already loaded and configured.
  var skipMathJax = options.skipMathJax;
  var widgetsDeferred = $.Deferred(); // HACK(charlie): To maintain backwards compatibility, only exclude the
  // extra widgets if the parameter is explicitly falsey (rather than merely
  // undefined). We should probably bump the Perseus major version number
  // (since this is a breaking change in the API) but this is a more
  // lightweight fix that will get exercises working in our mobile apps
  // immediately.
  // TODO(aria): Re-enable extra-widgets
  //if (options.loadExtraWidgets === undefined || options.loadExtraWidgets) {
  //    const Widgets = _widgetsJs;
  //    require.ensure(
  //        [],
  //        require => {
  //            const extraWidgets = _extraWidgetsJs;
  //            Widgets.registerMany(extraWidgets);
  //            widgetsDeferred.resolve();
  //        },
  //        "extra-widgets"
  //    );
  //} else {

  widgetsDeferred.resolve(); //}

  var mathJaxDeferred = $.Deferred();

  if (skipMathJax) {
    mathJaxDeferred.resolve();
  } else {
    MathJax.Hub.Config({
      messageStyle: "none",
      skipStartupTypeset: "none",
      "HTML-CSS": {
        availableFonts: ["TeX"],
        imageFont: null,
        scale: 100,
        showMathMenu: false
      }
    });
    MathJax.Hub.Configured();
    MathJax.Hub.Queue(mathJaxDeferred.resolve);
  }

  return widgetsDeferred.then(() => mathJaxDeferred);
};

_module_$i.exports = init$1;
var _initJs = _module_$i.exports;

var module$2 = {
  exports: {}
};
/**
 * A generic tooltip library for React.js
 *
 * This should eventually end up in react-components
 *
 * Interface: ({a, b} means one of a or b)
 * const Tooltip = require("./tooltip.jsx");
 * <Tooltip
 *     className="class-for-tooltip-contents"
 *     horizontalPosition="left" // one of "left", "right"
 *     horizontalAlign="left" // one of "left", "right"
 *     verticalPosition="bottom" // one of "top", "bottom"
 *     arrowSize={10} // arrow size in pixels
 *     borderColor="#ccc" // color of the border for the tooltip
 *     show={true} // whether the tooltip should currently be visible
 *     targetContainerStyle={targetContainerStyle}
 * >
 *     <TargetElementOfTheTooltip />
 *     <TooltipContents1 />
 *     <TooltipContents2 />
 * </Tooltip>
 *
 * To show/hide the tooltip, the parent component should call the
 * .show() and .hide() methods of the tooltip when appropriate.
 * (These are usually set up as handlers of events on the target element.)
 *
 * Notes:
 *     className should not specify a border; that is handled by borderColor
 *     so that the arrow and tooltip match
 */
//          __,,--``\\
//  _,,-''``         \\     ,
// '----------_.------'-.___|\__
//    _.--''``    `)__   )__   @\__
//   (  .. ''---/___,,E/__,E'------`
//    `-''`''
// Here be dragons.
// TODO(joel/aria) fix z-index issues https://s3.amazonaws.com/uploads.hipchat.com/6574/29028/yOApjwmgiMhEZYJ/Screen%20Shot%202014-05-30%20at%203.34.18%20PM.png
// z-index: 3 on perseus-formats-tooltip seemed to work

var React$i = _react__default["default"];
var ReactDOM$3 = _reactDom__default["default"];
var createReactClass$2 = _createReactClass__default["default"];
var PropTypes$2 = _propTypes__default["default"];
var zIndex = 10;
var Triangle = createReactClass$2({
  displayName: "Triangle",
  propTypes: {
    color: PropTypes$2.string.isRequired,
    left: PropTypes$2.number.isRequired,
    "top": PropTypes$2.number.isRequired,
    width: PropTypes$2.number.isRequired,
    height: PropTypes$2.number.isRequired,
    horizontalDirection: PropTypes$2.oneOf(["left", "right"]).isRequired,
    verticalDirection: PropTypes$2.oneOf(["top", "bottom"]).isRequired
  },
  render: function render() {
    var borderLeft;
    var borderRight;
    var borderTop;
    var borderBottom;
    var hBorder = "".concat(this.props.width, "px solid transparent");

    if (this.props.horizontalDirection === "right") {
      borderLeft = hBorder;
    } else {
      borderRight = hBorder;
    }

    var vBorder = "".concat(this.props.height, "px solid ").concat(this.props.color);

    if (this.props.verticalDirection === "top") {
      borderTop = vBorder;
    } else {
      borderBottom = vBorder;
    }

    return /*#__PURE__*/React$i.createElement("div", {
      style: {
        display: "block",
        height: 0,
        width: 0,
        position: "absolute",
        left: this.props.left,
        "top": this.props["top"],
        borderLeft: borderLeft,
        borderRight: borderRight,
        borderTop: borderTop,
        borderBottom: borderBottom
      }
    });
  }
});
var TooltipArrow = createReactClass$2({
  displayName: "TooltipArrow",
  propTypes: {
    position: PropTypes$2.string,
    visibility: PropTypes$2.string,
    left: PropTypes$2.number,
    "top": PropTypes$2.number,
    color: PropTypes$2.string.isRequired,
    // a css color
    border: PropTypes$2.string.isRequired,
    // a css color
    width: PropTypes$2.number.isRequired,
    height: PropTypes$2.number.isRequired,
    horizontalDirection: PropTypes$2.oneOf(["left", "right"]).isRequired,
    verticalDirection: PropTypes$2.oneOf(["top", "bottom"]).isRequired
  },
  getDefaultProps: function getDefaultProps() {
    return {
      position: "relative",
      visibility: "visible",
      left: 0,
      "top": 0
    };
  },
  // TODO(aria): Think about adding a box-shadow to the triangle here
  // See http://css-tricks.com/triangle-with-shadow/
  render: function render() {
    //const isRight = (this.props.horizontalDirection === "right");
    var isTop = this.props.verticalDirection === "top";
    var frontTopOffset = isTop ? 0 : 1;
    var borderTopOffset = isTop ? 0 : -1;
    return /*#__PURE__*/React$i.createElement("div", {
      style: {
        display: "block",
        position: this.props.position,
        visibility: this.props.visibility,
        left: this.props.left,
        "top": this.props["top"],
        width: this.props.width + 2,
        height: this.props.height + 1,
        marginTop: -1,
        marginBottom: -2,
        zIndex: zIndex
      }
    }, /*#__PURE__*/React$i.createElement(Triangle, {
      horizontalDirection: this.props.horizontalDirection,
      verticalDirection: this.props.verticalDirection,
      color: this.props.border,
      left: 0,
      top: borderTopOffset,
      width: this.props.width + 2 // one extra for the diagonal
      ,
      height: this.props.height + 2
    }), /*#__PURE__*/React$i.createElement(Triangle, {
      horizontalDirection: this.props.horizontalDirection,
      verticalDirection: this.props.verticalDirection,
      color: this.props.color,
      left: 1,
      top: frontTopOffset,
      width: this.props.width,
      height: this.props.height
    }));
  }
});
var VERTICAL_CORNERS = {
  "top": {
    "top": "-100%"
  },
  bottom: {
    "top": 0
  }
};
var HORIZONTAL_CORNERS = {
  left: {
    targetLeft: 0
  },
  right: {
    targetLeft: "100%"
  }
};
var HORIZONTAL_ALIGNMNENTS = {
  left: {
    tooltipLeft: 0,
    arrowLeft: arrowSize => 0
  },
  right: {
    tooltipLeft: "-100%",
    arrowLeft: arrowSize => -arrowSize - 2
  }
};
var Tooltip$2 = createReactClass$2({
  displayName: "Tooltip",
  propTypes: {
    show: PropTypes$2.bool.isRequired,
    className: PropTypes$2.string,
    arrowSize: PropTypes$2.number,
    borderColor: PropTypes$2.string,
    verticalPosition: PropTypes$2.oneOf(Object.keys(VERTICAL_CORNERS)),
    horizontalPosition: PropTypes$2.oneOf(Object.keys(HORIZONTAL_CORNERS)),
    horizontalAlign: PropTypes$2.oneOf(Object.keys(HORIZONTAL_ALIGNMNENTS)),
    children: PropTypes$2.arrayOf(PropTypes$2.element).isRequired,
    targetContainerStyle: PropTypes$2.any // style object

  },
  getDefaultProps: function getDefaultProps() {
    return {
      className: "",
      arrowSize: 10,
      borderColor: "#ccc",
      verticalPosition: "bottom",
      horizontalPosition: "left",
      horizontalAlign: "left",
      targetContainerStyle: {}
    };
  },
  getInitialState: function getInitialState() {
    return {
      height: null // used for offsetting "top" positioned tooltips

    };
  },
  componentDidMount: function componentDidMount() {
    this._updateHeight();
  },
  componentWillReceiveProps: function componentWillReceiveProps() {
    // If the contents have changed, reset our measure of the height
    this.setState({
      height: null
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    this._updateHeight();
  },
  _renderToolTipDiv: function _renderToolTipDiv(isTooltipAbove) {
    var settings = Object.assign({}, HORIZONTAL_CORNERS[this.props.horizontalPosition], HORIZONTAL_ALIGNMNENTS[this.props.horizontalAlign], VERTICAL_CORNERS[this.props.verticalPosition]);
    var arrowAbove;
    var arrowBelow;

    if (isTooltipAbove) {
      // We put an absolutely positioned arrow in the correct place
      arrowAbove = /*#__PURE__*/React$i.createElement(TooltipArrow, {
        verticalDirection: "top",
        horizontalDirection: this.props.horizontalAlign,
        position: "absolute",
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -this.props.arrowSize + 2,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      }); // And we use a visibility: hidden arrow below to shift up the
      // content by the correct amount

      arrowBelow = /*#__PURE__*/React$i.createElement(TooltipArrow, {
        verticalDirection: "top",
        horizontalDirection: this.props.horizontalAlign,
        visibility: "hidden",
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -1,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      });
    } else {
      arrowAbove = /*#__PURE__*/React$i.createElement(TooltipArrow, {
        verticalDirection: "bottom",
        horizontalDirection: this.props.horizontalAlign,
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -1,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      });
      arrowBelow = null;
    }
    /* A positioned div below the input to be the parent for our
        tooltip */


    return /*#__PURE__*/React$i.createElement("div", {
      style: {
        position: "relative",
        height: 0,
        display: this.props.show ? "block" : "none"
      }
    }, /*#__PURE__*/React$i.createElement("div", {
      ref: "tooltipContainer",
      className: "tooltipContainer",
      style: {
        position: "absolute",
        // height must start out undefined, not null, so that
        // we can measure the actual height with jquery.
        // This is used to position the tooltip with top: -100%
        // when in verticalPosition: "top" mode
        height: this.state.height || undefined,
        left: settings.targetLeft
      }
    }, arrowAbove, /*#__PURE__*/React$i.createElement("div", {
      className: this.props.className,
      ref: "tooltipContent",
      style: {
        position: "relative",
        top: settings["top"],
        left: settings.tooltipLeft,
        border: "1px solid " + this.props.borderColor,
        WebkitBoxShadow: "0 1px 3px " + this.props.borderColor,
        MozBoxShadow: "0 1px 3px " + this.props.borderColor,
        boxShadow: "0 1px 3px " + this.props.borderColor,
        zIndex: zIndex - 1
      }
    }, this.props.children.slice(1)), arrowBelow));
  },
  _updateHeight: function _updateHeight() {
    var height = ReactDOM$3.findDOMNode(this.refs.tooltipContainer).offsetHeight;

    if (height !== this.state.height) {
      this.setState({
        height
      });
    }
  },
  render: function render() {
    var isTooltipAbove = this.props.verticalPosition === "top";
    /* We wrap the entire output in a span so that it displays inline */

    return /*#__PURE__*/React$i.createElement("span", null, isTooltipAbove && this._renderToolTipDiv(isTooltipAbove), /*#__PURE__*/React$i.createElement("div", {
      style: this.props.targetContainerStyle
    }, this.props.children[0]), !isTooltipAbove && this._renderToolTipDiv());
  }
}); // Sorry.  // Apology-Oriented-Programming

module$2.exports = Tooltip$2;
var _reactComponentsTooltipJsx = module$2.exports;

var _module_$h = {
  exports: {}
};
/* eslint-disable react/sort-comp */

var React$h = _react__default["default"];
var Tooltip$1 = _reactComponentsTooltipJsx;
var _$b = _underscore__default["default"];
var ApiClassNames$4 = _perseusApiJsx.ClassNames;
var MathInput$1 = _componentsMathInputJsx;
var Renderer$3 = _rendererJsx;
var TextInput$1 = _componentsTextInputJsx;
var MathOutput = _componentsMathOutputJsx;
var Gorgon = _gorgonGorgonJs;
var captureScratchpadTouchStart$1 = Util$q.captureScratchpadTouchStart;
var MATH = "math";
var TEXT = "text";
var TEX = "tex";
var InputWithExamples$3 = createReactClass({
  displayName: "InputWithExamples",
  propTypes: {
    type: PropTypes.oneOf([MATH, TEXT, TEX]),
    value: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    className: PropTypes.string,
    examples: PropTypes.arrayOf(PropTypes.string).isRequired,
    shouldShowExamples: PropTypes.bool,
    convertDotToTimes: PropTypes.bool,
    buttonSet: PropTypes.string,
    buttonsVisible: PropTypes.oneOf(["always", "never", "focused"]),
    labelText: PropTypes.string,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    disabled: PropTypes.bool,
    // A unique string identifying this InputWithExamples
    id: PropTypes.string.isRequired,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      type: TEXT,
      shouldShowExamples: true,
      onFocus: function onFocus() {},
      onBlur: function onBlur() {},
      disabled: false,
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      focused: false,
      showExamples: false
    };
  },
  _getUniqueId: function _getUniqueId() {
    return "input-with-examples-".concat(btoa(this.props.id).replace(/=/g, ""));
  },
  _getInputClassName: function _getInputClassName() {
    // <MathOutput> is a special component that manages its own class and
    // state, as it's a <span> that wants to act like an <input>.
    if (this.props.type === TEX) {
      return this.props.className;
    } // Otherwise, we need to add these INPUT and FOCUSED tags here.


    var className = ApiClassNames$4.INPUT + " " + ApiClassNames$4.INTERACTIVE;

    if (this.state.focused) {
      className += " " + ApiClassNames$4.FOCUSED;
    }

    if (this.props.className) {
      className += " " + this.props.className;
    }

    return className;
  },
  _getPropsForInputType: function _getPropsForInputType() {
    // Minimal set of props, used by each input type
    var inputProps = {
      "aria-describedby": this._getUniqueId(),
      ref: "input",
      className: this._getInputClassName(),
      labelText: this.props.labelText,
      value: this.props.value,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      disabled: this.props.disabled
    };

    if (this.props.type === TEX) {
      return inputProps;
    } // Add useful props required for MATH and TEXT modes


    _$b.extend(inputProps, {
      onChange: this.props.onChange,
      onTouchStart: captureScratchpadTouchStart$1
    }); // And add final props that are MATH- and TEXT-specific


    if (this.props.type === MATH) {
      return _$b.extend({
        buttonSet: this.props.buttonSet,
        buttonsVisible: this.props.buttonsVisible,
        convertDotToTimes: this.props.convertDotToTimes
      }, inputProps);
    } else if (this.props.type === TEXT) {
      return _$b.extend({
        autoCapitalize: "off",
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false"
      }, inputProps);
    }
  },
  _getComponentForInputType: function _getComponentForInputType() {
    switch (this.props.type) {
      case TEX:
        return MathOutput;

      case MATH:
        return MathInput$1;

      case TEXT:
        return TextInput$1;

      default:
        return null;
    }
  },
  _renderInput: function _renderInput() {
    var inputProps = this._getPropsForInputType();

    var InputComponent = this._getComponentForInputType();

    return /*#__PURE__*/React$h.createElement(InputComponent, inputProps);
  },
  render: function render() {
    var input = this._renderInput(); // Static rendering, which doesn't include the 'tooltip' logic that the
    // other types require, and is hence handled separately.


    if (this.props.type === TEX) {
      return input;
    } // Else, we need to be able to show examples


    var examplesContent = _$b.map(this.props.examples, example => {
      return "- " + example;
    }).join("\n");

    var showExamples = this.props.shouldShowExamples && this.state.showExamples;
    return /*#__PURE__*/React$h.createElement(Tooltip$1, {
      ref: "tooltip",
      className: "perseus-formats-tooltip preview-measure",
      horizontalPosition: "left",
      horizontalAlign: "left",
      verticalPosition: "bottom",
      arrowSize: 10,
      borderColor: "#ccc",
      show: showExamples
    }, input, /*#__PURE__*/React$h.createElement("div", {
      id: this._getUniqueId()
    }, /*#__PURE__*/React$h.createElement(Renderer$3, {
      content: examplesContent,
      linterContext: Gorgon.pushContextStack(this.props.linterContext, 'input-with-examples')
    })));
  },
  _handleFocus: function _handleFocus() {
    this.props.onFocus();
    this.setState({
      focused: true,
      showExamples: true
    });
  },
  show: function show() {
    this.setState({
      showExamples: true
    });
  },
  hide: function hide() {
    this.setState({
      showExamples: false
    });
  },
  _handleBlur: function _handleBlur() {
    this.props.onBlur();
    this.setState({
      focused: false,
      showExamples: false
    });
  },
  focus: function focus() {
    this.refs.input.focus();
  },
  blur: function blur() {
    this.refs.input.blur();
  },
  handleChange: function handleChange(e) {
    this.props.onChange(e.target.value);
  }
});
_module_$h.exports = InputWithExamples$3;
var _componentsInputWithExamplesJsx = _module_$h.exports;

var _module_$g = {
  exports: {}
};
/* eslint-disable comma-dangle, indent, no-redeclare, no-undef, no-unused-vars, no-var, object-curly-spacing, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var classNames$4 = _classnames__default["default"];
var React$g = _react__default["default"];
var Tooltip = _reactComponentsTooltipJsx;
var _$a = _underscore__default["default"];
var ApiOptions$3 = _perseusApiJsx.Options;
var Changeable$3 = Changeable$Q;
var ApiOptions$3 = _perseusApiJsx.Options;
var ApiClassNames$3 = _perseusApiJsx.ClassNames;
var KhanAnswerTypes$2 = _utilAnswerTypesJs;
var InlineIcon$4 = _componentsInlineIconJsx;
var InputWithExamples$2 = _componentsInputWithExamplesJsx;
var MathInput = _componentsMathInputJsx;
var TexButtons$1 = _componentsTexButtonsJsx;
var {
  KeypadInput
} = _mathInput__default["default"].components;
var {
  keypadConfigurationPropType,
  keypadElementPropType: keypadElementPropType$2
} = _mathInput__default["default"].propTypes;
var {
  KeypadTypes
} = _mathInput__default["default"].consts;

var ERROR_MESSAGE = i18n._("Sorry, I don't understand that!"); // TODON'T(emily): Don't delete these.

var insertBraces = value => {
  // HACK(alex): Make sure that all LaTeX super/subscripts are wrapped
  // in curly braces to avoid the mismatch between KAS and LaTeX sup/sub
  // parsing.
  //
  // What exactly is this mismatch? Due to its heritage of parsing plain
  // text math from <OldExpression />, KAS parses "x^12" as x^(12).
  // This is both generally what the user expects to happen, and is
  // consistent with other computer algebra systems. It is NOT
  // consistent with LaTeX however, where x^12 is equivalent to x^{1}2.
  //
  // Since the only LaTeX we parse comes from MathQuill, this wouldn't
  // be a problem if MathQuill just always gave us the latter version
  // (with explicit braces). However, instead it always gives the former.
  // This behavior is baked in pretty deep; my naive attempts at changing
  // it triggered all sorts of confusing errors. So instead we just make
  // sure to add in any missing braces before grading MathQuill input.
  //
  // TODO(alex): Properly hack MathQuill to always use explicit braces.
  return value.replace(/([_^])([^{])/g, "$1{$2}");
}; // The new, MathQuill input expression widget


var Expression$1 = createReactClass({
  displayName: "Expression",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$3.propTypes), {}, {
    apiOptions: ApiOptions$3.propTypes,
    buttonSets: TexButtons$1.buttonSetsType,
    buttonsVisible: PropTypes.oneOf(["always", "never", "focused"]),
    functions: PropTypes.arrayOf(PropTypes.string),
    keypadConfiguration: keypadConfigurationPropType,
    keypadElement: keypadElementPropType$2,
    times: PropTypes.bool,
    trackInteraction: PropTypes.func.isRequired,
    value: PropTypes.string,
    widgetId: PropTypes.string.isRequired,
    linterContext: linterContextProps
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      value: "",
      times: false,
      functions: [],
      buttonSets: ["basic", "trig", "prealgebra", "logarithms"],
      onFocus: function onFocus() {},
      onBlur: function onBlur() {},
      apiOptions: ApiOptions$3.defaults,
      linterContext: linterContextDefault
    };
  },
  getInitialState: function getInitialState() {
    return {
      showErrorTooltip: false,
      showErrorText: false
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$3.change.apply(this, args);
  },

  parse: function parse(value, props) {
    // TODO(jack): Disable icu for content creators here, or
    // make it so that solution answers with ','s or '.'s work
    var options = _$a.pick(props || this.props, "functions");

    if (window.icu && window.icu.getDecimalFormatSymbols) {
      _$a.extend(options, window.icu.getDecimalFormatSymbols());
    }

    return KAS.parse(insertBraces(value), options);
  },
  render: function render() {
    if (this.props.apiOptions.customKeypad) {
      return /*#__PURE__*/React$g.createElement(KeypadInput, {
        ref: "input",
        value: this.props.value,
        keypadElement: this.props.keypadElement,
        onChange: this.changeAndTrack,
        onFocus: () => {
          this.props.keypadElement.configure(this.props.keypadConfiguration, () => {
            if (this.isMounted()) {
              this._handleFocus();
            }
          });
        },
        onBlur: this._handleBlur
      });
    } else if (this.props.apiOptions.staticRender) {
      // To make things slightly easier, we just use an InputWithExamples
      // component to handle the static rendering, which is the same
      // component used by InputNumber and NumericInput
      return /*#__PURE__*/React$g.createElement(InputWithExamples$2, {
        ref: "input",
        value: this.props.value,
        type: "tex",
        examples: [],
        shouldShowExamples: false,
        onChange: this.changeAndTrack,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur,
        id: this.props.widgetId,
        linterContext: this.props.linterContext
      });
    } else {
      // TODO(alex): Style this tooltip to be more consistent with other
      // tooltips on the site; align to left middle (once possible)
      var errorTooltip = /*#__PURE__*/React$g.createElement("span", {
        className: "error-tooltip"
      }, /*#__PURE__*/React$g.createElement(Tooltip, {
        className: "error-text-container",
        horizontalPosition: "right",
        horizontalAlign: "left",
        verticalPosition: "top",
        arrowSize: 10,
        borderColor: "#fcc335",
        show: this.state.showErrorText
      }, /*#__PURE__*/React$g.createElement("span", {
        className: "error-icon",
        onMouseEnter: () => {
          this.setState({
            showErrorText: true
          });
        },
        onMouseLeave: () => {
          this.setState({
            showErrorText: false
          });
        },
        onClick: () => {
          // TODO(alex): Better error feedback for mobile
          this.setState({
            showErrorText: !this.state.showErrorText
          });
        }
      }, /*#__PURE__*/React$g.createElement(InlineIcon$4, iconExclamationSign)), /*#__PURE__*/React$g.createElement("div", {
        className: "error-text"
      }, ERROR_MESSAGE)));
      var className = classNames$4({
        "perseus-widget-expression": true,
        "show-error-tooltip": this.state.showErrorTooltip
      });
      return /*#__PURE__*/React$g.createElement("span", {
        className: className
      }, /*#__PURE__*/React$g.createElement(MathInput, {
        ref: "input",
        className: ApiClassNames$3.INTERACTIVE,
        value: this.props.value,
        onChange: this.changeAndTrack,
        convertDotToTimes: this.props.times,
        buttonsVisible: this.props.buttonsVisible || "focused",
        buttonSets: this.props.buttonSets,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur
      }), this.state.showErrorTooltip && errorTooltip);
    }
  },
  changeAndTrack: function changeAndTrack(e, cb) {
    this.change("value", e, cb);
    this.props.trackInteraction();
  },
  _handleFocus: function _handleFocus() {
    this.props.onFocus([]);
  },
  _handleBlur: function _handleBlur() {
    this.props.onBlur([]);
  },
  errorTimeout: null,
  // Whenever the input value changes, attempt to parse it.
  //
  // Clear any errors if this parse succeeds, show an error within a second
  // if it fails.
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (!_$a.isEqual(this.props.value, nextProps.value) || !_$a.isEqual(this.props.functions, nextProps.functions)) {
      clearTimeout(this.errorTimeout);

      if (this.parse(nextProps.value, nextProps).parsed) {
        this.setState({
          showErrorTooltip: false
        });
      } else {
        // Store timeout ID so that we can clear it above
        this.errorTimeout = setTimeout(() => {
          var apiResult = this.props.apiOptions.onInputError(null, // reserved for some widget identifier
          this.props.value, ERROR_MESSAGE);

          if (apiResult !== false) {
            this.setState({
              showErrorTooltip: true
            });
          }
        }, 2000);
      }
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    clearTimeout(this.errorTimeout);
  },
  focus: function focus() {
    if (this.props.apiOptions.customKeypad) {
      this.refs.input.focus();
    }

    return true;
  },
  focusInputPath: function focusInputPath(inputPath) {
    this.refs.input.focus();
  },
  blurInputPath: function blurInputPath(inputPath) {
    this.refs.input.blur();
  },
  // HACK(joel)
  insert: function insert(text) {
    if (!this.props.apiOptions.staticRender) {
      this.refs.input.insert(text);
    }
  },
  getInputPaths: function getInputPaths() {
    // The widget itself is an input, so we return a single empty list to
    // indicate this.
    return [[]];
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(inputPath) {
    return "expression";
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    this.props.onChange({
      value: newValue
    }, cb);
  },
  getAcceptableFormatsForInputPath: function getAcceptableFormatsForInputPath() {
    // TODO(charlie): What format does the mobile team want this in?
    return null;
  },
  getUserInput: function getUserInput() {
    return insertBraces(this.props.value);
  },
  simpleValidate: function simpleValidate(rubric, onInputError) {
    onInputError = onInputError || function () {};

    return Expression$1.validate(this.getUserInput(), rubric, onInputError);
  }
});
/* Content creators input a list of answers which are matched from top to
 * bottom. The intent is that they can include spcific solutions which should
 * be graded as correct or incorrect (or ungraded!) first, then get more
 * general.
 *
 * We iterate through each answer, trying to match it with the user's input
 * using the following angorithm:
 * - Try to parse the user's input. If it doesn't parse then return "not
 *   graded".
 * - For each answer:
 *   ~ Try to validate the user's input against the answer. The answer is
 *     expected to parse.
 *   ~ If the user's input validates (the validator judges it "correct"), we've
 *     matched and can stop considering answers.
 * - If there were no matches or the matching answer is considered "ungraded",
 *   show the user an error. TODO(joel) - what error?
 * - Otherwise, pass through the resulting points and message.
 */

_$a.extend(Expression$1, {
  validate: function validate(state, rubric, onInputError) {
    var options = _$a.clone(rubric);

    if (window.icu && window.icu.getDecimalFormatSymbols) {
      _$a.extend(options, window.icu.getDecimalFormatSymbols());
    }

    var createValidator = answer => {
      return KhanAnswerTypes$2.expression.createValidatorFunctional( // We don't give options to KAS.parse here because that is
      // parsing the solution answer, not the student answer, and we
      // don't want a solution to work if the student is using a
      // different language but not in english.
      KAS.parse(answer.value, rubric).expr, _$a.extend({}, options, {
        simplify: answer.simplify,
        form: answer.form
      }));
    }; // find the first result to match the user's input


    var result;
    var matchingAnswer;
    var allEmpty = true;
    var foundMatch = !!rubric.answerForms.find(answer => {
      var validate = createValidator(answer); // save these because they'll be needed if this answer matches

      result = validate(state);
      matchingAnswer = answer;
      allEmpty = allEmpty && result.empty; // short-circuit as soon as an answer matches

      return result.correct;
    });
    var message = result && result.message; // now check to see whether it's considered correct, incorrect, or
    // ungraded

    if (!foundMatch) {
      if (allEmpty) {
        // If everything graded as empty, it's invalid.
        return {
          type: "invalid",
          message: null
        };
      } else {
        // We fell through all the possibilities and we're not empty,
        // so the answer is considered incorrect.
        return {
          type: "points",
          earned: 0,
          total: 1
        };
      } // we matched an ungraded answer - return "invalid"

    } else if (matchingAnswer.considered === "ungraded") {
      var apiResult = onInputError(null, // reserved for some widget identifier
      state, message);
      return {
        type: "invalid",
        message: apiResult === false ? null : message
      }; // The user's input matched one of the answers - is it correct or
      // incorrect?
    } else {
      // TODO(eater): Seems silly to translate result to this
      // invalid/points thing and immediately translate it back in
      // ItemRenderer.scoreInput()
      return {
        type: "points",
        earned: matchingAnswer.considered === "correct" ? 1 : 0,
        total: 1,
        message: message
      };
    }
  }
});
/**
 * Determine the keypad configuration parameters for the input, based on the
 * provided properties.
 *
 * There are two configuration parameters to be passed to the keypad:
 *   (1) The keypad type. For the Expression widget, we always use the
 *       Expression keypad.
 *   (2) The extra keys; namely, any variables or constants (like Pi) that need
 *       to be included as keys on the keypad. These are scraped from the answer
 *       forms.
 */


var keypadConfigurationForProps = props => {
  // Always use the Expression keypad, regardless of the button sets that have
  // been enabled.
  var keypadType = KeypadTypes.EXPRESSION; // Extract any and all variables and constants from the answer forms.

  var uniqueExtraVariables = {};
  var uniqueExtraConstants = {};

  for (var answerForm of props.answerForms) {
    var maybeExpr = KAS.parse(answerForm.value, props);

    if (maybeExpr.parsed) {
      (function () {
        var expr = maybeExpr.expr; // The keypad expects Greek letters to be capitalized (e.g., it
        // requires `PI` instead of `pi`). Right now, it only supports Pi
        // and Theta, so we special-case.

        var isGreek = symbol => symbol === "pi" || symbol === "theta";

        var toKey = symbol => isGreek(symbol) ? symbol.toUpperCase() : symbol;

        for (var variable of expr.getVars()) {
          uniqueExtraVariables[toKey(variable)] = true;
        }

        for (var constant of expr.getConsts()) {
          uniqueExtraConstants[toKey(constant)] = true;
        }
      })();
    }
  } // TODO(charlie): Alert the keypad as to which of these symbols should be
  // treated as functions.


  var extraVariables = Object.keys(uniqueExtraVariables);
  extraVariables.sort();
  var extraConstants = Object.keys(uniqueExtraConstants);
  extraConstants.sort();
  var extraKeys = [...extraVariables, ...extraConstants];

  if (!extraKeys.length) {
    // If there are no extra symbols available, we include Pi anyway, so
    // that the "extra symbols" button doesn't appear empty.
    extraKeys.push("PI");
  }

  return {
    keypadType,
    extraKeys
  };
};
/*
 * v0 props follow this schema:
 *
 *     times: bool
 *     buttonSets: [string]
 *     functions: [string]
 *     buttonsVisible: "always" | "focused" | "never"
 *
 *     value: string
 *     form: bool
 *     simplify: bool
 *
 * v1 props follow this schema:
 *
 *     times: bool
 *     buttonSets: [string]
 *     functions: [string]
 *     buttonsVisible: "always" | "focused" | "never"
 *
 *     answerForms: [{
 *         considered: "correct" | "ungraded" | "incorrect"
 *         form: bool
 *         simplify: bool
 *         value: string
 *     }]
 */


var propUpgrades$1 = {
  1: v0props => ({
    times: v0props.times,
    buttonSets: v0props.buttonSets,
    functions: v0props.functions,
    buttonsVisible: v0props.buttonsVisible,
    answerForms: [{
      considered: "correct",
      form: v0props.form,
      simplify: v0props.simplify,
      value: v0props.value,
      key: 0
    }]
  })
};
_module_$g.exports = {
  name: "expression",
  displayName: "Expression / Equation",
  defaultAlignment: "inline-block",
  widget: Expression$1,
  transform: editorProps => {
    var {
      times,
      functions,
      buttonSets,
      buttonsVisible
    } = editorProps;
    return {
      keypadConfiguration: keypadConfigurationForProps(editorProps),
      times,
      functions,
      buttonSets,
      buttonsVisible
    };
  },
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades$1,
  // For use by the editor
  Expression: Expression$1,
  isLintable: true
};
var _widgetsExpressionJsx = _module_$g.exports;

var module$1 = {
  exports: {}
};
var React$f = _react__default["default"];
var ReactDOM$2 = _reactDom__default["default"];
var createReactClass$1 = _createReactClass__default["default"];
var PropTypes$1 = _propTypes__default["default"];
var PT = PropTypes$1; // Takes an array of components to sort

var SortableArea$1 = createReactClass$1({
  displayName: "SortableArea",
  propTypes: {
    className: PT.string,
    components: PT.arrayOf(PT.node).isRequired,
    onReorder: PT.func.isRequired,
    style: PT.any,
    verify: PT.func
  },
  getDefaultProps: function getDefaultProps() {
    return {
      verify: () => true
    };
  },
  getInitialState: function getInitialState() {
    return {
      // index of the component being dragged
      dragging: null,
      components: this.props.components
    };
  },
  // Firefox refuses to drag an element unless you set data on it. Hackily
  // add data each time an item is dragged.
  componentDidMount: function componentDidMount() {
    this._setDragEvents();
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.setState({
      components: nextProps.components
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    this._setDragEvents();
  },
  // Alternatively send each handler to each component individually,
  // partially applied
  onDragStart: function onDragStart(startIndex) {
    this.setState({
      dragging: startIndex
    });
  },
  onDrop: function onDrop() {
    // tell the parent component
    this.setState({
      dragging: null
    });
    this.props.onReorder(this.state.components);
  },
  onDragEnter: function onDragEnter(enterIndex) {
    // When a label is first dragged it triggers a dragEnter with itself,
    // which we don't care about.
    if (this.state.dragging === enterIndex) {
      return;
    }

    var newComponents = this.state.components.slice(); // splice the tab out of its old position

    var removed = newComponents.splice(this.state.dragging, 1); // ... and into its new position

    newComponents.splice(enterIndex, 0, removed[0]);
    var verified = this.props.verify(newComponents);

    if (verified) {
      this.setState({
        dragging: enterIndex,
        components: newComponents
      });
    }

    return verified;
  },
  _listenEvent: function _listenEvent(e) {
    e.dataTransfer.setData('hackhackhack', 'because browsers!');
  },
  _cancelEvent: function _cancelEvent(e) {
    // prevent the browser from redirecting to 'because browsers!'
    e.preventDefault();
  },
  _setDragEvents: function _setDragEvents() {
    this._dragItems = this._dragItems || [];
    var items = ReactDOM$2.findDOMNode(this).querySelectorAll('[draggable=true]');
    var oldItems = [];
    var newItems = [];

    for (var i = 0; i < this._dragItems.length; i++) {
      var item = this._dragItems[i];

      if (items.indexOf(item) < 0) {
        oldItems.push(item);
      }
    }

    for (var _i = 0; _i < items.length; _i++) {
      var _item = items[_i];

      if (this._dragItems.indexOf(_item) < 0) {
        newItems.push(_item);
      }
    }

    for (var _i2 = 0; _i2 < newItems.length; _i2++) {
      var dragItem = newItems[_i2];
      dragItem.addEventListener('dragstart', this._listenEvent);
      dragItem.addEventListener('drop', this._cancelEvent);
    }

    for (var _i3 = 0; _i3 < oldItems.length; _i3++) {
      var _dragItem = oldItems[_i3];

      _dragItem.removeEventListener('dragstart', this._listenEvent);

      _dragItem.removeEventListener('drop', this._cancelEvent);
    }
  },
  render: function render() {
    var sortables = this.state.components.map((component, index) => /*#__PURE__*/React$f.createElement(SortableItem, {
      index: index,
      component: component,
      area: this,
      key: component.key,
      draggable: component.props.draggable,
      dragging: index === this.state.dragging
    }));
    return /*#__PURE__*/React$f.createElement("ol", {
      className: this.props.className,
      style: this.props.style
    }, sortables);
  }
}); // An individual sortable item

var SortableItem = createReactClass$1({
  displayName: "SortableItem",
  propTypes: {
    area: PT.shape({
      onDragEnter: PT.func.isRequired,
      onDragStart: PT.func.isRequired,
      onDrop: PT.func.isRequired
    }),
    component: PT.node.isRequired,
    dragging: PT.bool.isRequired,
    draggable: PT.bool.isRequired,
    index: PT.number.isRequired
  },
  handleDragStart: function handleDragStart(e) {
    e.nativeEvent.dataTransfer.effectAllowed = "move";
    this.props.area.onDragStart(this.props.index);
  },
  handleDrop: function handleDrop() {
    this.props.area.onDrop(this.props.index);
  },
  handleDragEnter: function handleDragEnter(e) {
    var verified = this.props.area.onDragEnter(this.props.index); // Ideally this would change the cursor based on whether this is a
    // valid place to drop.

    e.nativeEvent.dataTransfer.effectAllowed = verified ? "move" : "none";
  },
  handleDragOver: function handleDragOver(e) {
    // allow a drop by preventing default handling
    e.preventDefault();
  },
  render: function render() {
    var dragState = "sortable-disabled";

    if (this.props.dragging) {
      dragState = "sortable-dragging";
    } else if (this.props.draggable) {
      dragState = "sortable-enabled";
    }

    return /*#__PURE__*/React$f.createElement("li", {
      draggable: this.props.draggable,
      className: dragState,
      onDragStart: this.handleDragStart,
      onDrop: this.handleDrop,
      onDragEnter: this.handleDragEnter,
      onDragOver: this.handleDragOver
    }, this.props.component);
  }
});
module$1.exports = SortableArea$1;
var _reactComponentsSortableJsx = module$1.exports;

var _module_$f = {
  exports: {}
};
/* eslint-disable comma-dangle, indent, no-var, object-curly-spacing, one-var, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$e = _react__default["default"];
var _$9 = _underscore__default["default"];
var lens = lens$3;
var Changeable$2 = Changeable$Q;
var InfoTip$2 = _componentsInfoTipJsx;
var PropCheckBox$2 = _componentsPropCheckBoxJsx;
var SortableArea = _reactComponentsSortableJsx;
var TeX = _reactComponentsTexJsx; // OldExpression only

var TexButtons = _componentsTexButtonsJsx;
var Expression = _widgetsExpressionJsx.Expression; // An answer can be considered correct, wrong, or ungraded.

var CONSIDERED = ["correct", "wrong", "ungraded"];
var answerFormType = PropTypes.shape({
  considered: PropTypes.oneOf(CONSIDERED).isRequired,
  value: PropTypes.string.isRequired,
  form: PropTypes.bool.isRequired,
  simplify: PropTypes.bool.isRequired
}); // Pick a key that isn't currently used by an answer in answerForms

var _makeNewKey = answerForms => {
  // first note all the currently used keys in an array, used like a map :3
  // note that this automatically updates the array's length property to
  // be one past the largest key.
  var usedKeys = [];
  answerForms.forEach(ans => {
    usedKeys[ans.key] = true;
  }); // then scan through the array to find the first unused (undefined) key

  for (var i = 0; i < usedKeys.length; i++) {
    if (!usedKeys[i]) {
      return i;
    }
  } // if we didn't find a key, make one bigger than all the other keys,
  // since that's how the length property is defined to work on arrays


  return usedKeys.length;
};

var ExpressionEditor = createReactClass({
  displayName: "ExpressionEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$2.propTypes), {}, {
    answerForms: PropTypes.arrayOf(answerFormType),
    times: PropTypes.bool,
    buttonSets: TexButtons.buttonSetsType,
    functions: PropTypes.arrayOf(PropTypes.string)
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      answerForms: [],
      times: false,
      buttonSets: ["basic"],
      functions: ["f", "g", "h"]
    };
  },
  getInitialState: function getInitialState() {
    // Is the format of `value` TeX or plain text?
    // TODO(alex): Remove after backfilling everything to TeX
    // TODO(joel) - sucks if you edit some expression without
    // backslashes or curly braces, then come back to the question and
    // it's surprisingly not TeX anymore.
    var isTex; // default to TeX if new;

    if (this.props.answerForms.length === 0) {
      isTex = true;
    } else {
      isTex = this.props.answerForms.some(form => {
        var {
          value
        } = form; // only TeX has backslashes and curly braces

        return _$9.indexOf(value, "\\") !== -1 || _$9.indexOf(value, "{") !== -1;
      });
    }

    return {
      isTex
    };
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$2.change.apply(this, args);
  },

  render: function render() {
    var answerOptions = this.props.answerForms.map((obj, ix) => {
      var expressionProps = {
        // note we're using
        // *this.props*.{times,functions,buttonSets} since each
        // answer area has the same settings for those
        times: this.props.times,
        functions: this.props.functions,
        buttonSets: this.props.buttonSets,
        buttonsVisible: "focused",
        form: obj.form,
        simplify: obj.simplify,
        value: obj.value,
        onChange: props => this.updateForm(ix, props),
        trackInteraction: () => {},
        widgetId: this.props.widgetId + "-" + ix
      };
      return lens(obj).merge([], {
        draggable: true,
        onChange: props => this.updateForm(ix, props),
        onDelete: () => this.handleRemoveForm(ix),
        expressionProps: expressionProps
      }).freeze();
    }).map(obj => /*#__PURE__*/React$e.createElement(AnswerOption, obj));
    var sortable = /*#__PURE__*/React$e.createElement(SortableArea, {
      components: answerOptions,
      onReorder: this.handleReorder,
      className: "answer-options-list"
    }); // checkboxes to choose which sets of input buttons are shown

    var buttonSetChoices = TexButtons.buttonSets.map((set, name) => {
      // The first one gets special cased to always be checked, disabled,
      // and float left.
      var isFirst = name === "basic";
      var checked = _$9.contains(this.props.buttonSets, name) || isFirst;
      var className = isFirst ? "button-set-label-float" : "button-set-label";
      return /*#__PURE__*/React$e.createElement("label", {
        className: className,
        key: name
      }, /*#__PURE__*/React$e.createElement("input", {
        type: "checkbox",
        checked: checked,
        disabled: isFirst,
        onChange: () => this.handleButtonSet(name)
      }), name);
    });
    buttonSetChoices.splice(1, 1, /*#__PURE__*/React$e.createElement("label", {
      key: "show-div"
    }, /*#__PURE__*/React$e.createElement("input", {
      type: "checkbox",
      onChange: this.handleToggleDiv
    }), /*#__PURE__*/React$e.createElement("span", {
      className: "show-div-button"
    }, "show ", /*#__PURE__*/React$e.createElement(TeX, null, "\\div"), " button")));
    return /*#__PURE__*/React$e.createElement("div", {
      className: "perseus-widget-expression-editor"
    }, /*#__PURE__*/React$e.createElement("h3", {
      className: "expression-editor-h3"
    }, "Global Options"), /*#__PURE__*/React$e.createElement("div", null, /*#__PURE__*/React$e.createElement(PropCheckBox$2, {
      times: this.props.times,
      onChange: this.props.onChange,
      labelAlignment: "right",
      label: "Use \xD7 for rendering multiplication instead of a center dot."
    }), /*#__PURE__*/React$e.createElement(InfoTip$2, null, /*#__PURE__*/React$e.createElement("p", null, "For pre-algebra problems this option displays multiplication as \\times instead of \\cdot in both the rendered output and the acceptable formats examples."))), /*#__PURE__*/React$e.createElement("div", null, /*#__PURE__*/React$e.createElement("label", null, "Function variables: ", /*#__PURE__*/React$e.createElement("input", {
      type: "text",
      defaultValue: this.props.functions.join(" "),
      onChange: this.handleFunctions
    })), /*#__PURE__*/React$e.createElement(InfoTip$2, null, /*#__PURE__*/React$e.createElement("p", null, "Single-letter variables listed here will be interpreted as functions. This let us know that f(x) means \"f of x\" and not \"f times x\"."))), /*#__PURE__*/React$e.createElement("div", null, /*#__PURE__*/React$e.createElement("div", null, "Button sets:"), buttonSetChoices), this.state.isTex && /*#__PURE__*/React$e.createElement(TexButtons, {
      className: "math-input-buttons",
      sets: this.props.buttonSets,
      convertDotToTimes: this.props.times,
      onInsert: this.handleTexInsert
    }), /*#__PURE__*/React$e.createElement("h3", {
      className: "expression-editor-h3"
    }, "Answers"), /*#__PURE__*/React$e.createElement("p", {
      style: {
        margin: "4px 0"
      }
    }, "student responses area matched against these from top to bottom"), sortable, /*#__PURE__*/React$e.createElement("div", null, /*#__PURE__*/React$e.createElement("button", {
      className: "simple-button orange",
      style: {
        fontSize: 13
      },
      onClick: this.newAnswer,
      type: "button"
    }, "Add new answer")));
  },
  serialize: function serialize() {
    var formSerializables = ["value", "form", "simplify", "considered", // it's a little weird to serialize the react key, but saves some
    // effort reconstructing them when this item is loaded later.
    "key"];
    var serializables = ["answerForms", "buttonSets", "functions", "times"];
    var answerForms = this.props.answerForms.map(form => {
      return _$9.pick(form, formSerializables);
    });
    return lens(this.props).set(["answerForms"], answerForms).mod([], props => _$9.pick(props, serializables)).freeze();
  },
  getSaveWarnings: function getSaveWarnings() {
    var issues = [];

    if (this.props.answerForms.length === 0) {
      issues.push("No answers specified");
    } else {
      var hasCorrect = !!this.props.answerForms.find(form => {
        return form.considered === "correct";
      });

      if (!hasCorrect) {
        issues.push("No correct answer specified");
      }

      this.props.answerForms.forEach((form, ix) => {
        if (this.props.value === "") {
          issues.push("Answer ".concat(ix + 1, " is empty"));
        } else {
          // note we're not using icu for content creators
          var expression = KAS.parse(form.value);

          if (!expression.parsed) {
            issues.push("Couldn't parse ".concat(form.value));
          } else if (form.simplify && !expression.expr.isSimplified()) {
            issues.push("".concat(form.value, " isn't simplified, but is required\" +\n                            \" to be"));
          }
        }
      }); // TODO(joel) - warn about:
      //   - unreachable answers (how??)
      //   - specific answers following unspecific answers
      //   - incorrect answers as the final form
    }

    return issues;
  },
  _newEmptyAnswerForm: function _newEmptyAnswerForm() {
    return {
      considered: "correct",
      form: false,
      // note: the key means "n-th form created" - not "form in
      // position n" and will stay the same for the life of this form
      key: _makeNewKey(this.props.answerForms),
      simplify: false,
      value: ""
    };
  },
  newAnswer: function newAnswer() {
    var answerForms = this.props.answerForms.slice();
    answerForms.push(this._newEmptyAnswerForm());
    this.change({
      answerForms
    });
  },
  handleRemoveForm: function handleRemoveForm(i) {
    var answerForms = this.props.answerForms.slice();
    answerForms.splice(i, 1);
    this.change({
      answerForms
    });
  },
  // called when the options (including the expression itself) to an answer
  // form change
  updateForm: function updateForm(i, props) {
    var answerForms = lens(this.props.answerForms).merge([i], props).freeze();
    this.change({
      answerForms
    });
  },
  handleReorder: function handleReorder(components) {
    var answerForms = components.map(component => {
      var form = _$9.pick(component.props, "considered", "form", "simplify", "value");

      form.key = component.key;
      return form;
    });
    this.change({
      answerForms
    });
  },
  // called when the selected buttonset changes
  handleButtonSet: function handleButtonSet(changingName) {
    var buttonSetNames = Object.keys(TexButtons.buttonSets); // Filter to preserve order - using .union and .difference would always
    // move the last added button set to the end.

    var buttonSets = buttonSetNames.filter(set => {
      return _$9.contains(this.props.buttonSets, set) !== (set === changingName);
    });
    this.props.onChange({
      buttonSets
    });
  },
  handleToggleDiv: function handleToggleDiv() {
    // We always want buttonSets to contain exactly one of "basic" and
    // "basic+div". Toggle between the two of them.
    // If someone can think of a more elegant formulation of this (there
    // must be one!) feel free to change it.
    var keep, remove;

    if (_$9.contains(this.props.buttonSets, "basic+div")) {
      keep = "basic";
      remove = "basic+div";
    } else {
      keep = "basic+div";
      remove = "basic";
    }

    var buttonSets = _$9.reject(this.props.buttonSets, set => set === remove).concat(keep);

    this.change("buttonSets", buttonSets);
  },
  // called when the correct answer changes
  handleTexInsert: function handleTexInsert(str) {
    this.refs.expression.insert(str);
  },
  // called when the function variables change
  handleFunctions: function handleFunctions(e) {
    var newProps = {};
    newProps.functions = _$9.compact(e.target.value.split(/[ ,]+/));
    this.props.onChange(newProps);
  }
}); // Find the next element in arr after val, wrapping around to the first.

var findNextIn = function findNextIn(arr, val) {
  var ix = arr.indexOf(val);
  ix = (ix + 1) % arr.length;
  return arr[ix];
};

var AnswerOption = createReactClass({
  displayName: "AnswerOption",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable$2.propTypes), {}, {
    considered: PropTypes.oneOf(CONSIDERED).isRequired,
    expressionProps: PropTypes.object.isRequired,
    // Must the answer have the same form as this answer.
    form: PropTypes.bool.isRequired,
    // Must the answer be simplified.
    simplify: PropTypes.bool.isRequired,
    onChange: PropTypes.func.isRequired,
    onDelete: PropTypes.func.isRequired
  }),
  getInitialState: function getInitialState() {
    return {
      deleteFocused: false
    };
  },
  handleDeleteBlur: function handleDeleteBlur() {
    this.setState({
      deleteFocused: false
    });
  },

  change() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return Changeable$2.change.apply(this, args);
  },

  render: function render() {
    var removeButton = null;

    if (this.state.deleteFocused) {
      removeButton = /*#__PURE__*/React$e.createElement("button", {
        type: "button",
        className: "simple-button orange",
        onClick: this.handleImSure,
        onBlur: this.handleDeleteBlur
      }, "I'm sure!");
    } else {
      removeButton = /*#__PURE__*/React$e.createElement("button", {
        type: "button",
        className: "simple-button orange",
        onClick: this.handleDelete
      }, "Delete");
    }

    return /*#__PURE__*/React$e.createElement("div", {
      className: "expression-answer-option"
    }, /*#__PURE__*/React$e.createElement("div", {
      className: "answer-handle"
    }), /*#__PURE__*/React$e.createElement("div", {
      className: "answer-body"
    }, /*#__PURE__*/React$e.createElement("div", {
      className: "answer-considered"
    }, /*#__PURE__*/React$e.createElement("div", {
      onClick: this.toggleConsidered,
      className: "answer-status " + this.props.considered
    }, this.props.considered), /*#__PURE__*/React$e.createElement("div", {
      className: "answer-expression"
    }, /*#__PURE__*/React$e.createElement(Expression, this.props.expressionProps))), /*#__PURE__*/React$e.createElement("div", {
      className: "answer-option"
    }, /*#__PURE__*/React$e.createElement(PropCheckBox$2, {
      form: this.props.form,
      onChange: this.props.onChange,
      labelAlignment: "right",
      label: "Answer expression must have the same form."
    }), /*#__PURE__*/React$e.createElement(InfoTip$2, null, /*#__PURE__*/React$e.createElement("p", null, "The student's answer must be in the same form. Commutativity and excess negative signs are ignored."))), /*#__PURE__*/React$e.createElement("div", {
      className: "answer-option"
    }, /*#__PURE__*/React$e.createElement(PropCheckBox$2, {
      simplify: this.props.simplify,
      onChange: this.props.onChange,
      labelAlignment: "right",
      label: "Answer expression must be fully expanded and simplified."
    }), /*#__PURE__*/React$e.createElement(InfoTip$2, null, /*#__PURE__*/React$e.createElement("p", null, "The student's answer must be fully expanded and simplified. Answering this equation (x^2+2x+1) with this factored equation (x+1)^2 will render this response \"Your answer is not fully expanded and simplified.\""))), /*#__PURE__*/React$e.createElement("div", {
      className: "remove-container"
    }, removeButton)));
  },
  handleImSure: function handleImSure() {
    this.props.onDelete();
  },
  handleDelete: function handleDelete() {
    this.setState({
      deleteFocused: true
    });
  },
  toggleConsidered: function toggleConsidered() {
    var newVal = findNextIn(CONSIDERED, this.props.considered);
    this.change({
      considered: newVal
    });
  }
});
_module_$f.exports = ExpressionEditor;
var _widgetsExpressionEditorJsx = _module_$f.exports;

var _module_$e = {
  exports: {}
};
/* eslint-disable comma-dangle, no-redeclare, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp, space-infix-ops */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$d = _react__default["default"];
var _$8 = _underscore__default["default"];
var Changeable$1 = Changeable$Q;
var EditorJsonify = _mixinsEditorJsonifyJsx;
var ButtonGroup = _reactComponentsButtonGroupJsx;
var Editor$1 = _editorJsx;
var InfoTip$1 = _componentsInfoTipJsx;
var InlineIcon$3 = _componentsInlineIconJsx;
var MultiButtonGroup = _reactComponentsMultiButtonGroupJsx;
var NumberInput = _componentsNumberInputJsx;
var PropCheckBox$1 = _componentsPropCheckBoxJsx;
var TextInput = _componentsTextInputJsx;
var firstNumericalParse = Util$q.firstNumericalParse;
var answerFormButtons$1 = [{
  title: "Integers",
  value: "integer",
  content: "6"
}, {
  title: "Decimals",
  value: "decimal",
  content: "0.75"
}, {
  title: "Proper fractions",
  value: "proper",
  content: "\u2157"
}, {
  title: "Improper fractions",
  value: "improper",
  content: "\u2077\u2044\u2084"
}, {
  title: "Mixed numbers",
  value: "mixed",
  content: "1\u00BE"
}, {
  title: "Numbers with \u03C0",
  value: "pi",
  content: "\u03C0"
}];

var initAnswer = status => {
  return {
    value: null,
    status: status,
    message: "",
    simplify: "required",
    answerForms: [],
    strict: false,
    maxError: null
  };
};

var NumericInputEditor = createReactClass({
  displayName: "NumericInputEditor",
  propTypes: _objectSpread2({}, Changeable$1.propTypes),
  getDefaultProps: function getDefaultProps() {
    return {
      answers: [initAnswer("correct")],
      size: "normal",
      coefficient: false,
      labelText: "",
      multipleNumberInput: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      lastStatus: "wrong",
      showOptions: _$8.map(this.props.answers, () => false)
    };
  },
  render: function render() {
    var answers = this.props.answers;

    var unsimplifiedAnswers = i => /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$d.createElement("label", null, "Unsimplified answers are"), /*#__PURE__*/React$d.createElement(ButtonGroup, {
      value: answers[i]["simplify"],
      allowEmpty: false,
      buttons: [{
        value: "required",
        content: "ungraded"
      }, {
        value: "optional",
        content: "accepted"
      }, {
        value: "enforced",
        content: "wrong"
      }],
      onChange: this.updateAnswer(i, "simplify")
    }), /*#__PURE__*/React$d.createElement(InfoTip$1, null, /*#__PURE__*/React$d.createElement("p", null, "Normally select \"ungraded\". This will give the user a message saying the answer is correct but not simplified. The user will then have to simplify it and re-enter, but will not be penalized. (5th grade and after)"), /*#__PURE__*/React$d.createElement("p", null, "Select \"accepted\" only if the user is not expected to know how to simplify fractions yet. (Anything prior to 5th grade)"), /*#__PURE__*/React$d.createElement("p", null, "Select \"wrong\" ", /*#__PURE__*/React$d.createElement("em", null, "only"), " if we are specifically assessing the ability to simplify.")));

    var suggestedAnswerTypes = i => /*#__PURE__*/React$d.createElement("div", null, /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$d.createElement("label", null, "Choose the suggested answer formats"), /*#__PURE__*/React$d.createElement(MultiButtonGroup, {
      buttons: answerFormButtons$1,
      values: answers[i]["answerForms"],
      onChange: this.updateAnswer(i, "answerForms")
    }), /*#__PURE__*/React$d.createElement(InfoTip$1, null, /*#__PURE__*/React$d.createElement("p", null, "Formats will be autoselected for you based on the given answer; to show no suggested formats and accept all types, simply have a decimal/integer be the answer. Values with \u03C0 will have format \"pi\", and values that are fractions will have some subset (mixed will be \"mixed\" and \"proper\"; improper/proper will both be \"improper\" and \"proper\"). If you would like to specify that it is only a proper fraction (or only a mixed/improper fraction), deselect the other format. Except for specific cases, you should not need to change the autoselected formats."), /*#__PURE__*/React$d.createElement("p", null, "To restrict the answer to ", /*#__PURE__*/React$d.createElement("em", null, "only"), " an improper fraction (i.e. 7/4), select the improper fraction and toggle \"strict\" to true. This ", /*#__PURE__*/React$d.createElement("b", null, "will not"), " ", " accept 1.75 as an answer.", " "), /*#__PURE__*/React$d.createElement("p", null, "Unless you are testing that specific skill, please do not restrict the answer format."))), /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$d.createElement(PropCheckBox$1, {
      label: "Strictly match only these formats",
      strict: answers[i]["strict"],
      onChange: this.updateAnswer.bind(this, i)
    })));

    var maxError = i => /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$d.createElement("label", null, "Max error", " ", /*#__PURE__*/React$d.createElement(NumberInput, {
      className: "max-error",
      value: answers[i]["maxError"],
      onChange: this.updateAnswer(i, "maxError"),
      placeholder: "0"
    })));

    var inputSize = /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$d.createElement("label", null, "Width:  "), /*#__PURE__*/React$d.createElement(ButtonGroup, {
      value: this.props.size,
      allowEmpty: false,
      buttons: [{
        value: "normal",
        content: "Normal (80px)"
      }, {
        value: "small",
        content: "Small (40px)"
      }],
      onChange: this.change("size")
    }), /*#__PURE__*/React$d.createElement(InfoTip$1, null, /*#__PURE__*/React$d.createElement("p", null, "Use size \"Normal\" for all text boxes, unless there are multiple text boxes in one line and the answer area is too narrow to fit them.")));
    var labelText = /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$d.createElement("label", null, "Label text:", " ", /*#__PURE__*/React$d.createElement(TextInput, {
      value: this.props.labelText,
      onChange: this.change("labelText")
    })), /*#__PURE__*/React$d.createElement(InfoTip$1, null, /*#__PURE__*/React$d.createElement("p", null, "Text to describe this input. This will be shown to users using screenreaders.")));
    var coefficientCheck = /*#__PURE__*/React$d.createElement("div", null, /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$d.createElement(PropCheckBox$1, {
      label: "Coefficient",
      coefficient: this.props.coefficient,
      onChange: this.props.onChange
    }), /*#__PURE__*/React$d.createElement(InfoTip$1, null, /*#__PURE__*/React$d.createElement("p", null, "A coefficient style number allows the student to use - for -1 and an empty string to mean 1."))));
    var addAnswerButton = /*#__PURE__*/React$d.createElement("div", null, /*#__PURE__*/React$d.createElement("a", {
      href: "javascript:void(0)",
      className: "simple-button orange",
      onClick: () => this.addAnswer(),
      onKeyDown: e => this.onSpace(e, this.addAnswer)
    }, /*#__PURE__*/React$d.createElement("span", null, "Add new answer")));
    var instructions = {
      wrong: "(address the mistake/misconception)",
      ungraded: "(explain in detail to avoid confusion)",
      correct: "(reinforce the user's understanding)"
    };

    var generateInputAnswerEditors = () => answers.map((answer, i) => {
      var editor = /*#__PURE__*/React$d.createElement(Editor$1, {
        apiOptions: this.props.apiOptions,
        content: answer.message || "",
        placeholder: "Why is this answer " + answer.status + "?\t" + instructions[answer.status],
        widgetEnabled: false,
        onChange: newProps => {
          if ("content" in newProps) {
            this.updateAnswer(i, {
              message: newProps.content
            });
          }
        }
      });
      return /*#__PURE__*/React$d.createElement("div", {
        className: "perseus-widget-row",
        key: i
      }, /*#__PURE__*/React$d.createElement("div", {
        className: "input-answer-editor-value-container" + (answer.maxError ? " with-max-error" : "")
      }, /*#__PURE__*/React$d.createElement(NumberInput, {
        value: answer.value,
        className: "numeric-input-value",
        placeholder: "answer",
        format: _$8.last(answer.answerForms),
        onFormatChange: (newValue, format) => {
          // NOTE(charlie): The mobile web expression
          // editor relies on this automatic answer
          // form resolution for determining when to
          // show the Pi symbol. If we get rid of it,
          // we should also disable Pi for
          // NumericInput and require problems that
          // use Pi to build on Expression.
          // Alternatively, we could store answers
          // as plaintext and parse them to determine
          // whether or not to reveal Pi on the
          // keypad (right now, answers are stored as
          // resolved values, like '0.125' rather
          // than '1/8').
          var forms;

          if (format === "pi") {
            forms = ["pi"];
          } else if (format === "mixed") {
            forms = ["proper", "mixed"];
          } else if (format === "proper" || format === "improper") {
            forms = ["proper", "improper"];
          }

          this.updateAnswer(i, {
            value: firstNumericalParse(newValue),
            answerForms: forms
          });
        },
        onChange: newValue => {
          this.updateAnswer(i, {
            value: firstNumericalParse(newValue)
          });
        }
      }), answer.strict && /*#__PURE__*/React$d.createElement("div", {
        className: "is-strict-indicator",
        title: "strictly equivalent to"
      }, "\u2261"), answer.simplify !== "required" && answer.status === "correct" && /*#__PURE__*/React$d.createElement("div", {
        className: "simplify-indicator " + answer.simplify,
        title: "accepts unsimplified answers"
      }, "\u2030"), answer.maxError ? /*#__PURE__*/React$d.createElement("div", {
        className: "max-error-container"
      }, /*#__PURE__*/React$d.createElement("div", {
        className: "max-error-plusmn"
      }, "\xB1"), /*#__PURE__*/React$d.createElement(NumberInput, {
        placeholder: 0,
        value: answers[i]["maxError"],
        format: _$8.last(answer.answerForms),
        onChange: this.updateAnswer(i, "maxError")
      })) : null, /*#__PURE__*/React$d.createElement("div", {
        className: "value-divider"
      }), /*#__PURE__*/React$d.createElement("a", {
        href: "javascript:void(0)",
        className: "answer-status " + answer.status,
        onClick: () => this.onStatusChange(i),
        onKeyDown: e => this.onSpace(e, this.onStatusChange, i)
      }, answer.status), /*#__PURE__*/React$d.createElement("a", {
        href: "javascript:void(0)",
        className: "answer-trash",
        onClick: () => this.onTrashAnswer(i),
        onKeyDown: e => this.onSpace(e, this.onTrashAnswer, i)
      }, /*#__PURE__*/React$d.createElement(InlineIcon$3, iconTrash)), /*#__PURE__*/React$d.createElement("a", {
        href: "javascript:void(0)",
        className: "options-toggle",
        onClick: () => this.onToggleOptions(i),
        onKeyDown: e => this.onSpace(e, this.onToggleOptions, i)
      }, /*#__PURE__*/React$d.createElement(InlineIcon$3, iconGear))), /*#__PURE__*/React$d.createElement("div", {
        className: "input-answer-editor-message"
      }, editor), this.state.showOptions[i] && /*#__PURE__*/React$d.createElement("div", {
        className: "options-container"
      }, maxError(i), answer.status === "correct" && unsimplifiedAnswers(i), suggestedAnswerTypes(i)));
    });

    return /*#__PURE__*/React$d.createElement("div", {
      className: "perseus-input-number-editor"
    }, /*#__PURE__*/React$d.createElement("div", {
      ref: e => this.multInputOption = e
    }, /*#__PURE__*/React$d.createElement("select", {
      onChange: this.onMultipleInputChange
    }, /*#__PURE__*/React$d.createElement("option", {
      value: "simple-numeric-input"
    }, "Ask for one correct solution"), /*#__PURE__*/React$d.createElement("option", {
      value: "multiple-numeric-input"
    }, "Ask for all correct solutions"))), /*#__PURE__*/React$d.createElement("div", {
      className: "ui-title"
    }, "User input"), /*#__PURE__*/React$d.createElement("div", {
      className: "msg-title"
    }, "Message shown to user on attempt"), generateInputAnswerEditors(), addAnswerButton, inputSize, coefficientCheck, labelText);
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable$1.change.apply(this, args);
  },

  onToggleOptions: function onToggleOptions(choiceIndex) {
    var showOptions = this.state.showOptions.slice();
    showOptions[choiceIndex] = !showOptions[choiceIndex];
    this.setState({
      showOptions: showOptions
    });
  },
  onTrashAnswer: function onTrashAnswer(choiceIndex) {
    if (choiceIndex >= 0 && choiceIndex < this.props.answers.length) {
      var answers = this.props.answers.slice(0);
      answers.splice(choiceIndex, 1);
      this.props.onChange({
        answers: answers
      });
    }
  },
  onSpace: function onSpace(e, callback) {
    if (e.key === " ") {
      e.preventDefault(); // prevent page shifting

      var args = _$8.toArray(arguments).slice(2);

      callback.apply(this, args);
    }
  },
  onStatusChange: function onStatusChange(choiceIndex) {
    var statuses = ["wrong", "ungraded", "correct"];
    var answers = this.props.answers;

    var i = _$8.indexOf(statuses, answers[choiceIndex].status);

    var newStatus = statuses[(i + 1) % statuses.length];
    this.updateAnswer(choiceIndex, {
      status: newStatus,
      simplify: newStatus === "correct" ? "required" : "accepted"
    });
  },
  onMultipleInputChange: function onMultipleInputChange(event) {
    var newOption = event.target.value;

    if (newOption === "multiple-numeric-input") {
      this.props.onChange({
        multipleNumberInput: true
      });
    } else {
      this.props.onChange({
        multipleNumberInput: false
      });
    }
  },
  updateAnswer: function updateAnswer(choiceIndex, update) {
    if (!_$8.isObject(update)) {
      return _$8.partial((choiceIndex, key, value) => {
        var update = {};
        update[key] = value;
        this.updateAnswer(choiceIndex, update);
      }, choiceIndex, update);
    }

    var answers = _$8.clone(this.props.answers); // Don't bother to make a new answer box unless we are editing the last
    // one.
    // TODO(oliver): This might not be necessary anymore.


    if (choiceIndex === answers.length) {
      var lastAnswer = initAnswer(this.state.lastStatus);
      var answers = answers.concat(lastAnswer);
    }

    answers[choiceIndex] = _$8.extend({}, answers[choiceIndex], update);
    this.props.onChange({
      answers: answers
    });
  },
  addAnswer: function addAnswer() {
    var lastAnswer = initAnswer(this.state.lastStatus);
    var answers = this.props.answers.concat(lastAnswer);
    this.props.onChange({
      answers: answers
    });
  },
  getSaveWarnings: function getSaveWarnings() {
    // Filter out all the empty answers
    var warnings = []; // TODO(emily): This doesn't actually work, because the value is either
    // null or undefined when undefined, probably.

    if (_$8.contains(_$8.pluck(this.props.answers, "value"), "")) {
      warnings.push("One or more answers is empty");
    }

    this.props.answers.forEach((answer, i) => {
      var formatError = answer.strict && (!answer.answerForms || answer.answerForms.length === 0);

      if (formatError) {
        warnings.push("Answer ".concat(i + 1, " is set to string format ") + "matching, but no format was selected");
      }
    });
    return warnings;
  },

  serialize() {
    return EditorJsonify.serialize.call(this);
  }

});
_module_$e.exports = NumericInputEditor;
var _widgetsNumericInputEditorJsx = _module_$e.exports;

var _module_$d = {
  exports: {}
};
/**
 * In review mode (currently only visible in the sat-mission), NumericInput and
 * InputNumber use this component to display the set of correct answers.
 */

var React$c = _react__default["default"];
var _$7 = _underscore__default["default"];
var PossibleAnswers$2 = createReactClass({
  displayName: "PossibleAnswers",
  propTypes: {
    answers: PropTypes.arrayOf(PropTypes.string)
  },
  render: function render() {
    // It's redundant to show duplicate answers.
    // So, remove duplicates from the given list of answer strings.
    var answers = _$7.uniq(this.props.answers);

    var answerComponents = _$7.map(answers, answer => {
      // Plus, now that our answers are distinct, we can safely use the
      // answer string as a key.
      return /*#__PURE__*/React$c.createElement("dd", {
        key: answer
      }, answer);
    });

    return /*#__PURE__*/React$c.createElement("dl", {
      className: "perseus-possible-answers"
    }, /*#__PURE__*/React$c.createElement("dt", null, "Correct Answer"), answerComponents);
  }
});
_module_$d.exports = PossibleAnswers$2;
var _componentsPossibleAnswersJsx = _module_$d.exports;

var _module_$c = {
  exports: {}
};
/* eslint-disable brace-style, comma-dangle, indent, no-undef, no-var, object-curly-spacing, react/forbid-prop-types, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var classNames$3 = _classnames__default["default"];
var React$b = _react__default["default"];
var _$6 = _underscore__default["default"];
var InputWithExamples$1 = _componentsInputWithExamplesJsx;
var SimpleKeypadInput$1 = _componentsSimpleKeypadInputJsx;
var ParseTex$1 = _texWranglerJs.parseTex;
var PossibleAnswers$1 = _componentsPossibleAnswersJsx;
var ApiClassNames$2 = _perseusApiJsx.ClassNames;
var ApiOptions$2 = _perseusApiJsx.Options;
var KhanAnswerTypes$1 = _utilAnswerTypesJs;
var KhanMath = _utilMathJs;
var {
  keypadElementPropType: keypadElementPropType$1
} = _mathInput__default["default"].propTypes;
var InlineIcon$2 = _componentsInlineIconJsx;
var answerFormButtons = [{
  title: "Integers",
  value: "integer",
  content: "6"
}, {
  title: "Decimals",
  value: "decimal",
  content: "0.75"
}, {
  title: "Proper fractions",
  value: "proper",
  content: "\u2157"
}, {
  title: "Improper fractions",
  value: "improper",
  content: "\u2077\u2044\u2084"
}, {
  title: "Mixed numbers",
  value: "mixed",
  content: "1\u00BE"
}, {
  title: "Numbers with \u03C0",
  value: "pi",
  content: "\u03C0"
}];
var formExamples$1 = {
  integer: () => i18n._("an integer, like $6$"),
  proper: form => form.simplify === "optional" ? i18n._("a *proper* fraction, like $1/2$ or $6/10$") : i18n._("a *simplified proper* fraction, like $3/5$"),
  improper: form => form.simplify === "optional" ? i18n._("an *improper* fraction, like $10/7$ or $14/8$") : i18n._("a *simplified improper* fraction, like $7/4$"),
  mixed: () => i18n._("a mixed number, like $1\\ 3/4$"),
  decimal: () => i18n._("an *exact* decimal, like $0.75$"),
  pi: () => i18n._("a multiple of pi, like $12\\ \\text{pi}$ or " + "$2/3\\ \\text{pi}$")
};
var NumericInput = createReactClass({
  displayName: "NumericInput",
  propTypes: {
    currentValue: PropTypes.string,
    currentMultipleValues: PropTypes.arrayOf(PropTypes.string),
    size: PropTypes.oneOf(["normal", "small"]),
    apiOptions: ApiOptions$2.propTypes,
    coefficient: PropTypes.bool,
    answerForms: PropTypes.arrayOf(PropTypes.shape({
      name: PropTypes.string.isRequired,
      simplify: PropTypes.oneOf(["required", "optional"]).isRequired
    })),
    keypadElement: keypadElementPropType$1,
    labelText: PropTypes.string,
    reviewModeRubric: PropTypes.object,
    trackInteraction: PropTypes.func.isRequired,
    widgetId: PropTypes.string.isRequired,
    linterContext: linterContextProps,
    multipleNumberInput: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      currentValue: "",
      // currentMultipleValues has an empty string, because if finite
      // solutions is chosen, there must be at least 1 answer
      currentMultipleValues: [""],
      size: "normal",
      apiOptions: ApiOptions$2.defaults,
      coefficient: false,
      answerForms: [],
      labelText: "",
      linterContext: linterContextDefault,
      multipleNumberInput: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      // dropdown option: either no-solutions or finite-solutions
      numSolutions: "no-solutions",
      // keeps track of the other set of values when switching
      // between 0 and finite solutions
      previousValues: [""]
    };
  },
  getAnswerBlurb: function getAnswerBlurb(rubric) {
    var correct;
    var answerBlurb;

    if (this.props.apiOptions.satStyling && rubric) {
      var score = this.simpleValidate(rubric);
      correct = score.type === "points" && score.earned === score.total;

      if (!correct) {
        var correctAnswers = _$6.filter(rubric.answers, answer => answer.status === "correct");

        var answerStrings = _$6.map(correctAnswers, answer => {
          // Figure out how this answer is supposed to be
          // displayed
          var format = "decimal";

          if (answer.answerForms && answer.answerForms[0]) {
            // NOTE(johnsullivan): This isn't exactly ideal, but
            // it does behave well for all the currently known
            // problems. See D14742 for some discussion on
            // alternate strategies.
            format = answer.answerForms[0];
          }

          var answerString = KhanMath.toNumericString(answer.value, format);

          if (answer.maxError) {
            answerString += " \u00B1 " + KhanMath.toNumericString(answer.maxError, format);
          }

          return answerString;
        });

        answerBlurb = /*#__PURE__*/React$b.createElement(PossibleAnswers$1, {
          answers: answerStrings
        });
      }
    }

    return [answerBlurb, correct];
  },
  getClasses: function getClasses(correct, rubric) {
    var classes = {};
    classes["perseus-input-size-" + this.props.size] = true;
    classes[ApiClassNames$2.CORRECT] = rubric && correct && this.props.currentValue;
    classes[ApiClassNames$2.INCORRECT] = rubric && !correct && this.props.currentValue;
    classes[ApiClassNames$2.UNANSWERED] = rubric && !this.props.currentValue;
    return classes;
  },
  render: function render() {
    var rubric = this.props.reviewModeRubric;
    var answers = this.getAnswerBlurb(rubric);
    var answerBlurb = answers[0];
    var correct = answers[1];
    var classes = this.getClasses(correct, rubric);
    var labelText = this.props.labelText;

    if (labelText == null || labelText === "") {
      labelText = i18n._("Your answer:");
    }

    var selectClasses = classNames$3({
      "perseus-widget-dropdown": true
    });
    var dropdown = /*#__PURE__*/React$b.createElement("div", null, /*#__PURE__*/React$b.createElement("select", {
      onChange: this.handleNumSolutionsChange,
      className: selectClasses + " " + aphrodite.css(styles$3.dropdown) + " " + ApiClassNames$2.INTERACTIVE,
      value: this.state.numSolutions
    }, /*#__PURE__*/React$b.createElement("option", {
      value: "no-solutions"
    }, i18n._("0 solutions")), /*#__PURE__*/React$b.createElement("option", {
      value: "finite-solutions"
    }, i18n._("Finite solutions"))), /*#__PURE__*/React$b.createElement(InlineIcon$2, _extends({}, iconDropdownArrow, {
      style: {
        marginLeft: -24,
        height: 24,
        width: 24
      }
    })));
    var input;

    if (this.props.multipleNumberInput) {
      if (this.state.numSolutions === "no-solutions") {
        return dropdown;
      } else {
        var addInput = /*#__PURE__*/React$b.createElement("div", {
          className: aphrodite.css(styles$3.addInputButton),
          onClick: this._addInput
        }, "+");
        input = /*#__PURE__*/React$b.createElement("div", null, this.props.currentMultipleValues.map((item, i) => /*#__PURE__*/React$b.createElement("div", {
          key: i,
          className: aphrodite.css(styles$3.numberInputContainer)
        }, i > 0 && /*#__PURE__*/React$b.createElement("div", {
          className: aphrodite.css(styles$3.removeInputButton),
          onClick: evt => this._removeInput(i, evt),
          "aria-label": "Remove this answer"
        }, "-"), this.props.apiOptions.customKeypad ? /*#__PURE__*/React$b.createElement(SimpleKeypadInput$1, {
          ref: "input",
          value: this.props.currentMultipleValues[i],
          keypadElement: this.props.keypadElement,
          onChange: e => this.handleMultipleInputChange(i, e),
          onFocus: this._handleFocus,
          onBlur: this._handleBlur
        }) : /*#__PURE__*/React$b.createElement(InputWithExamples$1, {
          ref: "input",
          value: this.props.currentMultipleValues[i],
          onChange: e => this.handleMultipleInputChange(i, e),
          className: classNames$3(classes, aphrodite.css(styles$3.numberInput)),
          labelText: labelText,
          type: this._getInputType(),
          examples: this.examples(),
          shouldShowExamples: this.shouldShowExamples(),
          onFocus: this._handleFocus,
          onBlur: this._handleBlur,
          id: this.props.widgetId,
          disabled: this.props.apiOptions.readOnly,
          highlightLint: this.props.highlightLint
        }))), addInput, "Add answer");
      }
    } else {
      if (this.props.apiOptions.customKeypad) {
        // TODO(charlie): Support "Review Mode".
        return /*#__PURE__*/React$b.createElement(SimpleKeypadInput$1, {
          ref: "input",
          value: this.props.currentValue,
          keypadElement: this.props.keypadElement,
          onChange: this.handleChange,
          onFocus: this._handleFocus,
          onBlur: this._handleBlur
        });
      } else {
        input = /*#__PURE__*/React$b.createElement(InputWithExamples$1, {
          ref: "input",
          value: this.props.currentValue,
          onChange: this.handleChange,
          className: classNames$3(classes),
          labelText: labelText,
          type: this._getInputType(),
          examples: this.examples(),
          shouldShowExamples: this.shouldShowExamples(),
          onFocus: this._handleFocus,
          onBlur: this._handleBlur,
          id: this.props.widgetId,
          disabled: this.props.apiOptions.readOnly,
          highlightLint: this.props.highlightLint
        });
      }
    }

    if (answerBlurb) {
      return /*#__PURE__*/React$b.createElement("span", {
        className: "perseus-input-with-answer-blurb"
      }, this.props.multipleNumberInput && dropdown, input, answerBlurb);
    } else if (this.props.apiOptions.satStyling) {
      // NOTE(amy): the input widgets themselves already have
      // a default aria label of "Your Answer", so we hide this
      // redundant label from screen-readers.
      return /*#__PURE__*/React$b.createElement("label", {
        className: "perseus-input-with-label",
        "aria-hidden": "true"
      }, /*#__PURE__*/React$b.createElement("span", {
        className: "perseus-input-label"
      }, i18n.i18nDoNotTranslate("Answer:")), this.props.multipleNumberInput && dropdown, input);
    } else {
      return /*#__PURE__*/React$b.createElement("div", null, this.props.multipleNumberInput && dropdown, input);
    }
  },
  handleChange: function handleChange(newValue, cb) {
    this.props.onChange({
      currentValue: newValue
    }, cb);
    this.props.trackInteraction();
  },
  handleMultipleInputChange: function handleMultipleInputChange(index, newValue) {
    var newValues = this.props.currentMultipleValues.slice();
    newValues[index] = newValue;
    this.props.onChange({
      currentMultipleValues: newValues
    });
    this.props.trackInteraction();
  },
  handleNumSolutionsChange: function handleNumSolutionsChange(event) {
    var newValue = event.target.value;
    this.setState({
      numSolutions: newValue
    }); // Saves the values the user entered when switching between no
    // solutions and finite solutions, however, we also correctly update
    // the answer that is to be graded

    if (newValue === "no-solutions") {
      this.setState({
        previousValues: this.props.currentMultipleValues
      });
      this.props.onChange({
        currentMultipleValues: []
      });
    } else {
      this.props.onChange({
        currentMultipleValues: this.state.previousValues
      });
      this.setState({
        previousValues: []
      });
    }
  },
  _getInputType: function _getInputType() {
    if (this.props.apiOptions.staticRender) {
      return "tex";
    } else {
      return "text";
    }
  },
  _handleFocus: function _handleFocus() {
    this.props.onFocus([]); // HACK(kevinb): We want to dismiss the feedback popover that webapp
    // displays as soon as a user clicks in in the input field so we call
    // interactionCallback directly.

    var {
      interactionCallback
    } = this.props.apiOptions;

    if (interactionCallback) {
      interactionCallback();
    }
  },
  _handleBlur: function _handleBlur() {
    this.props.onBlur([]);
  },
  _addInput: function _addInput() {
    // Add a new blank value to the list of current values
    this.props.onChange({
      currentMultipleValues: this.props.currentMultipleValues.concat([""])
    });
  },
  _removeInput: function _removeInput(i, event) {
    var length = this.props.currentMultipleValues.length;
    var newValues = this.props.currentMultipleValues.slice(0, i).concat(this.props.currentMultipleValues.slice(i + 1, length));
    this.props.onChange({
      currentMultipleValues: newValues
    });
  },
  focus: function focus() {
    this.refs.input.focus();
    return true;
  },
  focusInputPath: function focusInputPath(inputPath) {
    this.refs.input.focus();
  },
  blurInputPath: function blurInputPath(inputPath) {
    this.refs.input.blur();
  },
  getInputPaths: function getInputPaths() {
    // The widget itself is an input, so we return a single empty list to
    // indicate this.
    return [[]];
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(inputPath) {
    return "number";
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    this.props.onChange({
      currentValue: newValue
    }, cb);
  },
  getUserInput: function getUserInput() {
    var multiple = this.props.multipleNumberInput;
    return {
      multInput: multiple,
      currentValue: multiple ? this.props.currentMultipleValues : this.props.currentValue
    };
  },
  simpleValidate: function simpleValidate(rubric) {
    return NumericInput.validate(this.getUserInput(), rubric);
  },
  shouldShowExamples: function shouldShowExamples() {
    var noFormsAccepted = this.props.answerForms.length === 0; // To check if all answer forms are accepted, we must first
    // find the *names* of all accepted forms, and see if they are
    // all present, ignoring duplicates

    var answerFormNames = _$6.uniq(this.props.answerForms.map(form => form.name));

    var allFormsAccepted = answerFormNames.length >= _$6.size(formExamples$1);

    return !noFormsAccepted && !allFormsAccepted;
  },
  examples: function examples() {
    // if the set of specified forms are empty, allow all forms
    var forms = this.props.answerForms.length !== 0 ? this.props.answerForms : _$6.map(_$6.keys(formExamples$1), name => {
      return {
        name: name,
        simplify: "required"
      };
    });

    var examples = _$6.map(forms, form => {
      return formExamples$1[form.name](form);
    }); // Ensure no duplicate tooltip text from simplified and unsimplified
    // versions of the same format


    examples = _$6.uniq(examples);
    return [i18n._("**Your answer should be** ")].concat(examples);
  }
});

_$6.extend(NumericInput, {
  validate: function validate(state, rubric) {
    var allAnswerForms = _$6.pluck(answerFormButtons, "value");

    var createValidator = answer => KhanAnswerTypes$1.number.createValidatorFunctional(answer.value, {
      message: answer.message,
      simplify: answer.status === "correct" ? answer.simplify : "optional",
      inexact: true,
      // TODO(merlob) backfill / delete
      maxError: answer.maxError,
      forms: answer.strict && answer.answerForms && answer.answerForms.length !== 0 ? answer.answerForms : allAnswerForms
    }); // We may have received TeX; try to parse it before grading.
    // If `currentValue` is not TeX, this should be a no-op.


    var currentValue = ParseTex$1(state.currentValue);

    var correctAnswers = _$6.where(rubric.answers, {
      status: "correct"
    });

    if (state.multInput) {
      // sort the answers and the solutions so they can be compared
      var sortedInputs = currentValue.split(",").sort();
      correctAnswers.sort((a, b) => {
        return a.value > b.value ? 1 : -1;
      }); // If the number of correct answers and user answers do not match
      // return early that the answer is wrong

      if (sortedInputs.length !== correctAnswers.length) {
        return {
          type: "points",
          earned: 0,
          total: 1,
          message: "Incorrect number of answers"
        };
      } // Look through all correct answers and make sure there is
      // the correct user answer for each


      var correct = true;
      var message;
      correctAnswers.forEach(function (answer, i) {
        var localValue = sortedInputs[i];

        if (rubric.coefficient) {
          if (!localValue) {
            localValue = 1;
          } else if (localValue === "-") {
            localValue = -1;
          }
        }

        var validate = createValidator(answer);
        var status = validate(localValue);
        correct = correct && status.correct;

        if (status.message) {
          message = status.message;
        }
      });
      return {
        type: "points",
        earned: correct ? 1 : 0,
        total: 1,
        message: message
      };
    } else {
      // Look through all correct answers for one that matches either
      // precisely or approximately and return the appropriate message:
      // - if precise, return the message that the answer came with
      // - if it needs to be simplified, etc., show that message
      var result = _$6.find(_$6.map(correctAnswers, answer => {
        // The coefficient is an attribute of the widget
        var localValue = currentValue;

        if (rubric.coefficient) {
          if (!localValue) {
            localValue = 1;
          } else if (localValue === "-") {
            localValue = -1;
          }
        }

        var validate = createValidator(answer);
        return validate(localValue);
      }), match => match.correct || match.empty);

      if (!result) {
        // Otherwise, if the guess is not correct
        var otherAnswers = [].concat(_$6.where(rubric.answers, {
          status: "ungraded"
        }), _$6.where(rubric.answers, {
          status: "wrong"
        })); // Look through all other answers and if one matches either
        // precisely or approximately return the answer's message

        var match = _$6.find(otherAnswers, answer => {
          var validate = createValidator(answer);
          return validate(currentValue).correct;
        });

        result = {
          empty: match ? match.status === "ungraded" : false,
          correct: match ? match.status === "correct" : false,
          message: match ? match.message : null,
          guess: currentValue
        };
      } // TODO(eater): Seems silly to translate result to this
      // invalid/points thing and immediately translate it
      // back in ItemRenderer.scoreInput()


      if (result.empty) {
        return {
          type: "invalid",
          message: result.message
        };
      } else {
        return {
          type: "points",
          earned: result.correct ? 1 : 0,
          total: 1,
          message: result.message
        };
      }
    }
  }
}); // TODO(thomas): Currently we receive a list of lists of acceptable answer types
// and union them down into a single set. It's worth considering whether it
// wouldn't make more sense to have a single set of acceptable answer types for
// a given *problem* rather than for each possible [correct/wrong] *answer*.
// When should two answers to a problem take different answer types?
// See D27790 for more discussion.


var unionAnswerForms = function unionAnswerForms(answerFormsList) {
  // Takes a list of lists of answer forms, and returns a list of the forms
  // in each of these lists in the same order that they're listed in the
  // `formExamples` forms from above.
  // uniqueBy takes a list of elements and a function which compares whether
  // two elements are equal, and returns a list of unique elements. This is
  // just a helper function here, but works generally.
  var uniqueBy = function uniqueBy(list, iteratee) {
    return _$6.reduce(list, (uniqueList, element) => {
      // For each element, decide whether it's already in the list of
      // unique items.
      var inList = _$6.find(uniqueList, iteratee.bind(null, element));

      if (inList) {
        return uniqueList;
      } else {
        return uniqueList.concat([element]);
      }
    }, []);
  }; // Pull out all of the forms from the different lists.


  var allForms = _$6.flatten(answerFormsList); // Pull out the unique forms using uniqueBy.


  var uniqueForms = uniqueBy(allForms, _$6.isEqual); // Sort them by the order they appear in the `formExamples` list.

  return _$6.sortBy(uniqueForms, form => {
    return _$6.keys(formExamples$1).indexOf(form.name);
  });
};

var propsTransform = function propsTransform(editorProps) {
  var rendererProps = _$6.extend(_$6.omit(editorProps, "answers"), {
    answerForms: unionAnswerForms( // Pull out the name of each form and whether that form has
    // required simplification.
    _$6.map(editorProps.answers, answer => {
      return _$6.map(answer.answerForms, form => {
        return {
          simplify: answer.simplify,
          name: form
        };
      });
    }))
  });

  return rendererProps;
};

var styles$3 = aphrodite.StyleSheet.create({
  addInputButton: {
    cursor: "pointer",
    display: "inline-block",
    border: "2px solid ".concat(kaGreen),
    backgroundColor: kaGreen,
    color: white,
    fontSize: 20,
    borderRadius: 15,
    width: 18,
    height: 18,
    marginBottom: 7,
    marginRight: 8,
    marginTop: 3,
    textAlign: "center",
    paddingTop: 1
  },
  removeInputButton: {
    cursor: "pointer",
    display: "inline-block",
    border: "2px solid ".concat(red),
    backgroundColor: red,
    color: white,
    fontSize: 20,
    borderRadius: 15,
    width: 18,
    height: 18,
    marginBottom: 7,
    marginRight: 8,
    marginTop: 4,
    textAlign: "center"
  },
  dropdown: {
    width: 250,
    marginBottom: 10,
    appearance: 'none',
    backgroundColor: 'transparent',
    border: "1px solid ".concat(gray76),
    borderRadius: 4,
    boxShadow: 'none',
    fontFamily: baseFontFamily,
    padding: "9px 25px 9px 9px",
    ':focus': {
      outline: 'none',
      border: "2px solid ".concat(kaGreen),
      padding: "8px 25px 8px 8px"
    },
    ':focus + svg': {
      color: "".concat(kaGreen)
    },
    ':disabled': {
      color: gray68
    },
    ':disabled + svg': {
      color: gray68
    }
  },
  numberInput: {
    float: "right",
    width: 170,
    marginBottom: 10,
    border: "1px solid ".concat(gray76),
    borderRadius: 4,
    padding: "9px 25px 9px 9px",
    ':focus': {
      outline: 'none',
      border: "2px solid ".concat(kaGreen),
      padding: "8px 25px 8px 8px"
    }
  },
  numberInputContainer: {
    display: "flex"
  }
});
_module_$c.exports = {
  name: "numeric-input",
  displayName: "Number text box",
  defaultAlignment: "inline-block",
  accessible: true,
  widget: NumericInput,
  transform: propsTransform,
  isLintable: true
};
var _widgetsNumericInputJsx = _module_$c.exports;

var _module_$b = {
  exports: {}
};
/* eslint-disable comma-dangle, no-var, react/jsx-closing-bracket-location, react/jsx-indent-props, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$a = _react__default["default"];
var ReactDOM$1 = _reactDom__default["default"];
var _$5 = _underscore__default["default"];
var Util$1 = Util$q;
var BlurInput = _reactComponentsBlurInputJsx;
var InfoTip = _componentsInfoTipJsx;
var answerTypes$1 = {
  number: {
    name: "Numbers",
    forms: "integer, decimal, proper, improper, mixed"
  },
  decimal: {
    name: "Decimals",
    forms: "decimal"
  },
  integer: {
    name: "Integers",
    forms: "integer"
  },
  rational: {
    name: "Fractions and mixed numbers",
    forms: "integer, proper, improper, mixed"
  },
  improper: {
    name: "Improper numbers (no mixed)",
    forms: "integer, proper, improper"
  },
  mixed: {
    name: "Mixed numbers (no improper)",
    forms: "integer, proper, mixed"
  },
  percent: {
    name: "Numbers or percents",
    forms: "integer, decimal, proper, improper, mixed, percent"
  },
  pi: {
    name: "Numbers with pi",
    forms: "pi"
  }
};
var InputNumberEditor = createReactClass({
  displayName: "InputNumberEditor",
  propTypes: {
    value: PropTypes.number,
    simplify: PropTypes.oneOf(["required", "optional", "enforced"]),
    size: PropTypes.oneOf(["normal", "small"]),
    inexact: PropTypes.bool,
    maxError: PropTypes.number,
    answerType: PropTypes.string
  },
  getDefaultProps: function getDefaultProps() {
    return {
      value: 0,
      simplify: "required",
      size: "normal",
      inexact: false,
      maxError: 0.1,
      answerType: "number"
    };
  },
  handleAnswerChange: function handleAnswerChange(str) {
    var value = Util$1.firstNumericalParse(str) || 0;
    this.props.onChange({
      value: value
    });
  },
  render: function render() {
    var answerTypeOptions = _$5.map(answerTypes$1, function (v, k) {
      return /*#__PURE__*/React$a.createElement("option", {
        value: k,
        key: k
      }, v.name);
    }, this);

    return /*#__PURE__*/React$a.createElement("div", null, /*#__PURE__*/React$a.createElement("div", null, /*#__PURE__*/React$a.createElement("label", null, "Correct answer:", " ", /*#__PURE__*/React$a.createElement(BlurInput, {
      value: "" + this.props.value,
      onChange: this.handleAnswerChange,
      ref: "input"
    }))), /*#__PURE__*/React$a.createElement("div", null, /*#__PURE__*/React$a.createElement("label", null, "Unsimplified answers", " ", /*#__PURE__*/React$a.createElement("select", {
      value: this.props.simplify,
      onChange: e => {
        this.props.onChange({
          simplify: e.target.value
        });
      }
    }, /*#__PURE__*/React$a.createElement("option", {
      value: "required"
    }, "will not be graded"), /*#__PURE__*/React$a.createElement("option", {
      value: "optional"
    }, "will be accepted"), /*#__PURE__*/React$a.createElement("option", {
      value: "enforced"
    }, "will be marked wrong"))), /*#__PURE__*/React$a.createElement(InfoTip, null, /*#__PURE__*/React$a.createElement("p", null, "Normally select \"will not be graded\". This will give the user a message saying the answer is correct but not simplified. The user will then have to simplify it and re-enter, but will not be penalized. (5th grade and anything after)"), /*#__PURE__*/React$a.createElement("p", null, "Select \"will be accepted\" only if the user is not expected to know how to simplify fractions yet. (Anything prior to 5th grade)"), /*#__PURE__*/React$a.createElement("p", null, "Select \"will be marked wrong\" only if we are specifically assessing the ability to simplify."))), /*#__PURE__*/React$a.createElement("div", null, /*#__PURE__*/React$a.createElement("label", null, /*#__PURE__*/React$a.createElement("input", {
      type: "checkbox",
      checked: this.props.inexact,
      onChange: e => {
        this.props.onChange({
          inexact: e.target.checked
        });
      }
    }), " ", "Allow inexact answers"), /*#__PURE__*/React$a.createElement("label", null, /*#__PURE__*/React$a.createElement("input", {
      /* TODO(emily): don't use a hidden checkbox
      for alignment */
      type: "checkbox",
      style: {
        visibility: "hidden"
      }
    }), "Max error:", " ", /*#__PURE__*/React$a.createElement("input", {
      type: "text",
      disabled: !this.props.inexact,
      defaultValue: this.props.maxError,
      onBlur: e => {
        var ans = "" + (Util$1.firstNumericalParse(e.target.value) || 0);
        e.target.value = ans;
        this.props.onChange({
          maxError: ans
        });
      }
    }))), /*#__PURE__*/React$a.createElement("div", null, "Answer type:", " ", /*#__PURE__*/React$a.createElement("select", {
      value: this.props.answerType,
      onChange: e => {
        this.props.onChange({
          answerType: e.target.value
        });
      }
    }, answerTypeOptions), /*#__PURE__*/React$a.createElement(InfoTip, null, /*#__PURE__*/React$a.createElement("p", null, "Use the default \"Numbers\" unless the answer must be in a specific form (e.g., question is about converting decimals to fractions)."))), /*#__PURE__*/React$a.createElement("div", null, /*#__PURE__*/React$a.createElement("label", null, "Width", " ", /*#__PURE__*/React$a.createElement("select", {
      value: this.props.size,
      onChange: e => {
        this.props.onChange({
          size: e.target.value
        });
      }
    }, /*#__PURE__*/React$a.createElement("option", {
      value: "normal"
    }, "Normal (80px)"), /*#__PURE__*/React$a.createElement("option", {
      value: "small"
    }, "Small (40px)"))), /*#__PURE__*/React$a.createElement(InfoTip, null, /*#__PURE__*/React$a.createElement("p", null, "Use size \"Normal\" for all text boxes, unless there are multiple text boxes in one line and the answer area is too narrow to fit them."))));
  },
  focus: function focus() {
    ReactDOM$1.findDOMNode(this.refs.input).focus();
    return true;
  },
  serialize: function serialize() {
    return _$5.pick(this.props, "value", "simplify", "size", "inexact", "maxError", "answerType");
  }
});
_module_$b.exports = InputNumberEditor;
var _widgetsInputNumberEditorJsx = _module_$b.exports;

var _module_$a = {
  exports: {}
};
/* eslint-disable brace-style, comma-dangle, no-undef, no-var, object-curly-spacing, react/forbid-prop-types, react/prop-types, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var classNames$2 = _classnames__default["default"];
var React$9 = _react__default["default"];
var _$4 = _underscore__default["default"];
var InputWithExamples = _componentsInputWithExamplesJsx;
var SimpleKeypadInput = _componentsSimpleKeypadInputJsx;
var ParseTex = _texWranglerJs.parseTex;
var PossibleAnswers = _componentsPossibleAnswersJsx;
var KhanAnswerTypes = _utilAnswerTypesJs;
var {
  keypadElementPropType
} = _mathInput__default["default"].propTypes;
var ApiClassNames$1 = _perseusApiJsx.ClassNames;
var ApiOptions$1 = _perseusApiJsx.Options;
var answerTypes = {
  number: {
    name: "Numbers",
    forms: "integer, decimal, proper, improper, mixed"
  },
  decimal: {
    name: "Decimals",
    forms: "decimal"
  },
  integer: {
    name: "Integers",
    forms: "integer"
  },
  rational: {
    name: "Fractions and mixed numbers",
    forms: "integer, proper, improper, mixed"
  },
  improper: {
    name: "Improper numbers (no mixed)",
    forms: "integer, proper, improper"
  },
  mixed: {
    name: "Mixed numbers (no improper)",
    forms: "integer, proper, mixed"
  },
  percent: {
    name: "Numbers or percents",
    forms: "integer, decimal, proper, improper, mixed, percent"
  },
  pi: {
    name: "Numbers with pi",
    forms: "pi"
  }
};
var formExamples = {
  integer: function integer(options) {
    return i18n._("an integer, like $6$");
  },
  proper: function proper(options) {
    if (options.simplify === "optional") {
      return i18n._("a *proper* fraction, like $1/2$ or $6/10$");
    } else {
      return i18n._("a *simplified proper* fraction, like $3/5$");
    }
  },
  improper: function improper(options) {
    if (options.simplify === "optional") {
      return i18n._("an *improper* fraction, like $10/7$ or $14/8$");
    } else {
      return i18n._("a *simplified improper* fraction, like $7/4$");
    }
  },
  mixed: function mixed(options) {
    return i18n._("a mixed number, like $1\\ 3/4$");
  },
  decimal: function decimal(options) {
    return i18n._("an *exact* decimal, like $0.75$");
  },
  percent: function percent(options) {
    return i18n._("a percent, like $12.34\\%$");
  },
  pi: function pi(options) {
    return i18n._("a multiple of pi, like $12\\ \\text{pi}$ or " + "$2/3\\ \\text{pi}$");
  }
};
var InputNumber = createReactClass({
  displayName: "InputNumber",
  propTypes: {
    answerType: PropTypes.oneOf(Object.keys(answerTypes)),
    currentValue: PropTypes.string,
    keypadElement: keypadElementPropType,
    reviewModeRubric: PropTypes.object,
    widgetId: PropTypes.string.isRequired,
    linterContext: linterContextProps
  },
  getDefaultProps: function getDefaultProps() {
    return {
      currentValue: "",
      size: "normal",
      answerType: "number",
      apiOptions: ApiOptions$1.defaults,
      linterContext: linterContextDefault
    };
  },
  shouldShowExamples: function shouldShowExamples() {
    return this.props.answerType !== "number" && !this.props.apiOptions.staticRender;
  },
  render: function render() {
    if (this.props.apiOptions.customKeypad) {
      // TODO(charlie): Support "Review Mode".
      return /*#__PURE__*/React$9.createElement(SimpleKeypadInput, {
        ref: "input",
        value: this.props.currentValue,
        keypadElement: this.props.keypadElement,
        onChange: this.handleChange,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur
      });
    } else {
      // HACK(johnsullivan): Create a function with shared logic between
      // this and NumericInput.
      var rubric = this.props.reviewModeRubric;
      var correct = null;
      var answerBlurb = null;

      if (this.props.apiOptions.satStyling && rubric) {
        var score = this.simpleValidate(rubric);
        correct = score.type === "points" && score.earned === score.total;

        if (!correct) {
          // TODO(johnsullivan): Make this a little more
          // human-friendly.
          var answerString = String(rubric.value);

          if (rubric.inexact && rubric.maxError) {
            answerString += " \u00B1 " + rubric.maxError;
          }

          var answerStrings = [answerString];
          answerBlurb = /*#__PURE__*/React$9.createElement(PossibleAnswers, {
            answers: answerStrings
          });
        }
      }

      var classes = {};
      classes["perseus-input-size-" + this.props.size] = true;
      classes[ApiClassNames$1.CORRECT] = rubric && correct && this.props.currentValue;
      classes[ApiClassNames$1.INCORRECT] = rubric && !correct && this.props.currentValue;
      classes[ApiClassNames$1.UNANSWERED] = rubric && !this.props.currentValue;
      var input = /*#__PURE__*/React$9.createElement(InputWithExamples, {
        ref: "input",
        value: this.props.currentValue,
        onChange: this.handleChange,
        className: classNames$2(classes),
        type: this._getInputType(),
        examples: this.examples(),
        shouldShowExamples: this.shouldShowExamples(),
        onFocus: this._handleFocus,
        onBlur: this._handleBlur,
        id: this.props.widgetId,
        disabled: this.props.apiOptions.readOnly,
        linterContext: this.props.linterContext
      });

      if (answerBlurb) {
        return /*#__PURE__*/React$9.createElement("span", {
          className: "perseus-input-with-answer-blurb"
        }, input, answerBlurb);
      } else {
        return input;
      }
    }
  },
  handleChange: function handleChange(newValue, cb) {
    this.props.onChange({
      currentValue: newValue
    }, cb);
  },
  _getInputType: function _getInputType() {
    if (this.props.apiOptions.staticRender) {
      return "tex";
    } else {
      return "text";
    }
  },
  _handleFocus: function _handleFocus() {
    this.props.onFocus([]); // HACK(kevinb): We want to dismiss the feedback popover that webapp
    // displays as soon as a user clicks in in the input field so we call
    // interactionCallback directly.

    var {
      interactionCallback
    } = this.props.apiOptions;

    if (interactionCallback) {
      interactionCallback();
    }
  },
  _handleBlur: function _handleBlur() {
    this.props.onBlur([]);
  },
  focus: function focus() {
    this.refs.input.focus();
    return true;
  },
  focusInputPath: function focusInputPath(inputPath) {
    this.refs.input.focus();
  },
  blurInputPath: function blurInputPath(inputPath) {
    this.refs.input.blur();
  },
  getInputPaths: function getInputPaths() {
    // The widget itself is an input, so we return a single empty list to
    // indicate this.
    return [[]];
  },
  getGrammarTypeForPath: function getGrammarTypeForPath(path) {
    return "number";
  },
  setInputValue: function setInputValue(path, newValue, cb) {
    this.props.onChange({
      currentValue: newValue
    }, cb);
  },
  getUserInput: function getUserInput() {
    return {
      currentValue: this.props.currentValue
    };
  },
  simpleValidate: function simpleValidate(rubric, onInputError) {
    onInputError = onInputError || function () {};

    return InputNumber.validate(this.getUserInput(), rubric, onInputError);
  },
  examples: function examples() {
    var type = this.props.answerType;
    var forms = answerTypes[type].forms.split(/\s*,\s*/);

    var examples = _$4.map(forms, function (form) {
      return formExamples[form](this.props);
    }, this);

    return [i18n._("**Your answer should be** ")].concat(examples);
  }
});

_$4.extend(InputNumber, {
  validate: function validate(state, rubric, onInputError) {
    if (rubric.answerType == null) {
      rubric.answerType = "number";
    }

    var val = KhanAnswerTypes.number.createValidatorFunctional(rubric.value, {
      simplify: rubric.simplify,
      inexact: rubric.inexact || undefined,
      maxError: rubric.maxError,
      forms: answerTypes[rubric.answerType].forms
    }); // We may have received TeX; try to parse it before grading.
    // If `currentValue` is not TeX, this should be a no-op.

    var currentValue = ParseTex(state.currentValue);
    var result = val(currentValue); // TODO(eater): Seems silly to translate result to this invalid/points
    // thing and immediately translate it back in ItemRenderer.scoreInput()

    if (result.empty) {
      var apiResult = onInputError(null, // reserved for some widget identifier
      state.currentValue, result.message);
      return {
        type: "invalid",
        message: apiResult === false ? null : result.message
      };
    } else {
      return {
        type: "points",
        earned: result.correct ? 1 : 0,
        total: 1,
        message: result.message
      };
    }
  }
});

var propTransform = editorProps => {
  var {
    simplify,
    size,
    answerType
  } = editorProps;
  return {
    simplify,
    size,
    answerType
  };
};

_module_$a.exports = {
  name: "input-number",
  displayName: "Number text box (old)",
  defaultAlignment: "inline-block",
  hidden: true,
  widget: InputNumber,
  transform: propTransform,
  isLintable: true
};
var _widgetsInputNumberJsx = _module_$a.exports;

var _module_$9 = {
  exports: {}
};
/**
 * Renders text indicating whether the choice was correct or
 * not and whether the choice was selected or not.
 * This information is redundant with that provided in the
 * ChoiceIcon visualizations but is meant to make the distinctions
 * between the states more immediately clear to users.
 */

/* globals i18n */

var React$8 = _react__default["default"];

class OptionStatus$1 extends React$8.Component {
  render() {
    var {
      checked,
      correct
    } = this.props;
    var correctness = correct ? i18n._("correct") : i18n._("incorrect");
    var selectedness = checked ? i18n._("(selected)") : "";
    var text = "".concat(correctness, " ").concat(selectedness);
    var textStyle = correct ? styles$2.correct : styles$2.incorrect;
    return /*#__PURE__*/React$8.createElement("div", {
      className: aphrodite.css(styles$2.text, textStyle)
    }, text);
  }

}

var styles$2 = aphrodite.StyleSheet.create({
  text: {
    alignItems: "center",
    display: "flex",
    fontSize: 12,
    height: 32,
    textTransform: "uppercase"
  },
  correct: {
    color: kaGreen
  },
  incorrect: {
    color: warning1
  }
});
_module_$9.exports = OptionStatus$1;
var _optionStatusJsx = _module_$9.exports;

var _module_$8 = {
  exports: {}
};
/**
 * Renders a circular selection ring around the child.
 */

var React$7 = _react__default["default"];

class FocusRing$1 extends React$7.Component {
  render() {
    var borderColor = this.props.visible ? this.props.color : "transparent";
    var style = {
      borderColor: borderColor
    };
    return /*#__PURE__*/React$7.createElement("span", {
      className: aphrodite.css(styles$1.ring),
      style: style
    }, this.props.children);
  }

}

_defineProperty(FocusRing$1, "defaultProps", {
  visible: true,
  color: kaGreen
});

var styles$1 = aphrodite.StyleSheet.create({
  ring: {
    margin: "auto",
    display: "inline-block",
    borderRadius: "50%",
    borderWidth: 2,
    padding: 2,
    borderStyle: "solid"
  }
});
_module_$8.exports = FocusRing$1;
var _focusRingJsx = _module_$8.exports;

var _module_$7 = {
  exports: {}
};
/* Component for rendering a letter icon in radio choice */

/* global i18n */

var React$6 = _react__default["default"];
var InlineIcon$1 = _componentsInlineIconJsx;
var FocusRing = _focusRingJsx;

class SATChoiceIcon extends React$6.Component {
  // TODO(amy): figure out a better scheme for specifying these
  // styles that isn't such a pain to grok. See some neat ideas
  // from MDR in https://phabricator.khanacademy.org/D35249.
  constructStyles(reviewMode, correct, checked) {
    var backgroundColor;
    var borderColor = satBlue;
    var color = satBlue;

    if (reviewMode) {
      if (correct) {
        borderColor = satCorrectColor;
        color = checked ? white : satCorrectColor;
        backgroundColor = checked ? satCorrectColor : white;
      } else if (checked) {
        borderColor = satIncorrectColor;
        color = white;
        backgroundColor = satIncorrectColor;
      }
    } else if (checked) {
      color = white;
      backgroundColor = satBlue;
    }

    return {
      color,
      backgroundColor,
      borderColor
    };
  }

  render() {
    var {
      letter,
      a11yText,
      reviewMode,
      checked,
      correct
    } = this.props;
    var {
      color,
      backgroundColor,
      borderColor
    } = this.constructStyles(reviewMode, correct, checked);
    return /*#__PURE__*/React$6.createElement("div", null, /*#__PURE__*/React$6.createElement("div", {
      className: aphrodite.css(styles.satCircle),
      style: {
        backgroundColor,
        borderColor
      }
    }), /*#__PURE__*/React$6.createElement("div", {
      style: {
        color
      },
      className: aphrodite.css(styles.letter)
    }, /*#__PURE__*/React$6.createElement("span", {
      className: "perseus-sr-only"
    }, a11yText), /*#__PURE__*/React$6.createElement("span", {
      "aria-hidden": "true"
    }, letter)));
  }

}

class LibraryChoiceIcon extends React$6.Component {
  getChoiceInner() {
    var {
      letter,
      showCorrectness,
      correct
    } = this.props;

    if (!showCorrectness) {
      return letter;
    } else if (correct) {
      return /*#__PURE__*/React$6.createElement(InlineIcon$1, _extends({}, iconCheck, {
        style: {
          position: "relative",
          top: -1
        }
      }));
    } else {
      return /*#__PURE__*/React$6.createElement(InlineIcon$1, iconMinus);
    }
  } // Handle dynamic styling of the multiple choice icon. Most
  // MC icon styles are constant, but we do allow the caller
  // to specify the selected color, and thus must control styles
  // related to the selected state dynamically.


  getDynamicStyles() {
    var {
      checked,
      showCorrectness,
      pressed,
      primaryProductColor,
      correct
    } = this.props;

    if (!showCorrectness && pressed) {
      return {
        borderColor: primaryProductColor,
        color: primaryProductColor,
        backgroundColor: white
      };
    } else if (checked) {
      // Note: kaGreen is not only the default product color,
      // but also the "correctness" color
      var bg = showCorrectness && correct ? kaGreen : primaryProductColor;
      return {
        color: white,
        backgroundColor: bg,
        borderColor: bg
      };
    } else {
      return {
        borderColor: gray68,
        color: gray68
      };
    }
  }

  render() {
    var {
      checked,
      showCorrectness,
      correct,
      focused,
      primaryProductColor
    } = this.props;
    return /*#__PURE__*/React$6.createElement(FocusRing, {
      color: primaryProductColor,
      visible: focused
    }, /*#__PURE__*/React$6.createElement("div", {
      style: this.getDynamicStyles(),
      className: aphrodite.css(styles.libraryCircle, showCorrectness && correct && styles.libraryCircleCorrect, showCorrectness && !correct && styles.libraryCircleIncorrect, showCorrectness && !correct && checked && styles.libraryCircleIncorrectSelected) // used in BaseRadio to check if we actually clicked on the
      // radio icon
      ,
      "data-is-radio-icon": true
    }, this.getChoiceInner()));
  }

}

class ChoiceIcon$1 extends React$6.Component {
  a11yText(letter) {
    // If the option was checked we need to reveal more context about
    // what the result was (correct/incorrect)
    if (this.props.checked) {
      if (this.props.showCorrectness) {
        if (this.props.correct) {
          return i18n._("(Choice %(letter)s, Checked, Correct)", {
            letter: letter
          });
        } else {
          return i18n._("(Choice %(letter)s, Checked, Incorrect)", {
            letter: letter
          });
        }
      }

      return i18n._("(Choice %(letter)s, Checked)", {
        letter: letter
      }); // If the option wasn't checked, but was correct, we need to tell
      // the user that this was, in fact, the correct answer.
    } else if (this.props.showCorrectness && this.props.correct) {
      return i18n._("(Choice %(letter)s, Correct Answer)", {
        letter: letter
      });
    }

    return i18n._("(Choice %(letter)s)", {
      letter: letter
    });
  }

  getLetter() {
    /* I18N: This is a list of single-character labels that will appear in
     * front of multiple-choice options. For instance, a multiple-choice
     * question with three options would display
     *  (A) first option
     *  (B) second option
     *  (C) third option
     * There must be spaces between each of the different characters. The
     * characters will show up next to options in the order that they are
     * listed here. Most multiple choice questions have 5 or fewer options.
     */
    var lettersString = i18n._("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");

    var letters = lettersString.split(" ");
    var pos = this.props.pos;

    if (pos < letters.length) {
      // If the position we need is listed in the localized string, use
      // that.
      return letters[pos];
    } else {
      // If we're out of letters, give up and return a space.
      return " ";
    }
  }

  render() {
    var {
      reviewMode,
      checked,
      correct,
      product,
      showCorrectness,
      pressed,
      focused,
      primaryProductColor
    } = this.props;
    var letter = this.getLetter();

    if (product === "sat") {
      return /*#__PURE__*/React$6.createElement(SATChoiceIcon, {
        letter: letter,
        a11yText: this.a11yText(letter),
        reviewMode: reviewMode,
        checked: checked,
        correct: correct
      });
    } else {
      return /*#__PURE__*/React$6.createElement(LibraryChoiceIcon, {
        letter: letter,
        a11yText: this.a11yText(letter),
        reviewMode: reviewMode,
        checked: checked,
        pressed: pressed,
        focused: focused,
        correct: correct,
        showCorrectness: showCorrectness,
        primaryProductColor: primaryProductColor
      });
    }
  }

}

_defineProperty(ChoiceIcon$1, "defaultProps", {
  primaryProductColor: kaGreen
});

var styles = aphrodite.StyleSheet.create({
  satCircle: {
    display: "block",
    borderRadius: 25,
    borderStyle: "solid",
    borderWidth: 2,
    content: "''",
    height: 25,
    width: 25,
    position: "absolute",
    top: 1,
    left: 1
  },
  libraryCircle: {
    // Make the circle
    width: 24,
    height: 24,
    boxSizing: "border-box",
    borderRadius: 24,
    borderStyle: "solid",
    borderWidth: 2,
    // The default icons have letters in them. Style those letters.
    fontFamily: baseFontFamily,
    // NOTE(emily): We explicitly set the font weight instead of using the
    // "bold font family" so that characters which fall back to the default
    // font get bolded too.
    fontWeight: "bold",
    fontSize: 12,
    // Center the contents of the icon.
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    // HACK(emily): I don't know why adding this line height makes the text
    // appear centered better than any other value, but it does. In
    // particular, at large zoom levels this line height does almost
    // nothing, but at the default size this shifts the letter down one
    // pixel so it is much better centered.
    lineHeight: "1px"
  },
  libraryCircleCorrect: {
    fontSize: 24
  },
  libraryCircleIncorrect: {
    fontSize: 24,
    borderColor: warning1,
    color: warning1
  },
  libraryCircleIncorrectSelected: {
    backgroundColor: warning1,
    color: white
  },
  letter: {
    // These properties make sure that this element has the exact
    // same size as `circle` so that we can center things
    // inside of it.
    border: "2px solid transparent",
    width: 25,
    height: 25,
    position: "absolute",
    left: 1,
    top: 1,
    // Center contained items.
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    fontFamily: boldFontFamily,
    fontSize: 13
  }
});
_module_$7.exports = ChoiceIcon$1;
var _choiceIconJsx = _module_$7.exports;

var _excluded = ["inputRef", "onChecked"];
var _module_$6 = {
  exports: {}
};
var React$5 = _react__default["default"];
/**
 * A radio button that can be unchecked by clicking it again.
 *
 * This component behaves much like a checkbox in that when you click it again
 * (or hit space bar or select it in some other way), it will become unchecked.
 * (Hopefully) it behaves exactly like a radio button in every other way though
 * (arrow keys can still be used to select it within a group for example).
 *
 * Here's a summary of which of our event handlers fire for each way to select
 * or deselect the button:
 *
 * - Clicking a button: handleClick, handleChange
 * - Pressing spacebar with button focussed: handleKeyDown, handleKeyUp (we
 *   suppress the default behavior of some browsers to synthesize a click event
 *   here).
 * - When radio button A is selected, pressing down arrow to select B:
 *   handleKeyDown (A), handleClick (B), handleChange (B), handleKeyUp (B)
 * - Clicking with mac screenreader: handleClick, handleChange
 */

var ToggleableRadioButton$1 = createReactClass({
  displayName: "ToggleableRadioButton",
  propTypes: {
    // Whether the radio button should be checked or unchecked (this is a
    // controlled component).
    checked: PropTypes.bool.isRequired,
    // A ref function to attach to the <input> element.
    inputRef: PropTypes.func,
    // A function that will be called whenever the radio button is checked
    // or unchecked. It's possible for this to be called twice for a single
    // checking or unchecking.
    onChecked: PropTypes.func.isRequired
  },
  handleClick: function handleClick(event) {
    this.props.onChecked(!this.props.checked); // NOTE(johnsullivan): Preventing default would make sense to do here
    //     because we're fully controlling the state of the check box and
    //     don't really want it to be (un)checked accidently. React
    //     requires that we *don't* call preventDefault from the onClick or
    //     onChecked handlers of a controlled component though.
  },
  handleKeyUp: function handleKeyUp(event) {
    // Make hitting the spacebar with the element selected equivalent to
    // clicking it. Some browsers do this as part of the radio button's
    // default behavior, but since some browsers don't we normalize the
    // behavior here.
    if (event.key === " ") {
      this.props.onChecked(!this.props.checked);
      event.preventDefault();
    }
  },
  handleChange: function handleChange(event) {
    // If the checkbox is going from unchecked to checked, we'll handle it
    // here.
    // NOTE(johnsullivan): The onClick/onKeyUp handler most likely *also*
    //     handled this, but we're being defensive against browsers/devices
    //     that might not call those handlers like we'd expect. It's
    //     unclear to me whether this is strictly necessary.
    if (!this.props.checked && event.target.checked) {
      this.props.onChecked(true);
    }
  },
  handleKeyDown: function handleKeyDown(event) {
    // This is necessary in order to prevent IE9 from creating a duplicate
    // click event on the radio button when the space bar is hit.
    if (event.key === " ") {
      event.preventDefault();
    }
  },
  render: function render() {
    var _this$props = this.props,
        otherProps = _objectWithoutProperties(_this$props, _excluded);

    return /*#__PURE__*/React$5.createElement("input", _extends({}, otherProps, {
      type: "radio",
      onChange: this.handleChange,
      onClick: this.handleClick,
      onKeyDown: this.handleKeyDown,
      onKeyUp: this.handleKeyUp,
      ref: this.props.inputRef
    }));
  }
});
_module_$6.exports = ToggleableRadioButton$1;
var _toggleableRadioButtonJsx = _module_$6.exports;

var _module_$5 = {
  exports: {}
};
var React$4 = _react__default["default"];
var classNames$1 = _classnames__default["default"];
var sharedStyles$1 = _stylesSharedJs;
var mediaQueries$1 = _stylesMediaQueriesJs;
var ToggleableRadioButton = _toggleableRadioButtonJsx;
var ChoiceIcon = _choiceIconJsx;
var OptionStatus = _optionStatusJsx;
var focusedStyleMixin = {
  backgroundColor: satSelectedBackgroundColor,
  outline: "2px solid ".concat(satBlue),
  // Render the outline higher than the next element's border
  zIndex: 1
};
var intermediateCheckboxPadding = "16px 16px";
var intermediateCheckboxPaddingPhone = "12px 16px";
var Choice$1 = createReactClass({
  displayName: "Choice",
  propTypes: {
    // TODO(kevinb) use Options.propTypes from perseus-api.jsx
    // This change will also require make sure that item-renderer.jsx and
    // server-item-renderer.jsx have appropriate defaults for apiOptions
    // because many of the properties on Options.propTypes are required.
    apiOptions: PropTypes.shape({
      satStyling: PropTypes.bool,
      isMobile: PropTypes.bool,
      styling: PropTypes.shape({
        radioStyleVersion: PropTypes.oneOf(["intermediate", "final"]),
        primaryProductColor: PropTypes.string
      }),
      readOnly: PropTypes.bool
    }),
    checked: PropTypes.bool,
    className: PropTypes.string,
    rationale: PropTypes.node,
    content: PropTypes.node,
    correct: PropTypes.bool,
    deselectEnabled: PropTypes.bool,
    disabled: PropTypes.bool,
    editMode: PropTypes.bool,
    groupName: PropTypes.string,
    isLastChoice: PropTypes.bool,
    // Needed for border styling
    // This indicates the position of the choice relative to others
    // (so that we can display a nice little (A), (B), etc. next to it)
    // Also used to generate an id for each input.
    pos: PropTypes.number,
    reviewMode: PropTypes.bool,
    showRationale: PropTypes.bool,
    showCorrectness: PropTypes.bool,
    type: PropTypes.string,
    // Indicates whether the user has "crossed out" this choice, meaning
    // that they don't think it's correct. This value does not affect
    // scoring or other behavior; it's just a note for the user's
    // reference.
    crossedOut: PropTypes.bool,
    // A callback indicating that this choice has changed. Its argument is
    // an object with two keys: `checked` and `crossedOut`. Each contains a
    // boolean value specifying the new checked and crossed-out value of
    // this choice.
    onChange: PropTypes.func
  },
  statics: {
    styles: aphrodite.StyleSheet.create({
      pos: {
        display: "none"
      },
      description: {
        display: "inline-block",
        width: "100%"
      },
      satDescription: {
        display: "block",
        position: "relative",
        boxSizing: "border-box",
        cursor: "pointer",
        marginLeft: 0,
        padding: "17px 14px"
      },
      satDescriptionInputFocused: _objectSpread2({}, focusedStyleMixin),
      satDescriptionInputActive: _objectSpread2(_objectSpread2({}, focusedStyleMixin), {}, {
        backgroundColor: satActiveBackgroundColor
      }),
      satDescriptionCorrect: {
        color: satCorrectColor
      },
      satDescriptionCorrectChecked: {
        backgroundColor: satCorrectBackgroundColor
      },
      satDescriptionIncorrectChecked: {
        color: satIncorrectColor,
        backgroundColor: satIncorrectBackgroundColor
      },
      input: {
        display: "inline-block",
        width: 20,
        margin: 3,
        marginLeft: -20,
        marginRight: 0,
        float: "none"
      },
      satReviewInput: {
        pointerEvents: "none"
      },
      satRadioOptionContent: {
        userSelect: "text",
        display: "block",
        marginLeft: 45,
        // Overriding here, not sure why typically set
        // to "cursor: default" in js
        cursor: "inherit"
      },
      satReviewRadioOptionContent: {
        fontWeight: "bold"
      },
      satCheckboxOptionContent: {
        position: "absolute",
        display: "block",
        top: "50%",
        margin: "-16px 0 0 0",
        width: "auto"
      },
      choiceIconWrapper: {
        display: "flex",
        marginRight: 12,
        // NOTE(mdr): Without this style, the bubbles shrink on iOS
        //     when answer text gets long.
        flexShrink: 0
      },
      optionStatusContainer: {
        display: "block"
      },
      rationale: {
        display: "block"
      },
      nonSatRationale: {
        padding: intermediateCheckboxPadding,
        paddingTop: 0,
        marginLeft: 44,
        [mediaQueries$1.smOrSmaller]: {
          padding: intermediateCheckboxPaddingPhone,
          paddingTop: 0
        }
      },
      satReviewRationale: {
        marginTop: 13,
        marginLeft: 45
      },
      label: {
        display: "block"
      },
      responsiveLabel: {
        WebkitTapHighlightColor: "transparent",
        display: "flex"
      },
      satLabel: {
        cursor: "pointer"
      },
      intermediateResponsiveCheckbox: {
        display: "flex",
        alignItems: "center",
        padding: intermediateCheckboxPadding,
        [mediaQueries$1.smOrSmaller]: {
          padding: intermediateCheckboxPaddingPhone
        }
      },
      intermediateResponsiveCheckboxReview: {
        alignItems: 'flex-start'
      },
      crossOutLink: {
        textAlign: "right",
        alignSelf: "center",
        width: 100
      }
    })
  },
  getDefaultProps: function getDefaultProps() {
    return {
      checked: false,
      classSet: {},
      disabled: false,
      editMode: false,
      showRationale: false,
      type: "radio",
      pos: 0
    };
  },
  getInitialState: function getInitialState() {
    return {
      isInputFocused: false,
      isInputActive: false
    };
  },

  componentWillUpdate(nextProps) {
    if (this.state.isInputFocused && nextProps.disabled) {
      this.setState({
        isInputFocused: false
      });
    }
  },

  onInputFocus: function onInputFocus() {
    this.setState({
      isInputFocused: true
    });
  },
  onInputBlur: function onInputBlur() {
    this.setState({
      isInputFocused: false
    });
  },
  onInputMouseDown: function onInputMouseDown(e) {
    if (e.type === "mousedown" && this.justFinishedTouch) {
      return;
    }

    this.setState({
      isInputActive: true
    }); // Simulate Chrome's radio button behavior in all browsers: when the
    // mouse goes down or up, the radio button should become focused.
    // That way, the newly-selected answer becomes highlighted after click.

    if (this.props.apiOptions.satStyling && this._input) {
      this._input.focus();
    }
  },
  onInputMouseUp: function onInputMouseUp(e) {
    if (e.type === "mouseup" && this.justFinishedTouch) {
      return;
    } // NOTE(emily): We do some special handling here of touch events to
    // make the "active" effect look better. In particular, when you click
    // using touch events, we get a series of events going
    // touchstart -> (delay) -> touchend -> mousedown -> mouseup -> click
    // In order to make sure that we don't turn the active state of and on
    // and off again during the touchend -> mousedown -> mouseup series, we
    // set a flag (this.justFinishedTouch) after the touchend, and ignore
    // the mousedown and mouseup events. Then, a little while later, we
    // turn the flag off. Instead of turning the active state off right at
    // the beginning, we wait for a little bit to sync it up better with
    // the click event.


    if (e.type === "touchend") {
      this.justFinishedTouch = true;
      setTimeout(() => {
        this.setState({
          isInputActive: false
        });
        this.justFinishedTouch = false;
      }, 10);
      return;
    }

    this.setState({
      isInputActive: false
    }); // Simulate Chrome's radio button behavior in all browsers: when the
    // mouse goes down or up, the radio button should become focused.
    // That way, the newly-selected answer becomes highlighted after click.

    if (this.props.apiOptions.satStyling && this._input) {
      this._input.focus();
    }
  },
  onInputMouseOut: function onInputMouseOut() {
    this.setState({
      isInputActive: false
    });
  },
  inputRef: function inputRef(ref) {
    this._input = ref;
  },

  renderOptionStatus() {
    var {
      correct,
      checked,
      reviewMode
    } = this.props; // Option status is shown only in review mode, and excluded for SAT

    if (!reviewMode || this.props.apiOptions.satStyling) {
      return;
    }

    return /*#__PURE__*/React$4.createElement(OptionStatus, {
      checked: checked,
      correct: correct
    });
  },

  renderChoiceIcon() {
    var {
      radioStyleVersion,
      primaryProductColor
    } = this.props.apiOptions.styling;
    var finalStyles = typeof radioStyleVersion === "undefined" ? false : radioStyleVersion === "final";

    if (!finalStyles && !this.props.apiOptions.satStyling) {
      return null;
    }

    return /*#__PURE__*/React$4.createElement(ChoiceIcon, {
      pos: this.props.pos,
      correct: this.props.correct,
      pressed: this.state.isInputActive,
      focused: this.state.isInputFocused,
      checked: this.props.checked,
      showCorrectness: this.props.showCorrectness,
      reviewMode: this.props.reviewMode,
      product: this.props.apiOptions.satStyling ? "sat" : "library",
      primaryProductColor: primaryProductColor
    });
  },

  // NOTE(mdr): This method expects to be auto-bound. If this component is
  //     converted to an ES6 class, take care to auto-bind this method!
  _toggleCrossOut: function _toggleCrossOut() {
    var willBeCrossedOut = !this.props.crossedOut;

    if (willBeCrossedOut) {
      // If we're crossing out a checked option, let's also uncheck it.
      this._sendChange({
        checked: false,
        crossedOut: true
      });
    } else {
      this._sendChange({
        crossedOut: false
      });
    }
  },
  // Call `this.props.onChange` with the given values. Any keys that are not
  // specified will be filled in with the current value. (For example, if
  // `checked` is specified but `crossedOut` is not, then `crossedOut` will
  // be filled in with `this.props.crossedOut`.)
  //
  // This enables us to use shorthand inside this component, while
  // maintaining a consistent API for the parent.
  _sendChange: function _sendChange(newValues) {
    var checked = newValues.checked != null ? newValues.checked : this.props.checked;
    var crossedOut = newValues.crossedOut != null ? newValues.crossedOut : this.props.crossedOut;
    this.props.onChange({
      checked,
      crossedOut
    });
  },
  render: function render() {
    var styles = Choice$1.styles;
    var sat = this.props.apiOptions.satStyling;
    var isMobile = this.props.apiOptions.isMobile;
    var {
      radioStyleVersion
    } = this.props.apiOptions.styling;
    var finalStyles = typeof radioStyleVersion === "undefined" ? false : radioStyleVersion === "final";
    var className = classNames$1(this.props.className, "checkbox-label", aphrodite.css(styles.label, isMobile && sharedStyles$1.disableTextSelection, !sat && styles.responsiveLabel, sat && styles.satLabel)); // There's two different input components we could use (the builtin
    // input component, or the ToggleableRadioButton component). These are
    // the props that we will pass to either.

    var commonInputProps = {
      type: this.props.type,
      name: this.props.groupName,
      id: "".concat(this.props.groupName, "-choice-").concat(this.props.pos),
      checked: this.props.checked,
      disabled: this.props.disabled,
      onFocus: this.onInputFocus,
      onBlur: this.onInputBlur,
      className: aphrodite.css( // intermediate styles are not different for radio and
      // checkbox, and have a separate active state.
      !finalStyles && sharedStyles$1.perseusInteractive, !finalStyles && styles.input, !finalStyles && sharedStyles$1.responsiveInput, !finalStyles && !sat && sharedStyles$1.responsiveRadioInput, !finalStyles && !sat && this.state.isInputActive && sharedStyles$1.responsiveRadioInputActive, finalStyles && sharedStyles$1.perseusSrOnly, sat && sharedStyles$1.perseusSrOnly, sat && this.props.reviewMode && styles.satReviewInput)
    };
    var input = null;

    if (this.props.type === "radio") {
      // This is a special radio button that allows a user to deselect
      // it by merely clicking/selecting it again.
      input = /*#__PURE__*/React$4.createElement(ToggleableRadioButton, _extends({
        onChecked: willBeChecked => {
          this._sendChange({
            checked: willBeChecked
          });
        },
        inputRef: this.inputRef
      }, commonInputProps));
    } else {
      input = /*#__PURE__*/React$4.createElement("input", _extends({
        onChange: event => {
          this._sendChange({
            checked: event.target.checked
          });
        },
        ref: this.inputRef
      }, commonInputProps));
    }

    var {
      reviewMode,
      correct,
      checked,
      isLastChoice
    } = this.props; // HACK: while most of the styling for rendering SAT items is handled
    // via aphrodite, we also need to assign normal CSS classnames here to
    // special-case the coloring of MathJax formulas (see .MathJax .math in
    // stylesheets/task-package/tasks.less)

    var satCorrectChoice = sat && reviewMode && correct;
    var satIncorrectChecked = sat && reviewMode && !correct && checked;
    var descriptionClassName = classNames$1("description", satCorrectChoice && "sat-correct", satIncorrectChecked && "sat-incorrect", aphrodite.css(!sat && styles.description, sat && this.state.isInputFocused && styles.satDescriptionInputFocused, sat && this.state.isInputActive && styles.satDescriptionInputActive, sat && styles.satDescription, satCorrectChoice && styles.satDescriptionCorrect, satCorrectChoice && checked && styles.satDescriptionCorrectChecked, satIncorrectChecked && styles.satDescriptionIncorrectChecked, sat && isLastChoice && styles.satDescriptionLastChoice));
    var checkboxContentClassName = classNames$1("checkbox", aphrodite.css(sharedStyles$1.perseusInteractive, !sat && styles.choiceIconWrapper, sat && styles.satCheckboxOptionContent));
    var checkboxAndOptionClassName = classNames$1("checkbox-and-option", aphrodite.css(!sat && styles.intermediateResponsiveCheckbox, !sat && reviewMode && styles.intermediateResponsiveCheckboxReview));
    var rationaleClassName = classNames$1("perseus-radio-rationale-content", aphrodite.css(styles.rationale, !sat && styles.nonSatRationale, sat && styles.satReviewRationale)); // In edit mode, we must allow selection of the contentEditable
    // element inside, therefore we cannot use a label, which makes
    // selection of anything inside automatically select the input
    // element instead

    var LabelOrDiv = this.props.editMode ? "div" : "label";
    var showCrossOut = !this.props.showCorrectness && !sat && // HACK(mdr): This should go behind a real flag; this is just a
    //     quick hack so I can ship this code for review (and maybe
    //     land before the Nov 2017 TSM) before overcommitting to arch.
    //     https://app.asana.com/0/329800276300868/467694510751339
    document.location.href.indexOf("PERSEUS-HACK-SHOW-CROSS-OUT") >= 0; // We want to show the choices as dimmed out when the choices are
    // disabled. However, we don't want to do this in the SAT product and
    // we also don't want to do this when we're in review mode in the
    // content library.

    var showDimmed = !sat && !reviewMode && this.props.apiOptions.readOnly || // HACK(mdr): This is a temporary way of showing the crossedOut
    //     state. Eventually, we'll have custom visuals for this state,
    //     at which point we'll remove this condition.
    //     https://app.asana.com/0/329800276300868/467694510751336
    showCrossOut && this.props.crossedOut;
    return /*#__PURE__*/React$4.createElement(LabelOrDiv, {
      htmlFor: !this.props.editMode && commonInputProps.id,
      className: className,
      style: {
        opacity: showDimmed ? 0.5 : 1.0
      }
    }, /*#__PURE__*/React$4.createElement("div", {
      className: descriptionClassName,
      onMouseDown: this.onInputMouseDown,
      onMouseUp: this.onInputMouseUp,
      onMouseOut: this.onInputMouseOut,
      onTouchStart: this.onInputMouseDown,
      onTouchEnd: this.onInputMouseUp
    }, /*#__PURE__*/React$4.createElement("div", {
      className: checkboxAndOptionClassName
    }, /*#__PURE__*/React$4.createElement("span", {
      className: checkboxContentClassName
    }, input, this.renderChoiceIcon()), /*#__PURE__*/React$4.createElement("span", {
      className: classNames$1(ClassNames.RADIO.OPTION_CONTENT, ClassNames.INTERACTIVE, aphrodite.css(sat && styles.satRadioOptionContent, sat && reviewMode && styles.satReviewRadioOptionContent)),
      style: {
        cursor: "default"
      }
    }, /*#__PURE__*/React$4.createElement("div", {
      className: aphrodite.css(styles.optionStatusContainer)
    }, this.renderOptionStatus()), /*#__PURE__*/React$4.createElement("div", null, this.props.content))), this.props.showRationale && /*#__PURE__*/React$4.createElement("div", {
      className: rationaleClassName
    }, this.props.rationale)), showCrossOut && /*#__PURE__*/React$4.createElement("a", {
      href: "javascript:void 0",
      onClick: this._toggleCrossOut,
      className: aphrodite.css(styles.crossOutLink)
    }, this.props.crossedOut ? i18n.i18nDoNotTranslate("Uncross out") : i18n.i18nDoNotTranslate("Cross out")));
  }
});
_module_$5.exports = Choice$1;
var _choiceJsx = _module_$5.exports;

var _module_$4 = {
  exports: {}
};
var classNames = _classnames__default["default"];
var React$3 = _react__default["default"];
var ReactDOM = _reactDom__default["default"];
var _$3 = _underscore__default["default"];
var ApiClassNames = _perseusApiJsx.ClassNames;
var Renderer$2 = _rendererJsx;
var sharedStyles = _stylesSharedJs;
var mediaQueries = _stylesMediaQueriesJs;
var captureScratchpadTouchStart = Util$q.captureScratchpadTouchStart;
var Choice = _choiceJsx;
var ChoiceNoneAbove = createReactClass({
  displayName: "ChoiceNoneAbove",
  propTypes: {
    className: PropTypes.string,
    content: PropTypes.node,
    showContent: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      showContent: true
    };
  },
  render: function render() {
    var choiceProps = _$3.extend({}, this.props, {
      className: classNames(this.props.className, "none-of-above"),
      content: this.props.showContent ? this.props.content :
      /*#__PURE__*/
      // We use a Renderer here because that is how
      // `this.props.content` is wrapped otherwise.
      // We pass in a key here so that we avoid a semi-spurious
      // react warning when we render this in the same place
      // as the previous choice content renderer.
      // Note this destroys state, but since all we're doing
      // is outputting "None of the above", that is okay.
      React$3.createElement(Renderer$2, {
        key: "noneOfTheAboveRenderer",
        content: i18n._("None of the above")
      })
    });

    return /*#__PURE__*/React$3.createElement(Choice, choiceProps);
  }
});
var ChoicesType = PropTypes.arrayOf(PropTypes.shape({
  // Indicates whether this choice is checked.
  checked: PropTypes.bool,
  // Indicates whether the user has "crossed out" this choice, meaning
  // that they don't think it's correct. This value does not affect
  // scoring or other behavior; it's just a note for the user's
  // reference.
  crossedOut: PropTypes.bool,
  content: PropTypes.node,
  rationale: PropTypes.node,
  hasRationale: PropTypes.bool,
  showRationale: PropTypes.bool,
  showCorrectness: PropTypes.bool,
  correct: PropTypes.bool,
  originalIndex: PropTypes.number,
  isNoneOfTheAbove: PropTypes.bool
}));
var radioBorderColor = radioBorderColor$1;
var BaseRadio$2 = createReactClass({
  displayName: "BaseRadio",
  propTypes: {
    apiOptions: PropTypes.shape({
      readOnly: PropTypes.bool,
      satStyling: PropTypes.bool,
      isMobile: PropTypes.bool,
      styling: PropTypes.shape({
        radioStyleVersion: PropTypes.oneOf(["intermediate", "final"])
      })
    }),
    choices: ChoicesType,
    deselectEnabled: PropTypes.bool,
    editMode: PropTypes.bool,
    labelWrap: PropTypes.bool,
    countChoices: PropTypes.bool,
    numCorrect: PropTypes.number,
    multipleSelect: PropTypes.bool,
    reviewModeRubric: PropTypes.shape({
      choices: ChoicesType
    }),
    // A callback indicating that this choice has changed. Its argument is
    // an object with two keys: `checked` and `crossedOut`. Each contains
    // an array of boolean values, specifying the new checked and
    // crossed-out value of each choice.
    onChange: PropTypes.func
  },
  statics: {
    styles: aphrodite.StyleSheet.create({
      instructions: {
        display: "block",
        color: gray17,
        fontSize: 14,
        lineHeight: 1.25,
        fontStyle: "normal",
        fontWeight: "bold",
        marginBottom: 16
      },
      instructionsMobile: {
        fontSize: 18,
        [mediaQueries.smOrSmaller]: {
          fontSize: 16
        },
        // TODO(emily): We want this to match choice text, which turns
        // to 20px at min-width 1200px, but this media query is
        // min-width 1280px because our media queries don't exactly
        // match pure. Make those match up.
        [mediaQueries.xl]: {
          fontSize: 20
        }
      },
      radio: {
        // Avoid centering
        width: "100%"
      },
      responsiveRadioContainer: {
        borderBottom: "1px solid ".concat(radioBorderColor),
        borderTop: "1px solid ".concat(radioBorderColor),
        width: "auto",
        [mediaQueries.smOrSmaller]: {
          marginLeft: negativePhoneMargin,
          marginRight: negativePhoneMargin
        }
      },
      radioContainerFirstHighlighted: {
        borderTop: "1px solid rgba(0, 0, 0, 0)"
      },
      radioContainerLastHighlighted: {
        borderBottom: "1px solid rgba(0, 0, 0, 0)"
      },
      satRadio: {
        background: "none",
        marginLeft: 0,
        userSelect: "none"
      },
      satRadioOption: {
        margin: 0,
        padding: 0,
        borderBottom: "1px solid #ccc",
        ":first-child": {
          borderTop: "1px solid #ccc"
        }
      },
      satRadioOptionCorrect: {
        borderBottomColor: satCorrectBorderColor,
        ":first-child": {
          borderTopColor: satCorrectBorderColor
        }
      },
      satRadioOptionIncorrect: {
        borderBottomColor: satIncorrectBorderColor,
        ":first-child": {
          borderTopColor: satIncorrectBorderColor
        }
      },
      satRadioOptionNextCorrect: {
        borderBottomColor: satCorrectBorderColor
      },
      satRadioOptionNextIncorrect: {
        borderBottomColor: satIncorrectBorderColor
      },
      satReviewRadioOption: {
        pointerEvents: "none"
      },
      item: {
        marginLeft: 20
      },
      inlineItem: {
        display: "inline-block",
        paddingLeft: 20,
        verticalAlign: "middle" // See http://stackoverflow.com/q/8120466 for explanation of
        // why vertical align property is needed

      },
      responsiveItem: {
        marginLeft: 0,
        padding: 0,
        ":not(:last-child)": {
          borderBottom: "1px solid ".concat(radioBorderColor)
        }
      },
      selectedItem: {
        background: "white"
      },
      aboveBackdrop: {
        position: "relative",
        // HACK(emily): We want selected choices to show up above our
        // exercise backdrop, but below the exercise footer and
        // "feedback popover" that shows up. This z-index is carefully
        // coordinated between here and webapp. :(
        zIndex: 1062
      },
      aboveBackdropMobile: {
        boxShadow: "0 0 4px 0 rgba(0, 0, 0, 0.2)," + "0 0 2px 0 rgba(0, 0, 0, 0.1)",
        ":not(:last-child)": {
          borderBottom: "1px solid rgba(0, 0, 0, 0)"
        }
      },
      nextHighlighted: {
        ":not(:last-child)": {
          borderBottom: "1px solid rgba(0, 0, 0, 0)"
        }
      },
      responsiveContainer: {
        overflow: "auto",
        marginLeft: negativePhoneMargin,
        marginRight: negativePhoneMargin,
        paddingLeft: phoneMargin // paddingRight is handled by responsiveFieldset

      },
      responsiveFieldset: {
        paddingRight: phoneMargin
      }
    })
  },
  getDefaultProps: function getDefaultProps() {
    return {
      editMode: false
    };
  },
  getInitialState: function getInitialState() {
    return {
      // TODO(mdr): This keeps the ID stable across re-renders on the
      //     same machine, but, at time of writing, the server's state
      //     isn't rehydrated to the client during SSR, so the server and
      //     client will generate different IDs and cause a mismatch
      //     during SSR :(
      radioGroupName: _$3.uniqueId("perseus_radio_")
    };
  },
  // When a particular choice's `onChange` handler is called, indicating a
  // change in a single choice's values, we need to call our `onChange`
  // handler in order to notify our parent. However, our API with our parent
  // is that we always provide *all* values for *all* choices, even if just
  // one choice's values changed. (This is because sometimes an interaction
  // with one choice can affect many choices, like how checking a new answer
  // will usually cause the old answer to become unchecked.)
  //
  // So, given the new values for a particular choice, compute the new values
  // for all choices, and pass them to `this.props.onChange`.
  //
  // `newValues` is an object with two keys: `checked` and `crossedOut`. Each
  // contains a boolean value specifying the new checked and crossed-out
  // value of this choice.
  updateChoice: function updateChoice(choiceIndex, newValues) {
    // Get the baseline `checked` values. If we're checking a new answer
    // and multiple-select is not on, we should clear all choices to be
    // unchecked. Otherwise, we should copy the old checked values.
    var newCheckedList;

    if (newValues.checked && !this.props.multipleSelect) {
      newCheckedList = this.props.choices.map(_ => false);
    } else {
      newCheckedList = this.props.choices.map(c => c.checked);
    } // Get the baseline `crossedOut` values.


    var newCrossedOutList = this.props.choices.map(c => c.crossedOut); // Update this choice's `checked` and `crossedOut` values.

    newCheckedList[choiceIndex] = newValues.checked;
    newCrossedOutList[choiceIndex] = newValues.crossedOut;
    this.props.onChange({
      checked: newCheckedList,
      crossedOut: newCrossedOutList
    });
  },
  focus: function focus(i) {
    ReactDOM.findDOMNode(this.refs["radio" + (i || 0)]).focus();
    return true;
  },
  getInstructionsText: function getInstructionsText() {
    if (this.props.multipleSelect) {
      if (this.props.countChoices) {
        return i18n._("Choose %(numCorrect)s answers:", {
          numCorrect: this.props.numCorrect
        });
      } else {
        return i18n._("Choose all answers that apply:");
      }
    } else {
      return i18n._("Choose 1 answer:");
    }
  },
  deselectEnabled: function deselectEnabled() {
    // We want to force enable deselect on mobile.
    return this.props.apiOptions.isMobile || this.props.deselectEnabled;
  },
  render: function render() {
    var inputType = this.props.multipleSelect ? "checkbox" : "radio";
    var rubric = this.props.reviewModeRubric;
    var reviewMode = !!rubric;
    var styles = BaseRadio$2.styles;
    var sat = this.props.apiOptions.satStyling;
    var isMobile = this.props.apiOptions.isMobile;
    var choices = this.props.choices;
    var firstChoiceHighlighted = choices[0].highlighted;
    var lastChoiceHighlighted = choices[choices.length - 1].highlighted;
    var className = classNames("perseus-widget-radio", !this.props.editMode && "perseus-rendered-radio", aphrodite.css(styles.radio, // SAT doesn't use the "responsive styling" as it conflicts
    // with their custom theming.
    !sat && styles.responsiveRadioContainer, !sat && firstChoiceHighlighted && isMobile && styles.radioContainerFirstHighlighted, !sat && lastChoiceHighlighted && isMobile && styles.radioContainerLastHighlighted, sat && styles.satRadio));
    var instructionsClassName = classNames("instructions", aphrodite.css(styles.instructions, isMobile && styles.instructionsMobile));
    var instructions = this.getInstructionsText();
    var shouldShowInstructions = !sat;
    var responsiveClassName = aphrodite.css(styles.responsiveFieldset);
    var fieldset = /*#__PURE__*/React$3.createElement("fieldset", {
      className: "perseus-widget-radio-fieldset ".concat(responsiveClassName) // eslint-disable-line max-len

    }, /*#__PURE__*/React$3.createElement("legend", {
      className: "perseus-sr-only"
    }, instructions), shouldShowInstructions && /*#__PURE__*/React$3.createElement("div", {
      className: instructionsClassName
    }, instructions), /*#__PURE__*/React$3.createElement("ul", {
      className: className
    }, this.props.choices.map(function (choice, i) {
      var Element = Choice;
      var elementProps = {
        ref: "radio".concat(i),
        apiOptions: this.props.apiOptions,
        checked: choice.checked,
        crossedOut: choice.crossedOut,
        reviewMode,
        correct: choice.correct,
        rationale: choice.rationale,
        content: choice.content,
        disabled: this.props.apiOptions.readOnly || choice.disabled,
        editMode: this.props.editMode,
        groupName: this.state.radioGroupName,
        isLastChoice: i === this.props.choices.length - 1,
        showCorrectness: reviewMode || !!choice.showCorrectness,
        showRationale: choice.hasRationale && (reviewMode || choice.showRationale),
        type: inputType,
        pos: i,
        deselectEnabled: this.deselectEnabled(),
        onChange: newValues => {
          this.updateChoice(i, newValues);
        }
      };

      if (choice.isNoneOfTheAbove) {
        Element = ChoiceNoneAbove;

        _$3.extend(elementProps, {
          showContent: choice.revealNoneOfTheAbove
        });
      }

      var nextChoice = this.props.choices[i + 1];
      var nextChoiceHighlighted = !!nextChoice && nextChoice.highlighted;

      var aphroditeClassName = checked => {
        // Whether or not to show correctness borders
        // for this choice and the next choice.
        var satShowCorrectness = sat && reviewMode && checked;
        var satShowCorrectnessNext = sat && reviewMode && nextChoice && nextChoice.checked;
        return aphrodite.css(sharedStyles.aboveScratchpad, styles.item, !sat && styles.responsiveItem, !sat && checked && styles.selectedItem, !sat && checked && choice.highlighted && styles.aboveBackdrop, !sat && checked && choice.highlighted && this.props.apiOptions.isMobile && styles.aboveBackdropMobile, !sat && nextChoiceHighlighted && this.props.apiOptions.isMobile && styles.nextHighlighted, sat && styles.satRadioOption, satShowCorrectness && !choice.correct && styles.satRadioOptionIncorrect, satShowCorrectness && choice.correct && styles.satRadioOptionCorrect, satShowCorrectnessNext && !nextChoice.correct && styles.satRadioOptionNextIncorrect, satShowCorrectnessNext && nextChoice.correct && styles.satRadioOptionNextCorrect, sat && rubric && styles.satReviewRadioOption);
      }; // HACK(abdulrahman): Preloads the selection-state
      // css because of a bug that causes iOS to lag
      // when selecting the button for the first time.


      aphroditeClassName(true);
      var className = classNames(aphroditeClassName(choice.checked), // TODO(aria): Make test case for these API
      // classNames
      ApiClassNames.RADIO.OPTION, choice.checked && ApiClassNames.RADIO.SELECTED, reviewMode && rubric.choices[i].correct && ApiClassNames.CORRECT, reviewMode && !rubric.choices[i].correct && ApiClassNames.INCORRECT); // In edit mode, the Choice renders a Div in order to
      // allow for the contentEditable area to be selected
      // (label forces any clicks inside to select the input
      // element) We have to add some extra behavior to make
      // sure that we can still check the choice.

      var listElem = null;
      var clickHandler = null;

      if (this.props.editMode) {
        clickHandler = e => {
          // Traverse the parent nodes of the clicked
          // element.
          var elem = e.target;

          while (elem && elem !== listElem) {
            // If the clicked element is inside of the
            // radio icon, then we want to trigger the
            // check by flipping the choice of the icon.
            if (elem.getAttribute("data-is-radio-icon")) {
              this.updateChoice(i, {
                checked: !choice.checked
              });
              return;
            }

            elem = elem.parentNode;
          }
        };
      } // TODO(mattdr): Index isn't a *good* choice of key
      // here; is there a better one? Can we use choice
      // content somehow? Would changing our choice of key
      // somehow break something happening inside a choice's
      // child Renderers, by changing when we mount/unmount?


      return /*#__PURE__*/React$3.createElement("li", {
        key: i,
        ref: e => listElem = e,
        className: className,
        onClick: clickHandler,
        onTouchStart: !this.props.labelWrap ? null : captureScratchpadTouchStart
      }, /*#__PURE__*/React$3.createElement(Element, elementProps));
    }, this))); // Allow for horizontal scrolling if content is too wide, which may be
    // an issue especially on phones.
    // This is disabled in SAT, since it conflicts with their theming.

    return /*#__PURE__*/React$3.createElement("div", {
      className: aphrodite.css(!sat && styles.responsiveContainer)
    }, fieldset);
  }
});
_module_$4.exports = BaseRadio$2;
var _baseRadioJsx = _module_$4.exports;

var _module_$3 = {
  exports: {}
};
/* eslint-disable comma-dangle, indent, no-undef, no-var, object-curly-spacing, react/forbid-prop-types, react/jsx-closing-bracket-location, react/jsx-indent-props, react/sort-comp */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var React$2 = _react__default["default"];
var _$2 = _underscore__default["default"];
var ApiOptions = _perseusApiJsx.Options;
var BaseRadio$1 = _baseRadioJsx;
var Changeable = Changeable$Q;
var Editor = _editorJsx;
var InlineIcon = _componentsInlineIconJsx;
var PropCheckBox = _componentsPropCheckBoxJsx;
var ChoiceEditor = createReactClass({
  displayName: "ChoiceEditor",
  propTypes: {
    apiOptions: ApiOptions.propTypes,
    choice: PropTypes.object,
    showDelete: PropTypes.bool,
    onClueChange: PropTypes.func,
    onContentChange: PropTypes.func,
    onDelete: PropTypes.func
  },
  render: function render() {
    var checkedClass = this.props.choice.correct ? "correct" : "incorrect";
    var placeholder = "Type a choice here...";

    if (this.props.choice.isNoneOfTheAbove) {
      placeholder = this.props.choice.correct ? "Type the answer to reveal to the user..." : "None of the above";
    }

    var editor = /*#__PURE__*/React$2.createElement(Editor, {
      ref: "content-editor",
      apiOptions: this.props.apiOptions,
      content: this.props.choice.content || "",
      widgetEnabled: false,
      placeholder: placeholder,
      disabled: this.props.choice.isNoneOfTheAbove && !this.props.choice.correct,
      onChange: this.props.onContentChange
    });
    var clueEditor = /*#__PURE__*/React$2.createElement(Editor, {
      ref: "clue-editor",
      apiOptions: this.props.apiOptions,
      content: this.props.choice.clue || "",
      widgetEnabled: false,
      placeholder: i18n._("Why is this choice ".concat(checkedClass, "?")),
      onChange: this.props.onClueChange
    });
    var deleteLink = /*#__PURE__*/React$2.createElement("a", {
      className: "simple-button orange delete-choice",
      href: "#",
      onClick: this.props.onDelete,
      title: "Remove this choice"
    }, /*#__PURE__*/React$2.createElement(InlineIcon, iconTrash));
    return /*#__PURE__*/React$2.createElement("div", {
      className: "choice-clue-editors"
    }, /*#__PURE__*/React$2.createElement("div", {
      className: "choice-editor ".concat(checkedClass)
    }, editor), /*#__PURE__*/React$2.createElement("div", {
      className: "clue-editor"
    }, clueEditor), this.props.showDelete && deleteLink);
  }
});
var RadioEditor = createReactClass({
  displayName: "RadioEditor",
  propTypes: _objectSpread2(_objectSpread2({}, Changeable.propTypes), {}, {
    apiOptions: ApiOptions.propTypes,
    choices: PropTypes.arrayOf(PropTypes.shape({
      content: PropTypes.string,
      clue: PropTypes.string,
      correct: PropTypes.bool
    })),
    displayCount: PropTypes.number,
    randomize: PropTypes.bool,
    hasNoneOfTheAbove: PropTypes.bool,
    multipleSelect: PropTypes.bool,
    countChoices: PropTypes.bool,
    // TODO(kevinb): DEPRECATED: This is be used to force deselectEnabled
    // behavior on mobile but not on desktop.  When enabled, the user can
    // deselect a radio input by tapping on it again.
    deselectEnabled: PropTypes.bool,
    static: PropTypes.bool
  }),
  getDefaultProps: function getDefaultProps() {
    return {
      choices: [{}, {}],
      displayCount: null,
      randomize: false,
      hasNoneOfTheAbove: false,
      multipleSelect: false,
      countChoices: false,
      deselectEnabled: false
    };
  },
  render: function render() {
    var numCorrect = _$2.reduce(this.props.choices, function (memo, choice) {
      return choice.correct ? memo + 1 : memo;
    }, 0);

    return /*#__PURE__*/React$2.createElement("div", null, /*#__PURE__*/React$2.createElement("div", {
      className: "perseus-widget-row"
    }, /*#__PURE__*/React$2.createElement("a", {
      href: "https://docs.google.com/document/d/1frZf7yrWVWb1n4tVjqlzqVUiv1pn4cZXbxgP62-JDBY/edit#heading=h.8ng1isya19nu",
      target: "_blank"
    }, "Multiple choice style guide"), /*#__PURE__*/React$2.createElement("br", null), /*#__PURE__*/React$2.createElement("div", {
      className: "perseus-widget-left-col"
    }, /*#__PURE__*/React$2.createElement(PropCheckBox, {
      label: "Multiple selections",
      labelAlignment: "right",
      multipleSelect: this.props.multipleSelect,
      onChange: this.onMultipleSelectChange
    })), /*#__PURE__*/React$2.createElement("div", {
      className: "perseus-widget-right-col"
    }, /*#__PURE__*/React$2.createElement(PropCheckBox, {
      label: "Randomize order",
      labelAlignment: "right",
      randomize: this.props.randomize,
      onChange: this.props.onChange
    })), this.props.multipleSelect && /*#__PURE__*/React$2.createElement("div", {
      className: "perseus-widget-left-col"
    }, /*#__PURE__*/React$2.createElement(PropCheckBox, {
      label: "Specify number correct",
      labelAlignment: "right",
      countChoices: this.props.countChoices,
      onChange: this.onCountChoicesChange
    }))), /*#__PURE__*/React$2.createElement(BaseRadio$1, {
      ref: "baseRadio",
      multipleSelect: this.props.multipleSelect,
      countChoices: this.props.countChoices,
      numCorrect: numCorrect,
      editMode: true,
      labelWrap: false,
      apiOptions: this.props.apiOptions,
      choices: this.props.choices.map(function (choice, i) {
        return {
          content: /*#__PURE__*/React$2.createElement(ChoiceEditor, {
            ref: "choice-editor".concat(i),
            apiOptions: this.props.apiOptions,
            choice: choice,
            onContentChange: newProps => {
              if ("content" in newProps) {
                this.onContentChange(i, newProps.content);
              }
            },
            onClueChange: newProps => {
              if ("content" in newProps) {
                this.onClueChange(i, newProps.content);
              }
            },
            onDelete: this.onDelete.bind(this, i),
            showDelete: this.props.choices.length >= 2
          }),
          isNoneOfTheAbove: choice.isNoneOfTheAbove,
          checked: choice.correct
        };
      }, this),
      onChange: this.onChange
    }), /*#__PURE__*/React$2.createElement("div", {
      className: "add-choice-container"
    }, /*#__PURE__*/React$2.createElement("a", {
      className: "simple-button orange",
      href: "#",
      onClick: this.addChoice.bind(this, false)
    }, /*#__PURE__*/React$2.createElement(InlineIcon, iconPlus), " Add a choice", " "), !this.props.hasNoneOfTheAbove && /*#__PURE__*/React$2.createElement("a", {
      className: "simple-button",
      href: "#",
      onClick: this.addChoice.bind(this, true)
    }, /*#__PURE__*/React$2.createElement(InlineIcon, iconPlus), " None of the above", " ")));
  },

  change() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Changeable.change.apply(this, args);
  },

  onMultipleSelectChange: function onMultipleSelectChange(allowMultiple) {
    allowMultiple = allowMultiple.multipleSelect;

    var numCorrect = _$2.reduce(this.props.choices, function (memo, choice) {
      return choice.correct ? memo + 1 : memo;
    }, 0);

    if (!allowMultiple && numCorrect > 1) {
      var choices = _$2.map(this.props.choices, function (choice) {
        return _$2.defaults({
          correct: false
        }, choice);
      });

      this.props.onChange({
        multipleSelect: allowMultiple,
        choices: choices
      });
    } else {
      this.props.onChange({
        multipleSelect: allowMultiple
      });
    }
  },
  onCountChoicesChange: function onCountChoicesChange(count) {
    count = count.countChoices;
    this.props.onChange({
      countChoices: count
    });
  },
  onChange: function onChange(_ref) {
    var {
      checked
    } = _ref;

    var choices = _$2.map(this.props.choices, (choice, i) => {
      return _$2.extend({}, choice, {
        correct: checked[i],
        content: choice.isNoneOfTheAbove && !checked[i] ? "" : choice.content
      });
    });

    this.props.onChange({
      choices: choices
    });
  },
  onContentChange: function onContentChange(choiceIndex, newContent) {
    var choices = this.props.choices.slice();
    choices[choiceIndex] = _$2.extend({}, choices[choiceIndex], {
      content: newContent
    });
    this.props.onChange({
      choices: choices
    });
  },
  onClueChange: function onClueChange(choiceIndex, newClue) {
    var choices = this.props.choices.slice();
    choices[choiceIndex] = _$2.extend({}, choices[choiceIndex], {
      clue: newClue
    });

    if (newClue === "") {
      delete choices[choiceIndex].clue;
    }

    this.props.onChange({
      choices: choices
    });
  },
  onDelete: function onDelete(choiceIndex, e) {
    e.preventDefault();
    var choices = this.props.choices.slice();
    var deleted = choices[choiceIndex];
    choices.splice(choiceIndex, 1);
    this.props.onChange({
      choices: choices,
      hasNoneOfTheAbove: this.props.hasNoneOfTheAbove && !deleted.isNoneOfTheAbove
    });
  },
  addChoice: function addChoice(noneOfTheAbove, e) {
    e.preventDefault();
    var choices = this.props.choices.slice();
    var newChoice = {
      isNoneOfTheAbove: noneOfTheAbove
    };
    var addIndex = choices.length - (this.props.hasNoneOfTheAbove ? 1 : 0);
    choices.splice(addIndex, 0, newChoice);
    this.props.onChange({
      choices: choices,
      hasNoneOfTheAbove: noneOfTheAbove || this.props.hasNoneOfTheAbove
    }, () => {
      this.refs["choice-editor".concat(addIndex)].refs["content-editor"].focus();
    });
  },
  setDisplayCount: function setDisplayCount(num) {
    this.props.onChange({
      displayCount: num
    });
  },
  focus: function focus() {
    this.refs["choice-editor0"].refs["content-editor"].focus();
    return true;
  },
  getSaveWarnings: function getSaveWarnings() {
    if (!_$2.some(_$2.pluck(this.props.choices, "correct"))) {
      return ["No choice is marked as correct."];
    }

    return [];
  },
  serialize: function serialize() {
    return _$2.pick(this.props, "choices", "randomize", "multipleSelect", "countChoices", "displayCount", "hasNoneOfTheAbove", "deselectEnabled");
  }
});
_module_$3.exports = RadioEditor;
var _widgetsRadioEditorJsx = _module_$3.exports;

var _module_$2 = {
  exports: {}
};
/* global i18n */

var React$1 = _react__default["default"];
var _$1 = _underscore__default["default"];
var Renderer$1 = _rendererJsx;
var PassageRef = _passageRefJsx;
var Util = Util$q;
var BaseRadio = _baseRadioJsx;
var Radio$1 = createReactClass({
  displayName: "Radio",
  propTypes: {
    apiOptions: BaseRadio.propTypes.apiOptions,
    choices: PropTypes.arrayOf(PropTypes.shape({
      content: PropTypes.string.isRequired,
      // Clues are called "rationales" in most other places but are
      // left as "clue"s here to preserve legacy widget data.
      clue: PropTypes.string,
      correct: PropTypes.bool,
      isNoneOfTheAbove: PropTypes.bool,
      originalIndex: PropTypes.number.isRequired
    }).isRequired).isRequired,
    deselectEnabled: PropTypes.bool,
    displayCount: PropTypes.any,
    findWidgets: PropTypes.func,
    multipleSelect: PropTypes.bool,
    countChoices: PropTypes.bool,
    numCorrect: PropTypes.number,
    onChange: PropTypes.func.isRequired,
    questionCompleted: PropTypes.bool,
    reviewModeRubric: BaseRadio.propTypes.reviewModeRubric,
    trackInteraction: PropTypes.func.isRequired,
    // values is the legacy choiceState data format
    values: PropTypes.arrayOf(PropTypes.bool),
    choiceStates: PropTypes.arrayOf(PropTypes.shape({
      // Indicates whether this choice is selected. (Inside
      // BaseRadio, this is called `checked`.)
      selected: PropTypes.bool,
      // Indicates whether the user has "crossed out" this choice,
      // meaning that they don't think it's correct. This value does
      // not affect scoring or other behavior; it's just a note for
      // the user's reference.
      crossedOut: PropTypes.bool,
      highlighted: PropTypes.bool,
      rationaleShown: PropTypes.bool,
      correctnessShown: PropTypes.bool,
      readOnly: PropTypes.bool
    }).isRequired),
    linterContext: linterContextProps,
    static: PropTypes.bool
  },
  getDefaultProps: function getDefaultProps() {
    return {
      choices: [{}],
      displayCount: null,
      multipleSelect: false,
      countChoices: false,
      deselectEnabled: false,
      linterContext: linterContextDefault
    };
  },
  _renderRenderer: function _renderRenderer(content) {
    content = content || "";
    var nextPassageRefId = 1;
    var widgets = {};
    var modContent = content.replace(/\{\{passage-ref (\d+) (\d+)(?: "([^"]*)")?\}\}/g, (match, passageNum, refNum, summaryText) => {
      var widgetId = "passage-ref " + nextPassageRefId;
      nextPassageRefId++;
      widgets[widgetId] = {
        type: "passage-ref",
        graded: false,
        options: {
          passageNumber: parseInt(passageNum),
          referenceNumber: parseInt(refNum),
          summaryText: summaryText
        },
        version: PassageRef.version
      };
      return "[[" + Util.snowman + " " + widgetId + "]]";
    }); // alwaysUpdate={true} so that passage-refs findWidgets
    // get called when the outer passage updates the renderer
    // TODO(aria): This is really hacky
    // We pass in a key here so that we avoid a semi-spurious
    // react warning when the ChoiceNoneAbove renders a
    // different renderer in the same place. Note this destroys
    // state, but since all we're doing is outputting
    // "None of the above", that is okay.
    // TODO(mdr): Widgets inside this Renderer are not discoverable through
    //     the parent Renderer's `findWidgets` function.

    return /*#__PURE__*/React$1.createElement(Renderer$1, {
      key: "choiceContentRenderer",
      content: modContent,
      widgets: widgets,
      findExternalWidgets: this.props.findWidgets,
      alwaysUpdate: true,
      linterContext: this.props.linterContext
    });
  },
  focus: function focus(i) {
    return this.refs.baseRadio.focus(i);
  },
  // When `BaseRadio`'s `onChange` handler is called, indicating a change in
  // our choices' state, we need to call our `onChange` handler in order to
  // persist those changes in the item's Perseus state.
  //
  // So, given the new values for each choice, construct the new
  // `choiceStates` objects, and pass them to `this.props.onChange`.
  //
  // `newValueLists` is an object with two keys: `checked` and `crossedOut`.
  // Each contains an array of boolean values, specifying the new checked and
  // crossed-out value of each choice.
  //
  // NOTE(mdr): This method expects to be auto-bound. If this component is
  //     converted to an ES6 class, take care to auto-bind this method!
  updateChoices: function updateChoices(newValueLists) {
    var {
      choiceStates,
      choices
    } = this.props; // Construct the baseline `choiceStates` objects. If this is the user's
    // first interaction with the widget, we'll need to initialize them to
    // new objects with all fields set to the default values. Otherwise, we
    // should clone the old `choiceStates` objects, in preparation to
    // mutate them.

    var newChoiceStates;

    if (choiceStates) {
      newChoiceStates = choiceStates.map(state => _objectSpread2({}, state));
    } else {
      newChoiceStates = choices.map(() => ({
        selected: false,
        crossedOut: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false,
        readOnly: false
      }));
    } // Mutate the new `choiceState` objects, according to the new `checked`
    // and `crossedOut` values provided in `newValueLists`.


    newChoiceStates.forEach((choiceState, i) => {
      choiceState.selected = newValueLists.checked[i];
      choiceState.crossedOut = newValueLists.crossedOut[i];
    });
    this.props.onChange({
      choiceStates: newChoiceStates
    });
    this.props.trackInteraction();
  },
  getUserInput: function getUserInput() {
    // Return checked inputs in the form {choicesSelected: [bool]}. (Dear
    // future timeline implementers: this used to be {value: i} before
    // multiple select was added)
    if (this.props.choiceStates) {
      var noneOfTheAboveIndex = null;
      var noneOfTheAboveSelected = false;
      var choiceStates = this.props.choiceStates;
      var choicesSelected = choiceStates.map(() => false);
      var countChoices = this.props.countChoices;
      var numCorrect = this.props.numCorrect;

      for (var i = 0; i < choicesSelected.length; i++) {
        var index = this.props.choices[i].originalIndex;
        choicesSelected[index] = choiceStates[i].selected;

        if (this.props.choices[i].isNoneOfTheAbove) {
          noneOfTheAboveIndex = index;

          if (choicesSelected[i]) {
            noneOfTheAboveSelected = true;
          }
        }
      }

      return {
        countChoices,
        choicesSelected,
        numCorrect,
        noneOfTheAboveIndex,
        noneOfTheAboveSelected
      }; // Support legacy choiceState implementation
    } else if (this.props.values) {
      var _noneOfTheAboveIndex = null;
      var _noneOfTheAboveSelected = false;
      var values = this.props.values.slice();
      var _countChoices = this.props.countChoices;
      var _numCorrect = this.props.numCorrect;

      for (var _i = 0; _i < this.props.values.length; _i++) {
        var _index = this.props.choices[_i].originalIndex;
        values[_index] = this.props.values[_i];

        if (this.props.choices[_i].isNoneOfTheAbove) {
          _noneOfTheAboveIndex = _index;

          if (values[_i]) {
            _noneOfTheAboveSelected = true;
          }
        }
      }

      return {
        choicesSelected: values,
        noneOfTheAboveIndex: _noneOfTheAboveIndex,
        noneOfTheAboveSelected: _noneOfTheAboveSelected,
        countChoices: _countChoices,
        numCorrect: _numCorrect
      };
    } else {
      // Nothing checked
      return {
        choicesSelected: _$1.map(this.props.choices, () => false)
      };
    }
  },
  simpleValidate: function simpleValidate(rubric) {
    return Radio$1.validate(this.getUserInput(), rubric);
  },
  enforceOrdering: function enforceOrdering(choices) {
    var content = _$1.pluck(choices, "content");

    if (_$1.isEqual(content, [i18n._("False"), i18n._("True")]) || _$1.isEqual(content, [i18n._("No"), i18n._("Yes")])) {
      return [choices[1]].concat([choices[0]]);
    }

    return choices;
  },

  /**
   * Turn on rationale display for the currently selected choices. Note that
   * this leaves rationales on for choices that are already showing
   * rationales.
   */
  showRationalesForCurrentlySelectedChoices(rubric) {
    if (this.props.choiceStates) {
      var score = this.simpleValidate(rubric);
      var widgetCorrect = score.type === "points" && score.total === score.earned;
      var newStates = this.props.choiceStates.map(state => _objectSpread2(_objectSpread2({}, state), {}, {
        highlighted: state.selected,
        // If the choice is selected, show the rationale now
        rationaleShown: state.selected || // If the choice already had a rationale, keep it shown
        state.rationaleShown || // If the widget is correctly answered, show the rationale
        // for all the choices
        widgetCorrect,
        // We use the same behavior for the readOnly flag as for
        // rationaleShown, but we keep it separate in case other
        // behaviors want to disable choices without showing rationales.
        readOnly: state.selected || state.readOnly || widgetCorrect,
        correctnessShown: state.selected || state.correctnessShown
      }));
      this.props.onChange({
        choiceStates: newStates
      }, null, // cb
      true // silent
      );
    }
  },

  /**
   * Deselects any currently-selected choices that are not correct choices.
   */
  deselectIncorrectSelectedChoices() {
    if (this.props.choiceStates) {
      var newStates = this.props.choiceStates.map((state, i) => _objectSpread2(_objectSpread2({}, state), {}, {
        selected: state.selected && !!this.props.choices[i].correct,
        highlighted: false
      }));
      this.props.onChange({
        choiceStates: newStates
      }, null, // cb
      false // silent
      );
    }
  },

  render: function render() {
    var choices = this.props.choices;
    var choiceStates;

    if (this.props.static) {
      choiceStates = _$1.map(choices, val => ({
        selected: val.correct,
        crossedOut: val.crossedOut,
        readOnly: true,
        highlighted: false,
        rationaleShown: true,
        correctnessShown: true
      }));
    } else if (this.props.choiceStates) {
      choiceStates = this.props.choiceStates;
    } else if (this.props.values) {
      // Support legacy choiceStates implementation
      choiceStates = _$1.map(this.props.values, val => ({
        selected: val,
        crossedOut: false,
        readOnly: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false
      }));
    } else {
      choiceStates = _$1.map(choices, () => ({
        selected: false,
        crossedOut: false,
        readOnly: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false
      }));
    }

    choices = _$1.map(choices, (choice, i) => {
      var content = choice.isNoneOfTheAbove && !choice.content ? // we use i18n._ instead of $_ here because the content
      // sent to a renderer needs to be a string, not a react
      // node (/renderable/fragment).
      i18n._("None of the above") : choice.content;
      var {
        selected,
        crossedOut,
        rationaleShown,
        correctnessShown,
        readOnly,
        highlighted
      } = choiceStates[i];
      var reviewChoice = this.props.reviewModeRubric && this.props.reviewModeRubric.choices[i];
      return {
        content: this._renderRenderer(content),
        checked: selected,
        // Current versions of the radio widget always pass in the
        // "correct" value through the choices. Old serialized state
        // for radio widgets doesn't have this though, so we have to
        // pull the correctness out of the review mode rubric. This
        // only works because all of the places we use
        // `restoreSerializedState()` also turn on reviewMode, but is
        // fine for now.
        // TODO(emily): Come up with a more comprehensive way to solve
        // this sort of "serialized state breaks when internal
        // structure changes" problem.
        correct: typeof choice.correct === "undefined" ? !!reviewChoice && reviewChoice.correct : choice.correct,
        disabled: readOnly,
        hasRationale: !!choice.clue,
        rationale: this._renderRenderer(choice.clue),
        showRationale: rationaleShown,
        showCorrectness: correctnessShown,
        isNoneOfTheAbove: choice.isNoneOfTheAbove,
        revealNoneOfTheAbove: this.props.questionCompleted && selected,
        crossedOut,
        highlighted
      };
    });
    choices = this.enforceOrdering(choices);
    return /*#__PURE__*/React$1.createElement(BaseRadio, {
      ref: "baseRadio",
      labelWrap: true,
      multipleSelect: this.props.multipleSelect,
      countChoices: this.props.countChoices,
      numCorrect: this.props.numCorrect,
      choices: choices,
      onChange: this.updateChoices,
      reviewModeRubric: this.props.reviewModeRubric,
      deselectEnabled: this.props.deselectEnabled,
      apiOptions: this.props.apiOptions
    });
  }
});

_$1.extend(Radio$1, {
  validate: function validate(state, rubric) {
    var numSelected = _$1.reduce(state.choicesSelected, (sum, selected) => {
      return sum + (selected ? 1 : 0);
    }, 0);

    if (numSelected === 0) {
      return {
        type: "invalid",
        message: null
      };
    } else if (state.countChoices && numSelected !== state.numCorrect) {
      return {
        type: "invalid",
        message: i18n._("Please choose the correct number of answers.")
      }; // If NOTA and some other answer are checked, ...
    } else if (state.noneOfTheAboveSelected && numSelected > 1) {
      return {
        type: "invalid",
        message: i18n._("'None of the above' may not be selected " + "when other answers are selected.")
      };
    } else {
      /* jshint -W018 */
      var correct = _$1.all(state.choicesSelected, function (selected, i) {
        var isCorrect;

        if (state.noneOfTheAboveIndex === i) {
          isCorrect = _$1.all(rubric.choices, function (choice, j) {
            return i === j || !choice.correct;
          });
        } else {
          isCorrect = !!rubric.choices[i].correct;
        }

        return isCorrect === selected;
      });
      /* jshint +W018 */


      return {
        type: "points",
        earned: correct ? 1 : 0,
        total: 1,
        message: null
      };
    }
  }
});

_module_$2.exports = Radio$1;
var _radioWidgetJsx = _module_$2.exports;

var _module_$1 = {
  exports: {}
};
/* eslint-disable no-var, object-curly-spacing */

/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */

/* To fix, remove an entry above, run ka-lint, and fix errors. */

var _2 = _underscore__default["default"];
var shuffle = Util$q.shuffle;
var Radio = _radioWidgetJsx;

var _choiceTransform = (editorProps, problemNum) => {
  var _maybeRandomize = function _maybeRandomize(array) {
    return editorProps.randomize ? shuffle(array, problemNum) : array;
  };

  var _addNoneOfAbove = function _addNoneOfAbove(choices) {
    var noneOfTheAbove = null;

    var newChoices = _2.reject(choices, function (choice, index) {
      if (choice.isNoneOfTheAbove) {
        noneOfTheAbove = choice;
        return true;
      }
    }); // Place the "None of the above" options last


    if (noneOfTheAbove) {
      newChoices.push(noneOfTheAbove);
    }

    return newChoices;
  }; // Add meta-information to choices


  var choices = editorProps.choices.slice();
  choices = _2.map(choices, (choice, i) => {
    return _2.extend({}, choice, {
      originalIndex: i,
      correct: Boolean(choice.correct)
    });
  }); // Randomize and add 'None of the above'

  return _addNoneOfAbove(_maybeRandomize(choices));
};

var transform = (editorProps, problemNum) => {
  var choices = _choiceTransform(editorProps, problemNum);

  var numCorrect = _2.reduce(editorProps.choices, function (memo, choice) {
    return choice.correct ? memo + 1 : memo;
  }, 0);

  var {
    hasNoneOfTheAbove,
    multipleSelect,
    countChoices,
    correctAnswer,
    deselectEnabled
  } = editorProps;
  return {
    numCorrect,
    hasNoneOfTheAbove,
    multipleSelect,
    countChoices,
    correctAnswer,
    deselectEnabled,
    choices,
    selectedChoices: _2.pluck(choices, "correct")
  };
};

var propUpgrades = {
  1: v0props => {
    var choices;
    var hasNoneOfTheAbove;

    if (!v0props.noneOfTheAbove) {
      choices = v0props.choices;
      hasNoneOfTheAbove = false;
    } else {
      choices = _2.clone(v0props.choices);

      var noneOfTheAboveIndex = _2.random(0, v0props.choices.length - 1);

      var noneChoice = _2.extend({}, v0props.choices[noneOfTheAboveIndex], {
        isNoneOfTheAbove: true
      });

      choices.splice(noneOfTheAboveIndex, 1);
      choices.push(noneChoice);
      hasNoneOfTheAbove = true;
    }

    return _2.extend(_2.omit(v0props, "noneOfTheAbove"), {
      choices: choices,
      hasNoneOfTheAbove: hasNoneOfTheAbove
    });
  }
};
_module_$1.exports = {
  name: "radio",
  displayName: "Multiple choice",
  accessible: true,
  widget: Radio,
  transform: transform,
  staticTransform: transform,
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades,
  isLintable: true
};
var _widgetsRadioJsx = _module_$1.exports;

// webapp perseus/traversal.py so they can be properly translated.

var _basicWidgetsJs = [[_widgetsRadioJsx, _widgetsRadioEditorJsx], [_widgetsInputNumberJsx, _widgetsInputNumberEditorJsx], [_widgetsNumericInputJsx, _widgetsNumericInputEditorJsx], [_widgetsExpressionJsx, _widgetsExpressionEditorJsx]];

var _module_ = {
  exports: {}
};
var basicWidgets = _basicWidgetsJs;
var extraWidgets = allWidgets;
_module_.exports = basicWidgets.concat(extraWidgets);
var initialWidgets = _module_.exports;

var apiVersion$1 = {
	major: 10,
	minor: 2
};
var itemDataVersion$1 = {
	major: 0,
	minor: 1
};
var _versionJson = {
	apiVersion: apiVersion$1,
	itemDataVersion: itemDataVersion$1
};

// TODO(aria): fix up code to not depend on these
/**
 * Main entry point
 */

var version = _versionJson; // TODO(aria): This registers all widgets for now, but we could go back to only
// registering basic widgets

Widgets$5.registerMany(initialWidgets);
var apiVersion = version.apiVersion;
var itemDataVersion = version.itemDataVersion;
var init = _initJs;
var ArticleRenderer = _articleRendererJsx;
var QuestionRenderer = QuestionRenderer$1;
var ItemRenderer = _itemRendererJsx;
var ServerItemRenderer = _serverItemRendererJsx;
var HintsRenderer = _hintsRendererJsx;
var Renderer = _rendererJsx;
var MultiItems = _multiItemsJs;
var perseus = {
  apiVersion: version.apiVersion,
  itemDataVersion: version.itemDataVersion,
  init: _initJs,
  ArticleRenderer: _articleRendererJsx,
  QuestionRenderer: QuestionRenderer$1,
  ItemRenderer: _itemRendererJsx,
  ServerItemRenderer: _serverItemRendererJsx,
  HintsRenderer: _hintsRendererJsx,
  Renderer: _rendererJsx,
  MultiItems: _multiItemsJs
};

exports.ArticleRenderer = ArticleRenderer;
exports.HintsRenderer = HintsRenderer;
exports.ItemRenderer = ItemRenderer;
exports.MultiItems = MultiItems;
exports.QuestionRenderer = QuestionRenderer;
exports.Renderer = Renderer;
exports.ServerItemRenderer = ServerItemRenderer;
exports.apiVersion = apiVersion;
exports["default"] = perseus;
exports.init = init;
exports.itemDataVersion = itemDataVersion;
